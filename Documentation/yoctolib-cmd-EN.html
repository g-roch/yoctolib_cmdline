<HTML>
<HEAD>
<title>CmdLine API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cmd-EN.html 33830 2018-12-21 15:31:08Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-cmd-EN.html 33830 2018-12-21 15:31:08Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'YVSource get_advertisedValue',pro:'YVSource <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:''};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'YVSource get_extPowerFailure',pro:'YVSource <span id=pn>target</span> get_extPowerFailure',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if external power supply voltage is too low',ext:''};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'YVSource get_failure',pro:'YVSource <span id=pn>target</span> get_failure',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the module is in failure mode',ext:''};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'YVSource get_logicalName',pro:'YVSource <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:''};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'YVSource get_overCurrent',pro:'YVSource <span id=pn>target</span> get_overCurrent',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:''};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'YVSource get_overHeat',pro:'YVSource <span id=pn>target</span> get_overHeat',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to TRUE if the module is overheating',ext:''};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'YVSource get_overLoad',pro:'YVSource <span id=pn>target</span> get_overLoad',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:''};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'YVSource get_regulationFailure',pro:'YVSource <span id=pn>target</span> get_regulationFailure',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:''};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'YVSource get_unit',pro:'YVSource <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:''};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'YVSource pulse',pro:'YVSource <span id=pn>target</span> pulse <span id=pn>voltage</span> <span id=pn>ms_duration</span>',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'YVSource set_logicalName',pro:'YVSource <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage source.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'YVSource set_voltage',pro:'YVSource <span id=pn>target</span> set_voltage <span id=pn>newval</span>',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'YVSource voltageMove',pro:'YVSource <span id=pn>target</span> voltageMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: VSource)
//--- (generated code: Module)
var Language='CmdLine';
var IncludeLabel='';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'SUCCESS',YAPI_NOT_INITIALIZED:'NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'VERSION_MISMATCH',YAPI_DEVICE_BUSY:'DEVICE_BUSY',YAPI_TIMEOUT:'TIMEOUT',YAPI_IO_ERROR:'IO_ERROR',YAPI_NO_MORE_DATA:'NO_MORE_DATA',YAPI_EXHAUSTED:'EXHAUSTED',YAPI_DOUBLE_ACCES:'DOUBLE_ACCES',YAPI_UNAUTHORIZED:'UNAUTHORIZED',YAPI_RTC_NOT_READY:'RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'FILE_NOT_FOUND',null:'NULL'};
doc['Module']={'':{syn:'Module control interface',inc:'',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'YModule checkFirmware',pro:'YModule <span id=pn>target</span> checkFirmware <span id=pn>path</span> <span id=pn>onlynew</span>',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate <tt>.byn</tt> file. If the parameter <tt>onlynew</tt> is true, the function discards firmwares that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:'the path of the byn file to use or a empty string if no byn files matches the requirement',ext:''};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'YModule download',pro:'YModule <span id=pn>target</span> download <span id=pn>pathname</span>',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:''};
doc['Module']['get_allSettings']={syn:'Returns all the settings and uploaded files of the module.',lib:'YModule get_allSettings',pro:'YModule <span id=pn>target</span> get_allSettings',cmt:'<p>Returns all the settings and uploaded files of the module. Useful to backup all the logical names, calibrations parameters, and uploaded files of a device.</p>',ret:'a binary buffer with all the settings.',ext:''};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'YModule get_beacon',pro:'YModule <span id=pn>target</span> get_beacon',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the state of the localization beacon',ext:''};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'YModule get_firmwareRelease',pro:'YModule <span id=pn>target</span> get_firmwareRelease',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:''};
doc['Module']['get_functionIds']={syn:'Retrieve all hardware identifier that match the type passed in argument.',lib:'YModule get_functionIds',pro:'YModule <span id=pn>target</span> get_functionIds <span id=pn>funType</span>',cmt:'<p>Retrieve all hardware identifier that match the type passed in argument.</p>',par:{funType:'The type of function (Relay, LightSensor, Voltage,...)'},ret:'an array of strings.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'YModule get_hardwareId',pro:'YModule <span id=pn>target</span> get_hardwareId',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'YModule get_icon2d',pro:'YModule <span id=pn>target</span> get_icon2d',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'YModule get_lastLogs',pro:'YModule <span id=pn>target</span> get_lastLogs',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'YModule get_logicalName',pro:'YModule <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:''};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'YModule get_luminosity',pro:'YModule <span id=pn>target</span> get_luminosity',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:''};
doc['Module']['get_parentHub']={syn:'Returns the serial number of the YoctoHub on which this module is connected.',lib:'YModule get_parentHub',pro:'YModule <span id=pn>target</span> get_parentHub',cmt:'<p>Returns the serial number of the YoctoHub on which this module is connected. If the module is connected by USB, or if the module is the root YoctoHub, an empty string is returned.</p>',ret:'a string with the serial number of the YoctoHub or an empty string'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'YModule get_persistentSettings',pro:'YModule <span id=pn>target</span> get_persistentSettings',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>LOADED</tt>, <tt>SAVED</tt> and <tt>MODIFIED</tt> corresponding to the current state of persistent module settings',ext:''};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'YModule get_productId',pro:'YModule <span id=pn>target</span> get_productId',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:''};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'YModule get_productName',pro:'YModule <span id=pn>target</span> get_productName',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:''};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'YModule get_productRelease',pro:'YModule <span id=pn>target</span> get_productRelease',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:''};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'YModule get_rebootCountdown',pro:'YModule <span id=pn>target</span> get_rebootCountdown',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:''};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'YModule get_serialNumber',pro:'YModule <span id=pn>target</span> get_serialNumber',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:''};
doc['Module']['get_subDevices']={syn:'Returns a list of all the modules that are plugged into the current module.',lib:'YModule get_subDevices',pro:'YModule <span id=pn>target</span> get_subDevices',cmt:'<p>Returns a list of all the modules that are plugged into the current module. This method only makes sense when called for a YoctoHub/VirtualHub. Otherwise, an empty array will be returned.</p>',ret:'an array of strings containing the sub modules.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'YModule get_upTime',pro:'YModule <span id=pn>target</span> get_upTime',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:''};
doc['Module']['get_url']={syn:'Returns the URL used to access the module.',lib:'YModule get_url',pro:'YModule <span id=pn>target</span> get_url',cmt:'<p>Returns the URL used to access the module. If the module is connected by USB, the string \x27usb\x27 is returned.</p>',ret:'a string with the URL of the module.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'YModule get_usbCurrent',pro:'YModule <span id=pn>target</span> get_usbCurrent',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:''};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'YModule get_userVar',pro:'YModule <span id=pn>target</span> get_userVar',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:''};
doc['Module']['hasFunction']={syn:'Tests if the device includes a specific function.',lib:'YModule hasFunction',pro:'YModule <span id=pn>target</span> hasFunction <span id=pn>funcId</span>',cmt:'<p>Tests if the device includes a specific function. This method takes a function identifier and returns a boolean.</p>',par:{funcId:'the requested function identifier'},ret:'true if the device has the function identifier'};
doc['Module']['log']={syn:'Adds a text message to the device logs.',lib:'YModule log',pro:'YModule <span id=pn>target</span> log <span id=pn>text</span>',cmt:'<p>Adds a text message to the device logs. This function is useful in particular to trace the execution of HTTP callbacks. If a newline is desired after the message, it must be included in the string.</p>',par:{text:'the string to append to the logs.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'YModule reboot',pro:'YModule <span id=pn>target</span> reboot <span id=pn>secBeforeReboot</span>',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'YModule revertFromFlash',pro:'YModule <span id=pn>target</span> revertFromFlash',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'YModule saveToFlash',pro:'YModule <span id=pn>target</span> saveToFlash',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the device.',lib:'YModule set_allSettings',pro:'YModule <span id=pn>target</span> set_allSettings <span id=pn>settings</span>',cmt:'<p>Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters of a module from a backup.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['set_allSettingsAndFiles']={syn:'Restores all the settings and uploaded files to the module.',lib:'YModule set_allSettingsAndFiles',pro:'YModule <span id=pn>target</span> set_allSettingsAndFiles <span id=pn>settings</span>',cmt:'<p>Restores all the settings and uploaded files to the module. This method is useful to restore all the logical names and calibrations parameters, uploaded files etc. of a device from a backup.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'YModule set_beacon',pro:'YModule <span id=pn>target</span> set_beacon <span id=pn>newval</span>',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'YModule set_logicalName',pro:'YModule <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the module.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'YModule set_luminosity',pro:'YModule <span id=pn>target</span> set_luminosity <span id=pn>newval</span>',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_userVar']={syn:'Stores a 32 bit value in the device RAM.',lib:'YModule set_userVar',pro:'YModule <span id=pn>target</span> set_userVar <span id=pn>newval</span>',cmt:'<p>Stores a 32 bit value in the device RAM. This attribute is at programmer disposal, should he need to store a state variable. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['triggerConfigChangeCallback']={syn:'Triggers a configuration change callback, to check if they are supported or not.',lib:'YModule triggerConfigChangeCallback',pro:'YModule <span id=pn>target</span> triggerConfigChangeCallback',cmt:'<p>Triggers a configuration change callback, to check if they are supported or not.</p>'};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'YModule triggerFirmwareUpdate',pro:'YModule <span id=pn>target</span> triggerFirmwareUpdate <span id=pn>secBeforeReboot</span>',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'YModule updateFirmware',pro:'YModule <span id=pn>target</span> updateFirmware <span id=pn>path</span>',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
doc['Module']['updateFirmwareEx']={syn:'Prepares a firmware update of the module.',lib:'YModule updateFirmwareEx',pro:'YModule <span id=pn>target</span> updateFirmwareEx <span id=pn>path</span> <span id=pn>force</span>',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.',force:'true to force the firmware update even if some prerequisites appear not to be met'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
//--- (end of generated code: Module)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'',cmt:'<p>The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YHumidity calibrateFromPoints',pro:'YHumidity <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['get_absHum']={syn:'Returns the current absolute humidity, in grams per cubic meter of air.',lib:'YHumidity get_absHum',pro:'YHumidity <span id=pn>target</span> get_absHum',cmt:'<p>Returns the current absolute humidity, in grams per cubic meter of air.</p>',ret:'a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air',ext:''};
doc['Humidity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YHumidity get_advMode',pro:'YHumidity <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'YHumidity get_advertisedValue',pro:'YHumidity <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:''};
doc['Humidity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'YHumidity get_currentRawValue',pro:'YHumidity <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:''};
doc['Humidity']['get_currentValue']={syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'YHumidity get_currentValue',pro:'YHumidity <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:''};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'YHumidity get_highestValue',pro:'YHumidity <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:''};
doc['Humidity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YHumidity get_logFrequency',pro:'YHumidity <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'YHumidity get_logicalName',pro:'YHumidity <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:''};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'YHumidity get_lowestValue',pro:'YHumidity <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:''};
doc['Humidity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YHumidity get_recordedData',pro:'YHumidity <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Humidity']['get_relHum']={syn:'Returns the current relative humidity, in per cents.',lib:'YHumidity get_relHum',pro:'YHumidity <span id=pn>target</span> get_relHum',cmt:'<p>Returns the current relative humidity, in per cents.</p>',ret:'a floating point number corresponding to the current relative humidity, in per cents',ext:''};
doc['Humidity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YHumidity get_reportFrequency',pro:'YHumidity <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YHumidity get_resolution',pro:'YHumidity <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Humidity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YHumidity get_sensorState',pro:'YHumidity <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the humidity.',lib:'YHumidity get_unit',pro:'YHumidity <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:''};
doc['Humidity']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YHumidity isSensorReady',pro:'YHumidity <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Humidity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YHumidity loadCalibrationPoints',pro:'YHumidity <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YHumidity muteValueCallbacks',pro:'YHumidity <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Humidity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YHumidity set_advMode',pro:'YHumidity <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YHumidity set_highestValue',pro:'YHumidity <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YHumidity set_logFrequency',pro:'YHumidity <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'YHumidity set_logicalName',pro:'YHumidity <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the humidity sensor.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YHumidity set_lowestValue',pro:'YHumidity <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YHumidity set_reportFrequency',pro:'YHumidity <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YHumidity set_resolution',pro:'YHumidity <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_unit']={syn:'Changes the primary unit for measuring humidity.',lib:'YHumidity set_unit',pro:'YHumidity <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the primary unit for measuring humidity. That unit is a string. If that strings starts with the letter \x27g\x27, the primary measured value is the absolute humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity (RH), in per cents.</p>',par:{newval:'a string corresponding to the primary unit for measuring humidity'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YHumidity startDataLogger',pro:'YHumidity <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Humidity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YHumidity stopDataLogger',pro:'YHumidity <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Humidity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YHumidity unmuteValueCallbacks',pro:'YHumidity <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'',cmt:'<p>The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPressure calibrateFromPoints',pro:'YPressure <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPressure get_advMode',pro:'YPressure <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'YPressure get_advertisedValue',pro:'YPressure <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:''};
doc['Pressure']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'YPressure get_currentRawValue',pro:'YPressure <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:''};
doc['Pressure']['get_currentValue']={syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'YPressure get_currentValue',pro:'YPressure <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:''};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'YPressure get_highestValue',pro:'YPressure <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:''};
doc['Pressure']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPressure get_logFrequency',pro:'YPressure <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'YPressure get_logicalName',pro:'YPressure <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:''};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'YPressure get_lowestValue',pro:'YPressure <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:''};
doc['Pressure']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPressure get_recordedData',pro:'YPressure <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Pressure']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPressure get_reportFrequency',pro:'YPressure <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPressure get_resolution',pro:'YPressure <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Pressure']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPressure get_sensorState',pro:'YPressure <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the pressure.',lib:'YPressure get_unit',pro:'YPressure <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:''};
doc['Pressure']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPressure isSensorReady',pro:'YPressure <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Pressure']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPressure loadCalibrationPoints',pro:'YPressure <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPressure muteValueCallbacks',pro:'YPressure <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Pressure']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPressure set_advMode',pro:'YPressure <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPressure set_highestValue',pro:'YPressure <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPressure set_logFrequency',pro:'YPressure <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'YPressure set_logicalName',pro:'YPressure <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the pressure sensor.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPressure set_lowestValue',pro:'YPressure <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPressure set_reportFrequency',pro:'YPressure <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPressure set_resolution',pro:'YPressure <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPressure startDataLogger',pro:'YPressure <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Pressure']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPressure stopDataLogger',pro:'YPressure <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Pressure']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPressure unmuteValueCallbacks',pro:'YPressure <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Pressure)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'',cmt:'<p>The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YTemperature calibrateFromPoints',pro:'YTemperature <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTemperature get_advMode',pro:'YTemperature <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'YTemperature get_advertisedValue',pro:'YTemperature <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:''};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'YTemperature get_currentRawValue',pro:'YTemperature <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:''};
doc['Temperature']['get_currentValue']={syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'YTemperature get_currentValue',pro:'YTemperature <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:''};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'YTemperature get_highestValue',pro:'YTemperature <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:''};
doc['Temperature']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YTemperature get_logFrequency',pro:'YTemperature <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'YTemperature get_logicalName',pro:'YTemperature <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:''};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'YTemperature get_lowestValue',pro:'YTemperature <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:''};
doc['Temperature']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YTemperature get_recordedData',pro:'YTemperature <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Temperature']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YTemperature get_reportFrequency',pro:'YTemperature <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YTemperature get_resolution',pro:'YTemperature <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Temperature']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YTemperature get_sensorState',pro:'YTemperature <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'YTemperature get_sensorType',pro:'YTemperature <span id=pn>target</span> get_sensorType',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>DIGITAL</tt>, <tt>TYPE_K</tt>, <tt>TYPE_E</tt>, <tt>TYPE_J</tt>, <tt>TYPE_N</tt>, <tt>TYPE_R</tt>, <tt>TYPE_S</tt>, <tt>TYPE_T</tt>, <tt>PT100_4WIRES</tt>, <tt>PT100_3WIRES</tt>, <tt>PT100_2WIRES</tt>, <tt>RES_OHM</tt>, <tt>RES_NTC</tt>, <tt>RES_LINEAR</tt>, <tt>RES_INTERNAL</tt> and <tt>IR</tt> corresponding to the temperature sensor type',ext:''};
doc['Temperature']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'YTemperature get_signalUnit',pro:'YTemperature <span id=pn>target</span> get_signalUnit',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:''};
doc['Temperature']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'YTemperature get_signalValue',pro:'YTemperature <span id=pn>target</span> get_signalValue',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:''};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the temperature.',lib:'YTemperature get_unit',pro:'YTemperature <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:''};
doc['Temperature']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YTemperature isSensorReady',pro:'YTemperature <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Temperature']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YTemperature loadCalibrationPoints',pro:'YTemperature <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['loadThermistorResponseTable']={syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'YTemperature loadThermistorResponseTable',pro:'YTemperature <span id=pn>target</span> loadThermistorResponseTable <span id=pn>tempValues</span> <span id=pn>resValues</span>',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YTemperature muteValueCallbacks',pro:'YTemperature <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Temperature']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTemperature set_advMode',pro:'YTemperature <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YTemperature set_highestValue',pro:'YTemperature <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YTemperature set_logFrequency',pro:'YTemperature <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'YTemperature set_logicalName',pro:'YTemperature <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the temperature sensor.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YTemperature set_lowestValue',pro:'YTemperature <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_ntcParameters']={syn:'Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance.',lib:'YTemperature set_ntcParameters',pro:'YTemperature <span id=pn>target</span> set_ntcParameters <span id=pn>res25</span> <span id=pn>beta</span>',cmt:'<p>Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance. For increased precision, you can enter a complete mapping table using set_thermistorResponseTable. This function can only be used with a temperature sensor based on thermistors.</p>',par:{res25:'thermistor resistance at 25 degrees Celsius',beta:'Beta value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YTemperature set_reportFrequency',pro:'YTemperature <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YTemperature set_resolution',pro:'YTemperature <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_sensorType']={syn:'Changes the temperature sensor type.',lib:'YTemperature set_sensorType',pro:'YTemperature <span id=pn>target</span> set_sensorType <span id=pn>newval</span>',cmt:'<p>Changes the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor.</p>',par:{newval:'a value among <tt>DIGITAL</tt>, <tt>TYPE_K</tt>, <tt>TYPE_E</tt>, <tt>TYPE_J</tt>, <tt>TYPE_N</tt>, <tt>TYPE_R</tt>, <tt>TYPE_S</tt>, <tt>TYPE_T</tt>, <tt>PT100_4WIRES</tt>, <tt>PT100_3WIRES</tt>, <tt>PT100_2WIRES</tt>, <tt>RES_OHM</tt>, <tt>RES_NTC</tt>, <tt>RES_LINEAR</tt>, <tt>RES_INTERNAL</tt> and <tt>IR</tt> corresponding to the temperature sensor type'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_thermistorResponseTable']={syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'YTemperature set_thermistorResponseTable',pro:'YTemperature <span id=pn>target</span> set_thermistorResponseTable <span id=pn>tempValues</span> <span id=pn>resValues</span>',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_unit']={syn:'Changes the measuring unit for the measured temperature.',lib:'YTemperature set_unit',pro:'YTemperature <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that string ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YTemperature startDataLogger',pro:'YTemperature <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Temperature']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YTemperature stopDataLogger',pro:'YTemperature <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Temperature']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YTemperature unmuteValueCallbacks',pro:'YTemperature <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The DataLogger function controls the global parameters of the internal data logger. Recording control (start/stop) as well as data retreival is done at sensor objects level.</p>'}};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'YDataLogger forgetAllDataStreams',pro:'YDataLogger <span id=pn>target</span> forgetAllDataStreams',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'YDataLogger get_advertisedValue',pro:'YDataLogger <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:''};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'YDataLogger get_autoStart',pro:'YDataLogger <span id=pn>target</span> get_autoStart',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the default activation state of the data logger on power up',ext:''};
doc['DataLogger']['get_beaconDriven']={syn:'Returns true if the data logger is synchronised with the localization beacon.',lib:'YDataLogger get_beaconDriven',pro:'YDataLogger <span id=pn>target</span> get_beaconDriven',cmt:'<p>Returns true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to true if the data logger is synchronised with the localization beacon',ext:''};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'YDataLogger get_currentRunIndex',pro:'YDataLogger <span id=pn>target</span> get_currentRunIndex',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:''};
doc['DataLogger']['get_dataSets']={syn:'Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.',lib:'YDataLogger get_dataSets',pro:'YDataLogger <span id=pn>target</span> get_dataSets',cmt:'<p>Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>',ret:'a list of YDataSet object.',ext:''};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'YDataLogger get_logicalName',pro:'YDataLogger <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:''};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'YDataLogger get_recording',pro:'YDataLogger <span id=pn>target</span> get_recording',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'a value among <tt>OFF</tt>, <tt>ON</tt> and <tt>PENDING</tt> corresponding to the current activation state of the data logger',ext:''};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'YDataLogger get_timeUTC',pro:'YDataLogger <span id=pn>target</span> get_timeUTC',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:''};
doc['DataLogger']['get_usage']={syn:'Returns the percentage of datalogger memory in use.',lib:'YDataLogger get_usage',pro:'YDataLogger <span id=pn>target</span> get_usage',cmt:'<p>Returns the percentage of datalogger memory in use.</p>',ret:'an integer corresponding to the percentage of datalogger memory in use',ext:''};
doc['DataLogger']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YDataLogger muteValueCallbacks',pro:'YDataLogger <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'YDataLogger set_autoStart',pro:'YDataLogger <span id=pn>target</span> set_autoStart <span id=pn>newval</span>',cmt:'<p>Changes the default activation state of the data logger on power up. Note: if the device doesn\x27t have any time source at his disposal when starting up, it will wait for ~8 seconds before automatically starting to record with \x09 an arbitrary timestamp</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_beaconDriven']={syn:'Changes the type of synchronisation of the data logger.',lib:'YDataLogger set_beaconDriven',pro:'YDataLogger <span id=pn>target</span> set_beaconDriven <span id=pn>newval</span>',cmt:'<p>Changes the type of synchronisation of the data logger.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'YDataLogger set_logicalName',pro:'YDataLogger <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the data logger.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'YDataLogger set_recording',pro:'YDataLogger <span id=pn>target</span> set_recording <span id=pn>newval</span>',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>ON</tt> and <tt>PENDING</tt> corresponding to the activation state of the data logger to start/stop recording data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'YDataLogger set_timeUTC',pro:'YDataLogger <span id=pn>target</span> set_timeUTC <span id=pn>newval</span>',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YDataLogger unmuteValueCallbacks',pro:'YDataLogger <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: DataLogger)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'YDisplayLayer clear',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] clear',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'YDisplayLayer clearConsole',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] clearConsole',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'YDisplayLayer consoleOut',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] consoleOut <span id=pn>text</span>',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'YDisplayLayer drawBar',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawBar <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'YDisplayLayer drawBitmap',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawBitmap <span id=pn>x</span> <span id=pn>y</span> <span id=pn>w</span> <span id=pn>bitmap</span> <span id=pn>bgcol</span>',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'YDisplayLayer drawCircle',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawCircle <span id=pn>x</span> <span id=pn>y</span> <span id=pn>r</span>',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'YDisplayLayer drawDisc',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawDisc <span id=pn>x</span> <span id=pn>y</span> <span id=pn>r</span>',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'YDisplayLayer drawImage',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawImage <span id=pn>x</span> <span id=pn>y</span> <span id=pn>imagename</span>',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'YDisplayLayer drawPixel',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawPixel <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'YDisplayLayer drawRect',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawRect <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'YDisplayLayer drawText',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawText <span id=pn>x</span> <span id=pn>y</span> <span id=pn>anchor</span> <span id=pn>text</span>',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'YDisplayLayer get_displayHeight',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_displayHeight',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:''};
doc['DisplayLayer']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'YDisplayLayer get_displayWidth',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_displayWidth',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:''};
doc['DisplayLayer']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'YDisplayLayer get_layerHeight',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_layerHeight',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:''};
doc['DisplayLayer']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'YDisplayLayer get_layerWidth',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_layerWidth',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:''};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'YDisplayLayer hide',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] hide',cmt:'<p>Hides the layer. The state of the layer is preserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'YDisplayLayer lineTo',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] lineTo <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'YDisplayLayer moveTo',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] moveTo <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'YDisplayLayer reset',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] reset',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'YDisplayLayer selectColorPen',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectColorPen <span id=pn>color</span>',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'YDisplayLayer selectEraser',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectEraser',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'YDisplayLayer selectFont',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectFont <span id=pn>fontname</span>',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'YDisplayLayer selectGrayPen',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectGrayPen <span id=pn>graylevel</span>',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lightest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'YDisplayLayer setAntialiasingMode',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setAntialiasingMode <span id=pn>mode</span>',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzziness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<tt>true</tt> to enable anti-aliasing, <tt>false</tt> to disable it.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'YDisplayLayer setConsoleBackground',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleBackground <span id=pn>bgcol</span>',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'YDisplayLayer setConsoleMargins',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleMargins <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.',lib:'YDisplayLayer setConsoleWordWrap',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleWordWrap <span id=pn>wordwrap</span>',cmt:'<p>Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'YDisplayLayer setLayerPosition',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setLayerPosition <span id=pn>x</span> <span id=pn>y</span> <span id=pn>scrollTime</span>',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'YDisplayLayer unhide',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] unhide',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: DisplayLayer)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'',cmt:'<p>The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2 sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to perform manual calibration if required.</p>'}};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCarbonDioxide calibrateFromPoints',pro:'YCarbonDioxide <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'YCarbonDioxide get_abcPeriod',pro:'YCarbonDioxide <span id=pn>target</span> get_abcPeriod',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:''};
doc['CarbonDioxide']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCarbonDioxide get_advMode',pro:'YCarbonDioxide <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'YCarbonDioxide get_advertisedValue',pro:'YCarbonDioxide <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:''};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'YCarbonDioxide get_currentRawValue',pro:'YCarbonDioxide <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:''};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'YCarbonDioxide get_currentValue',pro:'YCarbonDioxide <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:''};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'YCarbonDioxide get_highestValue',pro:'YCarbonDioxide <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:''};
doc['CarbonDioxide']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCarbonDioxide get_logFrequency',pro:'YCarbonDioxide <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'YCarbonDioxide get_logicalName',pro:'YCarbonDioxide <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:''};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'YCarbonDioxide get_lowestValue',pro:'YCarbonDioxide <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:''};
doc['CarbonDioxide']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCarbonDioxide get_recordedData',pro:'YCarbonDioxide <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCarbonDioxide get_reportFrequency',pro:'YCarbonDioxide <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCarbonDioxide get_resolution',pro:'YCarbonDioxide <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['CarbonDioxide']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCarbonDioxide get_sensorState',pro:'YCarbonDioxide <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the CO2 concentration.',lib:'YCarbonDioxide get_unit',pro:'YCarbonDioxide <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:''};
doc['CarbonDioxide']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCarbonDioxide isSensorReady',pro:'YCarbonDioxide <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCarbonDioxide loadCalibrationPoints',pro:'YCarbonDioxide <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YCarbonDioxide muteValueCallbacks',pro:'YCarbonDioxide <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Changes Automatic Baseline Calibration period, in hours.',lib:'YCarbonDioxide set_abcPeriod',pro:'YCarbonDioxide <span id=pn>target</span> set_abcPeriod <span id=pn>newval</span>',cmt:'<p>Changes Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400 ppm CO2), set the period to -1.</p>',par:{newval:'an integer corresponding to Automatic Baseline Calibration period, in hours'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCarbonDioxide set_advMode',pro:'YCarbonDioxide <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCarbonDioxide set_highestValue',pro:'YCarbonDioxide <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCarbonDioxide set_logFrequency',pro:'YCarbonDioxide <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'YCarbonDioxide set_logicalName',pro:'YCarbonDioxide <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the CO2 sensor.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCarbonDioxide set_lowestValue',pro:'YCarbonDioxide <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCarbonDioxide set_reportFrequency',pro:'YCarbonDioxide <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCarbonDioxide set_resolution',pro:'YCarbonDioxide <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCarbonDioxide startDataLogger',pro:'YCarbonDioxide <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCarbonDioxide stopDataLogger',pro:'YCarbonDioxide <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['CarbonDioxide']['triggerBaselineCalibration']={syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'YCarbonDioxide triggerBaselineCalibration',pro:'YCarbonDioxide <span id=pn>target</span> triggerBaselineCalibration',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400 ppm.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['triggerZeroCalibration']={syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air.',lib:'YCarbonDioxide triggerZeroCalibration',pro:'YCarbonDioxide <span id=pn>target</span> triggerZeroCalibration',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YCarbonDioxide unmuteValueCallbacks',pro:'YCarbonDioxide <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'',cmt:'<p>The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCurrent calibrateFromPoints',pro:'YCurrent <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCurrent get_advMode',pro:'YCurrent <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'YCurrent get_advertisedValue',pro:'YCurrent <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:''};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'YCurrent get_currentRawValue',pro:'YCurrent <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:''};
doc['Current']['get_currentValue']={syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'YCurrent get_currentValue',pro:'YCurrent <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the current, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:''};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed for the current since the device was started.',lib:'YCurrent get_highestValue',pro:'YCurrent <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:''};
doc['Current']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCurrent get_logFrequency',pro:'YCurrent <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'YCurrent get_logicalName',pro:'YCurrent <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:''};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed for the current since the device was started.',lib:'YCurrent get_lowestValue',pro:'YCurrent <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:''};
doc['Current']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCurrent get_recordedData',pro:'YCurrent <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Current']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCurrent get_reportFrequency',pro:'YCurrent <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCurrent get_resolution',pro:'YCurrent <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Current']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCurrent get_sensorState',pro:'YCurrent <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the current.',lib:'YCurrent get_unit',pro:'YCurrent <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:''};
doc['Current']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCurrent isSensorReady',pro:'YCurrent <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Current']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCurrent loadCalibrationPoints',pro:'YCurrent <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YCurrent muteValueCallbacks',pro:'YCurrent <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Current']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCurrent set_advMode',pro:'YCurrent <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCurrent set_highestValue',pro:'YCurrent <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCurrent set_logFrequency',pro:'YCurrent <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'YCurrent set_logicalName',pro:'YCurrent <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the current sensor.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCurrent set_lowestValue',pro:'YCurrent <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCurrent set_reportFrequency',pro:'YCurrent <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCurrent set_resolution',pro:'YCurrent <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCurrent startDataLogger',pro:'YCurrent <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Current']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCurrent stopDataLogger',pro:'YCurrent <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Current']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YCurrent unmuteValueCallbacks',pro:'YCurrent <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Current)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'YDisplay copyLayerContent',pro:'YDisplay <span id=pn>target</span> copyLayerContent <span id=pn>srcLayerId</span> <span id=pn>dstLayerId</span>',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'YDisplay fade',pro:'YDisplay <span id=pn>target</span> fade <span id=pn>brightness</span> <span id=pn>duration</span>',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'YDisplay get_advertisedValue',pro:'YDisplay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:''};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'YDisplay get_brightness',pro:'YDisplay <span id=pn>target</span> get_brightness',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:''};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'YDisplay get_displayHeight',pro:'YDisplay <span id=pn>target</span> get_displayHeight',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:''};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'YDisplay get_displayType',pro:'YDisplay <span id=pn>target</span> get_displayType',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>MONO</tt>, <tt>GRAY</tt> and <tt>RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:''};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'YDisplay get_displayWidth',pro:'YDisplay <span id=pn>target</span> get_displayWidth',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:''};
doc['Display']['get_enabled']={syn:'Returns true if the screen is powered, false otherwise.',lib:'YDisplay get_enabled',pro:'YDisplay <span id=pn>target</span> get_enabled',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the screen is powered, false otherwise',ext:''};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'YDisplay get_layerCount',pro:'YDisplay <span id=pn>target</span> get_layerCount',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:''};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'YDisplay get_layerHeight',pro:'YDisplay <span id=pn>target</span> get_layerHeight',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:''};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'YDisplay get_layerWidth',pro:'YDisplay <span id=pn>target</span> get_layerWidth',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:''};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'YDisplay get_logicalName',pro:'YDisplay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:''};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'YDisplay get_orientation',pro:'YDisplay <span id=pn>target</span> get_orientation',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>LEFT</tt>, <tt>UP</tt>, <tt>RIGHT</tt> and <tt>DOWN</tt> corresponding to the currently selected display orientation',ext:''};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'YDisplay get_startupSeq',pro:'YDisplay <span id=pn>target</span> get_startupSeq',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:''};
doc['Display']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YDisplay muteValueCallbacks',pro:'YDisplay <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'YDisplay newSequence',pro:'YDisplay <span id=pn>target</span> newSequence',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'YDisplay pauseSequence',pro:'YDisplay <span id=pn>target</span> pauseSequence <span id=pn>delay_ms</span>',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'YDisplay playSequence',pro:'YDisplay <span id=pn>target</span> playSequence <span id=pn>sequenceName</span>',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'YDisplay resetAll',pro:'YDisplay <span id=pn>target</span> resetAll',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'YDisplay saveSequence',pro:'YDisplay <span id=pn>target</span> saveSequence <span id=pn>sequenceName</span>',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'YDisplay set_brightness',pro:'YDisplay <span id=pn>target</span> set_brightness <span id=pn>newval</span>',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_enabled']={syn:'Changes the power state of the display.',lib:'YDisplay set_enabled',pro:'YDisplay <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the power state of the display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'YDisplay set_logicalName',pro:'YDisplay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the display.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'YDisplay set_orientation',pro:'YDisplay <span id=pn>target</span> set_orientation <span id=pn>newval</span>',cmt:'<p>Changes the display orientation.</p>',par:{newval:'a value among <tt>LEFT</tt>, <tt>UP</tt>, <tt>RIGHT</tt> and <tt>DOWN</tt> corresponding to the display orientation'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'YDisplay set_startupSeq',pro:'YDisplay <span id=pn>target</span> set_startupSeq <span id=pn>newval</span>',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'YDisplay stopSequence',pro:'YDisplay <span id=pn>target</span> stopSequence',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'YDisplay swapLayerContent',pro:'YDisplay <span id=pn>target</span> swapLayerContent <span id=pn>layerIdA</span> <span id=pn>layerIdB</span>',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between one hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YDisplay unmuteValueCallbacks',pro:'YDisplay <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'YDisplay upload',pro:'YDisplay <span id=pn>target</span> upload <span id=pn>pathname</span> <span id=pn>content</span>',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Display)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'YFiles download',pro:'YFiles <span id=pn>target</span> download <span id=pn>pathname</span>',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:''};
doc['Files']['fileExist']={syn:'Test if a file exist on the filesystem of the module.',lib:'YFiles fileExist',pro:'YFiles <span id=pn>target</span> fileExist <span id=pn>filename</span>',cmt:'<p>Test if a file exist on the filesystem of the module.</p>',par:{filename:'the file name to test.'},ret:'a true if the file exist, false otherwise.',ext:''};
doc['Files']['format_fs']={syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'YFiles format_fs',pro:'YFiles <span id=pn>target</span> format_fs',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'YFiles get_advertisedValue',pro:'YFiles <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:''};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'YFiles get_filesCount',pro:'YFiles <span id=pn>target</span> get_filesCount',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:''};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'YFiles get_freeSpace',pro:'YFiles <span id=pn>target</span> get_freeSpace',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:''};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'YFiles get_list',pro:'YFiles <span id=pn>target</span> get_list <span id=pn>pattern</span>',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wild cards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:''};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'YFiles get_logicalName',pro:'YFiles <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:''};
doc['Files']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YFiles muteValueCallbacks',pro:'YFiles <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'YFiles remove',pro:'YFiles <span id=pn>target</span> remove <span id=pn>pathname</span>',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'YFiles set_logicalName',pro:'YFiles <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the filesystem.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YFiles unmuteValueCallbacks',pro:'YFiles <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'YFiles upload',pro:'YFiles <span id=pn>target</span> upload <span id=pn>pathname</span> <span id=pn>content</span>',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Files)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'',cmt:'<p>The YGenericSensor class allows you to read and configure Yoctopuce signal transducers. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGenericSensor calibrateFromPoints',pro:'YGenericSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGenericSensor get_advMode',pro:'YGenericSensor <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'YGenericSensor get_advertisedValue',pro:'YGenericSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:''};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'YGenericSensor get_currentRawValue',pro:'YGenericSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:''};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'YGenericSensor get_currentValue',pro:'YGenericSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:''};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YGenericSensor get_highestValue',pro:'YGenericSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['GenericSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGenericSensor get_logFrequency',pro:'YGenericSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'YGenericSensor get_logicalName',pro:'YGenericSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:''};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YGenericSensor get_lowestValue',pro:'YGenericSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['GenericSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGenericSensor get_recordedData',pro:'YGenericSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGenericSensor get_reportFrequency',pro:'YGenericSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGenericSensor get_resolution',pro:'YGenericSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['GenericSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGenericSensor get_sensorState',pro:'YGenericSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['GenericSensor']['get_signalBias']={syn:'Returns the electric signal bias for zero shift adjustment.',lib:'YGenericSensor get_signalBias',pro:'YGenericSensor <span id=pn>target</span> get_signalBias',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is under-reporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:''};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'YGenericSensor get_signalRange',pro:'YGenericSensor <span id=pn>target</span> get_signalRange',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:''};
doc['GenericSensor']['get_signalSampling']={syn:'Returns the electric signal sampling method to use.',lib:'YGenericSensor get_signalSampling',pro:'YGenericSensor <span id=pn>target</span> get_signalSampling',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>HIGH_RATE</tt>, <tt>HIGH_RATE_FILTERED</tt>, <tt>LOW_NOISE</tt>, <tt>LOW_NOISE_FILTERED</tt> and <tt>HIGHEST_RATE</tt> corresponding to the electric signal sampling method to use',ext:''};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'YGenericSensor get_signalUnit',pro:'YGenericSensor <span id=pn>target</span> get_signalUnit',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:''};
doc['GenericSensor']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'YGenericSensor get_signalValue',pro:'YGenericSensor <span id=pn>target</span> get_signalValue',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:''};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YGenericSensor get_unit',pro:'YGenericSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'YGenericSensor get_valueRange',pro:'YGenericSensor <span id=pn>target</span> get_valueRange',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:''};
doc['GenericSensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGenericSensor isSensorReady',pro:'YGenericSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGenericSensor loadCalibrationPoints',pro:'YGenericSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YGenericSensor muteValueCallbacks',pro:'YGenericSensor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['GenericSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGenericSensor set_advMode',pro:'YGenericSensor <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGenericSensor set_highestValue',pro:'YGenericSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGenericSensor set_logFrequency',pro:'YGenericSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'YGenericSensor set_logicalName',pro:'YGenericSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the generic sensor.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGenericSensor set_lowestValue',pro:'YGenericSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGenericSensor set_reportFrequency',pro:'YGenericSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGenericSensor set_resolution',pro:'YGenericSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalBias']={syn:'Changes the electric signal bias for zero shift adjustment.',lib:'YGenericSensor set_signalBias',pro:'YGenericSensor <span id=pn>target</span> set_signalBias <span id=pn>newval</span>',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positive when it should be zero, setup a positive signalBias of the same value to fix the zero shift.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'YGenericSensor set_signalRange',pro:'YGenericSensor <span id=pn>target</span> set_signalRange <span id=pn>newval</span>',cmt:'<p>Changes the electric signal range used by the sensor. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalSampling']={syn:'Changes the electric signal sampling method to use.',lib:'YGenericSensor set_signalSampling',pro:'YGenericSensor <span id=pn>target</span> set_signalSampling <span id=pn>newval</span>',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',par:{newval:'a value among <tt>HIGH_RATE</tt>, <tt>HIGH_RATE_FILTERED</tt>, <tt>LOW_NOISE</tt>, <tt>LOW_NOISE_FILTERED</tt> and <tt>HIGHEST_RATE</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'YGenericSensor set_unit',pro:'YGenericSensor <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured value.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'YGenericSensor set_valueRange',pro:'YGenericSensor <span id=pn>target</span> set_valueRange <span id=pn>newval</span>',cmt:'<p>Changes the physical value range measured by the sensor. As a side effect, the range modification may automatically modify the display resolution. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGenericSensor startDataLogger',pro:'YGenericSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GenericSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGenericSensor stopDataLogger',pro:'YGenericSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GenericSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YGenericSensor unmuteValueCallbacks',pro:'YGenericSensor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['GenericSensor']['zeroAdjust']={syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'YGenericSensor zeroAdjust',pro:'YGenericSensor <span id=pn>target</span> zeroAdjust',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: GenericSensor)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'',cmt:'<p>The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'YLightSensor calibrate',pro:'YLightSensor <span id=pn>target</span> calibrate <span id=pn>calibratedVal</span>',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLightSensor calibrateFromPoints',pro:'YLightSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLightSensor get_advMode',pro:'YLightSensor <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'YLightSensor get_advertisedValue',pro:'YLightSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:''};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YLightSensor get_currentRawValue',pro:'YLightSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['LightSensor']['get_currentValue']={syn:'Returns the current value of the ambient light, in the specified unit, as a floating point number.',lib:'YLightSensor get_currentValue',pro:'YLightSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the ambient light, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in the specified unit, as a floating point number',ext:''};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'YLightSensor get_highestValue',pro:'YLightSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:''};
doc['LightSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLightSensor get_logFrequency',pro:'YLightSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'YLightSensor get_logicalName',pro:'YLightSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:''};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'YLightSensor get_lowestValue',pro:'YLightSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:''};
doc['LightSensor']['get_measureType']={syn:'Returns the type of light measure.',lib:'YLightSensor get_measureType',pro:'YLightSensor <span id=pn>target</span> get_measureType',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>HUMAN_EYE</tt>, <tt>WIDE_SPECTRUM</tt>, <tt>INFRARED</tt>, <tt>HIGH_RATE</tt> and <tt>HIGH_ENERGY</tt> corresponding to the type of light measure',ext:''};
doc['LightSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLightSensor get_recordedData',pro:'YLightSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['LightSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLightSensor get_reportFrequency',pro:'YLightSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLightSensor get_resolution',pro:'YLightSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['LightSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLightSensor get_sensorState',pro:'YLightSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the ambient light.',lib:'YLightSensor get_unit',pro:'YLightSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:''};
doc['LightSensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLightSensor isSensorReady',pro:'YLightSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['LightSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLightSensor loadCalibrationPoints',pro:'YLightSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YLightSensor muteValueCallbacks',pro:'YLightSensor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['LightSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLightSensor set_advMode',pro:'YLightSensor <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLightSensor set_highestValue',pro:'YLightSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLightSensor set_logFrequency',pro:'YLightSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'YLightSensor set_logicalName',pro:'YLightSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the light sensor.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLightSensor set_lowestValue',pro:'YLightSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_measureType']={syn:'Changes the light sensor type used in the device.',lib:'YLightSensor set_measureType',pro:'YLightSensor <span id=pn>target</span> set_measureType <span id=pn>newval</span>',cmt:'<p>Changes the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell.</p>',par:{newval:'a value among <tt>HUMAN_EYE</tt>, <tt>WIDE_SPECTRUM</tt>, <tt>INFRARED</tt>, <tt>HIGH_RATE</tt> and <tt>HIGH_ENERGY</tt> corresponding to the light sensor type used in the device'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLightSensor set_reportFrequency',pro:'YLightSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLightSensor set_resolution',pro:'YLightSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLightSensor startDataLogger',pro:'YLightSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['LightSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLightSensor stopDataLogger',pro:'YLightSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['LightSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YLightSensor unmuteValueCallbacks',pro:'YLightSensor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: LightSensor)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'',cmt:'<p>The Yoctopuce class YPower allows you to read and configure Yoctopuce power sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPower calibrateFromPoints',pro:'YPower <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPower get_advMode',pro:'YPower <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'YPower get_advertisedValue',pro:'YPower <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:''};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'YPower get_cosPhi',pro:'YPower <span id=pn>target</span> get_cosPhi',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:''};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'YPower get_currentRawValue',pro:'YPower <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:''};
doc['Power']['get_currentValue']={syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'YPower get_currentValue',pro:'YPower <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:''};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'YPower get_highestValue',pro:'YPower <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:''};
doc['Power']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPower get_logFrequency',pro:'YPower <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'YPower get_logicalName',pro:'YPower <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:''};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'YPower get_lowestValue',pro:'YPower <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:''};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'YPower get_meter',pro:'YPower <span id=pn>target</span> get_meter',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:''};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'YPower get_meterTimer',pro:'YPower <span id=pn>target</span> get_meterTimer',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:''};
doc['Power']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPower get_recordedData',pro:'YPower <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Power']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPower get_reportFrequency',pro:'YPower <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPower get_resolution',pro:'YPower <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Power']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPower get_sensorState',pro:'YPower <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the electrical power.',lib:'YPower get_unit',pro:'YPower <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:''};
doc['Power']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPower isSensorReady',pro:'YPower <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Power']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPower loadCalibrationPoints',pro:'YPower <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPower muteValueCallbacks',pro:'YPower <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Power']['reset']={syn:'Resets the energy counter.',lib:'YPower reset',pro:'YPower <span id=pn>target</span> reset',cmt:'<p>Resets the energy counter.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPower set_advMode',pro:'YPower <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPower set_highestValue',pro:'YPower <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPower set_logFrequency',pro:'YPower <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'YPower set_logicalName',pro:'YPower <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the electrical power sensor.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPower set_lowestValue',pro:'YPower <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPower set_reportFrequency',pro:'YPower <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPower set_resolution',pro:'YPower <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPower startDataLogger',pro:'YPower <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Power']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPower stopDataLogger',pro:'YPower <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Power']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPower unmuteValueCallbacks',pro:'YPower <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Power)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'',cmt:'<p>The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YVoc calibrateFromPoints',pro:'YVoc <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YVoc get_advMode',pro:'YVoc <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'YVoc get_advertisedValue',pro:'YVoc <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:''};
doc['Voc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'YVoc get_currentRawValue',pro:'YVoc <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:''};
doc['Voc']['get_currentValue']={syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'YVoc get_currentValue',pro:'YVoc <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:''};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'YVoc get_highestValue',pro:'YVoc <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:''};
doc['Voc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YVoc get_logFrequency',pro:'YVoc <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'YVoc get_logicalName',pro:'YVoc <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:''};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'YVoc get_lowestValue',pro:'YVoc <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:''};
doc['Voc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YVoc get_recordedData',pro:'YVoc <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YVoc get_reportFrequency',pro:'YVoc <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YVoc get_resolution',pro:'YVoc <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Voc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YVoc get_sensorState',pro:'YVoc <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'YVoc get_unit',pro:'YVoc <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:''};
doc['Voc']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YVoc isSensorReady',pro:'YVoc <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Voc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YVoc loadCalibrationPoints',pro:'YVoc <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YVoc muteValueCallbacks',pro:'YVoc <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Voc']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YVoc set_advMode',pro:'YVoc <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YVoc set_highestValue',pro:'YVoc <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YVoc set_logFrequency',pro:'YVoc <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'YVoc set_logicalName',pro:'YVoc <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YVoc set_lowestValue',pro:'YVoc <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YVoc set_reportFrequency',pro:'YVoc <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YVoc set_resolution',pro:'YVoc <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YVoc startDataLogger',pro:'YVoc <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YVoc stopDataLogger',pro:'YVoc <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voc']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YVoc unmuteValueCallbacks',pro:'YVoc <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Voc)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'',cmt:'<p>The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YVoltage calibrateFromPoints',pro:'YVoltage <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YVoltage get_advMode',pro:'YVoltage <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'YVoltage get_advertisedValue',pro:'YVoltage <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:''};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'YVoltage get_currentRawValue',pro:'YVoltage <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:''};
doc['Voltage']['get_currentValue']={syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'YVoltage get_currentValue',pro:'YVoltage <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:''};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'YVoltage get_highestValue',pro:'YVoltage <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:''};
doc['Voltage']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YVoltage get_logFrequency',pro:'YVoltage <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'YVoltage get_logicalName',pro:'YVoltage <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:''};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'YVoltage get_lowestValue',pro:'YVoltage <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:''};
doc['Voltage']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YVoltage get_recordedData',pro:'YVoltage <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voltage']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YVoltage get_reportFrequency',pro:'YVoltage <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YVoltage get_resolution',pro:'YVoltage <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Voltage']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YVoltage get_sensorState',pro:'YVoltage <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'YVoltage get_unit',pro:'YVoltage <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:''};
doc['Voltage']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YVoltage isSensorReady',pro:'YVoltage <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Voltage']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YVoltage loadCalibrationPoints',pro:'YVoltage <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YVoltage muteValueCallbacks',pro:'YVoltage <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Voltage']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YVoltage set_advMode',pro:'YVoltage <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YVoltage set_highestValue',pro:'YVoltage <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YVoltage set_logFrequency',pro:'YVoltage <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'YVoltage set_logicalName',pro:'YVoltage <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage sensor.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YVoltage set_lowestValue',pro:'YVoltage <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YVoltage set_reportFrequency',pro:'YVoltage <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YVoltage set_resolution',pro:'YVoltage <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YVoltage startDataLogger',pro:'YVoltage <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voltage']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YVoltage stopDataLogger',pro:'YVoltage <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voltage']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YVoltage unmuteValueCallbacks',pro:'YVoltage <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Voltage)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'',cmt:'<p>YWireless functions provides control over wireless network parameters and status for devices that are wireless-enabled.</p>'}};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'YWireless adhocNetwork',pro:'YWireless <span id=pn>target</span> adhocNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g, it is best to use softAPNetworkInstead(), which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'YWireless get_advertisedValue',pro:'YWireless <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters).',ext:''};
doc['Wireless']['get_channel']={syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'YWireless get_channel',pro:'YWireless <span id=pn>target</span> get_channel',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:''};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects that describe detected Wireless networks.',lib:'YWireless get_detectedWlans',pro:'YWireless <span id=pn>target</span> get_detectedWlans',cmt:'<p>Returns a list of YWlanRecord objects that describe detected Wireless networks. This list is not updated when the module is already connected to an access point (infrastructure mode). To force an update of this list, <tt>startWlanScan()</tt> must be called. Note that an languages without garbage collections, the returned list must be freed by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:''};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'YWireless get_linkQuality',pro:'YWireless <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:''};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'YWireless get_logicalName',pro:'YWireless <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface.',ext:''};
doc['Wireless']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'YWireless get_message',pro:'YWireless <span id=pn>target</span> get_message',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:''};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'YWireless get_security',pro:'YWireless <span id=pn>target</span> get_security',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>UNKNOWN</tt>, <tt>OPEN</tt>, <tt>WEP</tt>, <tt>WPA</tt> and <tt>WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:''};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'YWireless get_ssid',pro:'YWireless <span id=pn>target</span> get_ssid',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:''};
doc['Wireless']['get_wlanState']={syn:'Returns the current state of the wireless interface.',lib:'YWireless get_wlanState',pro:'YWireless <span id=pn>target</span> get_wlanState',cmt:'<p>Returns the current state of the wireless interface. The state <tt>DOWN</tt> means that the network interface is not connected to a network. The state <tt>SCANNING</tt> means that the network interface is scanning available frequencies. During this stage, the device is not reachable, and the network settings are not yet applied. The state <tt>CONNECTED</tt> means that the network settings have been successfully applied ant that the device is reachable from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that the wireless network is up and that other devices can join the network. The state <tt>REJECTED</tt> means that the network interface has not been able to join the requested network. The description of the error can be obtain with the <tt>get_message()</tt> method.</p>',ret:'a value among <tt>DOWN</tt>, <tt>SCANNING</tt>, <tt>CONNECTED</tt> and <tt>REJECTED</tt> corresponding to the current state of the wireless interface',ext:''};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'YWireless joinNetwork',pro:'YWireless <span id=pn>target</span> joinNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YWireless muteValueCallbacks',pro:'YWireless <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'YWireless set_logicalName',pro:'YWireless <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the wireless lan interface.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Wireless']['softAPNetwork']={syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'YWireless softAPNetwork',pro:'YWireless <span id=pn>target</span> softAPNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g.</p><p> When a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['startWlanScan']={syn:'Triggers a scan of the wireless frequency and builds the list of available networks.',lib:'YWireless startWlanScan',pro:'YWireless <span id=pn>target</span> startWlanScan',cmt:'<p>Triggers a scan of the wireless frequency and builds the list of available networks. The scan forces a disconnection from the current network. At then end of the process, the the network interface attempts to reconnect to the previous network. During the scan, the <tt>wlanState</tt> switches to <tt>Y_WLANSTATE_DOWN</tt>, then to <tt>Y_WLANSTATE_SCANNING</tt>. When the scan is completed, <tt>get_wlanState()</tt> returns either <tt>Y_WLANSTATE_DOWN</tt> or <tt>Y_WLANSTATE_SCANNING</tt>. At this point, the list of detected network can be retrieved with the <tt>get_detectedWlans()</tt> method.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['Wireless']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YWireless unmuteValueCallbacks',pro:'YWireless <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Wireless)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Accelerometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YAccelerometer calibrateFromPoints',pro:'YAccelerometer <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YAccelerometer get_advMode',pro:'YAccelerometer <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Accelerometer']['get_advertisedValue']={syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'YAccelerometer get_advertisedValue',pro:'YAccelerometer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:''};
doc['Accelerometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YAccelerometer get_bandwidth',pro:'YAccelerometer <span id=pn>target</span> get_bandwidth',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:''};
doc['Accelerometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'YAccelerometer get_currentRawValue',pro:'YAccelerometer <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:''};
doc['Accelerometer']['get_currentValue']={syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'YAccelerometer get_currentValue',pro:'YAccelerometer <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:''};
doc['Accelerometer']['get_highestValue']={syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'YAccelerometer get_highestValue',pro:'YAccelerometer <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:''};
doc['Accelerometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YAccelerometer get_logFrequency',pro:'YAccelerometer <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Accelerometer']['get_logicalName']={syn:'Returns the logical name of the accelerometer.',lib:'YAccelerometer get_logicalName',pro:'YAccelerometer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:''};
doc['Accelerometer']['get_lowestValue']={syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'YAccelerometer get_lowestValue',pro:'YAccelerometer <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:''};
doc['Accelerometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YAccelerometer get_recordedData',pro:'YAccelerometer <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YAccelerometer get_reportFrequency',pro:'YAccelerometer <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Accelerometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YAccelerometer get_resolution',pro:'YAccelerometer <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Accelerometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YAccelerometer get_sensorState',pro:'YAccelerometer <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Accelerometer']['get_unit']={syn:'Returns the measuring unit for the acceleration.',lib:'YAccelerometer get_unit',pro:'YAccelerometer <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:''};
doc['Accelerometer']['get_xValue']={syn:'Returns the X component of the acceleration, as a floating point number.',lib:'YAccelerometer get_xValue',pro:'YAccelerometer <span id=pn>target</span> get_xValue',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['get_yValue']={syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'YAccelerometer get_yValue',pro:'YAccelerometer <span id=pn>target</span> get_yValue',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['get_zValue']={syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'YAccelerometer get_zValue',pro:'YAccelerometer <span id=pn>target</span> get_zValue',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YAccelerometer isSensorReady',pro:'YAccelerometer <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YAccelerometer loadCalibrationPoints',pro:'YAccelerometer <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YAccelerometer muteValueCallbacks',pro:'YAccelerometer <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Accelerometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YAccelerometer set_advMode',pro:'YAccelerometer <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YAccelerometer set_bandwidth',pro:'YAccelerometer <span id=pn>target</span> set_bandwidth <span id=pn>newval</span>',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YAccelerometer set_highestValue',pro:'YAccelerometer <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YAccelerometer set_logFrequency',pro:'YAccelerometer <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_logicalName']={syn:'Changes the logical name of the accelerometer.',lib:'YAccelerometer set_logicalName',pro:'YAccelerometer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the accelerometer.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YAccelerometer set_lowestValue',pro:'YAccelerometer <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YAccelerometer set_reportFrequency',pro:'YAccelerometer <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YAccelerometer set_resolution',pro:'YAccelerometer <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YAccelerometer startDataLogger',pro:'YAccelerometer <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Accelerometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YAccelerometer stopDataLogger',pro:'YAccelerometer <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Accelerometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YAccelerometer unmuteValueCallbacks',pro:'YAccelerometer <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Magnetometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YMagnetometer calibrateFromPoints',pro:'YMagnetometer <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YMagnetometer get_advMode',pro:'YMagnetometer <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Magnetometer']['get_advertisedValue']={syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'YMagnetometer get_advertisedValue',pro:'YMagnetometer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:''};
doc['Magnetometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YMagnetometer get_bandwidth',pro:'YMagnetometer <span id=pn>target</span> get_bandwidth',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:''};
doc['Magnetometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'YMagnetometer get_currentRawValue',pro:'YMagnetometer <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:''};
doc['Magnetometer']['get_currentValue']={syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'YMagnetometer get_currentValue',pro:'YMagnetometer <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:''};
doc['Magnetometer']['get_highestValue']={syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'YMagnetometer get_highestValue',pro:'YMagnetometer <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:''};
doc['Magnetometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YMagnetometer get_logFrequency',pro:'YMagnetometer <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Magnetometer']['get_logicalName']={syn:'Returns the logical name of the magnetometer.',lib:'YMagnetometer get_logicalName',pro:'YMagnetometer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:''};
doc['Magnetometer']['get_lowestValue']={syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'YMagnetometer get_lowestValue',pro:'YMagnetometer <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:''};
doc['Magnetometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YMagnetometer get_recordedData',pro:'YMagnetometer <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YMagnetometer get_reportFrequency',pro:'YMagnetometer <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Magnetometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YMagnetometer get_resolution',pro:'YMagnetometer <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Magnetometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YMagnetometer get_sensorState',pro:'YMagnetometer <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Magnetometer']['get_unit']={syn:'Returns the measuring unit for the magnetic field.',lib:'YMagnetometer get_unit',pro:'YMagnetometer <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:''};
doc['Magnetometer']['get_xValue']={syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_xValue',pro:'YMagnetometer <span id=pn>target</span> get_xValue',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['get_yValue']={syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_yValue',pro:'YMagnetometer <span id=pn>target</span> get_yValue',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['get_zValue']={syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_zValue',pro:'YMagnetometer <span id=pn>target</span> get_zValue',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YMagnetometer isSensorReady',pro:'YMagnetometer <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YMagnetometer loadCalibrationPoints',pro:'YMagnetometer <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMagnetometer muteValueCallbacks',pro:'YMagnetometer <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Magnetometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YMagnetometer set_advMode',pro:'YMagnetometer <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YMagnetometer set_bandwidth',pro:'YMagnetometer <span id=pn>target</span> set_bandwidth <span id=pn>newval</span>',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YMagnetometer set_highestValue',pro:'YMagnetometer <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YMagnetometer set_logFrequency',pro:'YMagnetometer <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_logicalName']={syn:'Changes the logical name of the magnetometer.',lib:'YMagnetometer set_logicalName',pro:'YMagnetometer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the magnetometer.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YMagnetometer set_lowestValue',pro:'YMagnetometer <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YMagnetometer set_reportFrequency',pro:'YMagnetometer <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YMagnetometer set_resolution',pro:'YMagnetometer <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YMagnetometer startDataLogger',pro:'YMagnetometer <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Magnetometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YMagnetometer stopDataLogger',pro:'YMagnetometer <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Magnetometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMagnetometer unmuteValueCallbacks',pro:'YMagnetometer <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Magnetometer)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Compass']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCompass calibrateFromPoints',pro:'YCompass <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCompass get_advMode',pro:'YCompass <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Compass']['get_advertisedValue']={syn:'Returns the current value of the compass (no more than 6 characters).',lib:'YCompass get_advertisedValue',pro:'YCompass <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the compass (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass (no more than 6 characters).',ext:''};
doc['Compass']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YCompass get_bandwidth',pro:'YCompass <span id=pn>target</span> get_bandwidth',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:''};
doc['Compass']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'YCompass get_currentRawValue',pro:'YCompass <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:''};
doc['Compass']['get_currentValue']={syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'YCompass get_currentValue',pro:'YCompass <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:''};
doc['Compass']['get_highestValue']={syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'YCompass get_highestValue',pro:'YCompass <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:''};
doc['Compass']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCompass get_logFrequency',pro:'YCompass <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Compass']['get_logicalName']={syn:'Returns the logical name of the compass.',lib:'YCompass get_logicalName',pro:'YCompass <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the compass.</p>',ret:'a string corresponding to the logical name of the compass.',ext:''};
doc['Compass']['get_lowestValue']={syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'YCompass get_lowestValue',pro:'YCompass <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:''};
doc['Compass']['get_magneticHeading']={syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'YCompass get_magneticHeading',pro:'YCompass <span id=pn>target</span> get_magneticHeading',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:''};
doc['Compass']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCompass get_recordedData',pro:'YCompass <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Compass']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCompass get_reportFrequency',pro:'YCompass <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Compass']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCompass get_resolution',pro:'YCompass <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Compass']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCompass get_sensorState',pro:'YCompass <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Compass']['get_unit']={syn:'Returns the measuring unit for the relative bearing.',lib:'YCompass get_unit',pro:'YCompass <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:''};
doc['Compass']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCompass isSensorReady',pro:'YCompass <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Compass']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCompass loadCalibrationPoints',pro:'YCompass <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YCompass muteValueCallbacks',pro:'YCompass <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Compass']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YCompass set_advMode',pro:'YCompass <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YCompass set_bandwidth',pro:'YCompass <span id=pn>target</span> set_bandwidth <span id=pn>newval</span>',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCompass set_highestValue',pro:'YCompass <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCompass set_logFrequency',pro:'YCompass <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_logicalName']={syn:'Changes the logical name of the compass.',lib:'YCompass set_logicalName',pro:'YCompass <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the compass.</p>',par:{newval:'a string corresponding to the logical name of the compass.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCompass set_lowestValue',pro:'YCompass <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCompass set_reportFrequency',pro:'YCompass <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCompass set_resolution',pro:'YCompass <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCompass startDataLogger',pro:'YCompass <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Compass']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCompass stopDataLogger',pro:'YCompass <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Compass']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YCompass unmuteValueCallbacks',pro:'YCompass <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Gyro']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGyro calibrateFromPoints',pro:'YGyro <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGyro get_advMode',pro:'YGyro <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Gyro']['get_advertisedValue']={syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'YGyro get_advertisedValue',pro:'YGyro <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:''};
doc['Gyro']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YGyro get_bandwidth',pro:'YGyro <span id=pn>target</span> get_bandwidth',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:''};
doc['Gyro']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'YGyro get_currentRawValue',pro:'YGyro <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:''};
doc['Gyro']['get_currentValue']={syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'YGyro get_currentValue',pro:'YGyro <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:''};
doc['Gyro']['get_heading']={syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_heading',pro:'YGyro <span id=pn>target</span> get_heading',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'};
doc['Gyro']['get_highestValue']={syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'YGyro get_highestValue',pro:'YGyro <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:''};
doc['Gyro']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGyro get_logFrequency',pro:'YGyro <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Gyro']['get_logicalName']={syn:'Returns the logical name of the gyroscope.',lib:'YGyro get_logicalName',pro:'YGyro <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:''};
doc['Gyro']['get_lowestValue']={syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'YGyro get_lowestValue',pro:'YGyro <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:''};
doc['Gyro']['get_pitch']={syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_pitch',pro:'YGyro <span id=pn>target</span> get_pitch',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'};
doc['Gyro']['get_quaternionW']={syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionW',pro:'YGyro <span id=pn>target</span> get_quaternionW',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.</p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionX',pro:'YGyro <span id=pn>target</span> get_quaternionX',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionY',pro:'YGyro <span id=pn>target</span> get_quaternionY',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionZ',pro:'YGyro <span id=pn>target</span> get_quaternionZ',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGyro get_recordedData',pro:'YGyro <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Gyro']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGyro get_reportFrequency',pro:'YGyro <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Gyro']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGyro get_resolution',pro:'YGyro <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Gyro']['get_roll']={syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_roll',pro:'YGyro <span id=pn>target</span> get_roll',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'};
doc['Gyro']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGyro get_sensorState',pro:'YGyro <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Gyro']['get_unit']={syn:'Returns the measuring unit for the angular velocity.',lib:'YGyro get_unit',pro:'YGyro <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:''};
doc['Gyro']['get_xValue']={syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'YGyro get_xValue',pro:'YGyro <span id=pn>target</span> get_xValue',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:''};
doc['Gyro']['get_yValue']={syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'YGyro get_yValue',pro:'YGyro <span id=pn>target</span> get_yValue',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:''};
doc['Gyro']['get_zValue']={syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'YGyro get_zValue',pro:'YGyro <span id=pn>target</span> get_zValue',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:''};
doc['Gyro']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGyro isSensorReady',pro:'YGyro <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Gyro']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGyro loadCalibrationPoints',pro:'YGyro <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YGyro muteValueCallbacks',pro:'YGyro <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Gyro']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGyro set_advMode',pro:'YGyro <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YGyro set_bandwidth',pro:'YGyro <span id=pn>target</span> set_bandwidth <span id=pn>newval</span>',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGyro set_highestValue',pro:'YGyro <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGyro set_logFrequency',pro:'YGyro <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_logicalName']={syn:'Changes the logical name of the gyroscope.',lib:'YGyro set_logicalName',pro:'YGyro <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the gyroscope.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGyro set_lowestValue',pro:'YGyro <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGyro set_reportFrequency',pro:'YGyro <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGyro set_resolution',pro:'YGyro <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGyro startDataLogger',pro:'YGyro <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Gyro']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGyro stopDataLogger',pro:'YGyro <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Gyro']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YGyro unmuteValueCallbacks',pro:'YGyro <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Tilt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YTilt calibrateFromPoints',pro:'YTilt <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTilt get_advMode',pro:'YTilt <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Tilt']['get_advertisedValue']={syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'YTilt get_advertisedValue',pro:'YTilt <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:''};
doc['Tilt']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YTilt get_bandwidth',pro:'YTilt <span id=pn>target</span> get_bandwidth',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:''};
doc['Tilt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'YTilt get_currentRawValue',pro:'YTilt <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:''};
doc['Tilt']['get_currentValue']={syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'YTilt get_currentValue',pro:'YTilt <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:''};
doc['Tilt']['get_highestValue']={syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'YTilt get_highestValue',pro:'YTilt <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:''};
doc['Tilt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YTilt get_logFrequency',pro:'YTilt <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Tilt']['get_logicalName']={syn:'Returns the logical name of the tilt sensor.',lib:'YTilt get_logicalName',pro:'YTilt <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:''};
doc['Tilt']['get_lowestValue']={syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'YTilt get_lowestValue',pro:'YTilt <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:''};
doc['Tilt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YTilt get_recordedData',pro:'YTilt <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tilt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YTilt get_reportFrequency',pro:'YTilt <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Tilt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YTilt get_resolution',pro:'YTilt <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Tilt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YTilt get_sensorState',pro:'YTilt <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Tilt']['get_unit']={syn:'Returns the measuring unit for the inclination.',lib:'YTilt get_unit',pro:'YTilt <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:''};
doc['Tilt']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YTilt isSensorReady',pro:'YTilt <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Tilt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YTilt loadCalibrationPoints',pro:'YTilt <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YTilt muteValueCallbacks',pro:'YTilt <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Tilt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTilt set_advMode',pro:'YTilt <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'YTilt set_bandwidth',pro:'YTilt <span id=pn>target</span> set_bandwidth <span id=pn>newval</span>',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YTilt set_highestValue',pro:'YTilt <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YTilt set_logFrequency',pro:'YTilt <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_logicalName']={syn:'Changes the logical name of the tilt sensor.',lib:'YTilt set_logicalName',pro:'YTilt <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the tilt sensor.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YTilt set_lowestValue',pro:'YTilt <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YTilt set_reportFrequency',pro:'YTilt <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YTilt set_resolution',pro:'YTilt <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YTilt startDataLogger',pro:'YTilt <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Tilt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YTilt stopDataLogger',pro:'YTilt <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Tilt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YTilt unmuteValueCallbacks',pro:'YTilt <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Tilt)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altitude function interface',inc:'',cmt:'<p>The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}};
doc['Altitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YAltitude calibrateFromPoints',pro:'YAltitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YAltitude get_advMode',pro:'YAltitude <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Altitude']['get_advertisedValue']={syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'YAltitude get_advertisedValue',pro:'YAltitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:''};
doc['Altitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'YAltitude get_currentRawValue',pro:'YAltitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:''};
doc['Altitude']['get_currentValue']={syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'YAltitude get_currentValue',pro:'YAltitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:''};
doc['Altitude']['get_highestValue']={syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'YAltitude get_highestValue',pro:'YAltitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:''};
doc['Altitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YAltitude get_logFrequency',pro:'YAltitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Altitude']['get_logicalName']={syn:'Returns the logical name of the altimeter.',lib:'YAltitude get_logicalName',pro:'YAltitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:''};
doc['Altitude']['get_lowestValue']={syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'YAltitude get_lowestValue',pro:'YAltitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:''};
doc['Altitude']['get_qnh']={syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'YAltitude get_qnh',pro:'YAltitude <span id=pn>target</span> get_qnh',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH). Applicable to barometric altimeters only.</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:''};
doc['Altitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YAltitude get_recordedData',pro:'YAltitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Altitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YAltitude get_reportFrequency',pro:'YAltitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Altitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YAltitude get_resolution',pro:'YAltitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Altitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YAltitude get_sensorState',pro:'YAltitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Altitude']['get_technology']={syn:'Returns the technology used by the sesnor to compute altitude.',lib:'YAltitude get_technology',pro:'YAltitude <span id=pn>target</span> get_technology',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:''};
doc['Altitude']['get_unit']={syn:'Returns the measuring unit for the altitude.',lib:'YAltitude get_unit',pro:'YAltitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:''};
doc['Altitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YAltitude isSensorReady',pro:'YAltitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Altitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YAltitude loadCalibrationPoints',pro:'YAltitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YAltitude muteValueCallbacks',pro:'YAltitude <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Altitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YAltitude set_advMode',pro:'YAltitude <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_currentValue']={syn:'Changes the current estimated altitude.',lib:'YAltitude set_currentValue',pro:'YAltitude <span id=pn>target</span> set_currentValue <span id=pn>newval</span>',cmt:'<p>Changes the current estimated altitude. This allows to compensate for ambient pressure variations and to work in relative mode.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YAltitude set_highestValue',pro:'YAltitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YAltitude set_logFrequency',pro:'YAltitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_logicalName']={syn:'Changes the logical name of the altimeter.',lib:'YAltitude set_logicalName',pro:'YAltitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the altimeter.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YAltitude set_lowestValue',pro:'YAltitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_qnh']={syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'YAltitude set_qnh',pro:'YAltitude <span id=pn>target</span> set_qnh <span id=pn>newval</span>',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions. Applicable to barometric altimeters only.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YAltitude set_reportFrequency',pro:'YAltitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YAltitude set_resolution',pro:'YAltitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YAltitude startDataLogger',pro:'YAltitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Altitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YAltitude stopDataLogger',pro:'YAltitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Altitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YAltitude unmuteValueCallbacks',pro:'YAltitude <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Altitude)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PwmInput function interface',inc:'',cmt:'<p>The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cycle, the frequency or the pulse width.</p>'}};
doc['PwmInput']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPwmInput calibrateFromPoints',pro:'YPwmInput <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPwmInput get_advMode',pro:'YPwmInput <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['PwmInput']['get_advertisedValue']={syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'YPwmInput get_advertisedValue',pro:'YPwmInput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:''};
doc['PwmInput']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'YPwmInput get_currentRawValue',pro:'YPwmInput <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:''};
doc['PwmInput']['get_currentValue']={syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'YPwmInput get_currentValue',pro:'YPwmInput <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in %, the pulse length in ms, etc.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:''};
doc['PwmInput']['get_debouncePeriod']={syn:'Returns the shortest expected pulse duration, in ms.',lib:'YPwmInput get_debouncePeriod',pro:'YPwmInput <span id=pn>target</span> get_debouncePeriod',cmt:'<p>Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',ret:'an integer corresponding to the shortest expected pulse duration, in ms',ext:''};
doc['PwmInput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'YPwmInput get_dutyCycle',pro:'YPwmInput <span id=pn>target</span> get_dutyCycle',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:''};
doc['PwmInput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'YPwmInput get_frequency',pro:'YPwmInput <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:''};
doc['PwmInput']['get_highestValue']={syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'YPwmInput get_highestValue',pro:'YPwmInput <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:''};
doc['PwmInput']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPwmInput get_logFrequency',pro:'YPwmInput <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['PwmInput']['get_logicalName']={syn:'Returns the logical name of the PWM input.',lib:'YPwmInput get_logicalName',pro:'YPwmInput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:''};
doc['PwmInput']['get_lowestValue']={syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'YPwmInput get_lowestValue',pro:'YPwmInput <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:''};
doc['PwmInput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'YPwmInput get_period',pro:'YPwmInput <span id=pn>target</span> get_period',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:''};
doc['PwmInput']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'YPwmInput get_pulseCounter',pro:'YPwmInput <span id=pn>target</span> get_pulseCounter',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion.</p>',ret:'an integer corresponding to the pulse counter value',ext:''};
doc['PwmInput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'YPwmInput get_pulseDuration',pro:'YPwmInput <span id=pn>target</span> get_pulseDuration',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:''};
doc['PwmInput']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'YPwmInput get_pulseTimer',pro:'YPwmInput <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:''};
doc['PwmInput']['get_pwmReportMode']={syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'YPwmInput get_pwmReportMode',pro:'YPwmInput <span id=pn>target</span> get_pwmReportMode',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>PWM_DUTYCYCLE</tt>, <tt>PWM_FREQUENCY</tt>, <tt>PWM_PULSEDURATION</tt>, <tt>PWM_EDGECOUNT</tt>, <tt>PWM_PULSECOUNT</tt>, <tt>PWM_CPS</tt>, <tt>PWM_CPM</tt>, <tt>PWM_STATE</tt>, <tt>PWM_FREQ_CPS</tt> and <tt>PWM_FREQ_CPM</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:''};
doc['PwmInput']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPwmInput get_recordedData',pro:'YPwmInput <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['PwmInput']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPwmInput get_reportFrequency',pro:'YPwmInput <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['PwmInput']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPwmInput get_resolution',pro:'YPwmInput <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['PwmInput']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPwmInput get_sensorState',pro:'YPwmInput <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['PwmInput']['get_unit']={syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'YPwmInput get_unit',pro:'YPwmInput <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings but can be modified if needed.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:''};
doc['PwmInput']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPwmInput isSensorReady',pro:'YPwmInput <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['PwmInput']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPwmInput loadCalibrationPoints',pro:'YPwmInput <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPwmInput muteValueCallbacks',pro:'YPwmInput <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmInput']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'YPwmInput resetCounter',pro:'YPwmInput <span id=pn>target</span> resetCounter',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YPwmInput set_advMode',pro:'YPwmInput <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_debouncePeriod']={syn:'Changes the shortest expected pulse duration, in ms.',lib:'YPwmInput set_debouncePeriod',pro:'YPwmInput <span id=pn>target</span> set_debouncePeriod <span id=pn>newval</span>',cmt:'<p>Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',par:{newval:'an integer corresponding to the shortest expected pulse duration, in ms'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPwmInput set_highestValue',pro:'YPwmInput <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPwmInput set_logFrequency',pro:'YPwmInput <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_logicalName']={syn:'Changes the logical name of the PWM input.',lib:'YPwmInput set_logicalName',pro:'YPwmInput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the PWM input.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPwmInput set_lowestValue',pro:'YPwmInput <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_pwmReportMode']={syn:'Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'YPwmInput set_pwmReportMode',pro:'YPwmInput <span id=pn>target</span> set_pwmReportMode <span id=pn>newval</span>',cmt:'<p>Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>PWM_DUTYCYCLE</tt>, <tt>PWM_FREQUENCY</tt>, <tt>PWM_PULSEDURATION</tt>, <tt>PWM_EDGECOUNT</tt>, <tt>PWM_PULSECOUNT</tt>, <tt>PWM_CPS</tt>, <tt>PWM_CPM</tt>, <tt>PWM_STATE</tt>, <tt>PWM_FREQ_CPS</tt> and <tt>PWM_FREQ_CPM</tt> corresponding to the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPwmInput set_reportFrequency',pro:'YPwmInput <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPwmInput set_resolution',pro:'YPwmInput <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_unit']={syn:'Changes the measuring unit for the measured quantity.',lib:'YPwmInput set_unit',pro:'YPwmInput <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured quantity. That unit is just a string which is automatically initialized each time the measurement mode is changed. But is can be set to an arbitrary value.</p>',par:{newval:'a string corresponding to the measuring unit for the measured quantity'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPwmInput startDataLogger',pro:'YPwmInput <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['PwmInput']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPwmInput stopDataLogger',pro:'YPwmInput <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['PwmInput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPwmInput unmuteValueCallbacks',pro:'YPwmInput <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: PwmInput)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude function interface',inc:'',cmt:'<p>The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Latitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLatitude calibrateFromPoints',pro:'YLatitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLatitude get_advMode',pro:'YLatitude <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Latitude']['get_advertisedValue']={syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'YLatitude get_advertisedValue',pro:'YLatitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:''};
doc['Latitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'YLatitude get_currentRawValue',pro:'YLatitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:''};
doc['Latitude']['get_currentValue']={syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'YLatitude get_currentValue',pro:'YLatitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:''};
doc['Latitude']['get_highestValue']={syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'YLatitude get_highestValue',pro:'YLatitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:''};
doc['Latitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLatitude get_logFrequency',pro:'YLatitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Latitude']['get_logicalName']={syn:'Returns the logical name of the latitude sensor.',lib:'YLatitude get_logicalName',pro:'YLatitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:''};
doc['Latitude']['get_lowestValue']={syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'YLatitude get_lowestValue',pro:'YLatitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:''};
doc['Latitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLatitude get_recordedData',pro:'YLatitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Latitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLatitude get_reportFrequency',pro:'YLatitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Latitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLatitude get_resolution',pro:'YLatitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Latitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLatitude get_sensorState',pro:'YLatitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Latitude']['get_unit']={syn:'Returns the measuring unit for the latitude.',lib:'YLatitude get_unit',pro:'YLatitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:''};
doc['Latitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLatitude isSensorReady',pro:'YLatitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Latitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLatitude loadCalibrationPoints',pro:'YLatitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YLatitude muteValueCallbacks',pro:'YLatitude <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Latitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLatitude set_advMode',pro:'YLatitude <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLatitude set_highestValue',pro:'YLatitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLatitude set_logFrequency',pro:'YLatitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_logicalName']={syn:'Changes the logical name of the latitude sensor.',lib:'YLatitude set_logicalName',pro:'YLatitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the latitude sensor.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLatitude set_lowestValue',pro:'YLatitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLatitude set_reportFrequency',pro:'YLatitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLatitude set_resolution',pro:'YLatitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLatitude startDataLogger',pro:'YLatitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Latitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLatitude stopDataLogger',pro:'YLatitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Latitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YLatitude unmuteValueCallbacks',pro:'YLatitude <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude function interface',inc:'',cmt:'<p>The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Longitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLongitude calibrateFromPoints',pro:'YLongitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLongitude get_advMode',pro:'YLongitude <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Longitude']['get_advertisedValue']={syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'YLongitude get_advertisedValue',pro:'YLongitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:''};
doc['Longitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'YLongitude get_currentRawValue',pro:'YLongitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:''};
doc['Longitude']['get_currentValue']={syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'YLongitude get_currentValue',pro:'YLongitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:''};
doc['Longitude']['get_highestValue']={syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'YLongitude get_highestValue',pro:'YLongitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:''};
doc['Longitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLongitude get_logFrequency',pro:'YLongitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Longitude']['get_logicalName']={syn:'Returns the logical name of the longitude sensor.',lib:'YLongitude get_logicalName',pro:'YLongitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:''};
doc['Longitude']['get_lowestValue']={syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'YLongitude get_lowestValue',pro:'YLongitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:''};
doc['Longitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLongitude get_recordedData',pro:'YLongitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Longitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLongitude get_reportFrequency',pro:'YLongitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Longitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLongitude get_resolution',pro:'YLongitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Longitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLongitude get_sensorState',pro:'YLongitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Longitude']['get_unit']={syn:'Returns the measuring unit for the longitude.',lib:'YLongitude get_unit',pro:'YLongitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:''};
doc['Longitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLongitude isSensorReady',pro:'YLongitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Longitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLongitude loadCalibrationPoints',pro:'YLongitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YLongitude muteValueCallbacks',pro:'YLongitude <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Longitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YLongitude set_advMode',pro:'YLongitude <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLongitude set_highestValue',pro:'YLongitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLongitude set_logFrequency',pro:'YLongitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_logicalName']={syn:'Changes the logical name of the longitude sensor.',lib:'YLongitude set_logicalName',pro:'YLongitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the longitude sensor.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLongitude set_lowestValue',pro:'YLongitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLongitude set_reportFrequency',pro:'YLongitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLongitude set_resolution',pro:'YLongitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLongitude startDataLogger',pro:'YLongitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Longitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLongitude stopDataLogger',pro:'YLongitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Longitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YLongitude unmuteValueCallbacks',pro:'YLongitude <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'GroundSpeed function interface',inc:'',cmt:'<p>The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGroundSpeed calibrateFromPoints',pro:'YGroundSpeed <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGroundSpeed get_advMode',pro:'YGroundSpeed <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['GroundSpeed']['get_advertisedValue']={syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'YGroundSpeed get_advertisedValue',pro:'YGroundSpeed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:''};
doc['GroundSpeed']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'YGroundSpeed get_currentRawValue',pro:'YGroundSpeed <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:''};
doc['GroundSpeed']['get_currentValue']={syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'YGroundSpeed get_currentValue',pro:'YGroundSpeed <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:''};
doc['GroundSpeed']['get_highestValue']={syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'YGroundSpeed get_highestValue',pro:'YGroundSpeed <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:''};
doc['GroundSpeed']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGroundSpeed get_logFrequency',pro:'YGroundSpeed <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['GroundSpeed']['get_logicalName']={syn:'Returns the logical name of the ground speed sensor.',lib:'YGroundSpeed get_logicalName',pro:'YGroundSpeed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:''};
doc['GroundSpeed']['get_lowestValue']={syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'YGroundSpeed get_lowestValue',pro:'YGroundSpeed <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:''};
doc['GroundSpeed']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGroundSpeed get_recordedData',pro:'YGroundSpeed <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGroundSpeed get_reportFrequency',pro:'YGroundSpeed <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['GroundSpeed']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGroundSpeed get_resolution',pro:'YGroundSpeed <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['GroundSpeed']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGroundSpeed get_sensorState',pro:'YGroundSpeed <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['GroundSpeed']['get_unit']={syn:'Returns the measuring unit for the ground speed.',lib:'YGroundSpeed get_unit',pro:'YGroundSpeed <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:''};
doc['GroundSpeed']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGroundSpeed isSensorReady',pro:'YGroundSpeed <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGroundSpeed loadCalibrationPoints',pro:'YGroundSpeed <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YGroundSpeed muteValueCallbacks',pro:'YGroundSpeed <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['GroundSpeed']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YGroundSpeed set_advMode',pro:'YGroundSpeed <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGroundSpeed set_highestValue',pro:'YGroundSpeed <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGroundSpeed set_logFrequency',pro:'YGroundSpeed <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_logicalName']={syn:'Changes the logical name of the ground speed sensor.',lib:'YGroundSpeed set_logicalName',pro:'YGroundSpeed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the ground speed sensor.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGroundSpeed set_lowestValue',pro:'YGroundSpeed <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGroundSpeed set_reportFrequency',pro:'YGroundSpeed <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGroundSpeed set_resolution',pro:'YGroundSpeed <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGroundSpeed startDataLogger',pro:'YGroundSpeed <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGroundSpeed stopDataLogger',pro:'YGroundSpeed <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GroundSpeed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YGroundSpeed unmuteValueCallbacks',pro:'YGroundSpeed <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: GroundSpeed)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular function interface',inc:'',cmt:'<p>YCellular functions provides control over cellular network parameters and status for devices that are GSM-enabled.</p>'}};
doc['Cellular']['_AT']={syn:'Sends an AT command to the GSM module and returns the command output.',lib:'YCellular _AT',pro:'YCellular <span id=pn>target</span> _AT <span id=pn>cmd</span>',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'};
doc['Cellular']['clearDataCounters']={syn:'Clear the transmitted data counters.',lib:'YCellular clearDataCounters',pro:'YCellular <span id=pn>target</span> clearDataCounters',cmt:'<p>Clear the transmitted data counters.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'YCellular get_advertisedValue',pro:'YCellular <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:''};
doc['Cellular']['get_airplaneMode']={syn:'Returns true if the airplane mode is active (radio turned off).',lib:'YCellular get_airplaneMode',pro:'YCellular <span id=pn>target</span> get_airplaneMode',cmt:'<p>Returns true if the airplane mode is active (radio turned off).</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to true if the airplane mode is active (radio turned off)',ext:''};
doc['Cellular']['get_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'YCellular get_apn',pro:'YCellular <span id=pn>target</span> get_apn',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:''};
doc['Cellular']['get_apnSecret']={syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'YCellular get_apnSecret',pro:'YCellular <span id=pn>target</span> get_apnSecret',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:''};
doc['Cellular']['get_availableOperators']={syn:'Returns the list detected cell operators in the neighborhood.',lib:'YCellular get_availableOperators',pro:'YCellular <span id=pn>target</span> get_availableOperators',cmt:'<p>Returns the list detected cell operators in the neighborhood. This function will typically take between 30 seconds to 1 minute to return. Note that any SIM card can usually only connect to specific operators. All networks returned by this function might therefore not be available for connection.</p>',ret:'a list of string (cell operator names).'};
doc['Cellular']['get_cellIdentifier']={syn:'Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.',lib:'YCellular get_cellIdentifier',pro:'YCellular <span id=pn>target</span> get_cellIdentifier',cmt:'<p>Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.</p>',ret:'a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID',ext:''};
doc['Cellular']['get_cellOperator']={syn:'Returns the name of the cell operator currently in use.',lib:'YCellular get_cellOperator',pro:'YCellular <span id=pn>target</span> get_cellOperator',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:''};
doc['Cellular']['get_cellType']={syn:'Active cellular connection type.',lib:'YCellular get_cellType',pro:'YCellular <span id=pn>target</span> get_cellType',cmt:'<p>Active cellular connection type.</p>',ret:'a value among <tt>GPRS</tt>, <tt>EGPRS</tt>, <tt>WCDMA</tt>, <tt>HSDPA</tt>, <tt>NONE</tt> and <tt>CDMA</tt>',ext:''};
doc['Cellular']['get_dataReceived']={syn:'Returns the number of bytes received so far.',lib:'YCellular get_dataReceived',pro:'YCellular <span id=pn>target</span> get_dataReceived',cmt:'<p>Returns the number of bytes received so far.</p>',ret:'an integer corresponding to the number of bytes received so far',ext:''};
doc['Cellular']['get_dataSent']={syn:'Returns the number of bytes sent so far.',lib:'YCellular get_dataSent',pro:'YCellular <span id=pn>target</span> get_dataSent',cmt:'<p>Returns the number of bytes sent so far.</p>',ret:'an integer corresponding to the number of bytes sent so far',ext:''};
doc['Cellular']['get_enableData']={syn:'Returns the condition for enabling IP data services (GPRS).',lib:'YCellular get_enableData',pro:'YCellular <span id=pn>target</span> get_enableData',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>HOMENETWORK</tt>, <tt>ROAMING</tt>, <tt>NEVER</tt> and <tt>NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:''};
doc['Cellular']['get_imsi']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YCellular get_imsi',pro:'YCellular <span id=pn>target</span> get_imsi',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['Cellular']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'YCellular get_linkQuality',pro:'YCellular <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:''};
doc['Cellular']['get_lockedOperator']={syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'YCellular get_lockedOperator',pro:'YCellular <span id=pn>target</span> get_lockedOperator',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:''};
doc['Cellular']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'YCellular get_logicalName',pro:'YCellular <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:''};
doc['Cellular']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'YCellular get_message',pro:'YCellular <span id=pn>target</span> get_message',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:''};
doc['Cellular']['get_pin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YCellular get_pin',pro:'YCellular <span id=pn>target</span> get_pin',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['Cellular']['get_pingInterval']={syn:'Returns the automated connectivity check interval, in seconds.',lib:'YCellular get_pingInterval',pro:'YCellular <span id=pn>target</span> get_pingInterval',cmt:'<p>Returns the automated connectivity check interval, in seconds.</p>',ret:'an integer corresponding to the automated connectivity check interval, in seconds',ext:''};
doc['Cellular']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YCellular muteValueCallbacks',pro:'YCellular <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['quickCellSurvey']={syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'YCellular quickCellSurvey',pro:'YCellular <span id=pn>target</span> quickCellSurvey',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighbor cells reported by the serving cell.</p>',ret:'a list of YCellRecords.'};
doc['Cellular']['sendPUK']={syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card.',lib:'YCellular sendPUK',pro:'YCellular <span id=pn>target</span> sendPUK <span id=pn>puk</span> <span id=pn>newPin</span>',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card. Only ten consecutive tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['set_airplaneMode']={syn:'Changes the activation state of airplane mode (radio turned off).',lib:'YCellular set_airplaneMode',pro:'YCellular <span id=pn>target</span> set_airplaneMode <span id=pn>newval</span>',cmt:'<p>Changes the activation state of airplane mode (radio turned off).</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the activation state of airplane mode (radio turned off)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'YCellular set_apn',pro:'YCellular <span id=pn>target</span> set_apn <span id=pn>newval</span>',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',par:{newval:'a string'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_apnAuth']={syn:'Configure authentication parameters to connect to the APN.',lib:'YCellular set_apnAuth',pro:'YCellular <span id=pn>target</span> set_apnAuth <span id=pn>username</span> <span id=pn>password</span>',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['set_dataReceived']={syn:'Changes the value of the incoming data counter.',lib:'YCellular set_dataReceived',pro:'YCellular <span id=pn>target</span> set_dataReceived <span id=pn>newval</span>',cmt:'<p>Changes the value of the incoming data counter.</p>',par:{newval:'an integer corresponding to the value of the incoming data counter'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_dataSent']={syn:'Changes the value of the outgoing data counter.',lib:'YCellular set_dataSent',pro:'YCellular <span id=pn>target</span> set_dataSent <span id=pn>newval</span>',cmt:'<p>Changes the value of the outgoing data counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing data counter'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_enableData']={syn:'Changes the condition for enabling IP data services (GPRS).',lib:'YCellular set_enableData',pro:'YCellular <span id=pn>target</span> set_enableData <span id=pn>newval</span>',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs !</p><p> When data services are disabled, SMS are the only mean of communication.</p>',par:{newval:'a value among <tt>HOMENETWORK</tt>, <tt>ROAMING</tt>, <tt>NEVER</tt> and <tt>NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_lockedOperator']={syn:'Changes the name of the cell operator to be used.',lib:'YCellular set_lockedOperator',pro:'YCellular <span id=pn>target</span> set_lockedOperator <span id=pn>newval</span>',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'YCellular set_logicalName',pro:'YCellular <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the cellular interface.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_pin']={syn:'Changes the PIN code used by the module to access the SIM card.',lib:'YCellular set_pin',pro:'YCellular <span id=pn>target</span> set_pin <span id=pn>newval</span>',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_pingInterval']={syn:'Changes the automated connectivity check interval, in seconds.',lib:'YCellular set_pingInterval',pro:'YCellular <span id=pn>target</span> set_pingInterval <span id=pn>newval</span>',cmt:'<p>Changes the automated connectivity check interval, in seconds.</p>',par:{newval:'an integer corresponding to the automated connectivity check interval, in seconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YCellular unmuteValueCallbacks',pro:'YCellular <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Cellular)
//--- (generated code: QuadratureDecoder)
doc['QuadratureDecoder']={'':{syn:'QuadratureDecoder function interface',inc:'',cmt:'<p>The class YQuadratureDecoder allows you to decode a two-wire signal produced by a quadrature encoder. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['QuadratureDecoder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YQuadratureDecoder calibrateFromPoints',pro:'YQuadratureDecoder <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YQuadratureDecoder get_advMode',pro:'YQuadratureDecoder <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['QuadratureDecoder']['get_advertisedValue']={syn:'Returns the current value of the quadrature decoder (no more than 6 characters).',lib:'YQuadratureDecoder get_advertisedValue',pro:'YQuadratureDecoder <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the quadrature decoder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quadrature decoder (no more than 6 characters).',ext:''};
doc['QuadratureDecoder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.',lib:'YQuadratureDecoder get_currentRawValue',pro:'YQuadratureDecoder <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number',ext:''};
doc['QuadratureDecoder']['get_currentValue']={syn:'Returns the current value of the position, in pas, as a floating point number.',lib:'YQuadratureDecoder get_currentValue',pro:'YQuadratureDecoder <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the position, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the position, in pas, as a floating point number',ext:''};
doc['QuadratureDecoder']['get_decoding']={syn:'Returns the current activation state of the quadrature decoder.',lib:'YQuadratureDecoder get_decoding',pro:'YQuadratureDecoder <span id=pn>target</span> get_decoding',cmt:'<p>Returns the current activation state of the quadrature decoder.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the current activation state of the quadrature decoder',ext:''};
doc['QuadratureDecoder']['get_highestValue']={syn:'Returns the maximal value observed for the position since the device was started.',lib:'YQuadratureDecoder get_highestValue',pro:'YQuadratureDecoder <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the position since the device was started',ext:''};
doc['QuadratureDecoder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YQuadratureDecoder get_logFrequency',pro:'YQuadratureDecoder <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['QuadratureDecoder']['get_logicalName']={syn:'Returns the logical name of the quadrature decoder.',lib:'YQuadratureDecoder get_logicalName',pro:'YQuadratureDecoder <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the quadrature decoder.</p>',ret:'a string corresponding to the logical name of the quadrature decoder.',ext:''};
doc['QuadratureDecoder']['get_lowestValue']={syn:'Returns the minimal value observed for the position since the device was started.',lib:'YQuadratureDecoder get_lowestValue',pro:'YQuadratureDecoder <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the position since the device was started',ext:''};
doc['QuadratureDecoder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YQuadratureDecoder get_recordedData',pro:'YQuadratureDecoder <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['QuadratureDecoder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YQuadratureDecoder get_reportFrequency',pro:'YQuadratureDecoder <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['QuadratureDecoder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YQuadratureDecoder get_resolution',pro:'YQuadratureDecoder <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['QuadratureDecoder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YQuadratureDecoder get_sensorState',pro:'YQuadratureDecoder <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['QuadratureDecoder']['get_speed']={syn:'Returns the increments frequency, in Hz.',lib:'YQuadratureDecoder get_speed',pro:'YQuadratureDecoder <span id=pn>target</span> get_speed',cmt:'<p>Returns the increments frequency, in Hz.</p>',ret:'a floating point number corresponding to the increments frequency, in Hz',ext:''};
doc['QuadratureDecoder']['get_unit']={syn:'Returns the measuring unit for the position.',lib:'YQuadratureDecoder get_unit',pro:'YQuadratureDecoder <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the position.</p>',ret:'a string corresponding to the measuring unit for the position',ext:''};
doc['QuadratureDecoder']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YQuadratureDecoder isSensorReady',pro:'YQuadratureDecoder <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['QuadratureDecoder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YQuadratureDecoder loadCalibrationPoints',pro:'YQuadratureDecoder <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YQuadratureDecoder muteValueCallbacks',pro:'YQuadratureDecoder <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YQuadratureDecoder set_advMode',pro:'YQuadratureDecoder <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_currentValue']={syn:'Changes the current expected position of the quadrature decoder.',lib:'YQuadratureDecoder set_currentValue',pro:'YQuadratureDecoder <span id=pn>target</span> set_currentValue <span id=pn>newval</span>',cmt:'<p>Changes the current expected position of the quadrature decoder. Invoking this function implicitly activates the quadrature decoder.</p>',par:{newval:'a floating point number corresponding to the current expected position of the quadrature decoder'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_decoding']={syn:'Changes the activation state of the quadrature decoder.',lib:'YQuadratureDecoder set_decoding',pro:'YQuadratureDecoder <span id=pn>target</span> set_decoding <span id=pn>newval</span>',cmt:'<p>Changes the activation state of the quadrature decoder.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the activation state of the quadrature decoder'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YQuadratureDecoder set_highestValue',pro:'YQuadratureDecoder <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YQuadratureDecoder set_logFrequency',pro:'YQuadratureDecoder <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_logicalName']={syn:'Changes the logical name of the quadrature decoder.',lib:'YQuadratureDecoder set_logicalName',pro:'YQuadratureDecoder <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the quadrature decoder.</p>',par:{newval:'a string corresponding to the logical name of the quadrature decoder.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YQuadratureDecoder set_lowestValue',pro:'YQuadratureDecoder <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YQuadratureDecoder set_reportFrequency',pro:'YQuadratureDecoder <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YQuadratureDecoder set_resolution',pro:'YQuadratureDecoder <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['QuadratureDecoder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YQuadratureDecoder startDataLogger',pro:'YQuadratureDecoder <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['QuadratureDecoder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YQuadratureDecoder stopDataLogger',pro:'YQuadratureDecoder <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['QuadratureDecoder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YQuadratureDecoder unmuteValueCallbacks',pro:'YQuadratureDecoder <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: QuadratureDecoder)
//--- (generated code: MessageBox)
doc['MessageBox']={'':{syn:'MessageBox function interface',inc:'',cmt:'<p>YMessageBox functions provides SMS sending and receiving capability to GSM-enabled Yoctopuce devices.</p>'}};
doc['MessageBox']['clearPduCounters']={syn:'Clear the SMS units counters.',lib:'YMessageBox clearPduCounters',pro:'YMessageBox <span id=pn>target</span> clearPduCounters',cmt:'<p>Clear the SMS units counters.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MessageBox']['get_advertisedValue']={syn:'Returns the current value of the MessageBox interface (no more than 6 characters).',lib:'YMessageBox get_advertisedValue',pro:'YMessageBox <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the MessageBox interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the MessageBox interface (no more than 6 characters).',ext:''};
doc['MessageBox']['get_logicalName']={syn:'Returns the logical name of the MessageBox interface.',lib:'YMessageBox get_logicalName',pro:'YMessageBox <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the MessageBox interface.</p>',ret:'a string corresponding to the logical name of the MessageBox interface.',ext:''};
doc['MessageBox']['get_messages']={syn:'Returns the list of messages received and not deleted.',lib:'YMessageBox get_messages',pro:'YMessageBox <span id=pn>target</span> get_messages',cmt:'<p>Returns the list of messages received and not deleted. This function will automatically decode concatenated SMS.</p>',ret:'an YSms object list.',ext:''};
doc['MessageBox']['get_pduReceived']={syn:'Returns the number of SMS units received so far.',lib:'YMessageBox get_pduReceived',pro:'YMessageBox <span id=pn>target</span> get_pduReceived',cmt:'<p>Returns the number of SMS units received so far.</p>',ret:'an integer corresponding to the number of SMS units received so far',ext:''};
doc['MessageBox']['get_pduSent']={syn:'Returns the number of SMS units sent so far.',lib:'YMessageBox get_pduSent',pro:'YMessageBox <span id=pn>target</span> get_pduSent',cmt:'<p>Returns the number of SMS units sent so far.</p>',ret:'an integer corresponding to the number of SMS units sent so far',ext:''};
doc['MessageBox']['get_slotsCount']={syn:'Returns the total number of message storage slots on the SIM card.',lib:'YMessageBox get_slotsCount',pro:'YMessageBox <span id=pn>target</span> get_slotsCount',cmt:'<p>Returns the total number of message storage slots on the SIM card.</p>',ret:'an integer corresponding to the total number of message storage slots on the SIM card',ext:''};
doc['MessageBox']['get_slotsInUse']={syn:'Returns the number of message storage slots currently in use.',lib:'YMessageBox get_slotsInUse',pro:'YMessageBox <span id=pn>target</span> get_slotsInUse',cmt:'<p>Returns the number of message storage slots currently in use.</p>',ret:'an integer corresponding to the number of message storage slots currently in use',ext:''};
doc['MessageBox']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMessageBox muteValueCallbacks',pro:'YMessageBox <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MessageBox']['newMessage']={syn:'Creates a new empty SMS message, to be configured and sent later on.',lib:'YMessageBox newMessage',pro:'YMessageBox <span id=pn>target</span> newMessage <span id=pn>recipient</span>',cmt:'<p>Creates a new empty SMS message, to be configured and sent later on.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MessageBox']['sendFlashMessage']={syn:'Sends a Flash SMS (class 0 message).',lib:'YMessageBox sendFlashMessage',pro:'YMessageBox <span id=pn>target</span> sendFlashMessage <span id=pn>recipient</span> <span id=pn>message</span>',cmt:'<p>Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset immediately and are usually not saved on the SIM card. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MessageBox']['sendTextMessage']={syn:'Sends a regular text SMS, with standard parameters.',lib:'YMessageBox sendTextMessage',pro:'YMessageBox <span id=pn>target</span> sendTextMessage <span id=pn>recipient</span> <span id=pn>message</span>',cmt:'<p>Sends a regular text SMS, with standard parameters. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> and <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MessageBox']['set_logicalName']={syn:'Changes the logical name of the MessageBox interface.',lib:'YMessageBox set_logicalName',pro:'YMessageBox <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the MessageBox interface.</p>',par:{newval:'a string corresponding to the logical name of the MessageBox interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MessageBox']['set_pduReceived']={syn:'Changes the value of the incoming SMS units counter.',lib:'YMessageBox set_pduReceived',pro:'YMessageBox <span id=pn>target</span> set_pduReceived <span id=pn>newval</span>',cmt:'<p>Changes the value of the incoming SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the incoming SMS units counter'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MessageBox']['set_pduSent']={syn:'Changes the value of the outgoing SMS units counter.',lib:'YMessageBox set_pduSent',pro:'YMessageBox <span id=pn>target</span> set_pduSent <span id=pn>newval</span>',cmt:'<p>Changes the value of the outgoing SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing SMS units counter'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MessageBox']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMessageBox unmuteValueCallbacks',pro:'YMessageBox <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: MessageBox)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'YAnButton get_advertisedValue',pro:'YAnButton <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:''};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'YAnButton get_analogCalibration',pro:'YAnButton <span id=pn>target</span> get_analogCalibration',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>',ext:''};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'YAnButton get_calibratedValue',pro:'YAnButton <span id=pn>target</span> get_calibratedValue',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:''};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'YAnButton get_calibrationMax',pro:'YAnButton <span id=pn>target</span> get_calibrationMax',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'YAnButton get_calibrationMin',pro:'YAnButton <span id=pn>target</span> get_calibrationMin',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'YAnButton get_isPressed',pro:'YAnButton <span id=pn>target</span> get_isPressed',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:''};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'YAnButton get_lastTimePressed',pro:'YAnButton <span id=pn>target</span> get_lastTimePressed',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:''};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'YAnButton get_lastTimeReleased',pro:'YAnButton <span id=pn>target</span> get_lastTimeReleased',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:''};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'YAnButton get_logicalName',pro:'YAnButton <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:''};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'YAnButton get_pulseCounter',pro:'YAnButton <span id=pn>target</span> get_pulseCounter',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:''};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'YAnButton get_pulseTimer',pro:'YAnButton <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:''};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'YAnButton get_rawValue',pro:'YAnButton <span id=pn>target</span> get_rawValue',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'YAnButton get_sensitivity',pro:'YAnButton <span id=pn>target</span> get_sensitivity',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:''};
doc['AnButton']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YAnButton muteValueCallbacks',pro:'YAnButton <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'YAnButton resetCounter',pro:'YAnButton <span id=pn>target</span> resetCounter',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'YAnButton set_analogCalibration',pro:'YAnButton <span id=pn>target</span> set_analogCalibration <span id=pn>newval</span>',cmt:'<p>Starts or stops the calibration process.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'YAnButton set_calibrationMax',pro:'YAnButton <span id=pn>target</span> set_calibrationMax <span id=pn>newval</span>',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'YAnButton set_calibrationMin',pro:'YAnButton <span id=pn>target</span> set_calibrationMin <span id=pn>newval</span>',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'YAnButton set_logicalName',pro:'YAnButton <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the analog input.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'YAnButton set_sensitivity',pro:'YAnButton <span id=pn>target</span> set_sensitivity <span id=pn>newval</span>',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YAnButton unmuteValueCallbacks',pro:'YAnButton <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: AnButton)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Reference frame configuration',inc:'',cmt:'<p>This class is used to setup the base orientation of the Yocto-3D, so that the orientation functions, relative to the earth surface plane, use the proper reference frame. The class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}};
doc['RefFrame']['cancel3DCalibration']={syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'YRefFrame cancel3DCalibration',pro:'YRefFrame <span id=pn>target</span> cancel3DCalibration',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationHint',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationHint',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Returns the latest log message from the calibration process.',lib:'YRefFrame get_3DCalibrationLogMsg',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationLogMsg',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationProgress',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationProgress',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationStage',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationStage',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationStageProgress',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationStageProgress',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_advertisedValue']={syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'YRefFrame get_advertisedValue',pro:'YRefFrame <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:''};
doc['RefFrame']['get_bearing']={syn:'Returns the reference bearing used by the compass.',lib:'YRefFrame get_bearing',pro:'YRefFrame <span id=pn>target</span> get_bearing',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:''};
doc['RefFrame']['get_calibrationState']={syn:'Returns the 3D sensor calibration state (Yocto-3D-V2 only).',lib:'YRefFrame get_calibrationState',pro:'YRefFrame <span id=pn>target</span> get_calibrationState',cmt:'<p>Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns an integer representing the calibration state of the 3 inertial sensors of the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state of the accelerometer, tenths show the calibration state of the magnetometer while units show the calibration state of the gyroscope. For each sensor, the value 0 means no calibration and the value 3 means full calibration.</p>',ret:'an integer representing the calibration state of Yocto-3D-V2: 333 when fully calibrated, 0 when not calibrated at all.',ext:''};
doc['RefFrame']['get_logicalName']={syn:'Returns the logical name of the reference frame.',lib:'YRefFrame get_logicalName',pro:'YRefFrame <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:''};
doc['RefFrame']['get_measureQuality']={syn:'Returns estimated quality of the orientation (Yocto-3D-V2 only).',lib:'YRefFrame get_measureQuality',pro:'YRefFrame <span id=pn>target</span> get_measureQuality',cmt:'<p>Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns an integer between 0 and 3 representing the degree of confidence of the position estimate. When the value is 3, the estimation is reliable. Below 3, one should expect sudden corrections, in particular for heading (<tt>compass</tt> function). The most frequent causes for values below 3 are magnetic interferences, and accelerations or rotations beyond the sensor range.</p>',ret:'an integer between 0 and 3 (3 when the measure is reliable)',ext:''};
doc['RefFrame']['get_mountOrientation']={syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'YRefFrame get_mountOrientation',pro:'YRefFrame <span id=pn>target</span> get_mountOrientation',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>TWELVE</tt>, <tt>THREE</tt>, <tt>SIX</tt>, <tt>NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:''};
doc['RefFrame']['get_mountPosition']={syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'YRefFrame get_mountPosition',pro:'YRefFrame <span id=pn>target</span> get_mountPosition',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>BOTTOM</tt>, <tt>TOP</tt>, <tt>FRONT</tt>, <tt>RIGHT</tt>, <tt>REAR</tt>, <tt>LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:''};
doc['RefFrame']['more3DCalibration']={syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'YRefFrame more3DCalibration',pro:'YRefFrame <span id=pn>target</span> more3DCalibration',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YRefFrame muteValueCallbacks',pro:'YRefFrame <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['RefFrame']['save3DCalibration']={syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'YRefFrame save3DCalibration',pro:'YRefFrame <span id=pn>target</span> save3DCalibration',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['set_bearing']={syn:'Changes the reference bearing used by the compass.',lib:'YRefFrame set_bearing',pro:'YRefFrame <span id=pn>target</span> set_bearing <span id=pn>newval</span>',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p><p> For instance, if you setup as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North.</p><p> Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RefFrame']['set_logicalName']={syn:'Changes the logical name of the reference frame.',lib:'YRefFrame set_logicalName',pro:'YRefFrame <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the reference frame.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RefFrame']['set_mountPosition']={syn:'Changes the compass and tilt sensor frame of reference.',lib:'YRefFrame set_mountPosition',pro:'YRefFrame <span id=pn>target</span> set_mountPosition <span id=pn>position</span> <span id=pn>orientation</span>',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>BOTTOM</tt>, <tt>TOP</tt>, <tt>FRONT</tt>, <tt>RIGHT</tt>, <tt>REAR</tt>, <tt>LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.'},ext:''};
doc['RefFrame']['start3DCalibration']={syn:'Initiates the sensors tridimensional calibration process.',lib:'YRefFrame start3DCalibration',pro:'YRefFrame <span id=pn>target</span> start3DCalibration',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors.</p><p> After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be cancelled at any time using method <tt>cancel3DCalibration</tt>.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YRefFrame unmuteValueCallbacks',pro:'YRefFrame <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: RefFrame)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'AudioIn function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the input channel.</p>'}};
doc['AudioIn']['get_advertisedValue']={syn:'Returns the current value of the audio input (no more than 6 characters).',lib:'YAudioIn get_advertisedValue',pro:'YAudioIn <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the audio input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio input (no more than 6 characters).',ext:''};
doc['AudioIn']['get_logicalName']={syn:'Returns the logical name of the audio input.',lib:'YAudioIn get_logicalName',pro:'YAudioIn <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the audio input.</p>',ret:'a string corresponding to the logical name of the audio input.',ext:''};
doc['AudioIn']['get_mute']={syn:'Returns the state of the mute function.',lib:'YAudioIn get_mute',pro:'YAudioIn <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['AudioIn']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'YAudioIn get_noSignalFor',pro:'YAudioIn <span id=pn>target</span> get_noSignalFor',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:''};
doc['AudioIn']['get_signal']={syn:'Returns the detected input signal level.',lib:'YAudioIn get_signal',pro:'YAudioIn <span id=pn>target</span> get_signal',cmt:'<p>Returns the detected input signal level.</p>',ret:'an integer corresponding to the detected input signal level',ext:''};
doc['AudioIn']['get_volume']={syn:'Returns audio input gain, in per cents.',lib:'YAudioIn get_volume',pro:'YAudioIn <span id=pn>target</span> get_volume',cmt:'<p>Returns audio input gain, in per cents.</p>',ret:'an integer corresponding to audio input gain, in per cents',ext:''};
doc['AudioIn']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'YAudioIn get_volumeRange',pro:'YAudioIn <span id=pn>target</span> get_volumeRange',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:''};
doc['AudioIn']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YAudioIn muteValueCallbacks',pro:'YAudioIn <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['AudioIn']['set_logicalName']={syn:'Changes the logical name of the audio input.',lib:'YAudioIn set_logicalName',pro:'YAudioIn <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the audio input.</p>',par:{newval:'a string corresponding to the logical name of the audio input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioIn']['set_mute']={syn:'Changes the state of the mute function.',lib:'YAudioIn set_mute',pro:'YAudioIn <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioIn']['set_volume']={syn:'Changes audio input gain, in per cents.',lib:'YAudioIn set_volume',pro:'YAudioIn <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes audio input gain, in per cents.</p>',par:{newval:'an integer corresponding to audio input gain, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioIn']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YAudioIn unmuteValueCallbacks',pro:'YAudioIn <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: AudioIn)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'AudioOut function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the outout.</p>'}};
doc['AudioOut']['get_advertisedValue']={syn:'Returns the current value of the audio output (no more than 6 characters).',lib:'YAudioOut get_advertisedValue',pro:'YAudioOut <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the audio output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio output (no more than 6 characters).',ext:''};
doc['AudioOut']['get_logicalName']={syn:'Returns the logical name of the audio output.',lib:'YAudioOut get_logicalName',pro:'YAudioOut <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the audio output.</p>',ret:'a string corresponding to the logical name of the audio output.',ext:''};
doc['AudioOut']['get_mute']={syn:'Returns the state of the mute function.',lib:'YAudioOut get_mute',pro:'YAudioOut <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['AudioOut']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'YAudioOut get_noSignalFor',pro:'YAudioOut <span id=pn>target</span> get_noSignalFor',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:''};
doc['AudioOut']['get_signal']={syn:'Returns the detected output current level.',lib:'YAudioOut get_signal',pro:'YAudioOut <span id=pn>target</span> get_signal',cmt:'<p>Returns the detected output current level.</p>',ret:'an integer corresponding to the detected output current level',ext:''};
doc['AudioOut']['get_volume']={syn:'Returns audio output volume, in per cents.',lib:'YAudioOut get_volume',pro:'YAudioOut <span id=pn>target</span> get_volume',cmt:'<p>Returns audio output volume, in per cents.</p>',ret:'an integer corresponding to audio output volume, in per cents',ext:''};
doc['AudioOut']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'YAudioOut get_volumeRange',pro:'YAudioOut <span id=pn>target</span> get_volumeRange',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:''};
doc['AudioOut']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YAudioOut muteValueCallbacks',pro:'YAudioOut <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['AudioOut']['set_logicalName']={syn:'Changes the logical name of the audio output.',lib:'YAudioOut set_logicalName',pro:'YAudioOut <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the audio output.</p>',par:{newval:'a string corresponding to the logical name of the audio output.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioOut']['set_mute']={syn:'Changes the state of the mute function.',lib:'YAudioOut set_mute',pro:'YAudioOut <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioOut']['set_volume']={syn:'Changes audio output volume, in per cents.',lib:'YAudioOut set_volume',pro:'YAudioOut <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes audio output volume, in per cents.</p>',par:{newval:'an integer corresponding to audio output volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioOut']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YAudioOut unmuteValueCallbacks',pro:'YAudioOut <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: AudioOut)
//--- (generated code: BluetoothLink)
doc['BluetoothLink']={'':{syn:'BluetoothLink function interface',inc:'',cmt:'<p>BluetoothLink function provides control over bluetooth link and status for devices that are bluetooth-enabled.</p>'}};
doc['BluetoothLink']['connect']={syn:'Attempt to connect to the previously selected remote device.',lib:'YBluetoothLink connect',pro:'YBluetoothLink <span id=pn>target</span> connect',cmt:'<p>Attempt to connect to the previously selected remote device.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['BluetoothLink']['disconnect']={syn:'Disconnect from the previously selected remote device.',lib:'YBluetoothLink disconnect',pro:'YBluetoothLink <span id=pn>target</span> disconnect',cmt:'<p>Disconnect from the previously selected remote device.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['BluetoothLink']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'YBluetoothLink get_advertisedValue',pro:'YBluetoothLink <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:''};
doc['BluetoothLink']['get_linkQuality']={syn:'Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.',lib:'YBluetoothLink get_linkQuality',pro:'YBluetoothLink <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.</p>',ret:'an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established',ext:''};
doc['BluetoothLink']['get_linkState']={syn:'Returns the bluetooth link state.',lib:'YBluetoothLink get_linkState',pro:'YBluetoothLink <span id=pn>target</span> get_linkState',cmt:'<p>Returns the bluetooth link state.</p>',ret:'a value among <tt>DOWN</tt>, <tt>FREE</tt>, <tt>SEARCH</tt>, <tt>EXISTS</tt>, <tt>LINKED</tt> and <tt>PLAY</tt> corresponding to the bluetooth link state',ext:''};
doc['BluetoothLink']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'YBluetoothLink get_logicalName',pro:'YBluetoothLink <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:''};
doc['BluetoothLink']['get_mute']={syn:'Returns the state of the mute function.',lib:'YBluetoothLink get_mute',pro:'YBluetoothLink <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['BluetoothLink']['get_ownAddress']={syn:'Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.',lib:'YBluetoothLink get_ownAddress',pro:'YBluetoothLink <span id=pn>target</span> get_ownAddress',cmt:'<p>Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.</p>',ret:'a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network',ext:''};
doc['BluetoothLink']['get_pairingPin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YBluetoothLink get_pairingPin',pro:'YBluetoothLink <span id=pn>target</span> get_pairingPin',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['BluetoothLink']['get_preAmplifier']={syn:'Returns the audio pre-amplifier volume, in per cents.',lib:'YBluetoothLink get_preAmplifier',pro:'YBluetoothLink <span id=pn>target</span> get_preAmplifier',cmt:'<p>Returns the audio pre-amplifier volume, in per cents.</p>',ret:'an integer corresponding to the audio pre-amplifier volume, in per cents',ext:''};
doc['BluetoothLink']['get_remoteAddress']={syn:'Returns the MAC-48 address of the remote device to connect to.',lib:'YBluetoothLink get_remoteAddress',pro:'YBluetoothLink <span id=pn>target</span> get_remoteAddress',cmt:'<p>Returns the MAC-48 address of the remote device to connect to.</p>',ret:'a string corresponding to the MAC-48 address of the remote device to connect to',ext:''};
doc['BluetoothLink']['get_remoteName']={syn:'Returns the bluetooth name the remote device, if found on the bluetooth network.',lib:'YBluetoothLink get_remoteName',pro:'YBluetoothLink <span id=pn>target</span> get_remoteName',cmt:'<p>Returns the bluetooth name the remote device, if found on the bluetooth network.</p>',ret:'a string corresponding to the bluetooth name the remote device, if found on the bluetooth network',ext:''};
doc['BluetoothLink']['get_volume']={syn:'Returns the connected headset volume, in per cents.',lib:'YBluetoothLink get_volume',pro:'YBluetoothLink <span id=pn>target</span> get_volume',cmt:'<p>Returns the connected headset volume, in per cents.</p>',ret:'an integer corresponding to the connected headset volume, in per cents',ext:''};
doc['BluetoothLink']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YBluetoothLink muteValueCallbacks',pro:'YBluetoothLink <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['BluetoothLink']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'YBluetoothLink set_logicalName',pro:'YBluetoothLink <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the cellular interface.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_mute']={syn:'Changes the state of the mute function.',lib:'YBluetoothLink set_mute',pro:'YBluetoothLink <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_pairingPin']={syn:'Changes the PIN code used by the module for bluetooth pairing.',lib:'YBluetoothLink set_pairingPin',pro:'YBluetoothLink <span id=pn>target</span> set_pairingPin <span id=pn>newval</span>',cmt:'<p>Changes the PIN code used by the module for bluetooth pairing.</p>',par:{newval:'a string corresponding to the PIN code used by the module for bluetooth pairing'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_preAmplifier']={syn:'Changes the audio pre-amplifier volume, in per cents.',lib:'YBluetoothLink set_preAmplifier',pro:'YBluetoothLink <span id=pn>target</span> set_preAmplifier <span id=pn>newval</span>',cmt:'<p>Changes the audio pre-amplifier volume, in per cents.</p>',par:{newval:'an integer corresponding to the audio pre-amplifier volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_remoteAddress']={syn:'Changes the MAC-48 address defining which remote device to connect to.',lib:'YBluetoothLink set_remoteAddress',pro:'YBluetoothLink <span id=pn>target</span> set_remoteAddress <span id=pn>newval</span>',cmt:'<p>Changes the MAC-48 address defining which remote device to connect to.</p>',par:{newval:'a string corresponding to the MAC-48 address defining which remote device to connect to'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_volume']={syn:'Changes the connected headset volume, in per cents.',lib:'YBluetoothLink set_volume',pro:'YBluetoothLink <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes the connected headset volume, in per cents.</p>',par:{newval:'an integer corresponding to the connected headset volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YBluetoothLink unmuteValueCallbacks',pro:'YBluetoothLink <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: BluetoothLink)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to choose the frequency and volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Adds a new frequency transition to the playing sequence.',lib:'YBuzzer addFreqMoveToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addFreqMoveToPlaySeq <span id=pn>freq</span> <span id=pn>msDelay</span>',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addNotesToPlaySeq']={syn:'Adds notes to the playing sequence.',lib:'YBuzzer addNotesToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addNotesToPlaySeq <span id=pn>notes</span>',cmt:'<p>Adds notes to the playing sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Adds a pulse to the playing sequence.',lib:'YBuzzer addPulseToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addPulseToPlaySeq <span id=pn>freq</span> <span id=pn>msDuration</span>',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Adds a new volume transition to the playing sequence.',lib:'YBuzzer addVolMoveToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addVolMoveToPlaySeq <span id=pn>volume</span> <span id=pn>msDuration</span>',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['freqMove']={syn:'Makes the buzzer frequency change over a period of time.',lib:'YBuzzer freqMove',pro:'YBuzzer <span id=pn>target</span> freqMove <span id=pn>frequency</span> <span id=pn>duration</span>',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['get_advertisedValue']={syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'YBuzzer get_advertisedValue',pro:'YBuzzer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:''};
doc['Buzzer']['get_frequency']={syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'YBuzzer get_frequency',pro:'YBuzzer <span id=pn>target</span> get_frequency',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:''};
doc['Buzzer']['get_logicalName']={syn:'Returns the logical name of the buzzer.',lib:'YBuzzer get_logicalName',pro:'YBuzzer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:''};
doc['Buzzer']['get_playSeqMaxSize']={syn:'Returns the maximum length of the playing sequence.',lib:'YBuzzer get_playSeqMaxSize',pro:'YBuzzer <span id=pn>target</span> get_playSeqMaxSize',cmt:'<p>Returns the maximum length of the playing sequence.</p>',ret:'an integer corresponding to the maximum length of the playing sequence',ext:''};
doc['Buzzer']['get_playSeqSignature']={syn:'Returns the playing sequence signature.',lib:'YBuzzer get_playSeqSignature',pro:'YBuzzer <span id=pn>target</span> get_playSeqSignature',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:''};
doc['Buzzer']['get_playSeqSize']={syn:'Returns the current length of the playing sequence.',lib:'YBuzzer get_playSeqSize',pro:'YBuzzer <span id=pn>target</span> get_playSeqSize',cmt:'<p>Returns the current length of the playing sequence.</p>',ret:'an integer corresponding to the current length of the playing sequence',ext:''};
doc['Buzzer']['get_volume']={syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'YBuzzer get_volume',pro:'YBuzzer <span id=pn>target</span> get_volume',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:''};
doc['Buzzer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YBuzzer muteValueCallbacks',pro:'YBuzzer <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Buzzer']['oncePlaySeq']={syn:'Starts the preprogrammed playing sequence and run it once only.',lib:'YBuzzer oncePlaySeq',pro:'YBuzzer <span id=pn>target</span> oncePlaySeq',cmt:'<p>Starts the preprogrammed playing sequence and run it once only.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['playNotes']={syn:'Immediately play a note sequence.',lib:'YBuzzer playNotes',pro:'YBuzzer <span id=pn>target</span> playNotes <span id=pn>notes</span>',cmt:'<p>Immediately play a note sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['pulse']={syn:'Activates the buzzer for a short duration.',lib:'YBuzzer pulse',pro:'YBuzzer <span id=pn>target</span> pulse <span id=pn>frequency</span> <span id=pn>duration</span>',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['resetPlaySeq']={syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'YBuzzer resetPlaySeq',pro:'YBuzzer <span id=pn>target</span> resetPlaySeq',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_frequency']={syn:'Changes the frequency of the signal sent to the buzzer.',lib:'YBuzzer set_frequency',pro:'YBuzzer <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['set_logicalName']={syn:'Changes the logical name of the buzzer.',lib:'YBuzzer set_logicalName',pro:'YBuzzer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the buzzer.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['set_volume']={syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'YBuzzer set_volume',pro:'YBuzzer <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['startPlaySeq']={syn:'Starts the preprogrammed playing sequence.',lib:'YBuzzer startPlaySeq',pro:'YBuzzer <span id=pn>target</span> startPlaySeq',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change. To play the sequence only once, use <tt>oncePlaySeq()</tt>.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['stopPlaySeq']={syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'YBuzzer stopPlaySeq',pro:'YBuzzer <span id=pn>target</span> stopPlaySeq',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YBuzzer unmuteValueCallbacks',pro:'YBuzzer <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Buzzer']['volumeMove']={syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'YBuzzer volumeMove',pro:'YBuzzer <span id=pn>target</span> volumeMove <span id=pn>volume</span> <span id=pn>duration</span>',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Buzzer)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'YColorLed addHslMoveToBlinkSeq',pro:'YColorLed <span id=pn>target</span> addHslMoveToBlinkSeq <span id=pn>HSLcolor</span> <span id=pn>msDelay</span>',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Adds a new transition to the blinking sequence, the move is performed in the RGB space.',lib:'YColorLed addRgbMoveToBlinkSeq',pro:'YColorLed <span id=pn>target</span> addRgbMoveToBlinkSeq <span id=pn>RGBcolor</span> <span id=pn>msDelay</span>',cmt:'<p>Adds a new transition to the blinking sequence, the move is performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB LED (no more than 6 characters).',lib:'YColorLed get_advertisedValue',pro:'YColorLed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the RGB LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED (no more than 6 characters).',ext:''};
doc['ColorLed']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of the blinking sequence.',lib:'YColorLed get_blinkSeqMaxSize',pro:'YColorLed <span id=pn>target</span> get_blinkSeqMaxSize',cmt:'<p>Returns the maximum length of the blinking sequence.</p>',ret:'an integer corresponding to the maximum length of the blinking sequence',ext:''};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Return the blinking sequence signature.',lib:'YColorLed get_blinkSeqSignature',pro:'YColorLed <span id=pn>target</span> get_blinkSeqSignature',cmt:'<p>Return the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer',ext:''};
doc['ColorLed']['get_blinkSeqSize']={syn:'Returns the current length of the blinking sequence.',lib:'YColorLed get_blinkSeqSize',pro:'YColorLed <span id=pn>target</span> get_blinkSeqSize',cmt:'<p>Returns the current length of the blinking sequence.</p>',ret:'an integer corresponding to the current length of the blinking sequence',ext:''};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the LED.',lib:'YColorLed get_hslColor',pro:'YColorLed <span id=pn>target</span> get_hslColor',cmt:'<p>Returns the current HSL color of the LED.</p>',ret:'an integer corresponding to the current HSL color of the LED',ext:''};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB LED.',lib:'YColorLed get_logicalName',pro:'YColorLed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the RGB LED.</p>',ret:'a string corresponding to the logical name of the RGB LED.',ext:''};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the LED.',lib:'YColorLed get_rgbColor',pro:'YColorLed <span id=pn>target</span> get_rgbColor',cmt:'<p>Returns the current RGB color of the LED.</p>',ret:'an integer corresponding to the current RGB color of the LED',ext:''};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'YColorLed get_rgbColorAtPowerOn',pro:'YColorLed <span id=pn>target</span> get_rgbColorAtPowerOn',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:''};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'YColorLed hslMove',pro:'YColorLed <span id=pn>target</span> hslMove <span id=pn>hsl_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YColorLed muteValueCallbacks',pro:'YColorLed <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLed']['resetBlinkSeq']={syn:'Resets the preprogrammed blinking sequence.',lib:'YColorLed resetBlinkSeq',pro:'YColorLed <span id=pn>target</span> resetBlinkSeq',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'YColorLed rgbMove',pro:'YColorLed <span id=pn>target</span> rgbMove <span id=pn>rgb_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the LED, using a color HSL.',lib:'YColorLed set_hslColor',pro:'YColorLed <span id=pn>target</span> set_hslColor <span id=pn>newval</span>',cmt:'<p>Changes the current color of the LED, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the LED, using a color HSL'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB LED.',lib:'YColorLed set_logicalName',pro:'YColorLed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the RGB LED.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the LED, using an RGB color.',lib:'YColorLed set_rgbColor',pro:'YColorLed <span id=pn>target</span> set_rgbColor <span id=pn>newval</span>',cmt:'<p>Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the LED, using an RGB color'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the LED will display by default when the module is turned on.',lib:'YColorLed set_rgbColorAtPowerOn',pro:'YColorLed <span id=pn>target</span> set_rgbColorAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the color that the LED will display by default when the module is turned on.</p>',par:{newval:'an integer corresponding to the color that the LED will display by default when the module is turned on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['startBlinkSeq']={syn:'Starts the preprogrammed blinking sequence.',lib:'YColorLed startBlinkSeq',pro:'YColorLed <span id=pn>target</span> startBlinkSeq',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence is run in a loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Stops the preprogrammed blinking sequence.',lib:'YColorLed stopBlinkSeq',pro:'YColorLed <span id=pn>target</span> stopBlinkSeq',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YColorLed unmuteValueCallbacks',pro:'YColorLed <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: ColorLed)
//--- (generated code: ColorLedCluster)
doc['ColorLedCluster']={'':{syn:'ColorLedCluster function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED cluster. Unlike the ColorLed class, the ColorLedCluster allows to handle several LEDs at one. Color changes can be done using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLedCluster']['addHslMoveToBlinkSeq']={syn:'Adds an HSL transition to a sequence.',lib:'YColorLedCluster addHslMoveToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> addHslMoveToBlinkSeq <span id=pn>seqIndex</span> <span id=pn>hslValue</span> <span id=pn>delay</span>',cmt:'<p>Adds an HSL transition to a sequence. A sequence is a transition list, which can be executed in loop by an group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',hslValue:'target color (0xHHSSLL)',delay:'transition duration in ms'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['addJumpToBlinkSeq']={syn:'Adds to a sequence a jump to another sequence.',lib:'YColorLedCluster addJumpToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> addJumpToBlinkSeq <span id=pn>seqIndex</span> <span id=pn>linkSeqIndex</span>',cmt:'<p>Adds to a sequence a jump to another sequence. When a pixel will reach this jump, it will be automatically relinked to the new sequence, and will run it starting from the beginning.</p>',par:{seqIndex:'sequence index.',linkSeqIndex:'index of the sequence to chain.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['addMirrorToBlinkSeq']={syn:'Adds a mirror ending to a sequence.',lib:'YColorLedCluster addMirrorToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> addMirrorToBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Adds a mirror ending to a sequence. When the sequence will reach the end of the last transition, its running speed will automatically be reversed so that the sequence plays in the reverse direction, like in a mirror. After the first transition of the sequence is played at the end of the reverse execution, the sequence starts again in the initial direction.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['addRgbMoveToBlinkSeq']={syn:'Adds an RGB transition to a sequence.',lib:'YColorLedCluster addRgbMoveToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> addRgbMoveToBlinkSeq <span id=pn>seqIndex</span> <span id=pn>rgbValue</span> <span id=pn>delay</span>',cmt:'<p>Adds an RGB transition to a sequence. A sequence is a transition list, which can be executed in loop by a group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',rgbValue:'target color (0xRRGGBB)',delay:'transition duration in ms'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['addUnlinkToBlinkSeq']={syn:'Adds a to a sequence a hard stop code.',lib:'YColorLedCluster addUnlinkToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> addUnlinkToBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Adds a to a sequence a hard stop code. When a pixel will reach this stop code, instead of restarting the sequence in a loop it will automatically be unlinked from the sequence.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['get_activeLedCount']={syn:'Returns the number of LEDs currently handled by the device.',lib:'YColorLedCluster get_activeLedCount',pro:'YColorLedCluster <span id=pn>target</span> get_activeLedCount',cmt:'<p>Returns the number of LEDs currently handled by the device.</p>',ret:'an integer corresponding to the number of LEDs currently handled by the device',ext:''};
doc['ColorLedCluster']['get_advertisedValue']={syn:'Returns the current value of the RGB LED cluster (no more than 6 characters).',lib:'YColorLedCluster get_advertisedValue',pro:'YColorLedCluster <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the RGB LED cluster (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED cluster (no more than 6 characters).',ext:''};
doc['ColorLedCluster']['get_blinkSeqMaxCount']={syn:'Returns the maximum number of sequences that the device can handle.',lib:'YColorLedCluster get_blinkSeqMaxCount',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqMaxCount',cmt:'<p>Returns the maximum number of sequences that the device can handle.</p>',ret:'an integer corresponding to the maximum number of sequences that the device can handle',ext:''};
doc['ColorLedCluster']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of sequences.',lib:'YColorLedCluster get_blinkSeqMaxSize',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqMaxSize',cmt:'<p>Returns the maximum length of sequences.</p>',ret:'an integer corresponding to the maximum length of sequences',ext:''};
doc['ColorLedCluster']['get_blinkSeqSignatures']={syn:'Returns a list on 32 bit signatures for specified blinking sequences.',lib:'YColorLedCluster get_blinkSeqSignatures',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqSignatures <span id=pn>seqIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list on 32 bit signatures for specified blinking sequences. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of 32 bit integer signatures',ext:''};
doc['ColorLedCluster']['get_blinkSeqState']={syn:'Returns a list of integers with the started state for specified blinking sequences.',lib:'YColorLedCluster get_blinkSeqState',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqState <span id=pn>seqIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list of integers with the started state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:''};
doc['ColorLedCluster']['get_blinkSeqStateAtPowerOn']={syn:'Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.',lib:'YColorLedCluster get_blinkSeqStateAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqStateAtPowerOn <span id=pn>seqIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:''};
doc['ColorLedCluster']['get_blinkSeqStateSpeed']={syn:'Returns a list of integers with the current speed for specified blinking sequences.',lib:'YColorLedCluster get_blinkSeqStateSpeed',pro:'YColorLedCluster <span id=pn>target</span> get_blinkSeqStateSpeed <span id=pn>seqIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list of integers with the current speed for specified blinking sequences.</p>',par:{seqIndex:'index of the first sequence speed which should be returned',count:'number of sequence speeds which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:''};
doc['ColorLedCluster']['get_ledType']={syn:'Returns the RGB LED type currently handled by the device.',lib:'YColorLedCluster get_ledType',pro:'YColorLedCluster <span id=pn>target</span> get_ledType',cmt:'<p>Returns the RGB LED type currently handled by the device.</p>',ret:'either <tt>RGB</tt> or <tt>RGBW</tt>, according to the RGB LED type currently handled by the device',ext:''};
doc['ColorLedCluster']['get_linkedSeqArray']={syn:'Returns a list on sequence index for each RGB LED.',lib:'YColorLedCluster get_linkedSeqArray',pro:'YColorLedCluster <span id=pn>target</span> get_linkedSeqArray <span id=pn>ledIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list on sequence index for each RGB LED. The first number represents the sequence index for the the first LED, the second number represents the sequence index for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of integers with sequence index',ext:''};
doc['ColorLedCluster']['get_logicalName']={syn:'Returns the logical name of the RGB LED cluster.',lib:'YColorLedCluster get_logicalName',pro:'YColorLedCluster <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the RGB LED cluster.</p>',ret:'a string corresponding to the logical name of the RGB LED cluster.',ext:''};
doc['ColorLedCluster']['get_maxLedCount']={syn:'Returns the maximum number of LEDs that the device can handle.',lib:'YColorLedCluster get_maxLedCount',pro:'YColorLedCluster <span id=pn>target</span> get_maxLedCount',cmt:'<p>Returns the maximum number of LEDs that the device can handle.</p>',ret:'an integer corresponding to the maximum number of LEDs that the device can handle',ext:''};
doc['ColorLedCluster']['get_rgbColorArray']={syn:'Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs.',lib:'YColorLedCluster get_rgbColorArray',pro:'YColorLedCluster <span id=pn>target</span> get_rgbColorArray <span id=pn>ledIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs. The first number represents the RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:''};
doc['ColorLedCluster']['get_rgbColorArrayAtPowerOn']={syn:'Returns a list on 24bit RGB color values with the RGB LEDs startup colors.',lib:'YColorLedCluster get_rgbColorArrayAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> get_rgbColorArrayAtPowerOn <span id=pn>ledIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a list on 24bit RGB color values with the RGB LEDs startup colors. The first number represents the startup RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:''};
doc['ColorLedCluster']['get_rgbColorBuffer']={syn:'Returns a binary buffer with content from the LED RGB buffer, as is.',lib:'YColorLedCluster get_rgbColorBuffer',pro:'YColorLedCluster <span id=pn>target</span> get_rgbColorBuffer <span id=pn>ledIndex</span> <span id=pn>count</span>',cmt:'<p>Returns a binary buffer with content from the LED RGB buffer, as is. First three bytes are RGB components for the first LED in the interval, the next three bytes for the second LED in the interval, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a binary buffer with RGB components of selected LEDs.',ext:''};
doc['ColorLedCluster']['hslArrayOfs_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'YColorLedCluster hslArrayOfs_move',pro:'YColorLedCluster <span id=pn>target</span> hslArrayOfs_move <span id=pn>ledIndex</span> <span id=pn>hslList</span> <span id=pn>delay</span>',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['hslArray_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'YColorLedCluster hslArray_move',pro:'YColorLedCluster <span id=pn>target</span> hslArray_move <span id=pn>hslList</span> <span id=pn>delay</span>',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['hsl_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'YColorLedCluster hsl_move',pro:'YColorLedCluster <span id=pn>target</span> hsl_move <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>hslValue</span> <span id=pn>delay</span>',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular value (0..360\xB0). There are always two paths to perform the transition: by increasing or by decreasing the hue. The module selects the shortest transition. If the difference is exactly 180\xB0, the module selects the transition which increases the hue.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color (0xHHSSLL).',delay:'transition duration in ms'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['linkLedToBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'YColorLedCluster linkLedToBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> linkLedToBlinkSeq <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>seqIndex</span> <span id=pn>offset</span>',cmt:'<p>Links adjacent LEDs to a specific sequence. These LEDs start to execute the sequence as soon as startBlinkSeq is called. It is possible to add an offset in the execution: that way we can have several groups of LED executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['linkLedToBlinkSeqAtPowerOn']={syn:'Links adjacent LEDs to a specific sequence at device power-on.',lib:'YColorLedCluster linkLedToBlinkSeqAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> linkLedToBlinkSeqAtPowerOn <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>seqIndex</span> <span id=pn>offset</span>',cmt:'<p>Links adjacent LEDs to a specific sequence at device power-on. Don\x27t forget to configure the sequence auto start flag as well and call <tt>saveLedsConfigAtPowerOn()</tt>. It is possible to add an offset in the execution: that way we can have several groups of LEDs executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['linkLedToPeriodicBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'YColorLedCluster linkLedToPeriodicBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> linkLedToPeriodicBlinkSeq <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>seqIndex</span> <span id=pn>periods</span>',cmt:'<p>Links adjacent LEDs to a specific sequence. These LED start to execute the sequence as soon as startBlinkSeq is called. This function automatically introduces a shift between LEDs so that the specified number of sequence periods appears on the group of LEDs (wave effect).</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',periods:'number of periods to show on LEDs.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YColorLedCluster muteValueCallbacks',pro:'YColorLedCluster <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['resetBlinkSeq']={syn:'Stops a sequence execution and resets its contents.',lib:'YColorLedCluster resetBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> resetBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Stops a sequence execution and resets its contents. LEDs linked to this sequence are not automatically updated anymore.</p>',par:{seqIndex:'index of the sequence to reset'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['rgbArrayOfs_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'YColorLedCluster rgbArrayOfs_move',pro:'YColorLedCluster <span id=pn>target</span> rgbArrayOfs_move <span id=pn>ledIndex</span> <span id=pn>rgbList</span> <span id=pn>delay</span>',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['rgbArray_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'YColorLedCluster rgbArray_move',pro:'YColorLedCluster <span id=pn>target</span> rgbArray_move <span id=pn>rgbList</span> <span id=pn>delay</span>',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['rgb_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'YColorLedCluster rgb_move',pro:'YColorLedCluster <span id=pn>target</span> rgb_move <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>rgbValue</span> <span id=pn>delay</span>',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the RGB space.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color (0xRRGGBB).',delay:'transition duration in ms'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['saveBlinkSeq']={syn:'Saves the definition of a sequence.',lib:'YColorLedCluster saveBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> saveBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Saves the definition of a sequence. Warning: only sequence steps and flags are saved. to save the LEDs startup bindings, the method <tt>saveLedsConfigAtPowerOn()</tt> must be called.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['saveLedsConfigAtPowerOn']={syn:'Saves the LEDs power-on configuration.',lib:'YColorLedCluster saveLedsConfigAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> saveLedsConfigAtPowerOn',cmt:'<p>Saves the LEDs power-on configuration. This includes the start-up color or sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the method <tt>saveBlinkSeq()</tt> must also be called to save the sequence definition.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_activeLedCount']={syn:'Changes the number of LEDs currently handled by the device.',lib:'YColorLedCluster set_activeLedCount',pro:'YColorLedCluster <span id=pn>target</span> set_activeLedCount <span id=pn>newval</span>',cmt:'<p>Changes the number of LEDs currently handled by the device.</p>',par:{newval:'an integer corresponding to the number of LEDs currently handled by the device'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_blinkSeqSpeed']={syn:'Changes the execution speed of a sequence.',lib:'YColorLedCluster set_blinkSeqSpeed',pro:'YColorLedCluster <span id=pn>target</span> set_blinkSeqSpeed <span id=pn>seqIndex</span> <span id=pn>speed</span>',cmt:'<p>Changes the execution speed of a sequence. The natural execution speed is 1000 per thousand. If you configure a slower speed, you can play the sequence in slow-motion. If you set a negative speed, you can play the sequence in reverse direction.</p>',par:{seqIndex:'index of the sequence to start.',speed:'sequence running speed (-1000...1000).'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_blinkSeqStateAtPowerOn']={syn:'Configures a sequence to make it start automatically at device startup.',lib:'YColorLedCluster set_blinkSeqStateAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> set_blinkSeqStateAtPowerOn <span id=pn>seqIndex</span> <span id=pn>autostart</span>',cmt:'<p>Configures a sequence to make it start automatically at device startup. Note that a sequence with a zero duration can\x27t be started. Don\x27t forget to call <tt>saveBlinkSeq()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{seqIndex:'index of the sequence to reset.',autostart:'0 to keep the sequence turned off and 1 to start it automatically.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_hslColor']={syn:'Changes the current color of consecutive LEDs in the cluster, using a HSL color.',lib:'YColorLedCluster set_hslColor',pro:'YColorLedCluster <span id=pn>target</span> set_hslColor <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>hslValue</span>',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_hslColorArray']={syn:'Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.',lib:'YColorLedCluster set_hslColorArray',pro:'YColorLedCluster <span id=pn>target</span> set_hslColorArray <span id=pn>ledIndex</span> <span id=pn>hslList</span>',cmt:'<p>Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is. The first number represents the HSL value of the LED specified as parameter, the second number represents the HSL value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of 24bit HSL codes, in the form 0xHHSSLL'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_hslColorAtPowerOn']={syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color.',lib:'YColorLedCluster set_hslColorAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> set_hslColorAtPowerOn <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>hslValue</span>',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_hslColorBuffer']={syn:'Sends a binary buffer to the LED HSL buffer, as is.',lib:'YColorLedCluster set_hslColorBuffer',pro:'YColorLedCluster <span id=pn>target</span> set_hslColorBuffer <span id=pn>ledIndex</span> <span id=pn>buff</span>',cmt:'<p>Sends a binary buffer to the LED HSL buffer, as is. First three bytes are HSL components for the LED specified as parameter, the next three bytes for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_ledType']={syn:'Changes the RGB LED type currently handled by the device.',lib:'YColorLedCluster set_ledType',pro:'YColorLedCluster <span id=pn>target</span> set_ledType <span id=pn>newval</span>',cmt:'<p>Changes the RGB LED type currently handled by the device.</p>',par:{newval:'either <tt>RGB</tt> or <tt>RGBW</tt>, according to the RGB LED type currently handled by the device'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_logicalName']={syn:'Changes the logical name of the RGB LED cluster.',lib:'YColorLedCluster set_logicalName',pro:'YColorLedCluster <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the RGB LED cluster.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED cluster.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_rgbColor']={syn:'Changes the current color of consecutive LEDs in the cluster, using a RGB color.',lib:'YColorLedCluster set_rgbColor',pro:'YColorLedCluster <span id=pn>target</span> set_rgbColor <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>rgbValue</span>',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_rgbColorArray']={syn:'Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.',lib:'YColorLedCluster set_rgbColorArray',pro:'YColorLedCluster <span id=pn>target</span> set_rgbColorArray <span id=pn>ledIndex</span> <span id=pn>rgbList</span>',cmt:'<p>Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is. The first number represents the RGB value of the LED specified as parameter, the second number represents the RGB value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of 24bit RGB codes, in the form 0xRRGGBB'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['set_rgbColorAtPowerOn']={syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color.',lib:'YColorLedCluster set_rgbColorAtPowerOn',pro:'YColorLedCluster <span id=pn>target</span> set_rgbColorAtPowerOn <span id=pn>ledIndex</span> <span id=pn>count</span> <span id=pn>rgbValue</span>',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['set_rgbColorBuffer']={syn:'Sends a binary buffer to the LED RGB buffer, as is.',lib:'YColorLedCluster set_rgbColorBuffer',pro:'YColorLedCluster <span id=pn>target</span> set_rgbColorBuffer <span id=pn>ledIndex</span> <span id=pn>buff</span>',cmt:'<p>Sends a binary buffer to the LED RGB buffer, as is. First three bytes are RGB components for LED specified as parameter, the next three bytes for the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLedCluster']['startBlinkSeq']={syn:'Starts a sequence execution: every LED linked to that sequence starts to run it in a loop.',lib:'YColorLedCluster startBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> startBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Starts a sequence execution: every LED linked to that sequence starts to run it in a loop. Note that a sequence with a zero duration can\x27t be started.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['stopBlinkSeq']={syn:'Stops a sequence execution.',lib:'YColorLedCluster stopBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> stopBlinkSeq <span id=pn>seqIndex</span>',cmt:'<p>Stops a sequence execution. If started again, the execution restarts from the beginning.</p>',par:{seqIndex:'index of the sequence to stop.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['unlinkLedFromBlinkSeq']={syn:'Unlinks adjacent LEDs from a sequence.',lib:'YColorLedCluster unlinkLedFromBlinkSeq',pro:'YColorLedCluster <span id=pn>target</span> unlinkLedFromBlinkSeq <span id=pn>ledIndex</span> <span id=pn>count</span>',cmt:'<p>Unlinks adjacent LEDs from a sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['ColorLedCluster']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YColorLedCluster unmuteValueCallbacks',pro:'YColorLedCluster <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: ColorLedCluster)
//--- (generated code: CurrentLoopOutput)
doc['CurrentLoopOutput']={'':{syn:'CurrentLoopOutput function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the 4-20mA \x09 output as well as to know the current loop state.</p>'}};
doc['CurrentLoopOutput']['currentMove']={syn:'Performs a smooth transition of current flowing in the loop.',lib:'YCurrentLoopOutput currentMove',pro:'YCurrentLoopOutput <span id=pn>target</span> currentMove <span id=pn>mA_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition of current flowing in the loop. Any current explicit change cancels any ongoing transition process.</p>',par:{mA_target:'new current value at the end of the transition (floating-point number, representing the end current in mA)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.'};
doc['CurrentLoopOutput']['get_advertisedValue']={syn:'Returns the current value of the 4-20mA output (no more than 6 characters).',lib:'YCurrentLoopOutput get_advertisedValue',pro:'YCurrentLoopOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the 4-20mA output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the 4-20mA output (no more than 6 characters).',ext:''};
doc['CurrentLoopOutput']['get_current']={syn:'Returns the loop current set point in mA.',lib:'YCurrentLoopOutput get_current',pro:'YCurrentLoopOutput <span id=pn>target</span> get_current',cmt:'<p>Returns the loop current set point in mA.</p>',ret:'a floating point number corresponding to the loop current set point in mA',ext:''};
doc['CurrentLoopOutput']['get_currentAtStartUp']={syn:'Returns the current in the loop at device startup, in mA.',lib:'YCurrentLoopOutput get_currentAtStartUp',pro:'YCurrentLoopOutput <span id=pn>target</span> get_currentAtStartUp',cmt:'<p>Returns the current in the loop at device startup, in mA.</p>',ret:'a floating point number corresponding to the current in the loop at device startup, in mA',ext:''};
doc['CurrentLoopOutput']['get_logicalName']={syn:'Returns the logical name of the 4-20mA output.',lib:'YCurrentLoopOutput get_logicalName',pro:'YCurrentLoopOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the 4-20mA output.</p>',ret:'a string corresponding to the logical name of the 4-20mA output.',ext:''};
doc['CurrentLoopOutput']['get_loopPower']={syn:'Returns the loop powerstate.',lib:'YCurrentLoopOutput get_loopPower',pro:'YCurrentLoopOutput <span id=pn>target</span> get_loopPower',cmt:'<p>Returns the loop powerstate. POWEROK: the loop \x09 is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not powered enough to maintain the current required (insufficient voltage).</p>',ret:'a value among <tt>NOPWR</tt>, <tt>LOWPWR</tt> and <tt>POWEROK</tt> corresponding to the loop powerstate',ext:''};
doc['CurrentLoopOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YCurrentLoopOutput muteValueCallbacks',pro:'YCurrentLoopOutput <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['CurrentLoopOutput']['set_current']={syn:'Changes the current loop, the valid range is from 3 to 21mA.',lib:'YCurrentLoopOutput set_current',pro:'YCurrentLoopOutput <span id=pn>target</span> set_current <span id=pn>newval</span>',cmt:'<p>Changes the current loop, the valid range is from 3 to 21mA. If the loop is \x09 not properly powered, the target current is not reached and \x09\x09loopPower is set to LOWPWR.</p>',par:{newval:'a floating point number corresponding to the current loop, the valid range is from 3 to 21mA'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CurrentLoopOutput']['set_currentAtStartUp']={syn:'Changes the loop current at device start up.',lib:'YCurrentLoopOutput set_currentAtStartUp',pro:'YCurrentLoopOutput <span id=pn>target</span> set_currentAtStartUp <span id=pn>newval</span>',cmt:'<p>Changes the loop current at device start up.</p>',par:{newval:'a floating point number corresponding to the loop current at device start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CurrentLoopOutput']['set_logicalName']={syn:'Changes the logical name of the 4-20mA output.',lib:'YCurrentLoopOutput set_logicalName',pro:'YCurrentLoopOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the 4-20mA output.</p>',par:{newval:'a string corresponding to the logical name of the 4-20mA output.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CurrentLoopOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YCurrentLoopOutput unmuteValueCallbacks',pro:'YCurrentLoopOutput <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: CurrentLoopOutput)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to switch the state of each channel of the I/O port. You can switch all channels at once, or one by one. Most functions \x09 use a binary representation for channels where bit 0 matches channel #0 , bit 1 matches channel \x09 #1 and so on.... If you are not familiar with numbers binary representation, you will find more \x09 information here: en.wikipedia.org/wiki/Binary_number#Representation . The library can also automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}};
doc['DigitalIO']['delayedPulse']={syn:'Schedules a pulse on a single bit for a specified duration.',lib:'YDigitalIO delayedPulse',pro:'YDigitalIO <span id=pn>target</span> delayedPulse <span id=pn>bitno</span> <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_advertisedValue']={syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'YDigitalIO get_advertisedValue',pro:'YDigitalIO <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:''};
doc['DigitalIO']['get_bitDirection']={syn:'Returns the direction of a single bit (i.e.',lib:'YDigitalIO get_bitDirection',pro:'YDigitalIO <span id=pn>target</span> get_bitDirection <span id=pn>bitno</span>',cmt:'<p>Returns the direction of a single bit (i.e. channel) from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'YDigitalIO get_bitOpenDrain',pro:'YDigitalIO <span id=pn>target</span> get_bitOpenDrain <span id=pn>bitno</span>',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:''};
doc['DigitalIO']['get_bitPolarity']={syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'YDigitalIO get_bitPolarity',pro:'YDigitalIO <span id=pn>target</span> get_bitPolarity <span id=pn>bitno</span>',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_bitState']={syn:'Returns the state of a single bit (i.e.',lib:'YDigitalIO get_bitState',pro:'YDigitalIO <span id=pn>target</span> get_bitState <span id=pn>bitno</span>',cmt:'<p>Returns the state of a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:''};
doc['DigitalIO']['get_logicalName']={syn:'Returns the logical name of the digital IO port.',lib:'YDigitalIO get_logicalName',pro:'YDigitalIO <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:''};
doc['DigitalIO']['get_outputVoltage']={syn:'Returns the voltage source used to drive output bits.',lib:'YDigitalIO get_outputVoltage',pro:'YDigitalIO <span id=pn>target</span> get_outputVoltage',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt> and <tt>EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:''};
doc['DigitalIO']['get_portDiags']={syn:'Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only).',lib:'YDigitalIO get_portDiags',pro:'YDigitalIO <span id=pn>target</span> get_portDiags',cmt:'<p>Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only). Bit 0 indicates a shortcut on output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent). During normal use, all diagnostic bits should stay clear.</p>',ret:'an integer corresponding to the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only)',ext:''};
doc['DigitalIO']['get_portDirection']={syn:'Returns the IO direction of all bits (i.e.',lib:'YDigitalIO get_portDirection',pro:'YDigitalIO <span id=pn>target</span> get_portDirection',cmt:'<p>Returns the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the IO direction of all bits (i.e',ext:''};
doc['DigitalIO']['get_portOpenDrain']={syn:'Returns the electrical interface for each bit of the port.',lib:'YDigitalIO get_portOpenDrain',pro:'YDigitalIO <span id=pn>target</span> get_portOpenDrain',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:''};
doc['DigitalIO']['get_portPolarity']={syn:'Returns the polarity of all the bits of the port.',lib:'YDigitalIO get_portPolarity',pro:'YDigitalIO <span id=pn>target</span> get_portPolarity',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:''};
doc['DigitalIO']['get_portSize']={syn:'Returns the number of bits (i.e.',lib:'YDigitalIO get_portSize',pro:'YDigitalIO <span id=pn>target</span> get_portSize',cmt:'<p>Returns the number of bits (i.e. channels)implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits (i.e',ext:''};
doc['DigitalIO']['get_portState']={syn:'Returns the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on..',lib:'YDigitalIO get_portState',pro:'YDigitalIO <span id=pn>target</span> get_portState',cmt:'<p>Returns the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on...</p>',ret:'an integer corresponding to the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on.',ext:''};
doc['DigitalIO']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YDigitalIO muteValueCallbacks',pro:'YDigitalIO <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['DigitalIO']['pulse']={syn:'Triggers a pulse on a single bit for a specified duration.',lib:'YDigitalIO pulse',pro:'YDigitalIO <span id=pn>target</span> pulse <span id=pn>bitno</span> <span id=pn>ms_duration</span>',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitDirection']={syn:'Changes the direction of a single bit (i.e.',lib:'YDigitalIO set_bitDirection',pro:'YDigitalIO <span id=pn>target</span> set_bitDirection <span id=pn>bitno</span> <span id=pn>bitdirection</span>',cmt:'<p>Changes the direction of a single bit (i.e. channel) from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'YDigitalIO set_bitOpenDrain',pro:'YDigitalIO <span id=pn>target</span> set_bitOpenDrain <span id=pn>bitno</span> <span id=pn>opendrain</span>',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitPolarity']={syn:'Changes the polarity of a single bit from the I/O port.',lib:'YDigitalIO set_bitPolarity',pro:'YDigitalIO <span id=pn>target</span> set_bitPolarity <span id=pn>bitno</span> <span id=pn>bitpolarity</span>',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitState']={syn:'Sets a single bit (i.e.',lib:'YDigitalIO set_bitState',pro:'YDigitalIO <span id=pn>target</span> set_bitState <span id=pn>bitno</span> <span id=pn>bitstate</span>',cmt:'<p>Sets a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_logicalName']={syn:'Changes the logical name of the digital IO port.',lib:'YDigitalIO set_logicalName',pro:'YDigitalIO <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the digital IO port.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_outputVoltage']={syn:'Changes the voltage source used to drive output bits.',lib:'YDigitalIO set_outputVoltage',pro:'YDigitalIO <span id=pn>target</span> set_outputVoltage <span id=pn>newval</span>',cmt:'<p>Changes the voltage source used to drive output bits.</p>',par:{newval:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt> and <tt>EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portDirection']={syn:'Changes the IO direction of all bits (i.e.',lib:'YDigitalIO set_portDirection',pro:'YDigitalIO <span id=pn>target</span> set_portDirection <span id=pn>newval</span>',cmt:'<p>Changes the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.</p>',par:{newval:'an integer corresponding to the IO direction of all bits (i.e'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portOpenDrain']={syn:'Changes the electrical interface for each bit of the port.',lib:'YDigitalIO set_portOpenDrain',pro:'YDigitalIO <span id=pn>target</span> set_portOpenDrain <span id=pn>newval</span>',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portPolarity']={syn:'Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.',lib:'YDigitalIO set_portPolarity',pro:'YDigitalIO <span id=pn>target</span> set_portPolarity <span id=pn>newval</span>',cmt:'<p>Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portState']={syn:'Changes the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel.',lib:'YDigitalIO set_portState',pro:'YDigitalIO <span id=pn>target</span> set_portState <span id=pn>newval</span>',cmt:'<p>Changes the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel. Bit 0 matches channel #0. So: To set all channels to 0 -> <tt>0b00000000</tt> -> parameter = 0 To set channel #0 to 1 -> <tt>0b00000001</tt> -> parameter = 1 To set channel #1 to 1 -> <tt>0b00000010</tt> -> parameter = 2 To set channel #0 and #1 -> <tt>0b00000011</tt> -> parameter = 3 To set channel #2 to 1 -> <tt>0b00000100</tt> -> parameter = 4 an so on.... Only channels configured as output, thanks to <tt>portDirection</tt>, are affected.</p>',par:{newval:'an integer corresponding to the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['toggle_bitState']={syn:'Reverts a single bit (i.e.',lib:'YDigitalIO toggle_bitState',pro:'YDigitalIO <span id=pn>target</span> toggle_bitState <span id=pn>bitno</span>',cmt:'<p>Reverts a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YDigitalIO unmuteValueCallbacks',pro:'YDigitalIO <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: DigitalIO)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'YDualPower get_advertisedValue',pro:'YDualPower <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters).',ext:''};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'YDualPower get_extVoltage',pro:'YDualPower <span id=pn>target</span> get_extVoltage',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:''};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'YDualPower get_logicalName',pro:'YDualPower <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control.',ext:''};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'YDualPower get_powerControl',pro:'YDualPower <span id=pn>target</span> get_powerControl',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>AUTO</tt>, <tt>FROM_USB</tt>, <tt>FROM_EXT</tt> and <tt>OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:''};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'YDualPower get_powerState',pro:'YDualPower <span id=pn>target</span> get_powerState',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>OFF</tt>, <tt>FROM_USB</tt> and <tt>FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:''};
doc['DualPower']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YDualPower muteValueCallbacks',pro:'YDualPower <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'YDualPower set_logicalName',pro:'YDualPower <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the power control.</p>',par:{newval:'a string corresponding to the logical name of the power control.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'YDualPower set_powerControl',pro:'YDualPower <span id=pn>target</span> set_powerControl <span id=pn>newval</span>',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>AUTO</tt>, <tt>FROM_USB</tt>, <tt>FROM_EXT</tt> and <tt>OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DualPower']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YDualPower unmuteValueCallbacks',pro:'YDualPower <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: DualPower)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'GPS function interface',inc:'',cmt:'<p>The GPS function allows you to extract positioning data from the GPS device. This class can provides complete positioning information: However, if you wish to define callbacks on position changes, you should use the YLatitude et YLongitude classes.</p>'}};
doc['Gps']['get_advertisedValue']={syn:'Returns the current value of the GPS (no more than 6 characters).',lib:'YGps get_advertisedValue',pro:'YGps <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the GPS (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the GPS (no more than 6 characters).',ext:''};
doc['Gps']['get_altitude']={syn:'Returns the current altitude.',lib:'YGps get_altitude',pro:'YGps <span id=pn>target</span> get_altitude',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:''};
doc['Gps']['get_coordSystem']={syn:'Returns the representation system used for positioning data.',lib:'YGps get_coordSystem',pro:'YGps <span id=pn>target</span> get_coordSystem',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>GPS_DMS</tt>, <tt>GPS_DM</tt> and <tt>GPS_D</tt> corresponding to the representation system used for positioning data',ext:''};
doc['Gps']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'YGps get_dateTime',pro:'YGps <span id=pn>target</span> get_dateTime',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:''};
doc['Gps']['get_dilution']={syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'YGps get_dilution',pro:'YGps <span id=pn>target</span> get_dilution',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:''};
doc['Gps']['get_direction']={syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'YGps get_direction',pro:'YGps <span id=pn>target</span> get_direction',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:''};
doc['Gps']['get_groundSpeed']={syn:'Returns the current ground speed in Km/h.',lib:'YGps get_groundSpeed',pro:'YGps <span id=pn>target</span> get_groundSpeed',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:''};
doc['Gps']['get_isFixed']={syn:'Returns TRUE if the receiver has found enough satellites to work.',lib:'YGps get_isFixed',pro:'YGps <span id=pn>target</span> get_isFixed',cmt:'<p>Returns TRUE if the receiver has found enough satellites to work.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to TRUE if the receiver has found enough satellites to work',ext:''};
doc['Gps']['get_latitude']={syn:'Returns the current latitude.',lib:'YGps get_latitude',pro:'YGps <span id=pn>target</span> get_latitude',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:''};
doc['Gps']['get_logicalName']={syn:'Returns the logical name of the GPS.',lib:'YGps get_logicalName',pro:'YGps <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the GPS.</p>',ret:'a string corresponding to the logical name of the GPS.',ext:''};
doc['Gps']['get_longitude']={syn:'Returns the current longitude.',lib:'YGps get_longitude',pro:'YGps <span id=pn>target</span> get_longitude',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:''};
doc['Gps']['get_satCount']={syn:'Returns the count of visible satellites.',lib:'YGps get_satCount',pro:'YGps <span id=pn>target</span> get_satCount',cmt:'<p>Returns the count of visible satellites.</p>',ret:'an integer corresponding to the count of visible satellites',ext:''};
doc['Gps']['get_unixTime']={syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'YGps get_unixTime',pro:'YGps <span id=pn>target</span> get_unixTime',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:''};
doc['Gps']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'YGps get_utcOffset',pro:'YGps <span id=pn>target</span> get_utcOffset',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:''};
doc['Gps']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YGps muteValueCallbacks',pro:'YGps <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Gps']['set_coordSystem']={syn:'Changes the representation system used for positioning data.',lib:'YGps set_coordSystem',pro:'YGps <span id=pn>target</span> set_coordSystem <span id=pn>newval</span>',cmt:'<p>Changes the representation system used for positioning data.</p>',par:{newval:'a value among <tt>GPS_DMS</tt>, <tt>GPS_DM</tt> and <tt>GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gps']['set_logicalName']={syn:'Changes the logical name of the GPS.',lib:'YGps set_logicalName',pro:'YGps <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the GPS.</p>',par:{newval:'a string corresponding to the logical name of the GPS.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gps']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'YGps set_utcOffset',pro:'YGps <span id=pn>target</span> set_utcOffset <span id=pn>newval</span>',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gps']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YGps unmuteValueCallbacks',pro:'YGps <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Gps)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'',cmt:'<p>YHubPort objects provide control over the power supply for every YoctoHub port and provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'YHubPort get_advertisedValue',pro:'YHubPort <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters).',ext:''};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'YHubPort get_baudRate',pro:'YHubPort <span id=pn>target</span> get_baudRate',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:''};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'YHubPort get_enabled',pro:'YHubPort <span id=pn>target</span> get_enabled',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:''};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port.',lib:'YHubPort get_logicalName',pro:'YHubPort <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the Yocto-hub port.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port.',ext:''};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'YHubPort get_portState',pro:'YHubPort <span id=pn>target</span> get_portState',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>OFF</tt>, <tt>OVRLD</tt>, <tt>ON</tt>, <tt>RUN</tt> and <tt>PROG</tt> corresponding to the current state of the Yocto-hub port',ext:''};
doc['HubPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YHubPort muteValueCallbacks',pro:'YHubPort <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'YHubPort set_enabled',pro:'YHubPort <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['HubPort']['set_logicalName']={syn:'Changes the logical name of the Yocto-hub port.',lib:'YHubPort set_logicalName',pro:'YHubPort <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the Yocto-hub port.</p>',par:{newval:'a string corresponding to the logical name of the Yocto-hub port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['HubPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YHubPort unmuteValueCallbacks',pro:'YHubPort <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: HubPort)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you not only to drive the intensity of the LED, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the LED (no more than 6 characters).',lib:'YLed get_advertisedValue',pro:'YLed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the LED (no more than 6 characters).',ext:''};
doc['Led']['get_blinking']={syn:'Returns the current LED signaling mode.',lib:'YLed get_blinking',pro:'YLed <span id=pn>target</span> get_blinking',cmt:'<p>Returns the current LED signaling mode.</p>',ret:'a value among <tt>STILL</tt>, <tt>RELAX</tt>, <tt>AWARE</tt>, <tt>RUN</tt>, <tt>CALL</tt> and <tt>PANIC</tt> corresponding to the current LED signaling mode',ext:''};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the LED.',lib:'YLed get_logicalName',pro:'YLed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the LED.</p>',ret:'a string corresponding to the logical name of the LED.',ext:''};
doc['Led']['get_luminosity']={syn:'Returns the current LED intensity (in per cent).',lib:'YLed get_luminosity',pro:'YLed <span id=pn>target</span> get_luminosity',cmt:'<p>Returns the current LED intensity (in per cent).</p>',ret:'an integer corresponding to the current LED intensity (in per cent)',ext:''};
doc['Led']['get_power']={syn:'Returns the current LED state.',lib:'YLed get_power',pro:'YLed <span id=pn>target</span> get_power',cmt:'<p>Returns the current LED state.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the current LED state',ext:''};
doc['Led']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YLed muteValueCallbacks',pro:'YLed <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Led']['set_blinking']={syn:'Changes the current LED signaling mode.',lib:'YLed set_blinking',pro:'YLed <span id=pn>target</span> set_blinking <span id=pn>newval</span>',cmt:'<p>Changes the current LED signaling mode.</p>',par:{newval:'a value among <tt>STILL</tt>, <tt>RELAX</tt>, <tt>AWARE</tt>, <tt>RUN</tt>, <tt>CALL</tt> and <tt>PANIC</tt> corresponding to the current LED signaling mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the LED.',lib:'YLed set_logicalName',pro:'YLed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the LED.</p>',par:{newval:'a string corresponding to the logical name of the LED.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_luminosity']={syn:'Changes the current LED intensity (in per cent).',lib:'YLed set_luminosity',pro:'YLed <span id=pn>target</span> set_luminosity <span id=pn>newval</span>',cmt:'<p>Changes the current LED intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current LED intensity (in per cent)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_power']={syn:'Changes the state of the LED.',lib:'YLed set_power',pro:'YLed <span id=pn>target</span> set_power <span id=pn>newval</span>',cmt:'<p>Changes the state of the LED.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the state of the LED'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YLed unmuteValueCallbacks',pro:'YLed <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Led)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to drive the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}};
doc['Motor']['brakingForceMove']={syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'YMotor brakingForceMove',pro:'YMotor <span id=pn>target</span> brakingForceMove <span id=pn>targetPower</span> <span id=pn>delay</span>',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['drivingForceMove']={syn:'Changes progressively the power sent to the motor for a specific duration.',lib:'YMotor drivingForceMove',pro:'YMotor <span id=pn>target</span> drivingForceMove <span id=pn>targetPower</span> <span id=pn>delay</span>',cmt:'<p>Changes progressively the power sent to the motor for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['get_advertisedValue']={syn:'Returns the current value of the motor (no more than 6 characters).',lib:'YMotor get_advertisedValue',pro:'YMotor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:''};
doc['Motor']['get_brakingForce']={syn:'Returns the braking force applied to the motor, as a percentage.',lib:'YMotor get_brakingForce',pro:'YMotor <span id=pn>target</span> get_brakingForce',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:''};
doc['Motor']['get_cutOffVoltage']={syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'YMotor get_cutOffVoltage',pro:'YMotor <span id=pn>target</span> get_cutOffVoltage',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:''};
doc['Motor']['get_drivingForce']={syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'YMotor get_drivingForce',pro:'YMotor <span id=pn>target</span> get_drivingForce',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:''};
doc['Motor']['get_failSafeTimeout']={syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'YMotor get_failSafeTimeout',pro:'YMotor <span id=pn>target</span> get_failSafeTimeout',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:''};
doc['Motor']['get_frequency']={syn:'Returns the PWM frequency used to control the motor.',lib:'YMotor get_frequency',pro:'YMotor <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:''};
doc['Motor']['get_logicalName']={syn:'Returns the logical name of the motor.',lib:'YMotor get_logicalName',pro:'YMotor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:''};
doc['Motor']['get_motorStatus']={syn:'Return the controller state.',lib:'YMotor get_motorStatus',pro:'YMotor <span id=pn>target</span> get_motorStatus',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an over current condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>IDLE</tt>, <tt>BRAKE</tt>, <tt>FORWD</tt>, <tt>BACKWD</tt>, <tt>LOVOLT</tt>, <tt>HICURR</tt>, <tt>HIHEAT</tt> and <tt>FAILSF</tt>',ext:''};
doc['Motor']['get_overCurrentLimit']={syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'YMotor get_overCurrentLimit',pro:'YMotor <span id=pn>target</span> get_overCurrentLimit',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:''};
doc['Motor']['get_starterTime']={syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'YMotor get_starterTime',pro:'YMotor <span id=pn>target</span> get_starterTime',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:''};
doc['Motor']['keepALive']={syn:'Rearms the controller failsafe timer.',lib:'YMotor keepALive',pro:'YMotor <span id=pn>target</span> keepALive',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitly rearms the failsafe timer.</p>'};
doc['Motor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMotor muteValueCallbacks',pro:'YMotor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Motor']['resetStatus']={syn:'Reset the controller state to IDLE.',lib:'YMotor resetStatus',pro:'YMotor <span id=pn>target</span> resetStatus',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitly after any error condition is signaled.</p>'};
doc['Motor']['set_brakingForce']={syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'YMotor set_brakingForce',pro:'YMotor <span id=pn>target</span> set_brakingForce <span id=pn>newval</span>',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_cutOffVoltage']={syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'YMotor set_cutOffVoltage',pro:'YMotor <span id=pn>target</span> set_cutOffVoltage <span id=pn>newval</span>',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_drivingForce']={syn:'Changes immediately the power sent to the motor.',lib:'YMotor set_drivingForce',pro:'YMotor <span id=pn>target</span> set_drivingForce <span id=pn>newval</span>',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_failSafeTimeout']={syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'YMotor set_failSafeTimeout',pro:'YMotor <span id=pn>target</span> set_failSafeTimeout <span id=pn>newval</span>',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_frequency']={syn:'Changes the PWM frequency used to control the motor.',lib:'YMotor set_frequency',pro:'YMotor <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_logicalName']={syn:'Changes the logical name of the motor.',lib:'YMotor set_logicalName',pro:'YMotor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the motor.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_overCurrentLimit']={syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'YMotor set_overCurrentLimit',pro:'YMotor <span id=pn>target</span> set_overCurrentLimit <span id=pn>newval</span>',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_starterTime']={syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'YMotor set_starterTime',pro:'YMotor <span id=pn>target</span> set_starterTime <span id=pn>newval</span>',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMotor unmuteValueCallbacks',pro:'YMotor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Motor)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'YNetwork callbackLogin',pro:'YNetwork <span id=pn>target</span> callbackLogin <span id=pn>username</span> <span id=pn>password</span>',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'YNetwork get_adminPassword',pro:'YNetwork <span id=pn>target</span> get_adminPassword',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:''};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'YNetwork get_advertisedValue',pro:'YNetwork <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:''};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'YNetwork get_callbackCredentials',pro:'YNetwork <span id=pn>target</span> get_callbackCredentials',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:''};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'YNetwork get_callbackEncoding',pro:'YNetwork <span id=pn>target</span> get_callbackEncoding',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>FORM</tt>, <tt>JSON</tt>, <tt>JSON_ARRAY</tt>, <tt>CSV</tt>, <tt>YOCTO_API</tt>, <tt>JSON_NUM</tt>, <tt>EMONCMS</tt>, <tt>AZURE</tt>, <tt>INFLUXDB</tt>, <tt>MQTT</tt>, <tt>YOCTO_API_JZON</tt> and <tt>PRTG</tt> corresponding to the encoding standard to use for representing notification values',ext:''};
doc['Network']['get_callbackInitialDelay']={syn:'Returns the initial waiting time before first callback notifications, in seconds.',lib:'YNetwork get_callbackInitialDelay',pro:'YNetwork <span id=pn>target</span> get_callbackInitialDelay',cmt:'<p>Returns the initial waiting time before first callback notifications, in seconds.</p>',ret:'an integer corresponding to the initial waiting time before first callback notifications, in seconds',ext:''};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the waiting time between two HTTP callbacks when there is nothing new.',lib:'YNetwork get_callbackMaxDelay',pro:'YNetwork <span id=pn>target</span> get_callbackMaxDelay',cmt:'<p>Returns the waiting time between two HTTP callbacks when there is nothing new.</p>',ret:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new',ext:''};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'YNetwork get_callbackMethod',pro:'YNetwork <span id=pn>target</span> get_callbackMethod',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>POST</tt>, <tt>GET</tt> and <tt>PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:''};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two HTTP callbacks, in seconds.',lib:'YNetwork get_callbackMinDelay',pro:'YNetwork <span id=pn>target</span> get_callbackMinDelay',cmt:'<p>Returns the minimum waiting time between two HTTP callbacks, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds',ext:''};
doc['Network']['get_callbackSchedule']={syn:'Returns the HTTP callback schedule strategy, as a text string.',lib:'YNetwork get_callbackSchedule',pro:'YNetwork <span id=pn>target</span> get_callbackSchedule',cmt:'<p>Returns the HTTP callback schedule strategy, as a text string.</p>',ret:'a string corresponding to the HTTP callback schedule strategy, as a text string',ext:''};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'YNetwork get_callbackUrl',pro:'YNetwork <span id=pn>target</span> get_callbackUrl',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:''};
doc['Network']['get_defaultPage']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'YNetwork get_defaultPage',pro:'YNetwork <span id=pn>target</span> get_defaultPage',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:''};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'YNetwork get_discoverable',pro:'YNetwork <span id=pn>target</span> get_discoverable',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:''};
doc['Network']['get_httpPort']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'YNetwork get_httpPort',pro:'YNetwork <span id=pn>target</span> get_httpPort',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'an integer corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:''};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'YNetwork get_ipAddress',pro:'YNetwork <span id=pn>target</span> get_ipAddress',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:''};
doc['Network']['get_ipConfig']={syn:'Returns the IP configuration of the network interface.',lib:'YNetwork get_ipConfig',pro:'YNetwork <span id=pn>target</span> get_ipConfig',cmt:'<p>Returns the IP configuration of the network interface.</p><p> If the network interface is setup to use a static IP address, the string starts with \x22STATIC:\x22 and is followed by three parameters, separated by \x22/\x22. The first is the device IP address, followed by the subnet mask length, and finally the router IP address (default gateway). For instance: \x22STATIC:192.168.1.14/16/192.168.1.1\x22</p><p> If the network interface is configured to receive its IP from a DHCP server, the string start with \x22DHCP:\x22 and is followed by three parameters separated by \x22/\x22. The first is the fallback IP address, then the fallback subnet mask length and finally the fallback router IP address. These three parameters are used when no DHCP reply is received.</p>',ret:'a string corresponding to the IP configuration of the network interface',ext:''};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'YNetwork get_logicalName',pro:'YNetwork <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:''};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'YNetwork get_macAddress',pro:'YNetwork <span id=pn>target</span> get_macAddress',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:''};
doc['Network']['get_ntpServer']={syn:'Returns the IP address of the NTP server to be used by the device.',lib:'YNetwork get_ntpServer',pro:'YNetwork <span id=pn>target</span> get_ntpServer',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:''};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.',lib:'YNetwork get_poeCurrent',pro:'YNetwork <span id=pn>target</span> get_poeCurrent',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milliamps',ext:''};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'YNetwork get_primaryDNS',pro:'YNetwork <span id=pn>target</span> get_primaryDNS',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:''};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'YNetwork get_readiness',pro:'YNetwork <span id=pn>target</span> get_readiness',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>DOWN</tt>, <tt>EXISTS</tt>, <tt>LINKED</tt>, <tt>LAN_OK</tt> and <tt>WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:''};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'YNetwork get_router',pro:'YNetwork <span id=pn>target</span> get_router',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:''};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'YNetwork get_secondaryDNS',pro:'YNetwork <span id=pn>target</span> get_secondaryDNS',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:''};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'YNetwork get_subnetMask',pro:'YNetwork <span id=pn>target</span> get_subnetMask',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:''};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'YNetwork get_userPassword',pro:'YNetwork <span id=pn>target</span> get_userPassword',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:''};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'YNetwork get_wwwWatchdogDelay',pro:'YNetwork <span id=pn>target</span> get_wwwWatchdogDelay',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:''};
doc['Network']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YNetwork muteValueCallbacks',pro:'YNetwork <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['ping']={syn:'Pings host to test the network connectivity.',lib:'YNetwork ping',pro:'YNetwork <span id=pn>target</span> ping <span id=pn>host</span>',cmt:'<p>Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'YNetwork set_adminPassword',pro:'YNetwork <span id=pn>target</span> set_adminPassword <span id=pn>newval</span>',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'YNetwork set_callbackCredentials',pro:'YNetwork <span id=pn>target</span> set_callbackCredentials <span id=pn>newval</span>',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'YNetwork set_callbackEncoding',pro:'YNetwork <span id=pn>target</span> set_callbackEncoding <span id=pn>newval</span>',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>FORM</tt>, <tt>JSON</tt>, <tt>JSON_ARRAY</tt>, <tt>CSV</tt>, <tt>YOCTO_API</tt>, <tt>JSON_NUM</tt>, <tt>EMONCMS</tt>, <tt>AZURE</tt>, <tt>INFLUXDB</tt>, <tt>MQTT</tt>, <tt>YOCTO_API_JZON</tt> and <tt>PRTG</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackInitialDelay']={syn:'Changes the initial waiting time before first callback notifications, in seconds.',lib:'YNetwork set_callbackInitialDelay',pro:'YNetwork <span id=pn>target</span> set_callbackInitialDelay <span id=pn>newval</span>',cmt:'<p>Changes the initial waiting time before first callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the initial waiting time before first callback notifications, in seconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the waiting time between two HTTP callbacks when there is nothing new.',lib:'YNetwork set_callbackMaxDelay',pro:'YNetwork <span id=pn>target</span> set_callbackMaxDelay <span id=pn>newval</span>',cmt:'<p>Changes the waiting time between two HTTP callbacks when there is nothing new.</p>',par:{newval:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'YNetwork set_callbackMethod',pro:'YNetwork <span id=pn>target</span> set_callbackMethod <span id=pn>newval</span>',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>POST</tt>, <tt>GET</tt> and <tt>PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two HTTP callbacks, in seconds.',lib:'YNetwork set_callbackMinDelay',pro:'YNetwork <span id=pn>target</span> set_callbackMinDelay <span id=pn>newval</span>',cmt:'<p>Changes the minimum waiting time between two HTTP callbacks, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackSchedule']={syn:'Changes the HTTP callback schedule strategy, as a text string.',lib:'YNetwork set_callbackSchedule',pro:'YNetwork <span id=pn>target</span> set_callbackSchedule <span id=pn>newval</span>',cmt:'<p>Changes the HTTP callback schedule strategy, as a text string.</p>',par:{newval:'a string corresponding to the HTTP callback schedule strategy, as a text string'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'YNetwork set_callbackUrl',pro:'YNetwork <span id=pn>target</span> set_callbackUrl <span id=pn>newval</span>',cmt:'<p>Changes the callback URL to notify significant state changes.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_defaultPage']={syn:'Changes the default HTML page returned by the hub.',lib:'YNetwork set_defaultPage',pro:'YNetwork <span id=pn>target</span> set_defaultPage <span id=pn>newval</span>',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible to change this page for file that has been uploaded on the hub.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'YNetwork set_discoverable',pro:'YNetwork <span id=pn>target</span> set_discoverable <span id=pn>newval</span>',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_httpPort']={syn:'Changes the default HTML page returned by the hub.',lib:'YNetwork set_httpPort',pro:'YNetwork <span id=pn>target</span> set_httpPort <span id=pn>newval</span>',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible to change this page for file that has been uploaded on the hub.</p>',par:{newval:'an integer corresponding to the default HTML page returned by the hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'YNetwork set_logicalName',pro:'YNetwork <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the network interface.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_ntpServer']={syn:'Changes the IP address of the NTP server to be used by the module.',lib:'YNetwork set_ntpServer',pro:'YNetwork <span id=pn>target</span> set_ntpServer <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the NTP server to be used by the module.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_periodicCallbackSchedule']={syn:'Setup periodic HTTP callbacks (simplified function).',lib:'YNetwork set_periodicCallbackSchedule',pro:'YNetwork <span id=pn>target</span> set_periodicCallbackSchedule <span id=pn>interval</span> <span id=pn>offset</span>',cmt:'<p>Setup periodic HTTP callbacks (simplified function).</p>',par:{interval:'a string representing the callback periodicity, expressed in seconds, minutes or hours, eg. \x2260s\x22, \x225m\x22, \x221h\x22, \x2248h\x22.',offset:'an integer representing the time offset relative to the period when the callback should occur. For instance, if the periodicity is 24h, an offset of 7 will make the callback occur each day at 7AM.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'YNetwork set_primaryDNS',pro:'YNetwork <span id=pn>target</span> set_primaryDNS <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'YNetwork set_secondaryDNS',pro:'YNetwork <span id=pn>target</span> set_secondaryDNS <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'YNetwork set_userPassword',pro:'YNetwork <span id=pn>target</span> set_userPassword <span id=pn>newval</span>',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'YNetwork set_wwwWatchdogDelay',pro:'YNetwork <span id=pn>target</span> set_wwwWatchdogDelay <span id=pn>newval</span>',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['triggerCallback']={syn:'Trigger an HTTP callback quickly.',lib:'YNetwork triggerCallback',pro:'YNetwork <span id=pn>target</span> triggerCallback',cmt:'<p>Trigger an HTTP callback quickly. This function can even be called within an HTTP callback, in which case the next callback will be triggered 5 seconds after the end of the current callback, regardless if the minimum time between callbacks configured in the device.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YNetwork unmuteValueCallbacks',pro:'YNetwork <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'YNetwork useDHCP',pro:'YNetwork <span id=pn>target</span> useDHCP <span id=pn>fallbackIpAddr</span> <span id=pn>fallbackSubnetMaskLen</span> <span id=pn>fallbackRouter</span>',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (e.g. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['useDHCPauto']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'YNetwork useDHCPauto',pro:'YNetwork <span id=pn>target</span> useDHCPauto',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses an IP of the network 169.254.0.0/16 (APIPA).</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'YNetwork useStaticIP',pro:'YNetwork <span id=pn>target</span> useStaticIP <span id=pn>ipAddress</span> <span id=pn>subnetMaskLen</span> <span id=pn>router</span>',cmt:'<p>Changes the configuration of the network interface to use a static IP address.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (e.g. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Network)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'External power supply control interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the power output featured on some devices such as the Yocto-Serial.</p>'}};
doc['PowerOutput']['get_advertisedValue']={syn:'Returns the current value of the power output control (no more than 6 characters).',lib:'YPowerOutput get_advertisedValue',pro:'YPowerOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the power output control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power output control (no more than 6 characters).',ext:''};
doc['PowerOutput']['get_logicalName']={syn:'Returns the logical name of the power output control.',lib:'YPowerOutput get_logicalName',pro:'YPowerOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the power output control.</p>',ret:'a string corresponding to the logical name of the power output control.',ext:''};
doc['PowerOutput']['get_voltage']={syn:'Returns the voltage on the power output featured by the module.',lib:'YPowerOutput get_voltage',pro:'YPowerOutput <span id=pn>target</span> get_voltage',cmt:'<p>Returns the voltage on the power output featured by the module.</p>',ret:'a value among <tt>OFF</tt>, <tt>OUT3V3</tt> and <tt>OUT5V</tt> corresponding to the voltage on the power output featured by the module',ext:''};
doc['PowerOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPowerOutput muteValueCallbacks',pro:'YPowerOutput <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PowerOutput']['set_logicalName']={syn:'Changes the logical name of the power output control.',lib:'YPowerOutput set_logicalName',pro:'YPowerOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the power output control.</p>',par:{newval:'a string corresponding to the logical name of the power output control.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerOutput']['set_voltage']={syn:'Changes the voltage on the power output provided by the module.',lib:'YPowerOutput set_voltage',pro:'YPowerOutput <span id=pn>target</span> set_voltage <span id=pn>newval</span>',cmt:'<p>Changes the voltage on the power output provided by the module.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>OUT3V3</tt> and <tt>OUT5V</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPowerOutput unmuteValueCallbacks',pro:'YPowerOutput <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: PowerOutput)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'PwmOutput function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.</p>'}};
doc['PwmOutput']['dutyCycleMove']={syn:'Performs a smooth change of the duty cycle toward a given value.',lib:'YPwmOutput dutyCycleMove',pro:'YPwmOutput <span id=pn>target</span> dutyCycleMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth change of the duty cycle toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new duty cycle at the end of the transition (percentage, floating-point number between 0 and 100)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['frequencyMove']={syn:'Performs a smooth frequency change toward a given value.',lib:'YPwmOutput frequencyMove',pro:'YPwmOutput <span id=pn>target</span> frequencyMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth frequency change toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new frequency at the end of the transition (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['get_advertisedValue']={syn:'Returns the current value of the PWM (no more than 6 characters).',lib:'YPwmOutput get_advertisedValue',pro:'YPwmOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the PWM (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM (no more than 6 characters).',ext:''};
doc['PwmOutput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'YPwmOutput get_dutyCycle',pro:'YPwmOutput <span id=pn>target</span> get_dutyCycle',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:''};
doc['PwmOutput']['get_dutyCycleAtPowerOn']={syn:'Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.',lib:'YPwmOutput get_dutyCycleAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> get_dutyCycleAtPowerOn',cmt:'<p>Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.</p>',ret:'a floating point number corresponding to the PWMs duty cycle at device power on as a floating point number between 0 and 100',ext:''};
doc['PwmOutput']['get_enabled']={syn:'Returns the state of the PWMs.',lib:'YPwmOutput get_enabled',pro:'YPwmOutput <span id=pn>target</span> get_enabled',cmt:'<p>Returns the state of the PWMs.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWMs',ext:''};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Returns the state of the PWM at device power on.',lib:'YPwmOutput get_enabledAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> get_enabledAtPowerOn',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWM at device power on',ext:''};
doc['PwmOutput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'YPwmOutput get_frequency',pro:'YPwmOutput <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:''};
doc['PwmOutput']['get_logicalName']={syn:'Returns the logical name of the PWM.',lib:'YPwmOutput get_logicalName',pro:'YPwmOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the PWM.</p>',ret:'a string corresponding to the logical name of the PWM.',ext:''};
doc['PwmOutput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'YPwmOutput get_period',pro:'YPwmOutput <span id=pn>target</span> get_period',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:''};
doc['PwmOutput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'YPwmOutput get_pulseDuration',pro:'YPwmOutput <span id=pn>target</span> get_pulseDuration',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:''};
doc['PwmOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPwmOutput muteValueCallbacks',pro:'YPwmOutput <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['phaseMove']={syn:'Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel.',lib:'YPwmOutput phaseMove',pro:'YPwmOutput <span id=pn>target</span> phaseMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel. The phase shift is executed by slightly changing the frequency temporarily during the specified duration. This function only makes sense when both channels are running, either at the same frequency, or at a multiple of the channel frequency. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'phase shift at the end of the transition, in milliseconds (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['pulseDurationMove']={syn:'Performs a smooth transition of the pulse duration toward a given value.',lib:'YPwmOutput pulseDurationMove',pro:'YPwmOutput <span id=pn>target</span> pulseDurationMove <span id=pn>ms_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['set_dutyCycle']={syn:'Changes the PWM duty cycle, in per cents.',lib:'YPwmOutput set_dutyCycle',pro:'YPwmOutput <span id=pn>target</span> set_dutyCycle <span id=pn>newval</span>',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Changes the PWM duty cycle at device power on.',lib:'YPwmOutput set_dutyCycleAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> set_dutyCycleAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the PWM duty cycle at device power on.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_enabled']={syn:'Stops or starts the PWM.',lib:'YPwmOutput set_enabled',pro:'YPwmOutput <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Changes the state of the PWM at device power on.',lib:'YPwmOutput set_enabledAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> set_enabledAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the state of the PWM at device power on.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_frequency']={syn:'Changes the PWM frequency.',lib:'YPwmOutput set_frequency',pro:'YPwmOutput <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change, in other words, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies. To stop the PWM signal, do not set the frequency to zero, use the set_enabled() method instead.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_logicalName']={syn:'Changes the logical name of the PWM.',lib:'YPwmOutput set_logicalName',pro:'YPwmOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the PWM.</p>',par:{newval:'a string corresponding to the logical name of the PWM.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_period']={syn:'Changes the PWM period in milliseconds.',lib:'YPwmOutput set_period',pro:'YPwmOutput <span id=pn>target</span> set_period <span id=pn>newval</span>',cmt:'<p>Changes the PWM period in milliseconds. Caution: in order to avoid random truncation of the current pulse, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_pulseDuration']={syn:'Changes the PWM pulse length, in milliseconds.',lib:'YPwmOutput set_pulseDuration',pro:'YPwmOutput <span id=pn>target</span> set_pulseDuration <span id=pn>newval</span>',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['triggerPulsesByDuration']={syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'YPwmOutput triggerPulsesByDuration',pro:'YPwmOutput <span id=pn>target</span> triggerPulsesByDuration <span id=pn>ms_target</span> <span id=pn>n_pulses</span>',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{ms_target:'desired pulse duration (floating-point number, representing the pulse duration in milliseconds)',n_pulses:'desired pulse count'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['triggerPulsesByDutyCycle']={syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'YPwmOutput triggerPulsesByDutyCycle',pro:'YPwmOutput <span id=pn>target</span> triggerPulsesByDutyCycle <span id=pn>target</span> <span id=pn>n_pulses</span>',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired duty cycle for the generated pulses (percentage, floating-point number between 0 and 100)',n_pulses:'desired pulse count'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['triggerPulsesByFrequency']={syn:'Trigger a given number of pulses at the specified frequency, using current duty cycle.',lib:'YPwmOutput triggerPulsesByFrequency',pro:'YPwmOutput <span id=pn>target</span> triggerPulsesByFrequency <span id=pn>target</span> <span id=pn>n_pulses</span>',cmt:'<p>Trigger a given number of pulses at the specified frequency, using current duty cycle. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired frequency for the generated pulses (floating-point number)',n_pulses:'desired pulse count'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPwmOutput unmuteValueCallbacks',pro:'YPwmOutput <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PwmPowerSource function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the voltage source used by all PWM on the same device.</p>'}};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'YPwmPowerSource get_advertisedValue',pro:'YPwmPowerSource <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters).',ext:''};
doc['PwmPowerSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'YPwmPowerSource get_logicalName',pro:'YPwmPowerSource <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source.',ext:''};
doc['PwmPowerSource']['get_powerMode']={syn:'Returns the selected power source for the PWM on the same device.',lib:'YPwmPowerSource get_powerMode',pro:'YPwmPowerSource <span id=pn>target</span> get_powerMode',cmt:'<p>Returns the selected power source for the PWM on the same device.</p>',ret:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt>, <tt>EXT_V</tt> and <tt>OPNDRN</tt> corresponding to the selected power source for the PWM on the same device',ext:''};
doc['PwmPowerSource']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPwmPowerSource muteValueCallbacks',pro:'YPwmPowerSource <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmPowerSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'YPwmPowerSource set_logicalName',pro:'YPwmPowerSource <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage source.</p>',par:{newval:'a string corresponding to the logical name of the voltage source.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmPowerSource']['set_powerMode']={syn:'Changes the PWM power source.',lib:'YPwmPowerSource set_powerMode',pro:'YPwmPowerSource <span id=pn>target</span> set_powerMode <span id=pn>newval</span>',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected.</p>',par:{newval:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt>, <tt>EXT_V</tt> and <tt>OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmPowerSource']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPwmPowerSource unmuteValueCallbacks',pro:'YPwmPowerSource <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'YRealTimeClock get_advertisedValue',pro:'YRealTimeClock <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters).',ext:''};
doc['RealTimeClock']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'YRealTimeClock get_dateTime',pro:'YRealTimeClock <span id=pn>target</span> get_dateTime',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:''};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'YRealTimeClock get_logicalName',pro:'YRealTimeClock <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock.',ext:''};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'YRealTimeClock get_timeSet',pro:'YRealTimeClock <span id=pn>target</span> get_timeSet',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:''};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'YRealTimeClock get_unixTime',pro:'YRealTimeClock <span id=pn>target</span> get_unixTime',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:''};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'YRealTimeClock get_utcOffset',pro:'YRealTimeClock <span id=pn>target</span> get_utcOffset',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:''};
doc['RealTimeClock']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YRealTimeClock muteValueCallbacks',pro:'YRealTimeClock <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'YRealTimeClock set_logicalName',pro:'YRealTimeClock <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the clock.</p>',par:{newval:'a string corresponding to the logical name of the clock.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'YRealTimeClock set_unixTime',pro:'YRealTimeClock <span id=pn>target</span> set_unixTime <span id=pn>newval</span>',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'YRealTimeClock set_utcOffset',pro:'YRealTimeClock <span id=pn>target</span> set_utcOffset <span id=pn>newval</span>',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RealTimeClock']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YRealTimeClock unmuteValueCallbacks',pro:'YRealTimeClock <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: RealTimeClock)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'YRelay delayedPulse',pro:'YRelay <span id=pn>target</span> delayedPulse <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'YRelay get_advertisedValue',pro:'YRelay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:''};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'YRelay get_countdown',pro:'YRelay <span id=pn>target</span> get_countdown',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:''};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'YRelay get_logicalName',pro:'YRelay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:''};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YRelay get_maxTimeOnStateA',pro:'YRelay <span id=pn>target</span> get_maxTimeOnStateA',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YRelay get_maxTimeOnStateB',pro:'YRelay <span id=pn>target</span> get_maxTimeOnStateB',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'YRelay get_output',pro:'YRelay <span id=pn>target</span> get_output',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:''};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'YRelay get_pulseTimer',pro:'YRelay <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:''};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'YRelay get_state',pro:'YRelay <span id=pn>target</span> get_state',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>A</tt> or <tt>B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:''};
doc['Relay']['get_stateAtPowerOn']={syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'YRelay get_stateAtPowerOn',pro:'YRelay <span id=pn>target</span> get_stateAtPowerOn',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:''};
doc['Relay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YRelay muteValueCallbacks',pro:'YRelay <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'YRelay pulse',pro:'YRelay <span id=pn>target</span> pulse <span id=pn>ms_duration</span>',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'YRelay set_logicalName',pro:'YRelay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the relay.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YRelay set_maxTimeOnStateA',pro:'YRelay <span id=pn>target</span> set_maxTimeOnStateA <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YRelay set_maxTimeOnStateB',pro:'YRelay <span id=pn>target</span> set_maxTimeOnStateB <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'YRelay set_output',pro:'YRelay <span id=pn>target</span> set_output <span id=pn>newval</span>',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'YRelay set_state',pro:'YRelay <span id=pn>target</span> set_state <span id=pn>newval</span>',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>A</tt> or <tt>B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_stateAtPowerOn']={syn:'Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'YRelay set_stateAtPowerOn',pro:'YRelay <span id=pn>target</span> set_stateAtPowerOn <span id=pn>newval</span>',cmt:'<p>Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).</p>',par:{newval:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YRelay unmuteValueCallbacks',pro:'YRelay <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Relay)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'SegmentedDisplay function interface',inc:'',cmt:'<p>The SegmentedDisplay class allows you to drive segmented displays.</p>'}};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Returns the current value of the segmented displays (no more than 6 characters).',lib:'YSegmentedDisplay get_advertisedValue',pro:'YSegmentedDisplay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the segmented displays (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented displays (no more than 6 characters).',ext:''};
doc['SegmentedDisplay']['get_displayedText']={syn:'Returns the text currently displayed on the screen.',lib:'YSegmentedDisplay get_displayedText',pro:'YSegmentedDisplay <span id=pn>target</span> get_displayedText',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:''};
doc['SegmentedDisplay']['get_logicalName']={syn:'Returns the logical name of the segmented displays.',lib:'YSegmentedDisplay get_logicalName',pro:'YSegmentedDisplay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the segmented displays.</p>',ret:'a string corresponding to the logical name of the segmented displays.',ext:''};
doc['SegmentedDisplay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YSegmentedDisplay muteValueCallbacks',pro:'YSegmentedDisplay <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['SegmentedDisplay']['set_displayedText']={syn:'Changes the text currently displayed on the screen.',lib:'YSegmentedDisplay set_displayedText',pro:'YSegmentedDisplay <span id=pn>target</span> set_displayedText <span id=pn>newval</span>',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SegmentedDisplay']['set_logicalName']={syn:'Changes the logical name of the segmented displays.',lib:'YSegmentedDisplay set_logicalName',pro:'YSegmentedDisplay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the segmented displays.</p>',par:{newval:'a string corresponding to the logical name of the segmented displays.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SegmentedDisplay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YSegmentedDisplay unmuteValueCallbacks',pro:'YSegmentedDisplay <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'SerialPort function interface',inc:'',cmt:'<p>The SerialPort function interface allows you to fully drive a Yoctopuce serial port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SerialPort']['get_CTS']={syn:'Reads the level of the CTS line.',lib:'YSerialPort get_CTS',pro:'YSerialPort <span id=pn>target</span> get_CTS',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:''};
doc['SerialPort']['get_advertisedValue']={syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'YSerialPort get_advertisedValue',pro:'YSerialPort <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:''};
doc['SerialPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'YSerialPort get_currentJob',pro:'YSerialPort <span id=pn>target</span> get_currentJob',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:''};
doc['SerialPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'YSerialPort get_errCount',pro:'YSerialPort <span id=pn>target</span> get_errCount',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:''};
doc['SerialPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'YSerialPort get_lastMsg',pro:'YSerialPort <span id=pn>target</span> get_lastMsg',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:''};
doc['SerialPort']['get_logicalName']={syn:'Returns the logical name of the serial port.',lib:'YSerialPort get_logicalName',pro:'YSerialPort <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:''};
doc['SerialPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'YSerialPort get_protocol',pro:'YSerialPort <span id=pn>target</span> get_protocol',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:''};
doc['SerialPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'YSerialPort get_rxCount',pro:'YSerialPort <span id=pn>target</span> get_rxCount',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:''};
doc['SerialPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'YSerialPort get_rxMsgCount',pro:'YSerialPort <span id=pn>target</span> get_rxMsgCount',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:''};
doc['SerialPort']['get_serialMode']={syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'YSerialPort get_serialMode',pro:'YSerialPort <span id=pn>target</span> get_serialMode',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:''};
doc['SerialPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'YSerialPort get_startupJob',pro:'YSerialPort <span id=pn>target</span> get_startupJob',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:''};
doc['SerialPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'YSerialPort get_txCount',pro:'YSerialPort <span id=pn>target</span> get_txCount',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:''};
doc['SerialPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'YSerialPort get_txMsgCount',pro:'YSerialPort <span id=pn>target</span> get_txMsgCount',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:''};
doc['SerialPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'YSerialPort get_voltageLevel',pro:'YSerialPort <span id=pn>target</span> get_voltageLevel',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage level used on the serial line',ext:''};
doc['SerialPort']['modbusReadBits']={syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'YSerialPort modbusReadBits',pro:'YSerialPort <span id=pn>target</span> modbusReadBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nBits</span>',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:''};
doc['SerialPort']['modbusReadInputBits']={syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'YSerialPort modbusReadInputBits',pro:'YSerialPort <span id=pn>target</span> modbusReadInputBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nBits</span>',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:''};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'YSerialPort modbusReadInputRegisters',pro:'YSerialPort <span id=pn>target</span> modbusReadInputRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nWords</span>',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:''};
doc['SerialPort']['modbusReadRegisters']={syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'YSerialPort modbusReadRegisters',pro:'YSerialPort <span id=pn>target</span> modbusReadRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nWords</span>',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:''};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'YSerialPort modbusWriteAndReadRegisters',pro:'YSerialPort <span id=pn>target</span> modbusWriteAndReadRegisters <span id=pn>slaveNo</span> <span id=pn>pduWriteAddr</span> <span id=pn>values</span> <span id=pn>pduReadAddr</span> <span id=pn>nReadWords</span>',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:''};
doc['SerialPort']['modbusWriteBit']={syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'YSerialPort modbusWriteBit',pro:'YSerialPort <span id=pn>target</span> modbusWriteBit <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>value</span>',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:''};
doc['SerialPort']['modbusWriteBits']={syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'YSerialPort modbusWriteBits',pro:'YSerialPort <span id=pn>target</span> modbusWriteBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>bits</span>',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:''};
doc['SerialPort']['modbusWriteRegister']={syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'YSerialPort modbusWriteRegister',pro:'YSerialPort <span id=pn>target</span> modbusWriteRegister <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>value</span>',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:''};
doc['SerialPort']['modbusWriteRegisters']={syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'YSerialPort modbusWriteRegisters',pro:'YSerialPort <span id=pn>target</span> modbusWriteRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>values</span>',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:''};
doc['SerialPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YSerialPort muteValueCallbacks',pro:'YSerialPort <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['SerialPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'YSerialPort queryLine',pro:'YSerialPort <span id=pn>target</span> queryLine <span id=pn>query</span> <span id=pn>maxWait</span>',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:''};
doc['SerialPort']['queryMODBUS']={syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'YSerialPort queryMODBUS',pro:'YSerialPort <span id=pn>target</span> queryMODBUS <span id=pn>slaveNo</span> <span id=pn>pduBytes</span>',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:''};
doc['SerialPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'YSerialPort readArray',pro:'YSerialPort <span id=pn>target</span> readArray <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:''};
doc['SerialPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'YSerialPort readBin',pro:'YSerialPort <span id=pn>target</span> readBin <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:''};
doc['SerialPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'YSerialPort readByte',pro:'YSerialPort <span id=pn>target</span> readByte',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:''};
doc['SerialPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'YSerialPort readHex',pro:'YSerialPort <span id=pn>target</span> readHex <span id=pn>nBytes</span>',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:''};
doc['SerialPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'YSerialPort readLine',pro:'YSerialPort <span id=pn>target</span> readLine',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:''};
doc['SerialPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'YSerialPort readMessages',pro:'YSerialPort <span id=pn>target</span> readMessages <span id=pn>pattern</span> <span id=pn>maxWait</span>',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:''};
doc['SerialPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'YSerialPort readStr',pro:'YSerialPort <span id=pn>target</span> readStr <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:''};
doc['SerialPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'YSerialPort read_avail',pro:'YSerialPort <span id=pn>target</span> read_avail',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SerialPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'YSerialPort read_seek',pro:'YSerialPort <span id=pn>target</span> read_seek <span id=pn>absPos</span>',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SerialPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'YSerialPort read_tell',pro:'YSerialPort <span id=pn>target</span> read_tell',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SerialPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'YSerialPort reset',pro:'YSerialPort <span id=pn>target</span> reset',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'YSerialPort selectJob',pro:'YSerialPort <span id=pn>target</span> selectJob <span id=pn>jobfile</span>',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_RTS']={syn:'Manually sets the state of the RTS line.',lib:'YSerialPort set_RTS',pro:'YSerialPort <span id=pn>target</span> set_RTS <span id=pn>val</span>',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSerialPort set_currentJob',pro:'YSerialPort <span id=pn>target</span> set_currentJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_logicalName']={syn:'Changes the logical name of the serial port.',lib:'YSerialPort set_logicalName',pro:'YSerialPort <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the serial port.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'YSerialPort set_protocol',pro:'YSerialPort <span id=pn>target</span> set_protocol <span id=pn>newval</span>',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_serialMode']={syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'YSerialPort set_serialMode',pro:'YSerialPort <span id=pn>target</span> set_serialMode <span id=pn>newval</span>',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSerialPort set_startupJob',pro:'YSerialPort <span id=pn>target</span> set_startupJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'YSerialPort set_voltageLevel',pro:'YSerialPort <span id=pn>target</span> set_voltageLevel <span id=pn>newval</span>',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['snoopMessages']={syn:'Retrieves messages (both direction) in the serial port buffer, starting at current position.',lib:'YSerialPort snoopMessages',pro:'YSerialPort <span id=pn>target</span> snoopMessages <span id=pn>maxWait</span>',cmt:'<p>Retrieves messages (both direction) in the serial port buffer, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of YSnoopingRecord objects containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:''};
doc['SerialPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YSerialPort unmuteValueCallbacks',pro:'YSerialPort <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['SerialPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'YSerialPort uploadJob',pro:'YSerialPort <span id=pn>target</span> uploadJob <span id=pn>jobfile</span> <span id=pn>jsonDef</span>',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'YSerialPort writeArray',pro:'YSerialPort <span id=pn>target</span> writeArray <span id=pn>byteList</span>',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'YSerialPort writeBin',pro:'YSerialPort <span id=pn>target</span> writeBin <span id=pn>buff</span>',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'YSerialPort writeByte',pro:'YSerialPort <span id=pn>target</span> writeByte <span id=pn>code</span>',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'YSerialPort writeHex',pro:'YSerialPort <span id=pn>target</span> writeHex <span id=pn>hexString</span>',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'YSerialPort writeLine',pro:'YSerialPort <span id=pn>target</span> writeLine <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeMODBUS']={syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'YSerialPort writeMODBUS',pro:'YSerialPort <span id=pn>target</span> writeMODBUS <span id=pn>hexString</span>',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'YSerialPort writeStr',pro:'YSerialPort <span id=pn>target</span> writeStr <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: SerialPort)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'YServo get_advertisedValue',pro:'YServo <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters).',ext:''};
doc['Servo']['get_enabled']={syn:'Returns the state of the servos.',lib:'YServo get_enabled',pro:'YServo <span id=pn>target</span> get_enabled',cmt:'<p>Returns the state of the servos.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the servos',ext:''};
doc['Servo']['get_enabledAtPowerOn']={syn:'Returns the servo signal generator state at power up.',lib:'YServo get_enabledAtPowerOn',pro:'YServo <span id=pn>target</span> get_enabledAtPowerOn',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the servo signal generator state at power up',ext:''};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'YServo get_logicalName',pro:'YServo <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo.',ext:''};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'YServo get_neutral',pro:'YServo <span id=pn>target</span> get_neutral',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:''};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'YServo get_position',pro:'YServo <span id=pn>target</span> get_position',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:''};
doc['Servo']['get_positionAtPowerOn']={syn:'Returns the servo position at device power up.',lib:'YServo get_positionAtPowerOn',pro:'YServo <span id=pn>target</span> get_positionAtPowerOn',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:''};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'YServo get_range',pro:'YServo <span id=pn>target</span> get_range',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:''};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'YServo move',pro:'YServo <span id=pn>target</span> move <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YServo muteValueCallbacks',pro:'YServo <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Servo']['set_enabled']={syn:'Stops or starts the servo.',lib:'YServo set_enabled',pro:'YServo <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Stops or starts the servo.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure the servo signal generator state at power up.',lib:'YServo set_enabledAtPowerOn',pro:'YServo <span id=pn>target</span> set_enabledAtPowerOn <span id=pn>newval</span>',cmt:'<p>Configure the servo signal generator state at power up.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'YServo set_logicalName',pro:'YServo <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the servo.</p>',par:{newval:'a string corresponding to the logical name of the servo.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'YServo set_neutral',pro:'YServo <span id=pn>target</span> set_neutral <span id=pn>newval</span>',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'YServo set_position',pro:'YServo <span id=pn>target</span> set_position <span id=pn>newval</span>',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure the servo position at device power up.',lib:'YServo set_positionAtPowerOn',pro:'YServo <span id=pn>target</span> set_positionAtPowerOn <span id=pn>newval</span>',cmt:'<p>Configure the servo position at device power up.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'YServo set_range',pro:'YServo <span id=pn>target</span> set_range <span id=pn>newval</span>',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YServo unmuteValueCallbacks',pro:'YServo <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Servo)
//--- (generated code: SpiPort)
doc['SpiPort']={'':{syn:'SPI Port function interface',inc:'',cmt:'<p>The SpiPort function interface allows you to fully drive a Yoctopuce SPI port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce SPI ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SpiPort']['get_advertisedValue']={syn:'Returns the current value of the SPI port (no more than 6 characters).',lib:'YSpiPort get_advertisedValue',pro:'YSpiPort <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the SPI port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SPI port (no more than 6 characters).',ext:''};
doc['SpiPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'YSpiPort get_currentJob',pro:'YSpiPort <span id=pn>target</span> get_currentJob',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:''};
doc['SpiPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'YSpiPort get_errCount',pro:'YSpiPort <span id=pn>target</span> get_errCount',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:''};
doc['SpiPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line and Frame protocols).',lib:'YSpiPort get_lastMsg',pro:'YSpiPort <span id=pn>target</span> get_lastMsg',cmt:'<p>Returns the latest message fully received (for Line and Frame protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line and Frame protocols)',ext:''};
doc['SpiPort']['get_logicalName']={syn:'Returns the logical name of the SPI port.',lib:'YSpiPort get_logicalName',pro:'YSpiPort <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the SPI port.</p>',ret:'a string corresponding to the logical name of the SPI port.',ext:''};
doc['SpiPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'YSpiPort get_protocol',pro:'YSpiPort <span id=pn>target</span> get_protocol',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:''};
doc['SpiPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'YSpiPort get_rxCount',pro:'YSpiPort <span id=pn>target</span> get_rxCount',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:''};
doc['SpiPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'YSpiPort get_rxMsgCount',pro:'YSpiPort <span id=pn>target</span> get_rxMsgCount',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:''};
doc['SpiPort']['get_shiftSampling']={syn:'Returns true when the SDI line phase is shifted with regards to the SDO line.',lib:'YSpiPort get_shiftSampling',pro:'YSpiPort <span id=pn>target</span> get_shiftSampling',cmt:'<p>Returns true when the SDI line phase is shifted with regards to the SDO line.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to true when the SDI line phase is shifted with regards to the SDO line',ext:''};
doc['SpiPort']['get_spiMode']={syn:'Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22.',lib:'YSpiPort get_spiMode',pro:'YSpiPort <span id=pn>target</span> get_spiMode',cmt:'<p>Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',ret:'a string corresponding to the SPI port communication parameters, as a string such as \x22125000,0,msb\x22',ext:''};
doc['SpiPort']['get_ssPolarity']={syn:'Returns the SS line polarity.',lib:'YSpiPort get_ssPolarity',pro:'YSpiPort <span id=pn>target</span> get_ssPolarity',cmt:'<p>Returns the SS line polarity.</p>',ret:'either <tt>ACTIVE_LOW</tt> or <tt>ACTIVE_HIGH</tt>, according to the SS line polarity',ext:''};
doc['SpiPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'YSpiPort get_startupJob',pro:'YSpiPort <span id=pn>target</span> get_startupJob',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:''};
doc['SpiPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'YSpiPort get_txCount',pro:'YSpiPort <span id=pn>target</span> get_txCount',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:''};
doc['SpiPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'YSpiPort get_txMsgCount',pro:'YSpiPort <span id=pn>target</span> get_txMsgCount',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:''};
doc['SpiPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'YSpiPort get_voltageLevel',pro:'YSpiPort <span id=pn>target</span> get_voltageLevel',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage level used on the serial line',ext:''};
doc['SpiPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YSpiPort muteValueCallbacks',pro:'YSpiPort <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['SpiPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'YSpiPort queryLine',pro:'YSpiPort <span id=pn>target</span> queryLine <span id=pn>query</span> <span id=pn>maxWait</span>',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:''};
doc['SpiPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'YSpiPort readArray',pro:'YSpiPort <span id=pn>target</span> readArray <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:''};
doc['SpiPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'YSpiPort readBin',pro:'YSpiPort <span id=pn>target</span> readBin <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:''};
doc['SpiPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'YSpiPort readByte',pro:'YSpiPort <span id=pn>target</span> readByte',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:''};
doc['SpiPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'YSpiPort readHex',pro:'YSpiPort <span id=pn>target</span> readHex <span id=pn>nBytes</span>',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:''};
doc['SpiPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'YSpiPort readLine',pro:'YSpiPort <span id=pn>target</span> readLine',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:''};
doc['SpiPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'YSpiPort readMessages',pro:'YSpiPort <span id=pn>target</span> readMessages <span id=pn>pattern</span> <span id=pn>maxWait</span>',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:''};
doc['SpiPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'YSpiPort readStr',pro:'YSpiPort <span id=pn>target</span> readStr <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:''};
doc['SpiPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'YSpiPort read_avail',pro:'YSpiPort <span id=pn>target</span> read_avail',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SpiPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'YSpiPort read_seek',pro:'YSpiPort <span id=pn>target</span> read_seek <span id=pn>absPos</span>',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SpiPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'YSpiPort read_tell',pro:'YSpiPort <span id=pn>target</span> read_tell',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SpiPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'YSpiPort reset',pro:'YSpiPort <span id=pn>target</span> reset',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'YSpiPort selectJob',pro:'YSpiPort <span id=pn>target</span> selectJob <span id=pn>jobfile</span>',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_SS']={syn:'Manually sets the state of the SS line.',lib:'YSpiPort set_SS',pro:'YSpiPort <span id=pn>target</span> set_SS <span id=pn>val</span>',cmt:'<p>Manually sets the state of the SS line. This function has no effect when the SS line is handled automatically.</p>',par:{val:'1 to turn SS active, 0 to release SS.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSpiPort set_currentJob',pro:'YSpiPort <span id=pn>target</span> set_currentJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_logicalName']={syn:'Changes the logical name of the SPI port.',lib:'YSpiPort set_logicalName',pro:'YSpiPort <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the SPI port.</p>',par:{newval:'a string corresponding to the logical name of the SPI port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'YSpiPort set_protocol',pro:'YSpiPort <span id=pn>target</span> set_protocol <span id=pn>newval</span>',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_shiftSampling']={syn:'Changes the SDI line sampling shift.',lib:'YSpiPort set_shiftSampling',pro:'YSpiPort <span id=pn>target</span> set_shiftSampling <span id=pn>newval</span>',cmt:'<p>Changes the SDI line sampling shift. When disabled, SDI line is sampled in the middle of data output time. When enabled, SDI line is samples at the end of data output time.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the SDI line sampling shift'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_spiMode']={syn:'Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22.',lib:'YSpiPort set_spiMode',pro:'YSpiPort <span id=pn>target</span> set_spiMode <span id=pn>newval</span>',cmt:'<p>Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',par:{newval:'a string corresponding to the SPI port communication parameters, with a string such as \x22125000,0,msb\x22'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_ssPolarity']={syn:'Changes the SS line polarity.',lib:'YSpiPort set_ssPolarity',pro:'YSpiPort <span id=pn>target</span> set_ssPolarity <span id=pn>newval</span>',cmt:'<p>Changes the SS line polarity.</p>',par:{newval:'either <tt>ACTIVE_LOW</tt> or <tt>ACTIVE_HIGH</tt>, according to the SS line polarity'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSpiPort set_startupJob',pro:'YSpiPort <span id=pn>target</span> set_startupJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'YSpiPort set_voltageLevel',pro:'YSpiPort <span id=pn>target</span> set_voltageLevel <span id=pn>newval</span>',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YSpiPort unmuteValueCallbacks',pro:'YSpiPort <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['SpiPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'YSpiPort uploadJob',pro:'YSpiPort <span id=pn>target</span> uploadJob <span id=pn>jobfile</span> <span id=pn>jsonDef</span>',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'YSpiPort writeArray',pro:'YSpiPort <span id=pn>target</span> writeArray <span id=pn>byteList</span>',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'YSpiPort writeBin',pro:'YSpiPort <span id=pn>target</span> writeBin <span id=pn>buff</span>',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'YSpiPort writeByte',pro:'YSpiPort <span id=pn>target</span> writeByte <span id=pn>code</span>',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'YSpiPort writeHex',pro:'YSpiPort <span id=pn>target</span> writeHex <span id=pn>hexString</span>',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'YSpiPort writeLine',pro:'YSpiPort <span id=pn>target</span> writeLine <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SpiPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'YSpiPort writeStr',pro:'YSpiPort <span id=pn>target</span> writeStr <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: SpiPort)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'',cmt:'<p>The WakeUpMonitor function handles globally all wake-up sources, as well as automated sleep mode.</p>'}};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'YWakeUpMonitor get_advertisedValue',pro:'YWakeUpMonitor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters).',ext:''};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'YWakeUpMonitor get_logicalName',pro:'YWakeUpMonitor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor.',ext:''};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Returns the next scheduled wake up date/time (UNIX format).',lib:'YWakeUpMonitor get_nextWakeUp',pro:'YWakeUpMonitor <span id=pn>target</span> get_nextWakeUp',cmt:'<p>Returns the next scheduled wake up date/time (UNIX format).</p>',ret:'an integer corresponding to the next scheduled wake up date/time (UNIX format)',ext:''};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'YWakeUpMonitor get_powerDuration',pro:'YWakeUpMonitor <span id=pn>target</span> get_powerDuration',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:''};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before the next sleep period.',lib:'YWakeUpMonitor get_sleepCountdown',pro:'YWakeUpMonitor <span id=pn>target</span> get_sleepCountdown',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:''};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Returns the latest wake up reason.',lib:'YWakeUpMonitor get_wakeUpReason',pro:'YWakeUpMonitor <span id=pn>target</span> get_wakeUpReason',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>USBPOWER</tt>, <tt>EXTPOWER</tt>, <tt>ENDOFSLEEP</tt>, <tt>EXTSIG1</tt>, <tt>SCHEDULE1</tt> and <tt>SCHEDULE2</tt> corresponding to the latest wake up reason',ext:''};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Returns the current state of the monitor.',lib:'YWakeUpMonitor get_wakeUpState',pro:'YWakeUpMonitor <span id=pn>target</span> get_wakeUpState',cmt:'<p>Returns the current state of the monitor.</p>',ret:'either <tt>SLEEPING</tt> or <tt>AWAKE</tt>, according to the current state of the monitor',ext:''};
doc['WakeUpMonitor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YWakeUpMonitor muteValueCallbacks',pro:'YWakeUpMonitor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Resets the sleep countdown.',lib:'YWakeUpMonitor resetSleepCountDown',pro:'YWakeUpMonitor <span id=pn>target</span> resetSleepCountDown',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'YWakeUpMonitor set_logicalName',pro:'YWakeUpMonitor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the monitor.</p>',par:{newval:'a string corresponding to the logical name of the monitor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week when a wake up must take place.',lib:'YWakeUpMonitor set_nextWakeUp',pro:'YWakeUpMonitor <span id=pn>target</span> set_nextWakeUp <span id=pn>newval</span>',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'YWakeUpMonitor set_powerDuration',pro:'YWakeUpMonitor <span id=pn>target</span> set_powerDuration <span id=pn>newval</span>',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before the next sleep period.',lib:'YWakeUpMonitor set_sleepCountdown',pro:'YWakeUpMonitor <span id=pn>target</span> set_sleepCountdown <span id=pn>newval</span>',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleep']={syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleep',pro:'YWakeUpMonitor <span id=pn>target</span> sleep <span id=pn>secBeforeSleep</span>',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleepFor']={syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleepFor',pro:'YWakeUpMonitor <span id=pn>target</span> sleepFor <span id=pn>secUntilWakeUp</span> <span id=pn>secBeforeSleep</span>',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleepUntil',pro:'YWakeUpMonitor <span id=pn>target</span> sleepUntil <span id=pn>wakeUpTime</span> <span id=pn>secBeforeSleep</span>',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YWakeUpMonitor unmuteValueCallbacks',pro:'YWakeUpMonitor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wake up.',lib:'YWakeUpMonitor wakeUp',pro:'YWakeUpMonitor <span id=pn>target</span> wakeUp',cmt:'<p>Forces a wake up.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'',cmt:'<p>The WakeUpSchedule function implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'YWakeUpSchedule get_advertisedValue',pro:'YWakeUpSchedule <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:''};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake up.',lib:'YWakeUpSchedule get_hours',pro:'YWakeUpSchedule <span id=pn>target</span> get_hours',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake up schedule.',lib:'YWakeUpSchedule get_logicalName',pro:'YWakeUpSchedule <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:''};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'YWakeUpSchedule get_minutes',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutes',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'YWakeUpSchedule get_minutesA',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutesA',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes in the 30-59 interval of each hour scheduled for wake up.',lib:'YWakeUpSchedule get_minutesB',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutesB',cmt:'<p>Returns the minutes in the 30-59 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 interval of each hour scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of the month scheduled for wake up.',lib:'YWakeUpSchedule get_monthDays',pro:'YWakeUpSchedule <span id=pn>target</span> get_monthDays',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_months']={syn:'Returns the months scheduled for wake up.',lib:'YWakeUpSchedule get_months',pro:'YWakeUpSchedule <span id=pn>target</span> get_months',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Returns the date/time (seconds) of the next wake up occurrence.',lib:'YWakeUpSchedule get_nextOccurence',pro:'YWakeUpSchedule <span id=pn>target</span> get_nextOccurence',cmt:'<p>Returns the date/time (seconds) of the next wake up occurrence.</p>',ret:'an integer corresponding to the date/time (seconds) of the next wake up occurrence',ext:''};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of the week scheduled for wake up.',lib:'YWakeUpSchedule get_weekDays',pro:'YWakeUpSchedule <span id=pn>target</span> get_weekDays',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:''};
doc['WakeUpSchedule']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YWakeUpSchedule muteValueCallbacks',pro:'YWakeUpSchedule <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours when a wake up must take place.',lib:'YWakeUpSchedule set_hours',pro:'YWakeUpSchedule <span id=pn>target</span> set_hours <span id=pn>newval</span>',cmt:'<p>Changes the hours when a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake up schedule.',lib:'YWakeUpSchedule set_logicalName',pro:'YWakeUpSchedule <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the wake up schedule.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'YWakeUpSchedule set_minutes',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutes <span id=pn>bitmap</span>',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'YWakeUpSchedule set_minutesA',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutesA <span id=pn>newval</span>',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'YWakeUpSchedule set_minutesB',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutesB <span id=pn>newval</span>',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the month when a wake up must take place.',lib:'YWakeUpSchedule set_monthDays',pro:'YWakeUpSchedule <span id=pn>target</span> set_monthDays <span id=pn>newval</span>',cmt:'<p>Changes the days of the month when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_months']={syn:'Changes the months when a wake up must take place.',lib:'YWakeUpSchedule set_months',pro:'YWakeUpSchedule <span id=pn>target</span> set_months <span id=pn>newval</span>',cmt:'<p>Changes the months when a wake up must take place.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week when a wake up must take place.',lib:'YWakeUpSchedule set_weekDays',pro:'YWakeUpSchedule <span id=pn>target</span> set_weekDays <span id=pn>newval</span>',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YWakeUpSchedule unmuteValueCallbacks',pro:'YWakeUpSchedule <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'',cmt:'<p>The watchdog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven directly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'YWatchdog delayedPulse',pro:'YWatchdog <span id=pn>target</span> delayedPulse <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'YWatchdog get_advertisedValue',pro:'YWatchdog <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:''};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog running state at module power on.',lib:'YWatchdog get_autoStart',pro:'YWatchdog <span id=pn>target</span> get_autoStart',cmt:'<p>Returns the watchdog running state at module power on.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog running state at module power on',ext:''};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'YWatchdog get_countdown',pro:'YWatchdog <span id=pn>target</span> get_countdown',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:''};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'YWatchdog get_logicalName',pro:'YWatchdog <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:''};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YWatchdog get_maxTimeOnStateA',pro:'YWatchdog <span id=pn>target</span> get_maxTimeOnStateA',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YWatchdog get_maxTimeOnStateB',pro:'YWatchdog <span id=pn>target</span> get_maxTimeOnStateB',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'YWatchdog get_output',pro:'YWatchdog <span id=pn>target</span> get_output',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:''};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'YWatchdog get_pulseTimer',pro:'YWatchdog <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:''};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'YWatchdog get_running',pro:'YWatchdog <span id=pn>target</span> get_running',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog running state',ext:''};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'YWatchdog get_state',pro:'YWatchdog <span id=pn>target</span> get_state',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>A</tt> or <tt>B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:''};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'YWatchdog get_stateAtPowerOn',pro:'YWatchdog <span id=pn>target</span> get_stateAtPowerOn',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:''};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'YWatchdog get_triggerDelay',pro:'YWatchdog <span id=pn>target</span> get_triggerDelay',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:''};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'YWatchdog get_triggerDuration',pro:'YWatchdog <span id=pn>target</span> get_triggerDuration',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:''};
doc['Watchdog']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YWatchdog muteValueCallbacks',pro:'YWatchdog <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'YWatchdog pulse',pro:'YWatchdog <span id=pn>target</span> pulse <span id=pn>ms_duration</span>',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'YWatchdog resetWatchdog',pro:'YWatchdog <span id=pn>target</span> resetWatchdog',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchdog to trigger</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog running state at module power on.',lib:'YWatchdog set_autoStart',pro:'YWatchdog <span id=pn>target</span> set_autoStart <span id=pn>newval</span>',cmt:'<p>Changes the watchdog running state at module power on.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog running state at module power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'YWatchdog set_logicalName',pro:'YWatchdog <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the watchdog.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YWatchdog set_maxTimeOnStateA',pro:'YWatchdog <span id=pn>target</span> set_maxTimeOnStateA <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YWatchdog set_maxTimeOnStateB',pro:'YWatchdog <span id=pn>target</span> set_maxTimeOnStateB <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'YWatchdog set_output',pro:'YWatchdog <span id=pn>target</span> set_output <span id=pn>newval</span>',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'YWatchdog set_running',pro:'YWatchdog <span id=pn>target</span> set_running <span id=pn>newval</span>',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the running state of the watchdog'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'YWatchdog set_state',pro:'YWatchdog <span id=pn>target</span> set_state <span id=pn>newval</span>',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>A</tt> or <tt>B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'YWatchdog set_stateAtPowerOn',pro:'YWatchdog <span id=pn>target</span> set_stateAtPowerOn <span id=pn>newval</span>',cmt:'<p>Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).</p>',par:{newval:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'YWatchdog set_triggerDelay',pro:'YWatchdog <span id=pn>target</span> set_triggerDelay <span id=pn>newval</span>',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'YWatchdog set_triggerDuration',pro:'YWatchdog <span id=pn>target</span> set_triggerDuration <span id=pn>newval</span>',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YWatchdog unmuteValueCallbacks',pro:'YWatchdog <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Watchdog)
//--- (generated code: StepperMotor)
doc['StepperMotor']={'':{syn:'StepperMotor function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['StepperMotor']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'YStepperMotor abortAndBrake',pro:'YStepperMotor <span id=pn>target</span> abortAndBrake',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'YStepperMotor abortAndHiZ',pro:'YStepperMotor <span id=pn>target</span> abortAndHiZ',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepDir']={syn:'Move one single step in the selected direction without regards to end switches.',lib:'YStepperMotor alertStepDir',pro:'YStepperMotor <span id=pn>target</span> alertStepDir <span id=pn>dir</span>',cmt:'<p>Move one single step in the selected direction without regards to end switches. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',par:{dir:'Value +1 or -1, according to the desired direction of the move'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepOut']={syn:'Move one step in the direction opposite the direction set when the most recent alert was raised.',lib:'YStepperMotor alertStepOut',pro:'YStepperMotor <span id=pn>target</span> alertStepOut',cmt:'<p>Move one step in the direction opposite the direction set when the most recent alert was raised. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['changeSpeed']={syn:'Starts the motor at a given speed.',lib:'YStepperMotor changeSpeed',pro:'YStepperMotor <span id=pn>target</span> changeSpeed <span id=pn>speed</span>',cmt:'<p>Starts the motor at a given speed. The time needed to reach the requested speed will depend on the acceleration parameters configured for the motor.</p>',par:{speed:'desired speed, in steps per second. The minimal non-zero speed is 0.001 pulse per second.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'YStepperMotor emergencyStop',pro:'YStepperMotor <span id=pn>target</span> emergencyStop',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['findHomePosition']={syn:'Starts the motor backward at the specified speed, to search for the motor home position.',lib:'YStepperMotor findHomePosition',pro:'YStepperMotor <span id=pn>target</span> findHomePosition <span id=pn>speed</span>',cmt:'<p>Starts the motor backward at the specified speed, to search for the motor home position.</p>',par:{speed:'desired speed, in steps per second.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['get_advertisedValue']={syn:'Returns the current value of the stepper motor (no more than 6 characters).',lib:'YStepperMotor get_advertisedValue',pro:'YStepperMotor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the stepper motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the stepper motor (no more than 6 characters).',ext:''};
doc['StepperMotor']['get_auxSignal']={syn:'Returns the current value of the signal generated on the auxiliary output.',lib:'YStepperMotor get_auxSignal',pro:'YStepperMotor <span id=pn>target</span> get_auxSignal',cmt:'<p>Returns the current value of the signal generated on the auxiliary output.</p>',ret:'an integer corresponding to the current value of the signal generated on the auxiliary output',ext:''};
doc['StepperMotor']['get_diags']={syn:'Returns the stepper motor controller diagnostics, as a bitmap.',lib:'YStepperMotor get_diags',pro:'YStepperMotor <span id=pn>target</span> get_diags',cmt:'<p>Returns the stepper motor controller diagnostics, as a bitmap.</p>',ret:'an integer corresponding to the stepper motor controller diagnostics, as a bitmap',ext:''};
doc['StepperMotor']['get_logicalName']={syn:'Returns the logical name of the stepper motor.',lib:'YStepperMotor get_logicalName',pro:'YStepperMotor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the stepper motor.</p>',ret:'a string corresponding to the logical name of the stepper motor.',ext:''};
doc['StepperMotor']['get_maxAccel']={syn:'Returns the maximal motor acceleration, measured in steps per second^2.',lib:'YStepperMotor get_maxAccel',pro:'YStepperMotor <span id=pn>target</span> get_maxAccel',cmt:'<p>Returns the maximal motor acceleration, measured in steps per second^2.</p>',ret:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2',ext:''};
doc['StepperMotor']['get_maxSpeed']={syn:'Returns the maximal motor speed, measured in steps per second.',lib:'YStepperMotor get_maxSpeed',pro:'YStepperMotor <span id=pn>target</span> get_maxSpeed',cmt:'<p>Returns the maximal motor speed, measured in steps per second.</p>',ret:'a floating point number corresponding to the maximal motor speed, measured in steps per second',ext:''};
doc['StepperMotor']['get_motorState']={syn:'Returns the motor working state.',lib:'YStepperMotor get_motorState',pro:'YStepperMotor <span id=pn>target</span> get_motorState',cmt:'<p>Returns the motor working state.</p>',ret:'a value among <tt>ABSENT</tt>, <tt>ALERT</tt>, <tt>HI_Z</tt>, <tt>STOP</tt>, <tt>RUN</tt> and <tt>BATCH</tt> corresponding to the motor working state',ext:''};
doc['StepperMotor']['get_overcurrent']={syn:'Returns the overcurrent alert and emergency stop threshold, measured in mA.',lib:'YStepperMotor get_overcurrent',pro:'YStepperMotor <span id=pn>target</span> get_overcurrent',cmt:'<p>Returns the overcurrent alert and emergency stop threshold, measured in mA.</p>',ret:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA',ext:''};
doc['StepperMotor']['get_pullinSpeed']={syn:'Returns the motor speed immediately reachable from stop state, measured in steps per second.',lib:'YStepperMotor get_pullinSpeed',pro:'YStepperMotor <span id=pn>target</span> get_pullinSpeed',cmt:'<p>Returns the motor speed immediately reachable from stop state, measured in steps per second.</p>',ret:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second',ext:''};
doc['StepperMotor']['get_speed']={syn:'Returns current motor speed, measured in steps per second.',lib:'YStepperMotor get_speed',pro:'YStepperMotor <span id=pn>target</span> get_speed',cmt:'<p>Returns current motor speed, measured in steps per second. To change speed, use method <tt>changeSpeed()</tt>.</p>',ret:'a floating point number corresponding to current motor speed, measured in steps per second',ext:''};
doc['StepperMotor']['get_stepPos']={syn:'Returns the current logical motor position, measured in steps.',lib:'YStepperMotor get_stepPos',pro:'YStepperMotor <span id=pn>target</span> get_stepPos',cmt:'<p>Returns the current logical motor position, measured in steps. The value may include a fractional part when micro-stepping is in use.</p>',ret:'a floating point number corresponding to the current logical motor position, measured in steps',ext:''};
doc['StepperMotor']['get_stepping']={syn:'Returns the stepping mode used to drive the motor.',lib:'YStepperMotor get_stepping',pro:'YStepperMotor <span id=pn>target</span> get_stepping',cmt:'<p>Returns the stepping mode used to drive the motor.</p>',ret:'a value among <tt>MICROSTEP16</tt>, <tt>MICROSTEP8</tt>, <tt>MICROSTEP4</tt>, <tt>HALFSTEP</tt> and <tt>FULLSTEP</tt> corresponding to the stepping mode used to drive the motor',ext:''};
doc['StepperMotor']['get_tCurrRun']={syn:'Returns the torque regulation current when the motor is running, measured in mA.',lib:'YStepperMotor get_tCurrRun',pro:'YStepperMotor <span id=pn>target</span> get_tCurrRun',cmt:'<p>Returns the torque regulation current when the motor is running, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is running, measured in mA',ext:''};
doc['StepperMotor']['get_tCurrStop']={syn:'Returns the torque regulation current when the motor is stopped, measured in mA.',lib:'YStepperMotor get_tCurrStop',pro:'YStepperMotor <span id=pn>target</span> get_tCurrStop',cmt:'<p>Returns the torque regulation current when the motor is stopped, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA',ext:''};
doc['StepperMotor']['moveRel']={syn:'Starts the motor to reach a given relative position.',lib:'YStepperMotor moveRel',pro:'YStepperMotor <span id=pn>target</span> moveRel <span id=pn>relPos</span>',cmt:'<p>Starts the motor to reach a given relative position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveRelSlow']={syn:'Starts the motor to reach a given relative position, keeping the speed under the specified limit.',lib:'YStepperMotor moveRelSlow',pro:'YStepperMotor <span id=pn>target</span> moveRelSlow <span id=pn>relPos</span> <span id=pn>maxSpeed</span>',cmt:'<p>Starts the motor to reach a given relative position, keeping the speed under the specified limit. The time needed to reach the requested position will depend on the acceleration parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.',maxSpeed:'limit speed, in steps per second.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveTo']={syn:'Starts the motor to reach a given absolute position.',lib:'YStepperMotor moveTo',pro:'YStepperMotor <span id=pn>target</span> moveTo <span id=pn>absPos</span>',cmt:'<p>Starts the motor to reach a given absolute position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{absPos:'absolute position, measured in steps from the origin.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YStepperMotor muteValueCallbacks',pro:'YStepperMotor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['StepperMotor']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'YStepperMotor pause',pro:'YStepperMotor <span id=pn>target</span> pause <span id=pn>waitMs</span>',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['reset']={syn:'Reinitialize the controller and clear all alert flags.',lib:'YStepperMotor reset',pro:'YStepperMotor <span id=pn>target</span> reset',cmt:'<p>Reinitialize the controller and clear all alert flags.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_auxSignal']={syn:'Changes the value of the signal generated on the auxiliary output.',lib:'YStepperMotor set_auxSignal',pro:'YStepperMotor <span id=pn>target</span> set_auxSignal <span id=pn>newval</span>',cmt:'<p>Changes the value of the signal generated on the auxiliary output. Acceptable values depend on the auxiliary output signal type configured.</p>',par:{newval:'an integer corresponding to the value of the signal generated on the auxiliary output'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_logicalName']={syn:'Changes the logical name of the stepper motor.',lib:'YStepperMotor set_logicalName',pro:'YStepperMotor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the stepper motor.</p>',par:{newval:'a string corresponding to the logical name of the stepper motor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_maxAccel']={syn:'Changes the maximal motor acceleration, measured in steps per second^2.',lib:'YStepperMotor set_maxAccel',pro:'YStepperMotor <span id=pn>target</span> set_maxAccel <span id=pn>newval</span>',cmt:'<p>Changes the maximal motor acceleration, measured in steps per second^2.</p>',par:{newval:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_maxSpeed']={syn:'Changes the maximal motor speed, measured in steps per second.',lib:'YStepperMotor set_maxSpeed',pro:'YStepperMotor <span id=pn>target</span> set_maxSpeed <span id=pn>newval</span>',cmt:'<p>Changes the maximal motor speed, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the maximal motor speed, measured in steps per second'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_overcurrent']={syn:'Changes the overcurrent alert and emergency stop threshold, measured in mA.',lib:'YStepperMotor set_overcurrent',pro:'YStepperMotor <span id=pn>target</span> set_overcurrent <span id=pn>newval</span>',cmt:'<p>Changes the overcurrent alert and emergency stop threshold, measured in mA.</p>',par:{newval:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_pullinSpeed']={syn:'Changes the motor speed immediately reachable from stop state, measured in steps per second.',lib:'YStepperMotor set_pullinSpeed',pro:'YStepperMotor <span id=pn>target</span> set_pullinSpeed <span id=pn>newval</span>',cmt:'<p>Changes the motor speed immediately reachable from stop state, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_stepPos']={syn:'Changes the current logical motor position, measured in steps.',lib:'YStepperMotor set_stepPos',pro:'YStepperMotor <span id=pn>target</span> set_stepPos <span id=pn>newval</span>',cmt:'<p>Changes the current logical motor position, measured in steps. This command does not cause any motor move, as its purpose is only to setup the origin of the position counter. The fractional part of the position, that corresponds to the physical position of the rotor, is not changed. To trigger a motor move, use methods <tt>moveTo()</tt> or <tt>moveRel()</tt> instead.</p>',par:{newval:'a floating point number corresponding to the current logical motor position, measured in steps'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_stepping']={syn:'Changes the stepping mode used to drive the motor.',lib:'YStepperMotor set_stepping',pro:'YStepperMotor <span id=pn>target</span> set_stepping <span id=pn>newval</span>',cmt:'<p>Changes the stepping mode used to drive the motor.</p>',par:{newval:'a value among <tt>MICROSTEP16</tt>, <tt>MICROSTEP8</tt>, <tt>MICROSTEP4</tt>, <tt>HALFSTEP</tt> and <tt>FULLSTEP</tt> corresponding to the stepping mode used to drive the motor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_tCurrRun']={syn:'Changes the torque regulation current when the motor is running, measured in mA.',lib:'YStepperMotor set_tCurrRun',pro:'YStepperMotor <span id=pn>target</span> set_tCurrRun <span id=pn>newval</span>',cmt:'<p>Changes the torque regulation current when the motor is running, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is running, measured in mA'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['set_tCurrStop']={syn:'Changes the torque regulation current when the motor is stopped, measured in mA.',lib:'YStepperMotor set_tCurrStop',pro:'YStepperMotor <span id=pn>target</span> set_tCurrStop <span id=pn>newval</span>',cmt:'<p>Changes the torque regulation current when the motor is stopped, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['StepperMotor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YStepperMotor unmuteValueCallbacks',pro:'YStepperMotor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: StepperMotor)
//--- (generated code: Proximity)
doc['Proximity']={'':{syn:'Proximity function interface',inc:'',cmt:'<p>The Yoctopuce class YProximity allows you to use and configure Yoctopuce proximity sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['Proximity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YProximity calibrateFromPoints',pro:'YProximity <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YProximity get_advMode',pro:'YProximity <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Proximity']['get_advertisedValue']={syn:'Returns the current value of the proximity sensor (no more than 6 characters).',lib:'YProximity get_advertisedValue',pro:'YProximity <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the proximity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the proximity sensor (no more than 6 characters).',ext:''};
doc['Proximity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YProximity get_currentRawValue',pro:'YProximity <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['Proximity']['get_currentValue']={syn:'Returns the current value of the proximity detection, in the specified unit, as a floating point number.',lib:'YProximity get_currentValue',pro:'YProximity <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the proximity detection, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the proximity detection, in the specified unit, as a floating point number',ext:''};
doc['Proximity']['get_detectionHysteresis']={syn:'Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'YProximity get_detectionHysteresis',pro:'YProximity <span id=pn>target</span> get_detectionHysteresis',cmt:'<p>Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:''};
doc['Proximity']['get_detectionThreshold']={syn:'Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'YProximity get_detectionThreshold',pro:'YProximity <span id=pn>target</span> get_detectionThreshold',cmt:'<p>Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:''};
doc['Proximity']['get_highestValue']={syn:'Returns the maximal value observed for the proximity detection since the device was started.',lib:'YProximity get_highestValue',pro:'YProximity <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the proximity detection since the device was started',ext:''};
doc['Proximity']['get_isPresent']={syn:'Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.',lib:'YProximity get_isPresent',pro:'YProximity <span id=pn>target</span> get_isPresent',cmt:'<p>Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise',ext:''};
doc['Proximity']['get_lastTimeApproached']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).',lib:'YProximity get_lastTimeApproached',pro:'YProximity <span id=pn>target</span> get_lastTimeApproached',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present)',ext:''};
doc['Proximity']['get_lastTimeRemoved']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).',lib:'YProximity get_lastTimeRemoved',pro:'YProximity <span id=pn>target</span> get_lastTimeRemoved',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent)',ext:''};
doc['Proximity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YProximity get_logFrequency',pro:'YProximity <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Proximity']['get_logicalName']={syn:'Returns the logical name of the proximity sensor.',lib:'YProximity get_logicalName',pro:'YProximity <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the proximity sensor.</p>',ret:'a string corresponding to the logical name of the proximity sensor.',ext:''};
doc['Proximity']['get_lowestValue']={syn:'Returns the minimal value observed for the proximity detection since the device was started.',lib:'YProximity get_lowestValue',pro:'YProximity <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the proximity detection since the device was started',ext:''};
doc['Proximity']['get_presenceMinTime']={syn:'Returns the minimal detection duration before signalling a presence event.',lib:'YProximity get_presenceMinTime',pro:'YProximity <span id=pn>target</span> get_presenceMinTime',cmt:'<p>Returns the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a presence event',ext:''};
doc['Proximity']['get_proximityReportMode']={syn:'Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'YProximity get_proximityReportMode',pro:'YProximity <span id=pn>target</span> get_proximityReportMode',cmt:'<p>Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.</p>',ret:'a value among <tt>NUMERIC</tt>, <tt>PRESENCE</tt> and <tt>PULSECOUNT</tt> corresponding to the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks',ext:''};
doc['Proximity']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'YProximity get_pulseCounter',pro:'YProximity <span id=pn>target</span> get_pulseCounter',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:''};
doc['Proximity']['get_pulseTimer']={syn:'Returns the timer of the pulse counter (ms).',lib:'YProximity get_pulseTimer',pro:'YProximity <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the timer of the pulse counter (ms).</p>',ret:'an integer corresponding to the timer of the pulse counter (ms)',ext:''};
doc['Proximity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YProximity get_recordedData',pro:'YProximity <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Proximity']['get_removalMinTime']={syn:'Returns the minimal detection duration before signalling a removal event.',lib:'YProximity get_removalMinTime',pro:'YProximity <span id=pn>target</span> get_removalMinTime',cmt:'<p>Returns the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a removal event',ext:''};
doc['Proximity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YProximity get_reportFrequency',pro:'YProximity <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Proximity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YProximity get_resolution',pro:'YProximity <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Proximity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YProximity get_sensorState',pro:'YProximity <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Proximity']['get_signalValue']={syn:'Returns the current value of signal measured by the proximity sensor.',lib:'YProximity get_signalValue',pro:'YProximity <span id=pn>target</span> get_signalValue',cmt:'<p>Returns the current value of signal measured by the proximity sensor.</p>',ret:'a floating point number corresponding to the current value of signal measured by the proximity sensor',ext:''};
doc['Proximity']['get_unit']={syn:'Returns the measuring unit for the proximity detection.',lib:'YProximity get_unit',pro:'YProximity <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the proximity detection.</p>',ret:'a string corresponding to the measuring unit for the proximity detection',ext:''};
doc['Proximity']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YProximity isSensorReady',pro:'YProximity <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Proximity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YProximity loadCalibrationPoints',pro:'YProximity <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YProximity muteValueCallbacks',pro:'YProximity <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Proximity']['resetCounter']={syn:'Resets the pulse counter value as well as its timer.',lib:'YProximity resetCounter',pro:'YProximity <span id=pn>target</span> resetCounter',cmt:'<p>Resets the pulse counter value as well as its timer.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YProximity set_advMode',pro:'YProximity <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_detectionHysteresis']={syn:'Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'YProximity set_detectionHysteresis',pro:'YProximity <span id=pn>target</span> set_detectionHysteresis <span id=pn>newval</span>',cmt:'<p>Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_detectionThreshold']={syn:'Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'YProximity set_detectionThreshold',pro:'YProximity <span id=pn>target</span> set_detectionThreshold <span id=pn>newval</span>',cmt:'<p>Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YProximity set_highestValue',pro:'YProximity <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YProximity set_logFrequency',pro:'YProximity <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_logicalName']={syn:'Changes the logical name of the proximity sensor.',lib:'YProximity set_logicalName',pro:'YProximity <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the proximity sensor.</p>',par:{newval:'a string corresponding to the logical name of the proximity sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YProximity set_lowestValue',pro:'YProximity <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_presenceMinTime']={syn:'Changes the minimal detection duration before signalling a presence event.',lib:'YProximity set_presenceMinTime',pro:'YProximity <span id=pn>target</span> set_presenceMinTime <span id=pn>newval</span>',cmt:'<p>Changes the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a presence event'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_proximityReportMode']={syn:'Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'YProximity set_proximityReportMode',pro:'YProximity <span id=pn>target</span> set_proximityReportMode <span id=pn>newval</span>',cmt:'<p>Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>NUMERIC</tt>, <tt>PRESENCE</tt> and <tt>PULSECOUNT</tt> corresponding to the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_removalMinTime']={syn:'Changes the minimal detection duration before signalling a removal event.',lib:'YProximity set_removalMinTime',pro:'YProximity <span id=pn>target</span> set_removalMinTime <span id=pn>newval</span>',cmt:'<p>Changes the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a removal event'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YProximity set_reportFrequency',pro:'YProximity <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YProximity set_resolution',pro:'YProximity <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Proximity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YProximity startDataLogger',pro:'YProximity <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Proximity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YProximity stopDataLogger',pro:'YProximity <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Proximity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YProximity unmuteValueCallbacks',pro:'YProximity <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Proximity)
//--- (generated code: MultiAxisController)
doc['MultiAxisController']={'':{syn:'MultiAxisController function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiAxisController']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'YMultiAxisController abortAndBrake',pro:'YMultiAxisController <span id=pn>target</span> abortAndBrake',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'YMultiAxisController abortAndHiZ',pro:'YMultiAxisController <span id=pn>target</span> abortAndHiZ',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'YMultiAxisController emergencyStop',pro:'YMultiAxisController <span id=pn>target</span> emergencyStop',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['findHomePosition']={syn:'Starts all motors backward at the specified speeds, to search for the motor home position.',lib:'YMultiAxisController findHomePosition',pro:'YMultiAxisController <span id=pn>target</span> findHomePosition <span id=pn>speed</span>',cmt:'<p>Starts all motors backward at the specified speeds, to search for the motor home position.</p>',par:{speed:'desired speed for all axis, in steps per second.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['get_advertisedValue']={syn:'Returns the current value of the multi-axis controller (no more than 6 characters).',lib:'YMultiAxisController get_advertisedValue',pro:'YMultiAxisController <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the multi-axis controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-axis controller (no more than 6 characters).',ext:''};
doc['MultiAxisController']['get_globalState']={syn:'Returns the stepper motor set overall state.',lib:'YMultiAxisController get_globalState',pro:'YMultiAxisController <span id=pn>target</span> get_globalState',cmt:'<p>Returns the stepper motor set overall state.</p>',ret:'a value among <tt>ABSENT</tt>, <tt>ALERT</tt>, <tt>HI_Z</tt>, <tt>STOP</tt>, <tt>RUN</tt> and <tt>BATCH</tt> corresponding to the stepper motor set overall state',ext:''};
doc['MultiAxisController']['get_logicalName']={syn:'Returns the logical name of the multi-axis controller.',lib:'YMultiAxisController get_logicalName',pro:'YMultiAxisController <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the multi-axis controller.</p>',ret:'a string corresponding to the logical name of the multi-axis controller.',ext:''};
doc['MultiAxisController']['get_nAxis']={syn:'Returns the number of synchronized controllers.',lib:'YMultiAxisController get_nAxis',pro:'YMultiAxisController <span id=pn>target</span> get_nAxis',cmt:'<p>Returns the number of synchronized controllers.</p>',ret:'an integer corresponding to the number of synchronized controllers',ext:''};
doc['MultiAxisController']['moveRel']={syn:'Starts all motors synchronously to reach a given relative position.',lib:'YMultiAxisController moveRel',pro:'YMultiAxisController <span id=pn>target</span> moveRel <span id=pn>relPos</span>',cmt:'<p>Starts all motors synchronously to reach a given relative position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['moveTo']={syn:'Starts all motors synchronously to reach a given absolute position.',lib:'YMultiAxisController moveTo',pro:'YMultiAxisController <span id=pn>target</span> moveTo <span id=pn>absPos</span>',cmt:'<p>Starts all motors synchronously to reach a given absolute position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{absPos:'absolute position, measured in steps from each origin.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMultiAxisController muteValueCallbacks',pro:'YMultiAxisController <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MultiAxisController']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'YMultiAxisController pause',pro:'YMultiAxisController <span id=pn>target</span> pause <span id=pn>waitMs</span>',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['reset']={syn:'Reinitialize all controllers and clear all alert flags.',lib:'YMultiAxisController reset',pro:'YMultiAxisController <span id=pn>target</span> reset',cmt:'<p>Reinitialize all controllers and clear all alert flags.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_logicalName']={syn:'Changes the logical name of the multi-axis controller.',lib:'YMultiAxisController set_logicalName',pro:'YMultiAxisController <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the multi-axis controller.</p>',par:{newval:'a string corresponding to the logical name of the multi-axis controller.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiAxisController']['set_nAxis']={syn:'Changes the number of synchronized controllers.',lib:'YMultiAxisController set_nAxis',pro:'YMultiAxisController <span id=pn>target</span> set_nAxis <span id=pn>newval</span>',cmt:'<p>Changes the number of synchronized controllers.</p>',par:{newval:'an integer corresponding to the number of synchronized controllers'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiAxisController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMultiAxisController unmuteValueCallbacks',pro:'YMultiAxisController <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: MultiAxisController)
//--- (generated code: RangeFinder)
doc['RangeFinder']={'':{syn:'RangeFinder function interface',inc:'',cmt:'<p>The Yoctopuce class YRangeFinder allows you to use and configure Yoctopuce range finder sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['RangeFinder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YRangeFinder calibrateFromPoints',pro:'YRangeFinder <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['cancelCoverGlassCalibrations']={syn:'Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings.',lib:'YRangeFinder cancelCoverGlassCalibrations',pro:'YRangeFinder <span id=pn>target</span> cancelCoverGlassCalibrations',cmt:'<p>Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YRangeFinder get_advMode',pro:'YRangeFinder <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['RangeFinder']['get_advertisedValue']={syn:'Returns the current value of the range finder (no more than 6 characters).',lib:'YRangeFinder get_advertisedValue',pro:'YRangeFinder <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the range finder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the range finder (no more than 6 characters).',ext:''};
doc['RangeFinder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.',lib:'YRangeFinder get_currentRawValue',pro:'YRangeFinder <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number',ext:''};
doc['RangeFinder']['get_currentTemperature']={syn:'Returns the current sensor temperature, as a floating point number.',lib:'YRangeFinder get_currentTemperature',pro:'YRangeFinder <span id=pn>target</span> get_currentTemperature',cmt:'<p>Returns the current sensor temperature, as a floating point number.</p>',ret:'a floating point number corresponding to the current sensor temperature, as a floating point number',ext:''};
doc['RangeFinder']['get_currentValue']={syn:'Returns the current value of the range measured, in mm, as a floating point number.',lib:'YRangeFinder get_currentValue',pro:'YRangeFinder <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the range measured, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the range measured, in mm, as a floating point number',ext:''};
doc['RangeFinder']['get_hardwareCalibrationTemperature']={syn:'Returns the temperature at the time when the latest calibration was performed.',lib:'YRangeFinder get_hardwareCalibrationTemperature',pro:'YRangeFinder <span id=pn>target</span> get_hardwareCalibrationTemperature',cmt:'<p>Returns the temperature at the time when the latest calibration was performed. This function can be used to determine if a new calibration for ambient temperature is required.</p>',ret:'a temperature, as a floating point number. On failure, throws an exception or return YAPI_INVALID_DOUBLE.'};
doc['RangeFinder']['get_highestValue']={syn:'Returns the maximal value observed for the range measured since the device was started.',lib:'YRangeFinder get_highestValue',pro:'YRangeFinder <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the range measured since the device was started',ext:''};
doc['RangeFinder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YRangeFinder get_logFrequency',pro:'YRangeFinder <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['RangeFinder']['get_logicalName']={syn:'Returns the logical name of the range finder.',lib:'YRangeFinder get_logicalName',pro:'YRangeFinder <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the range finder.</p>',ret:'a string corresponding to the logical name of the range finder.',ext:''};
doc['RangeFinder']['get_lowestValue']={syn:'Returns the minimal value observed for the range measured since the device was started.',lib:'YRangeFinder get_lowestValue',pro:'YRangeFinder <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the range measured since the device was started',ext:''};
doc['RangeFinder']['get_rangeFinderMode']={syn:'Returns the range finder running mode.',lib:'YRangeFinder get_rangeFinderMode',pro:'YRangeFinder <span id=pn>target</span> get_rangeFinderMode',cmt:'<p>Returns the range finder running mode. The rangefinder running mode allows you to put priority on precision, speed or maximum range.</p>',ret:'a value among <tt>DEFAULT</tt>, <tt>LONG_RANGE</tt>, <tt>HIGH_ACCURACY</tt> and <tt>HIGH_SPEED</tt> corresponding to the range finder running mode',ext:''};
doc['RangeFinder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YRangeFinder get_recordedData',pro:'YRangeFinder <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['RangeFinder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YRangeFinder get_reportFrequency',pro:'YRangeFinder <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['RangeFinder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YRangeFinder get_resolution',pro:'YRangeFinder <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['RangeFinder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YRangeFinder get_sensorState',pro:'YRangeFinder <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['RangeFinder']['get_unit']={syn:'Returns the measuring unit for the range measured.',lib:'YRangeFinder get_unit',pro:'YRangeFinder <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the range measured.</p>',ret:'a string corresponding to the measuring unit for the range measured',ext:''};
doc['RangeFinder']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YRangeFinder isSensorReady',pro:'YRangeFinder <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['RangeFinder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YRangeFinder loadCalibrationPoints',pro:'YRangeFinder <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YRangeFinder muteValueCallbacks',pro:'YRangeFinder <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['RangeFinder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YRangeFinder set_advMode',pro:'YRangeFinder <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YRangeFinder set_highestValue',pro:'YRangeFinder <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YRangeFinder set_logFrequency',pro:'YRangeFinder <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_logicalName']={syn:'Changes the logical name of the range finder.',lib:'YRangeFinder set_logicalName',pro:'YRangeFinder <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the range finder.</p>',par:{newval:'a string corresponding to the logical name of the range finder.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YRangeFinder set_lowestValue',pro:'YRangeFinder <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_rangeFinderMode']={syn:'Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.',lib:'YRangeFinder set_rangeFinderMode',pro:'YRangeFinder <span id=pn>target</span> set_rangeFinderMode <span id=pn>newval</span>',cmt:'<p>Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.</p>',par:{newval:'a value among <tt>DEFAULT</tt>, <tt>LONG_RANGE</tt>, <tt>HIGH_ACCURACY</tt> and <tt>HIGH_SPEED</tt> corresponding to the rangefinder running mode, allowing you to put priority on precision, speed or maximum range'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YRangeFinder set_reportFrequency',pro:'YRangeFinder <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YRangeFinder set_resolution',pro:'YRangeFinder <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['set_unit']={syn:'Changes the measuring unit for the measured range.',lib:'YRangeFinder set_unit',pro:'YRangeFinder <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured range. That unit is a string. String value can be <tt>\x22</tt> or <tt>mm</tt>. Any other value is ignored. WARNING: if a specific calibration is defined for the rangeFinder function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured range'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RangeFinder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YRangeFinder startDataLogger',pro:'YRangeFinder <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['RangeFinder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YRangeFinder stopDataLogger',pro:'YRangeFinder <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['RangeFinder']['triggerOffsetCalibration']={syn:'Triggers the hardware offset calibration of the distance sensor.',lib:'YRangeFinder triggerOffsetCalibration',pro:'YRangeFinder <span id=pn>target</span> triggerOffsetCalibration <span id=pn>targetDist</span>',cmt:'<p>Triggers the hardware offset calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerSpadCalibration']={syn:'Triggers the photon detector hardware calibration.',lib:'YRangeFinder triggerSpadCalibration',pro:'YRangeFinder <span id=pn>target</span> triggerSpadCalibration',cmt:'<p>Triggers the photon detector hardware calibration. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerTemperatureCalibration']={syn:'Triggers a sensor calibration according to the current ambient temperature.',lib:'YRangeFinder triggerTemperatureCalibration',pro:'YRangeFinder <span id=pn>target</span> triggerTemperatureCalibration',cmt:'<p>Triggers a sensor calibration according to the current ambient temperature. That calibration process needs no physical interaction with the sensor. It is performed automatically at device startup, but it is recommended to start it again when the temperature delta since the latest calibration exceeds 8\xB0C.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerXTalkCalibration']={syn:'Triggers the hardware cross-talk calibration of the distance sensor.',lib:'YRangeFinder triggerXTalkCalibration',pro:'YRangeFinder <span id=pn>target</span> triggerXTalkCalibration <span id=pn>targetDist</span>',cmt:'<p>Triggers the hardware cross-talk calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YRangeFinder unmuteValueCallbacks',pro:'YRangeFinder <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: RangeFinder)
//--- (generated code: DaisyChain)
doc['DaisyChain']={'':{syn:'DaisyChain function interface',inc:'',cmt:'<p>The YDaisyChain interface can be used to verify that devices that are daisy-chained directly from device to device, without a hub, are detected properly.</p>'}};
doc['DaisyChain']['get_advertisedValue']={syn:'Returns the current value of the module chain (no more than 6 characters).',lib:'YDaisyChain get_advertisedValue',pro:'YDaisyChain <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the module chain (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the module chain (no more than 6 characters).',ext:''};
doc['DaisyChain']['get_childCount']={syn:'Returns the number of child nodes currently detected.',lib:'YDaisyChain get_childCount',pro:'YDaisyChain <span id=pn>target</span> get_childCount',cmt:'<p>Returns the number of child nodes currently detected.</p>',ret:'an integer corresponding to the number of child nodes currently detected',ext:''};
doc['DaisyChain']['get_daisyState']={syn:'Returns the state of the daisy-link between modules.',lib:'YDaisyChain get_daisyState',pro:'YDaisyChain <span id=pn>target</span> get_daisyState',cmt:'<p>Returns the state of the daisy-link between modules.</p>',ret:'a value among <tt>READY</tt>, <tt>IS_CHILD</tt>, <tt>FIRMWARE_MISMATCH</tt>, <tt>CHILD_MISSING</tt> and <tt>CHILD_LOST</tt> corresponding to the state of the daisy-link between modules',ext:''};
doc['DaisyChain']['get_logicalName']={syn:'Returns the logical name of the module chain.',lib:'YDaisyChain get_logicalName',pro:'YDaisyChain <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the module chain.</p>',ret:'a string corresponding to the logical name of the module chain.',ext:''};
doc['DaisyChain']['get_requiredChildCount']={syn:'Returns the number of child nodes expected in normal conditions.',lib:'YDaisyChain get_requiredChildCount',pro:'YDaisyChain <span id=pn>target</span> get_requiredChildCount',cmt:'<p>Returns the number of child nodes expected in normal conditions.</p>',ret:'an integer corresponding to the number of child nodes expected in normal conditions',ext:''};
doc['DaisyChain']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YDaisyChain muteValueCallbacks',pro:'YDaisyChain <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['DaisyChain']['set_logicalName']={syn:'Changes the logical name of the module chain.',lib:'YDaisyChain set_logicalName',pro:'YDaisyChain <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the module chain.</p>',par:{newval:'a string corresponding to the logical name of the module chain.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DaisyChain']['set_requiredChildCount']={syn:'Changes the number of child nodes expected in normal conditions.',lib:'YDaisyChain set_requiredChildCount',pro:'YDaisyChain <span id=pn>target</span> set_requiredChildCount <span id=pn>newval</span>',cmt:'<p>Changes the number of child nodes expected in normal conditions. If the value is zero, no check is performed. If it is non-zero, the number child nodes is checked on startup and the status will change to error if the count does not match.</p>',par:{newval:'an integer corresponding to the number of child nodes expected in normal conditions'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DaisyChain']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YDaisyChain unmuteValueCallbacks',pro:'YDaisyChain <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: DaisyChain)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YSensor calibrateFromPoints',pro:'YSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YSensor get_advMode',pro:'YSensor <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Sensor']['get_advertisedValue']={syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'YSensor get_advertisedValue',pro:'YSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:''};
doc['Sensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YSensor get_currentRawValue',pro:'YSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['Sensor']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'YSensor get_currentValue',pro:'YSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:''};
doc['Sensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YSensor get_highestValue',pro:'YSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['Sensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YSensor get_logFrequency',pro:'YSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Sensor']['get_logicalName']={syn:'Returns the logical name of the sensor.',lib:'YSensor get_logicalName',pro:'YSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:''};
doc['Sensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YSensor get_lowestValue',pro:'YSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YSensor get_recordedData',pro:'YSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YSensor get_reportFrequency',pro:'YSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Sensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YSensor get_resolution',pro:'YSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Sensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YSensor get_sensorState',pro:'YSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Sensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YSensor get_unit',pro:'YSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['Sensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YSensor isSensorReady',pro:'YSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YSensor loadCalibrationPoints',pro:'YSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YSensor muteValueCallbacks',pro:'YSensor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Sensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YSensor set_advMode',pro:'YSensor <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YSensor set_highestValue',pro:'YSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YSensor set_logFrequency',pro:'YSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_logicalName']={syn:'Changes the logical name of the sensor.',lib:'YSensor set_logicalName',pro:'YSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the sensor.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YSensor set_lowestValue',pro:'YSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YSensor set_reportFrequency',pro:'YSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YSensor set_resolution',pro:'YSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YSensor startDataLogger',pro:'YSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YSensor stopDataLogger',pro:'YSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Sensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YSensor unmuteValueCallbacks',pro:'YSensor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Sensor)
//--- (generated code: VoltageOutput)
doc['VoltageOutput']={'':{syn:'VoltageOutput function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the voltage output.</p>'}};
doc['VoltageOutput']['get_advertisedValue']={syn:'Returns the current value of the voltage output (no more than 6 characters).',lib:'YVoltageOutput get_advertisedValue',pro:'YVoltageOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage output (no more than 6 characters).',ext:''};
doc['VoltageOutput']['get_currentVoltage']={syn:'Returns the output voltage set point, in V.',lib:'YVoltageOutput get_currentVoltage',pro:'YVoltageOutput <span id=pn>target</span> get_currentVoltage',cmt:'<p>Returns the output voltage set point, in V.</p>',ret:'a floating point number corresponding to the output voltage set point, in V',ext:''};
doc['VoltageOutput']['get_logicalName']={syn:'Returns the logical name of the voltage output.',lib:'YVoltageOutput get_logicalName',pro:'YVoltageOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage output.</p>',ret:'a string corresponding to the logical name of the voltage output.',ext:''};
doc['VoltageOutput']['get_voltageAtStartUp']={syn:'Returns the selected voltage output at device startup, in V.',lib:'YVoltageOutput get_voltageAtStartUp',pro:'YVoltageOutput <span id=pn>target</span> get_voltageAtStartUp',cmt:'<p>Returns the selected voltage output at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage output at device startup, in V',ext:''};
doc['VoltageOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YVoltageOutput muteValueCallbacks',pro:'YVoltageOutput <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['VoltageOutput']['set_currentVoltage']={syn:'Changes the output voltage, in V.',lib:'YVoltageOutput set_currentVoltage',pro:'YVoltageOutput <span id=pn>target</span> set_currentVoltage <span id=pn>newval</span>',cmt:'<p>Changes the output voltage, in V. Valid range is from 0 to 10V.</p>',par:{newval:'a floating point number corresponding to the output voltage, in V'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VoltageOutput']['set_logicalName']={syn:'Changes the logical name of the voltage output.',lib:'YVoltageOutput set_logicalName',pro:'YVoltageOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage output.</p>',par:{newval:'a string corresponding to the logical name of the voltage output.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VoltageOutput']['set_voltageAtStartUp']={syn:'Changes the output voltage at device start up.',lib:'YVoltageOutput set_voltageAtStartUp',pro:'YVoltageOutput <span id=pn>target</span> set_voltageAtStartUp <span id=pn>newval</span>',cmt:'<p>Changes the output voltage at device start up.</p>',par:{newval:'a floating point number corresponding to the output voltage at device start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VoltageOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YVoltageOutput unmuteValueCallbacks',pro:'YVoltageOutput <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['VoltageOutput']['voltageMove']={syn:'Performs a smooth transition of output voltage.',lib:'YVoltageOutput voltageMove',pro:'YVoltageOutput <span id=pn>target</span> voltageMove <span id=pn>V_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition of output voltage. Any explicit voltage change cancels any ongoing transition process.</p>',par:{V_target:'new output voltage value at the end of the transition (floating-point number, representing the end voltage in V)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.'};
//--- (end of generated code: VoltageOutput)
//--- (generated code: WeighScale)
doc['WeighScale']={'':{syn:'WeighScale function interface',inc:'',cmt:'<p>The YWeighScale class provides a weight measurement from a ratiometric load cell sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cell itself.</p>'}};
doc['WeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YWeighScale calibrateFromPoints',pro:'YWeighScale <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YWeighScale get_advMode',pro:'YWeighScale <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['WeighScale']['get_advertisedValue']={syn:'Returns the current value of the weighing scale sensor (no more than 6 characters).',lib:'YWeighScale get_advertisedValue',pro:'YWeighScale <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the weighing scale sensor (no more than 6 characters).',ext:''};
doc['WeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'YWeighScale get_compTempAvg',pro:'YWeighScale <span id=pn>target</span> get_compTempAvg',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:''};
doc['WeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'YWeighScale get_compTempChg',pro:'YWeighScale <span id=pn>target</span> get_compTempChg',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:''};
doc['WeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'YWeighScale get_compensation',pro:'YWeighScale <span id=pn>target</span> get_compensation',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:''};
doc['WeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YWeighScale get_currentRawValue',pro:'YWeighScale <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['WeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'YWeighScale get_currentValue',pro:'YWeighScale <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:''};
doc['WeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'YWeighScale get_excitation',pro:'YWeighScale <span id=pn>target</span> get_excitation',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>OFF</tt>, <tt>DC</tt> and <tt>AC</tt> corresponding to the current load cell bridge excitation method',ext:''};
doc['WeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YWeighScale get_highestValue',pro:'YWeighScale <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['WeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YWeighScale get_logFrequency',pro:'YWeighScale <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['WeighScale']['get_logicalName']={syn:'Returns the logical name of the weighing scale sensor.',lib:'YWeighScale get_logicalName',pro:'YWeighScale <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the weighing scale sensor.',ext:''};
doc['WeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YWeighScale get_lowestValue',pro:'YWeighScale <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['WeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YWeighScale get_recordedData',pro:'YWeighScale <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['WeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YWeighScale get_reportFrequency',pro:'YWeighScale <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['WeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YWeighScale get_resolution',pro:'YWeighScale <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['WeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YWeighScale get_sensorState',pro:'YWeighScale <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['WeighScale']['get_tempAvgAdaptRatio']={syn:'Returns the averaged temperature update rate, in per mille.',lib:'YWeighScale get_tempAvgAdaptRatio',pro:'YWeighScale <span id=pn>target</span> get_tempAvgAdaptRatio',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:''};
doc['WeighScale']['get_tempChgAdaptRatio']={syn:'Returns the temperature change update rate, in per mille.',lib:'YWeighScale get_tempChgAdaptRatio',pro:'YWeighScale <span id=pn>target</span> get_tempChgAdaptRatio',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:''};
doc['WeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YWeighScale get_unit',pro:'YWeighScale <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['WeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'YWeighScale get_zeroTracking',pro:'YWeighScale <span id=pn>target</span> get_zeroTracking',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:''};
doc['WeighScale']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YWeighScale isSensorReady',pro:'YWeighScale <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['WeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YWeighScale loadCalibrationPoints',pro:'YWeighScale <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['loadOffsetAvgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function.',lib:'YWeighScale loadOffsetAvgCompensationTable',pro:'YWeighScale <span id=pn>target</span> loadOffsetAvgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['loadOffsetChgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function.',lib:'YWeighScale loadOffsetChgCompensationTable',pro:'YWeighScale <span id=pn>target</span> loadOffsetChgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['loadSpanAvgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function.',lib:'YWeighScale loadSpanAvgCompensationTable',pro:'YWeighScale <span id=pn>target</span> loadSpanAvgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['loadSpanChgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function.',lib:'YWeighScale loadSpanChgCompensationTable',pro:'YWeighScale <span id=pn>target</span> loadSpanChgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all variation of temperature for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of variation of temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YWeighScale muteValueCallbacks',pro:'YWeighScale <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['WeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YWeighScale set_advMode',pro:'YWeighScale <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'YWeighScale set_excitation',pro:'YWeighScale <span id=pn>target</span> set_excitation <span id=pn>newval</span>',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>DC</tt> and <tt>AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YWeighScale set_highestValue',pro:'YWeighScale <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YWeighScale set_logFrequency',pro:'YWeighScale <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_logicalName']={syn:'Changes the logical name of the weighing scale sensor.',lib:'YWeighScale set_logicalName',pro:'YWeighScale <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the weighing scale sensor.</p>',par:{newval:'a string corresponding to the logical name of the weighing scale sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YWeighScale set_lowestValue',pro:'YWeighScale <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_offsetAvgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature.',lib:'YWeighScale set_offsetAvgCompensationTable',pro:'YWeighScale <span id=pn>target</span> set_offsetAvgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_offsetChgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'YWeighScale set_offsetChgCompensationTable',pro:'YWeighScale <span id=pn>target</span> set_offsetChgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YWeighScale set_reportFrequency',pro:'YWeighScale <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YWeighScale set_resolution',pro:'YWeighScale <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_spanAvgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature.',lib:'YWeighScale set_spanAvgCompensationTable',pro:'YWeighScale <span id=pn>target</span> set_spanAvgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_spanChgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'YWeighScale set_spanChgCompensationTable',pro:'YWeighScale <span id=pn>target</span> set_spanChgCompensationTable <span id=pn>tempValues</span> <span id=pn>compValues</span>',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all variations of temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_tempAvgAdaptRatio']={syn:'Changes the averaged temperature update rate, in per mille.',lib:'YWeighScale set_tempAvgAdaptRatio',pro:'YWeighScale <span id=pn>target</span> set_tempAvgAdaptRatio <span id=pn>newval</span>',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_tempChgAdaptRatio']={syn:'Changes the temperature change update rate, in per mille.',lib:'YWeighScale set_tempChgAdaptRatio',pro:'YWeighScale <span id=pn>target</span> set_tempChgAdaptRatio <span id=pn>newval</span>',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'YWeighScale set_unit',pro:'YWeighScale <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the weight.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'YWeighScale set_zeroTracking',pro:'YWeighScale <span id=pn>target</span> set_zeroTracking <span id=pn>newval</span>',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['setupSpan']={syn:'Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.',lib:'YWeighScale setupSpan',pro:'YWeighScale <span id=pn>target</span> setupSpan <span id=pn>currWeight</span> <span id=pn>maxWeight</span>',cmt:'<p>Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YWeighScale startDataLogger',pro:'YWeighScale <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['WeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YWeighScale stopDataLogger',pro:'YWeighScale <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['WeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'YWeighScale tare',pro:'YWeighScale <span id=pn>target</span> tare',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YWeighScale unmuteValueCallbacks',pro:'YWeighScale <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: WeighScale)
//--- (generated code: PowerSupply)
doc['PowerSupply']={'':{syn:'PowerSupply function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to change the voltage set point, the current limit and the enable/disable the output.</p>'}};
doc['PowerSupply']['get_advertisedValue']={syn:'Returns the current value of the regulated power supply (no more than 6 characters).',lib:'YPowerSupply get_advertisedValue',pro:'YPowerSupply <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the regulated power supply (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the regulated power supply (no more than 6 characters).',ext:''};
doc['PowerSupply']['get_currentAtStartUp']={syn:'Returns the selected current limit at device startup, in mA.',lib:'YPowerSupply get_currentAtStartUp',pro:'YPowerSupply <span id=pn>target</span> get_currentAtStartUp',cmt:'<p>Returns the selected current limit at device startup, in mA.</p>',ret:'a floating point number corresponding to the selected current limit at device startup, in mA',ext:''};
doc['PowerSupply']['get_currentLimit']={syn:'Returns the current limit, in mA.',lib:'YPowerSupply get_currentLimit',pro:'YPowerSupply <span id=pn>target</span> get_currentLimit',cmt:'<p>Returns the current limit, in mA.</p>',ret:'a floating point number corresponding to the current limit, in mA',ext:''};
doc['PowerSupply']['get_inputVoltage']={syn:'Returns the measured input voltage, in V.',lib:'YPowerSupply get_inputVoltage',pro:'YPowerSupply <span id=pn>target</span> get_inputVoltage',cmt:'<p>Returns the measured input voltage, in V.</p>',ret:'a floating point number corresponding to the measured input voltage, in V',ext:''};
doc['PowerSupply']['get_ldoTemperature']={syn:'Returns the LDO temperature, in Celsius.',lib:'YPowerSupply get_ldoTemperature',pro:'YPowerSupply <span id=pn>target</span> get_ldoTemperature',cmt:'<p>Returns the LDO temperature, in Celsius.</p>',ret:'a floating point number corresponding to the LDO temperature, in Celsius',ext:''};
doc['PowerSupply']['get_logicalName']={syn:'Returns the logical name of the regulated power supply.',lib:'YPowerSupply get_logicalName',pro:'YPowerSupply <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the regulated power supply.</p>',ret:'a string corresponding to the logical name of the regulated power supply.',ext:''};
doc['PowerSupply']['get_measuredCurrent']={syn:'Returns the measured output current, in mA.',lib:'YPowerSupply get_measuredCurrent',pro:'YPowerSupply <span id=pn>target</span> get_measuredCurrent',cmt:'<p>Returns the measured output current, in mA.</p>',ret:'a floating point number corresponding to the measured output current, in mA',ext:''};
doc['PowerSupply']['get_measuredVoltage']={syn:'Returns the measured output voltage, in V.',lib:'YPowerSupply get_measuredVoltage',pro:'YPowerSupply <span id=pn>target</span> get_measuredVoltage',cmt:'<p>Returns the measured output voltage, in V.</p>',ret:'a floating point number corresponding to the measured output voltage, in V',ext:''};
doc['PowerSupply']['get_powerOutput']={syn:'Returns the power supply output switch state.',lib:'YPowerSupply get_powerOutput',pro:'YPowerSupply <span id=pn>target</span> get_powerOutput',cmt:'<p>Returns the power supply output switch state.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the power supply output switch state',ext:''};
doc['PowerSupply']['get_vInt']={syn:'Returns the internal voltage, in V.',lib:'YPowerSupply get_vInt',pro:'YPowerSupply <span id=pn>target</span> get_vInt',cmt:'<p>Returns the internal voltage, in V.</p>',ret:'a floating point number corresponding to the internal voltage, in V',ext:''};
doc['PowerSupply']['get_voltageAtStartUp']={syn:'Returns the selected voltage set point at device startup, in V.',lib:'YPowerSupply get_voltageAtStartUp',pro:'YPowerSupply <span id=pn>target</span> get_voltageAtStartUp',cmt:'<p>Returns the selected voltage set point at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage set point at device startup, in V',ext:''};
doc['PowerSupply']['get_voltageSense']={syn:'Returns the output voltage control point.',lib:'YPowerSupply get_voltageSense',pro:'YPowerSupply <span id=pn>target</span> get_voltageSense',cmt:'<p>Returns the output voltage control point.</p>',ret:'either <tt>INT</tt> or <tt>EXT</tt>, according to the output voltage control point',ext:''};
doc['PowerSupply']['get_voltageSetPoint']={syn:'Returns the voltage set point, in V.',lib:'YPowerSupply get_voltageSetPoint',pro:'YPowerSupply <span id=pn>target</span> get_voltageSetPoint',cmt:'<p>Returns the voltage set point, in V.</p>',ret:'a floating point number corresponding to the voltage set point, in V',ext:''};
doc['PowerSupply']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YPowerSupply muteValueCallbacks',pro:'YPowerSupply <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PowerSupply']['set_currentAtStartUp']={syn:'Changes the current limit at device start up.',lib:'YPowerSupply set_currentAtStartUp',pro:'YPowerSupply <span id=pn>target</span> set_currentAtStartUp <span id=pn>newval</span>',cmt:'<p>Changes the current limit at device start up.</p>',par:{newval:'a floating point number corresponding to the current limit at device start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_currentLimit']={syn:'Changes the current limit, in mA.',lib:'YPowerSupply set_currentLimit',pro:'YPowerSupply <span id=pn>target</span> set_currentLimit <span id=pn>newval</span>',cmt:'<p>Changes the current limit, in mA.</p>',par:{newval:'a floating point number corresponding to the current limit, in mA'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_logicalName']={syn:'Changes the logical name of the regulated power supply.',lib:'YPowerSupply set_logicalName',pro:'YPowerSupply <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the regulated power supply.</p>',par:{newval:'a string corresponding to the logical name of the regulated power supply.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_powerOutput']={syn:'Changes the power supply output switch state.',lib:'YPowerSupply set_powerOutput',pro:'YPowerSupply <span id=pn>target</span> set_powerOutput <span id=pn>newval</span>',cmt:'<p>Changes the power supply output switch state.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the power supply output switch state'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_voltageAtStartUp']={syn:'Changes the voltage set point at device start up.',lib:'YPowerSupply set_voltageAtStartUp',pro:'YPowerSupply <span id=pn>target</span> set_voltageAtStartUp <span id=pn>newval</span>',cmt:'<p>Changes the voltage set point at device start up.</p>',par:{newval:'a floating point number corresponding to the voltage set point at device start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_voltageSense']={syn:'Changes the voltage control point.',lib:'YPowerSupply set_voltageSense',pro:'YPowerSupply <span id=pn>target</span> set_voltageSense <span id=pn>newval</span>',cmt:'<p>Changes the voltage control point.</p>',par:{newval:'either <tt>INT</tt> or <tt>EXT</tt>, according to the voltage control point'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['set_voltageSetPoint']={syn:'Changes the voltage set point, in V.',lib:'YPowerSupply set_voltageSetPoint',pro:'YPowerSupply <span id=pn>target</span> set_voltageSetPoint <span id=pn>newval</span>',cmt:'<p>Changes the voltage set point, in V.</p>',par:{newval:'a floating point number corresponding to the voltage set point, in V'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerSupply']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YPowerSupply unmuteValueCallbacks',pro:'YPowerSupply <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: PowerSupply)
//--- (generated code: MultiCellWeighScale)
doc['MultiCellWeighScale']={'':{syn:'MultiCellWeighScale function interface',inc:'',cmt:'<p>The YMultiCellWeighScale class provides a weight measurement from a set of ratiometric load cells sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cells themselves.</p>'}};
doc['MultiCellWeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YMultiCellWeighScale calibrateFromPoints',pro:'YMultiCellWeighScale <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YMultiCellWeighScale get_advMode',pro:'YMultiCellWeighScale <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['MultiCellWeighScale']['get_advertisedValue']={syn:'Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).',lib:'YMultiCellWeighScale get_advertisedValue',pro:'YMultiCellWeighScale <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-cell weighing scale sensor (no more than 6 characters).',ext:''};
doc['MultiCellWeighScale']['get_cellCount']={syn:'Returns the number of load cells in use.',lib:'YMultiCellWeighScale get_cellCount',pro:'YMultiCellWeighScale <span id=pn>target</span> get_cellCount',cmt:'<p>Returns the number of load cells in use.</p>',ret:'an integer corresponding to the number of load cells in use',ext:''};
doc['MultiCellWeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'YMultiCellWeighScale get_compTempAvg',pro:'YMultiCellWeighScale <span id=pn>target</span> get_compTempAvg',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:''};
doc['MultiCellWeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'YMultiCellWeighScale get_compTempChg',pro:'YMultiCellWeighScale <span id=pn>target</span> get_compTempChg',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:''};
doc['MultiCellWeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'YMultiCellWeighScale get_compensation',pro:'YMultiCellWeighScale <span id=pn>target</span> get_compensation',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:''};
doc['MultiCellWeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YMultiCellWeighScale get_currentRawValue',pro:'YMultiCellWeighScale <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['MultiCellWeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'YMultiCellWeighScale get_currentValue',pro:'YMultiCellWeighScale <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:''};
doc['MultiCellWeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'YMultiCellWeighScale get_excitation',pro:'YMultiCellWeighScale <span id=pn>target</span> get_excitation',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>OFF</tt>, <tt>DC</tt> and <tt>AC</tt> corresponding to the current load cell bridge excitation method',ext:''};
doc['MultiCellWeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YMultiCellWeighScale get_highestValue',pro:'YMultiCellWeighScale <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['MultiCellWeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YMultiCellWeighScale get_logFrequency',pro:'YMultiCellWeighScale <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['MultiCellWeighScale']['get_logicalName']={syn:'Returns the logical name of the multi-cell weighing scale sensor.',lib:'YMultiCellWeighScale get_logicalName',pro:'YMultiCellWeighScale <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the multi-cell weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the multi-cell weighing scale sensor.',ext:''};
doc['MultiCellWeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YMultiCellWeighScale get_lowestValue',pro:'YMultiCellWeighScale <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['MultiCellWeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YMultiCellWeighScale get_recordedData',pro:'YMultiCellWeighScale <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['MultiCellWeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YMultiCellWeighScale get_reportFrequency',pro:'YMultiCellWeighScale <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['MultiCellWeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YMultiCellWeighScale get_resolution',pro:'YMultiCellWeighScale <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['MultiCellWeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YMultiCellWeighScale get_sensorState',pro:'YMultiCellWeighScale <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['MultiCellWeighScale']['get_tempAvgAdaptRatio']={syn:'Returns the averaged temperature update rate, in per mille.',lib:'YMultiCellWeighScale get_tempAvgAdaptRatio',pro:'YMultiCellWeighScale <span id=pn>target</span> get_tempAvgAdaptRatio',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:''};
doc['MultiCellWeighScale']['get_tempChgAdaptRatio']={syn:'Returns the temperature change update rate, in per mille.',lib:'YMultiCellWeighScale get_tempChgAdaptRatio',pro:'YMultiCellWeighScale <span id=pn>target</span> get_tempChgAdaptRatio',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:''};
doc['MultiCellWeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YMultiCellWeighScale get_unit',pro:'YMultiCellWeighScale <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['MultiCellWeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'YMultiCellWeighScale get_zeroTracking',pro:'YMultiCellWeighScale <span id=pn>target</span> get_zeroTracking',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:''};
doc['MultiCellWeighScale']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YMultiCellWeighScale isSensorReady',pro:'YMultiCellWeighScale <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['MultiCellWeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YMultiCellWeighScale loadCalibrationPoints',pro:'YMultiCellWeighScale <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMultiCellWeighScale muteValueCallbacks',pro:'YMultiCellWeighScale <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YMultiCellWeighScale set_advMode',pro:'YMultiCellWeighScale <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_cellCount']={syn:'Changes the number of load cells in use.',lib:'YMultiCellWeighScale set_cellCount',pro:'YMultiCellWeighScale <span id=pn>target</span> set_cellCount <span id=pn>newval</span>',cmt:'<p>Changes the number of load cells in use.</p>',par:{newval:'an integer corresponding to the number of load cells in use'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'YMultiCellWeighScale set_excitation',pro:'YMultiCellWeighScale <span id=pn>target</span> set_excitation <span id=pn>newval</span>',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>DC</tt> and <tt>AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YMultiCellWeighScale set_highestValue',pro:'YMultiCellWeighScale <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YMultiCellWeighScale set_logFrequency',pro:'YMultiCellWeighScale <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_logicalName']={syn:'Changes the logical name of the multi-cell weighing scale sensor.',lib:'YMultiCellWeighScale set_logicalName',pro:'YMultiCellWeighScale <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the multi-cell weighing scale sensor.</p>',par:{newval:'a string corresponding to the logical name of the multi-cell weighing scale sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YMultiCellWeighScale set_lowestValue',pro:'YMultiCellWeighScale <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YMultiCellWeighScale set_reportFrequency',pro:'YMultiCellWeighScale <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YMultiCellWeighScale set_resolution',pro:'YMultiCellWeighScale <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_tempAvgAdaptRatio']={syn:'Changes the averaged temperature update rate, in per mille.',lib:'YMultiCellWeighScale set_tempAvgAdaptRatio',pro:'YMultiCellWeighScale <span id=pn>target</span> set_tempAvgAdaptRatio <span id=pn>newval</span>',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_tempChgAdaptRatio']={syn:'Changes the temperature change update rate, in per mille.',lib:'YMultiCellWeighScale set_tempChgAdaptRatio',pro:'YMultiCellWeighScale <span id=pn>target</span> set_tempChgAdaptRatio <span id=pn>newval</span>',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'YMultiCellWeighScale set_unit',pro:'YMultiCellWeighScale <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the weight.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'YMultiCellWeighScale set_zeroTracking',pro:'YMultiCellWeighScale <span id=pn>target</span> set_zeroTracking <span id=pn>newval</span>',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['setupSpan']={syn:'Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.',lib:'YMultiCellWeighScale setupSpan',pro:'YMultiCellWeighScale <span id=pn>target</span> setupSpan <span id=pn>currWeight</span> <span id=pn>maxWeight</span>',cmt:'<p>Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YMultiCellWeighScale startDataLogger',pro:'YMultiCellWeighScale <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YMultiCellWeighScale stopDataLogger',pro:'YMultiCellWeighScale <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'YMultiCellWeighScale tare',pro:'YMultiCellWeighScale <span id=pn>target</span> tare',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiCellWeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMultiCellWeighScale unmuteValueCallbacks',pro:'YMultiCellWeighScale <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: MultiCellWeighScale)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Quaternion interface',inc:'',cmt:'<p>The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation using a quaternion. It is usually not needed to use the YQt class directly, as the YGyro class provides a more convenient higher-level interface.</p>'}};
doc['Qt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YSensor calibrateFromPoints',pro:'YSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YSensor get_advMode',pro:'YSensor <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Qt']['get_advertisedValue']={syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'YSensor get_advertisedValue',pro:'YSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:''};
doc['Qt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'YSensor get_currentRawValue',pro:'YSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:''};
doc['Qt']['get_currentValue']={syn:'Returns the current value of the value, in units, as a floating point number.',lib:'YSensor get_currentValue',pro:'YSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the value, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:''};
doc['Qt']['get_highestValue']={syn:'Returns the maximal value observed for the value since the device was started.',lib:'YSensor get_highestValue',pro:'YSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:''};
doc['Qt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YSensor get_logFrequency',pro:'YSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Qt']['get_logicalName']={syn:'Returns the logical name of the quaternion component.',lib:'YSensor get_logicalName',pro:'YSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:''};
doc['Qt']['get_lowestValue']={syn:'Returns the minimal value observed for the value since the device was started.',lib:'YSensor get_lowestValue',pro:'YSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:''};
doc['Qt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YSensor get_recordedData',pro:'YSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Qt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YSensor get_reportFrequency',pro:'YSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Qt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YSensor get_resolution',pro:'YSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Qt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YSensor get_sensorState',pro:'YSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Qt']['get_unit']={syn:'Returns the measuring unit for the value.',lib:'YSensor get_unit',pro:'YSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:''};
doc['Qt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YSensor loadCalibrationPoints',pro:'YSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YSensor muteValueCallbacks',pro:'YSensor <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Qt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YSensor set_advMode',pro:'YSensor <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YSensor set_highestValue',pro:'YSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YSensor set_logFrequency',pro:'YSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_logicalName']={syn:'Changes the logical name of the quaternion component.',lib:'YSensor set_logicalName',pro:'YSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the quaternion component.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YSensor set_lowestValue',pro:'YSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YSensor set_reportFrequency',pro:'YSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YSensor set_resolution',pro:'YSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YSensor startDataLogger',pro:'YSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Qt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YSensor stopDataLogger',pro:'YSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Qt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YSensor unmuteValueCallbacks',pro:'YSensor <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Qt)
//--- (generated code: MultiSensorController)
doc['MultiSensorController']={'':{syn:'MultiSensorController function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiSensorController']['get_advertisedValue']={syn:'Returns the current value of the multi-sensor controller (no more than 6 characters).',lib:'YMultiSensorController get_advertisedValue',pro:'YMultiSensorController <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the multi-sensor controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-sensor controller (no more than 6 characters).',ext:''};
doc['MultiSensorController']['get_logicalName']={syn:'Returns the logical name of the multi-sensor controller.',lib:'YMultiSensorController get_logicalName',pro:'YMultiSensorController <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the multi-sensor controller.</p>',ret:'a string corresponding to the logical name of the multi-sensor controller.',ext:''};
doc['MultiSensorController']['get_maintenanceMode']={syn:'Returns true when the device is in maintenance mode.',lib:'YMultiSensorController get_maintenanceMode',pro:'YMultiSensorController <span id=pn>target</span> get_maintenanceMode',cmt:'<p>Returns true when the device is in maintenance mode.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true when the device is in maintenance mode',ext:''};
doc['MultiSensorController']['get_nSensors']={syn:'Returns the number of sensors to poll.',lib:'YMultiSensorController get_nSensors',pro:'YMultiSensorController <span id=pn>target</span> get_nSensors',cmt:'<p>Returns the number of sensors to poll.</p>',ret:'an integer corresponding to the number of sensors to poll',ext:''};
doc['MultiSensorController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMultiSensorController muteValueCallbacks',pro:'YMultiSensorController <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MultiSensorController']['set_logicalName']={syn:'Changes the logical name of the multi-sensor controller.',lib:'YMultiSensorController set_logicalName',pro:'YMultiSensorController <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the multi-sensor controller.</p>',par:{newval:'a string corresponding to the logical name of the multi-sensor controller.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensorController']['set_maintenanceMode']={syn:'Changes the device mode to enable maintenance and stop sensors polling.',lib:'YMultiSensorController set_maintenanceMode',pro:'YMultiSensorController <span id=pn>target</span> set_maintenanceMode <span id=pn>newval</span>',cmt:'<p>Changes the device mode to enable maintenance and stop sensors polling. This way, the device will not restart automatically in case it cannot communicate with one of the sensors.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the device mode to enable maintenance and stop sensors polling'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensorController']['set_nSensors']={syn:'Changes the number of sensors to poll.',lib:'YMultiSensorController set_nSensors',pro:'YMultiSensorController <span id=pn>target</span> set_nSensors <span id=pn>newval</span>',cmt:'<p>Changes the number of sensors to poll. Il is recommended to restart the device with <tt>module->reboot()</tt> after modifing (and saving) this settings</p>',par:{newval:'an integer corresponding to the number of sensors to poll'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensorController']['setupAddress']={syn:'Configure the I2C address of the only sensor connected to the device.',lib:'YMultiSensorController setupAddress',pro:'YMultiSensorController <span id=pn>target</span> setupAddress <span id=pn>addr</span>',cmt:'<p>Configure the I2C address of the only sensor connected to the device. It is recommanded to put the the device in maintenance mode before changing Sensors addresses. This method is only intended to work with a single sensor connected to the device, if several sensors are connected, result is unpredictible. Note that the device is probably expecting to find a string of sensors with specific addresses. Check the device documentation to find out which addresses should be used.</p>',par:{addr:'new address of the connected sensor'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMultiSensorController unmuteValueCallbacks',pro:'YMultiSensorController <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: MultiSensorController)
//--- (generated code: MultiSensController)
doc['MultiSensController']={'':{syn:'MultiSensController function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiSensController']['get_advertisedValue']={syn:'Returns the current value of the multi-sensor controller (no more than 6 characters).',lib:'YMultiSensController get_advertisedValue',pro:'YMultiSensController <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the multi-sensor controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-sensor controller (no more than 6 characters).',ext:''};
doc['MultiSensController']['get_logicalName']={syn:'Returns the logical name of the multi-sensor controller.',lib:'YMultiSensController get_logicalName',pro:'YMultiSensController <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the multi-sensor controller.</p>',ret:'a string corresponding to the logical name of the multi-sensor controller.',ext:''};
doc['MultiSensController']['get_maintenanceMode']={syn:'Returns true when the device is in maintenance mode.',lib:'YMultiSensController get_maintenanceMode',pro:'YMultiSensController <span id=pn>target</span> get_maintenanceMode',cmt:'<p>Returns true when the device is in maintenance mode.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true when the device is in maintenance mode',ext:''};
doc['MultiSensController']['get_maxSensors']={syn:'Returns the maximum configurable sensor count allowed on this device.',lib:'YMultiSensController get_maxSensors',pro:'YMultiSensController <span id=pn>target</span> get_maxSensors',cmt:'<p>Returns the maximum configurable sensor count allowed on this device.</p>',ret:'an integer corresponding to the maximum configurable sensor count allowed on this device',ext:''};
doc['MultiSensController']['get_nSensors']={syn:'Returns the number of sensors to poll.',lib:'YMultiSensController get_nSensors',pro:'YMultiSensController <span id=pn>target</span> get_nSensors',cmt:'<p>Returns the number of sensors to poll.</p>',ret:'an integer corresponding to the number of sensors to poll',ext:''};
doc['MultiSensController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YMultiSensController muteValueCallbacks',pro:'YMultiSensController <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['MultiSensController']['set_logicalName']={syn:'Changes the logical name of the multi-sensor controller.',lib:'YMultiSensController set_logicalName',pro:'YMultiSensController <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the multi-sensor controller.</p>',par:{newval:'a string corresponding to the logical name of the multi-sensor controller.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensController']['set_maintenanceMode']={syn:'Changes the device mode to enable maintenance and stop sensors polling.',lib:'YMultiSensController set_maintenanceMode',pro:'YMultiSensController <span id=pn>target</span> set_maintenanceMode <span id=pn>newval</span>',cmt:'<p>Changes the device mode to enable maintenance and stop sensors polling. This way, the device will not restart automatically in case it cannot communicate with one of the sensors.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the device mode to enable maintenance and stop sensors polling'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensController']['set_nSensors']={syn:'Changes the number of sensors to poll.',lib:'YMultiSensController set_nSensors',pro:'YMultiSensController <span id=pn>target</span> set_nSensors <span id=pn>newval</span>',cmt:'<p>Changes the number of sensors to poll. It\x27s recommended to restart the device with <tt>module->reboot()</tt> after modifying (and saving) this settings</p>',par:{newval:'an integer corresponding to the number of sensors to poll'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['MultiSensController']['setupAddress']={syn:'Configure the I2C address of the only sensor connected to the device.',lib:'YMultiSensController setupAddress',pro:'YMultiSensController <span id=pn>target</span> setupAddress <span id=pn>addr</span>',cmt:'<p>Configure the I2C address of the only sensor connected to the device. It is recommended to put the the device in maintenance mode before changing Sensors addresses. This method is only intended to work with a single sensor connected to the device, if several sensors are connected, result is unpredictable. Note that the device is probably expecting to find a string of sensors with specific addresses. Check the device documentation to find out which addresses should be used.</p>',par:{addr:'new address of the connected sensor'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YMultiSensController unmuteValueCallbacks',pro:'YMultiSensController <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: MultiSensController)
//--- (generated code: Tvoc)
doc['Tvoc']={'':{syn:'Tvoc function interface',inc:'',cmt:'<p>The Yoctopuce class YTvoc allows you to read and configure Yoctopuce Total Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Tvoc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YTvoc calibrateFromPoints',pro:'YTvoc <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTvoc get_advMode',pro:'YTvoc <span id=pn>target</span> get_advMode',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:''};
doc['Tvoc']['get_advertisedValue']={syn:'Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',lib:'YTvoc get_advertisedValue',pro:'YTvoc <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',ext:''};
doc['Tvoc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.',lib:'YTvoc get_currentRawValue',pro:'YTvoc <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number',ext:''};
doc['Tvoc']['get_currentValue']={syn:'Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number.',lib:'YTvoc get_currentValue',pro:'YTvoc <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated TVOC concentration, in ppb, as a floating point number',ext:''};
doc['Tvoc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated TVOC concentration since the device was started.',lib:'YTvoc get_highestValue',pro:'YTvoc <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated TVOC concentration since the device was started',ext:''};
doc['Tvoc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YTvoc get_logFrequency',pro:'YTvoc <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Tvoc']['get_logicalName']={syn:'Returns the logical name of the Total Volatile Organic Compound sensor.',lib:'YTvoc get_logicalName',pro:'YTvoc <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the Total Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.',ext:''};
doc['Tvoc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated TVOC concentration since the device was started.',lib:'YTvoc get_lowestValue',pro:'YTvoc <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated TVOC concentration since the device was started',ext:''};
doc['Tvoc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YTvoc get_recordedData',pro:'YTvoc <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tvoc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YTvoc get_reportFrequency',pro:'YTvoc <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Tvoc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YTvoc get_resolution',pro:'YTvoc <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Tvoc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YTvoc get_sensorState',pro:'YTvoc <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Tvoc']['get_unit']={syn:'Returns the measuring unit for the estimated TVOC concentration.',lib:'YTvoc get_unit',pro:'YTvoc <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the estimated TVOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated TVOC concentration',ext:''};
doc['Tvoc']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YTvoc isSensorReady',pro:'YTvoc <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Tvoc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YTvoc loadCalibrationPoints',pro:'YTvoc <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'YTvoc muteValueCallbacks',pro:'YTvoc <span id=pn>target</span> muteValueCallbacks',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Tvoc']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'YTvoc set_advMode',pro:'YTvoc <span id=pn>target</span> set_advMode <span id=pn>newval</span>',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>IMMEDIATE</tt>, <tt>PERIOD_AVG</tt>, <tt>PERIOD_MIN</tt> and <tt>PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YTvoc set_highestValue',pro:'YTvoc <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YTvoc set_logFrequency',pro:'YTvoc <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_logicalName']={syn:'Changes the logical name of the Total Volatile Organic Compound sensor.',lib:'YTvoc set_logicalName',pro:'YTvoc <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the Total Volatile Organic Compound sensor.</p>',par:{newval:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YTvoc set_lowestValue',pro:'YTvoc <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YTvoc set_reportFrequency',pro:'YTvoc <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YTvoc set_resolution',pro:'YTvoc <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tvoc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YTvoc startDataLogger',pro:'YTvoc <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Tvoc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YTvoc stopDataLogger',pro:'YTvoc <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Tvoc']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'YTvoc unmuteValueCallbacks',pro:'YTvoc <span id=pn>target</span> unmuteValueCallbacks',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Tvoc)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

