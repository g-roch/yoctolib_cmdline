Remove librairy used from libyocto-dev
--- a/Sources/cpplib/yapi/yapi.c
+++ /dev/null
@@ -1,5937 +0,0 @@
-/*********************************************************************
- *
- * $Id: yapi.c 33735 2018-12-14 16:06:53Z seb $
- *
- * Implementation of public entry points to the low-level API
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__  "yapi"
-#include "yapi.h"
-#include "yproto.h"
-#include "yhash.h"
-#include "yjson.h"
-#include "yprog.h"
-
-#ifdef WINDOWS_API
-#include <time.h>
-#else
-#include <sys/time.h>
-#endif
-
-static YRETCODE yapiUpdateDeviceList_internal(u32 forceupdate, char* errmsg);
-static void yapiUnregisterHub_internal(const char* url);
-static YRETCODE yapiPreregisterHub_internal(const char* url, char* errmsg);
-static YRETCODE yapiHandleEvents_internal(char* errmsg);
-static YRETCODE yapiHTTPRequestAsyncEx_internal(int tcpchan, const char* device, const char* request, int len, yapiRequestAsyncCallback callback, void* context, char* errmsg);
-
-//#define DEBUG_YAPI_REQ
-
-
-#ifdef DEBUG_YAPI_REQ
-
-#include <direct.h>
-#include <stdio.h>
-#define FILE_NO_BIT_MASK 0XFFF
-
-static yCRITICAL_SECTION   YREQ_CS;
-static int global_req_count = 0;
-
-static int write_onfile(int fileno, char *mode, const char *firstline, int firstline_len, const char * buffer, int bufferlen)
-{
-    char filename[128];
-    FILE *f;
-    int retry_count = 1;
-    YSPRINTF(filename, 128,"req_trace\\req_%03d.bin", fileno);
-    // write on file
-retry:
-    if (YFOPEN(&f, filename, mode) != 0) {
-        if (retry_count--){
-            _mkdir("req_trace");
-            goto retry;
-        }
-        return -1;
-    }
-    fwrite(firstline, 1, firstline_len, f);
-    if (buffer) {
-        fwrite(buffer, 1, bufferlen, f);
-    }
-    fclose(f);
-    return 0;
-}
-
-
-
-
-
-static int YREQ_LOG_START(const char *msg, const char *device, const char * request, int requestsize)
-{
-    char buffer[2048], buffer2[64];
-    struct tm timeinfo;
-    time_t rawtime;
-    int threadIdx, count, first_len;
-    int fileno;
-
-    //we may need to add mutex here
-    yEnterCriticalSection(&YREQ_CS);
-    count = global_req_count++;
-    yLeaveCriticalSection(&YREQ_CS);
-    fileno = count & FILE_NO_BIT_MASK;
-    // compute time string
-    time(&rawtime);
-    localtime_s(&timeinfo, &rawtime);
-    strftime(buffer2, sizeof(buffer2), "%Y-%m-%d %H:%M:%S", &timeinfo);
-    //format first info line
-    threadIdx = yThreadIndex();
-    first_len = YSPRINTF(buffer, 2048, "[%s/%"FMTu64"](%d):no=%d = %s on %s\n",buffer2, yapiGetTickCount(), threadIdx, count, msg, device);
-    write_onfile(fileno, "wb", buffer, first_len, request, requestsize);
-    return count;
-}
-
-static int YREQ_LOG_APPEND(int count, const char *msg, const char * response, int responsesize, u64 start_tm)
-{
-    char buffer[2048], buffer2[64];
-    struct tm timeinfo;
-    time_t rawtime;
-    int threadIdx, first_len;
-
-    int fileno = count & FILE_NO_BIT_MASK;
-    // compute time string
-    time(&rawtime);
-    localtime_s(&timeinfo, &rawtime);
-    strftime(buffer2, sizeof(buffer2), "%Y-%m-%d %H:%M:%S", &timeinfo);
-    //format first info line
-    threadIdx = yThreadIndex();
-    first_len = YSPRINTF(buffer, 2048, "[%s/%"FMTu64"](%d):no=%d : %s responsesize=%d\n",buffer2, yapiGetTickCount() - start_tm, threadIdx, count, msg, responsesize);
-    // write on file
-    write_onfile(fileno, "ab", buffer, first_len, response, responsesize);
-    return count;
-}
-
-static int YREQ_LOG_APPEND_ERR(int count, const char *msg, const char *errmsg, int error, u64 start_tm)
-{
-    char buffer[2048], buffer2[64];
-    struct tm timeinfo;
-    time_t rawtime;
-    int threadIdx, first_len;
-
-    int fileno = count & FILE_NO_BIT_MASK;
-    // compute time string
-    time(&rawtime);
-    localtime_s(&timeinfo, &rawtime);
-    strftime(buffer2, sizeof(buffer2), "%Y-%m-%d %H:%M:%S", &timeinfo);
-    //format first info line
-    threadIdx = yThreadIndex();
-    first_len = YSPRINTF(buffer, 2048, "[%s/%"FMTu64"](%d):no=%d : %s errmsg(%d)=%s\n", buffer2, yapiGetTickCount()- start_tm, threadIdx, count, msg, error, errmsg);
-    // write on file
-    write_onfile(fileno, "ab", buffer, first_len, NULL, 0);
-    return count;
-}
-#endif
-
-
-//#define DEBUG_CALLBACK
-
-#ifdef DEBUG_CALLBACK
-
-
-#include <direct.h>
-static int global_callback_count = 0;
-
-static write_cb_onfile(YAPI_FUNCTION fundescr, const char *value)
-{
-    char filename[128];
-    FILE *f;
-    int retry_count = 1;
-    int fileno = global_callback_count >> 16;
-    char *mode ="ab";
-    char buffer[2048], buffer2[64];
-    struct tm timeinfo;
-    time_t rawtime;
-    int threadIdx, bufferlen;
-    char serial[YOCTO_SERIAL_LEN], funcId[YOCTO_FUNCTION_LEN];
-
-    if ((global_callback_count & 0xffff) == 0) {
-        mode = "wb";
-    }
-
-    YSPRINTF(filename, 128,"callback_trace\\callback_%d.txt", fileno);
-    // compute time string
-    time(&rawtime);
-    localtime_s(&timeinfo, &rawtime);
-    strftime(buffer2, sizeof(buffer2), "%Y-%m-%d %H:%M:%S", &timeinfo);
-    //format first info line
-    threadIdx = yThreadIndex();
-    if (value == NULL){
-        value = "(NULL)";
-    }
-    if(ypGetFunctionInfo(fundescr, serial, funcId, NULL, NULL) < 0){
-        bufferlen = YSPRINTF(buffer, 2048, "[%s/%"FMTu64"](%d):no=%d : invalid function ID (%X)\n",buffer2, yapiGetTickCount(), threadIdx, global_callback_count, fundescr);
-    }else {
-        bufferlen = YSPRINTF(buffer, 2048, "[%s/%"FMTu64"](%d):no=%d : %s.%s (%X)=%s\n",buffer2, yapiGetTickCount(), threadIdx, global_callback_count, serial,funcId, fundescr, value);
-    }
-    global_callback_count++;
-
-
-    // write on file
-retry:
-    if (YFOPEN(&f, filename, mode) != 0) {
-        if (retry_count--){
-            _mkdir("callback_trace");
-            goto retry;
-        }
-        return -1;
-    }
-    fwrite(buffer, 1, bufferlen, f);
-    fclose(f);
-    return 0;
-}
-
-static write_timedcb_onfile(YAPI_FUNCTION fundescr, double deviceTime, const u8 *report, u32 len)
-{
-    char buffer[256];
-    YSPRINTF(buffer, 2048, "Timed %f %p:%u",deviceTime, report, len);
-    return write_cb_onfile(fundescr, buffer);
-}
-
-#endif
-
-
-void yFunctionUpdate(YAPI_FUNCTION fundescr, const char* value)
-{
-    if (yContext->functionCallback) {
-        yEnterCriticalSection(&yContext->functionCallbackCS);
-#ifdef DEBUG_CALLBACK
-        write_cb_onfile(fundescr, value);
-#endif
-        yContext->functionCallback(fundescr, value);
-        yLeaveCriticalSection(&yContext->functionCallbackCS);
-    }
-}
-
-void yFunctionTimedUpdate(YAPI_FUNCTION fundescr, u64 deviceTimeMs, u64 durationMs, const u8* report, u32 len)
-{
-    if (yContext->timedReportCallback) {
-        double duration = 0;
-        if (durationMs > 0) {
-            duration = durationMs / 1000.0;
-        }
-        yEnterCriticalSection(&yContext->functionCallbackCS);
-#ifdef DEBUG_CALLBACK
-        write_timedcb_onfile(fundescr, deviceTime, report, len);
-#endif
-        yContext->timedReportCallback(fundescr, deviceTimeMs / 1000.0, report, len, duration);
-        yLeaveCriticalSection(&yContext->functionCallbackCS);
-    }
-}
-
-
-/*****************************************************************************
- Internal functions for hub enumeration
- ****************************************************************************/
-
-typedef enum
-{
-    ENU_HTTP_START,
-    ENU_JSON_START,
-    ENU_API,
-    ENU_MODULE_START,
-    ENU_MODULE,
-    ENU_MODULE_FIRMWARE,
-    ENU_NETWORK_START,
-    ENU_NETWORK,
-    ENU_NET_ADMINPWD,
-    ENU_SERVICE,
-    ENU_WP_START,
-    ENU_WP_ARRAY,
-    ENU_WP_ENTRY,
-    ENU_WP_SERIAL,
-    ENU_WP_LOGICALNAME,
-    ENU_WP_PRODUCTNAME,
-    ENU_WP_PRODUCTID,
-    ENU_WP_DEVURL,
-    ENU_WP_BEACON,
-    ENU_WP_INDEX,
-    ENU_YP_CONTENT,
-    ENU_YP_TYPE,
-    ENU_YP_TYPE_LIST,
-    ENU_YP_ARRAY,
-    ENU_YP_ENTRY,
-    ENU_YP_BASETYPE,
-    ENU_YP_HARDWAREID,
-    ENU_YP_LOGICALNAME,
-    ENU_YP_PRODUCTNAME,
-    ENU_YP_ADVERTISEDVALUE,
-    ENU_YP_INDEX,
-    ENU_SKIP_FUNCTION_START,
-    ENU_SKIP_FUNCTION
-} ENU_PARSE_STATE;
-
-
-#ifdef DEBUG_NET_ENUM
-
-extern const char* yJsonStateStr[];
-const char* ENU_PARSE_STATE_STR[] =
-{
-    "ENU_HTTP_START",
-    "ENU_JSON_START",
-    "ENU_API",
-    "ENU_MODULE_START",
-    "ENU_MODULE",
-    "ENU_MODULE_FIRMWARE",
-    "ENU_NETWORK_START",
-    "ENU_NETWORK",
-    "ENU_NET_ADMINPWD",
-    "ENU_SERVICE",
-    "ENU_WP_START",
-    "ENU_WP_ARRAY",
-    "ENU_WP_ENTRY",
-    "ENU_WP_SERIAL",
-    "ENU_WP_LOGICALNAME",
-    "ENU_WP_PRODUCTNAME",
-    "ENU_WP_PRODUCTID",
-    "ENU_WP_DEVURL",
-    "ENU_WP_BEACON",
-    "ENU_WP_INDEX",
-    "ENU_YP_CONTENT",
-    "ENU_YP_TYPE",
-    "ENU_YP_TYPE_LIST",
-    "ENU_YP_ARRAY",
-    "ENU_YP_ENTRY",
-    "ENU_YP_BASETYPE",
-    "ENU_YP_HARDWAREID",
-    "ENU_YP_LOGICALNAME",
-    "ENU_YP_PRODUCTNAME",
-    "ENU_YP_ADVERTISEDVALUE",
-    "ENU_YP_INDEX",
-    "ENU_SKIP_FUNCTION_START",
-    "ENU_SKIP_FUNCTION"
-};
-#endif
-
-
-typedef enum
-{
-    WP_SERIAL,
-    WP_LOGICALNAME,
-    WP_PRODUCT,
-    WP_PROD_ID,
-    WP_NET_URL,
-    WP_BEACON,
-    WP_INDEX,
-    WP_DONE
-} ENU_WP_STATE;
-
-
-typedef enum
-{
-    YP_BASETYPE,
-    YP_HARDWAREID,
-    YP_LOGICALNAME,
-    YP_ADV_VAL,
-    YP_INDEX,
-    YP_DONE
-} ENU_YP_STATE;
-
-typedef struct
-{
-    HubSt* hub;
-    ENU_PARSE_STATE state;
-    yStrRef serial;
-    yStrRef logicalName;
-
-    union
-    {
-        struct
-        {
-            yStrRef productName;
-            u16 productId;
-            yUrlRef hubref;
-            s8 beacon;
-            u8 devYdx;
-        };
-
-        struct
-        {
-            yStrRef ypCateg;
-            yStrRef funcId;
-            char advertisedValue[YOCTO_PUBVAL_LEN];
-            u8 funClass;
-            u8 funYdx;
-        };
-    };
-
-    ENU_YP_STATE yp_state;
-    ENU_WP_STATE wp_state;
-    int nbKnownDevices;
-    yStrRef* knownDevices;
-} ENU_CONTEXT;
-
-
-// return 1 -> if this we should use devUrl instead of registered URL
-static int wpSafeCheckOverwrite(yUrlRef registeredUrl, HubSt* hub, yUrlRef devUrl)
-{
-    yAsbUrlType urlType = yHashGetUrlPort(devUrl, NULL, NULL, NULL, NULL, NULL, NULL);
-    yAsbUrlType registeredType;
-
-    if (urlType == USB_URL) {
-        // no USB device can unregister previous devices
-#ifdef  DEBUG_WP
-        dbglog("no USB device can unregister previous devices ( 0x%X) \n",devUrl);
-#endif
-        return 0;
-    }
-    registeredType = yHashGetUrlPort(registeredUrl, NULL, NULL, NULL, NULL, NULL, NULL);
-    if (registeredType == USB_URL) {
-#ifdef DEBUG_WP
-        dbglog("unregister same device connected by USB ( 0x%X vs 0x%X) \n",devUrl,hub->url);
-#endif
-        return 1;
-    } else {
-        if (registeredUrl != devUrl) {
-            if (devUrl == hub->url) {
-#ifdef DEBUG_WP
-                dbglog("unregister same device connected by a VirtualHub (0x%X vs 0x%X) \n",devUrl,hub->url);
-#endif
-                return 1;
-            }
-        }
-    }
-    return 0;
-}
-
-
-/*****************************************************************************
- * Generic device information stuff
- ***************************************************************************/
-
-void initDevYdxInfos(int devYdx, yStrRef serial)
-{
-    yGenericDeviceSt* gen = yContext->generic_infos + devYdx;
-    YASSERT(devYdx < ALLOC_YDX_PER_HUB);
-    yEnterCriticalSection(&yContext->generic_cs);
-    memset(gen, 0, sizeof(yGenericDeviceSt));
-    gen->serial = serial;
-    yLeaveCriticalSection(&yContext->generic_cs);
-}
-
-void freeDevYdxInfos(int devYdx)
-{
-    yGenericDeviceSt* gen = yContext->generic_infos + devYdx;
-    YASSERT(devYdx < ALLOC_YDX_PER_HUB);
-    yEnterCriticalSection(&yContext->generic_cs);
-    gen->serial = YSTRREF_EMPTY_STRING;
-    yLeaveCriticalSection(&yContext->generic_cs);
-}
-
-static void logResult(void* context, const u8* result, u32 resultlen, int retcode, const char* errmsg)
-{
-    char buffer[512];
-    yGenericDeviceSt* gen = (yGenericDeviceSt*)context;
-    int poslen;
-    const char* p = (char*)result;
-    const char* start = (char*)result;
-
-    if (yContext == NULL || yContext->logDeviceCallback == NULL)
-        return;
-
-    if (resultlen < 4) {
-        return; //invalid packet
-    }
-
-    if (result == NULL || start[0] != 'O' || start[1] != 'K') {
-        return; // invalid response
-    }
-    // drop http header
-    while (resultlen >= 4) {
-        if (p[0] == '\r' && p[1] == '\n' && p[2] == '\r' && p[3] == '\n') {
-            resultlen -= 4;
-            p += 4;
-            break;
-        }
-        p++;
-        resultlen--;
-    }
-    start = p;
-    //look of '@pos'
-    p = start + resultlen - 1;
-    poslen = 0;
-    while (p > start && *p != '@') {
-        if (*p < '0' || *p > '9') {
-            poslen = 0;
-        } else {
-            poslen++;
-        }
-        p--;
-        resultlen--;
-    }
-
-    if (*p != '@') {
-        return;
-    }
-
-    memcpy(buffer, p + 1, poslen);
-    buffer[poslen] = '\0';
-    //remove empty line before @pos
-    if (resultlen == 0)
-        return;
-    resultlen -= 2;
-    p = start;
-    yEnterCriticalSection(&yContext->generic_cs);
-    gen->deviceLogPos = atoi(buffer);
-    yLeaveCriticalSection(&yContext->generic_cs);
-    while (resultlen) {
-        if (*p == '\n') {
-            int linelen = (int)(p - start);
-            memcpy(buffer, start, linelen);
-            buffer[linelen] = '\0';
-            //dbglog("log:[%s]\n", buffer);
-            yContext->logDeviceCallback(gen->serial, buffer);
-            start = p + 1;
-        }
-        p++;
-        resultlen--;
-    }
-    yEnterCriticalSection(&yContext->generic_cs);
-    gen->flags &= ~(DEVGEN_LOG_PENDING | DEVGEN_LOG_PULLING);
-    yLeaveCriticalSection(&yContext->generic_cs);
-}
-
-static int yapiRequestOpenWS(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, int tcpchan, const char* request, int reqlen, u64 mstimeout, yapiRequestAsyncCallback callback, void* context, RequestProgress progress_cb, void* progress_ctx, char* errmsg);
-static int yapiRequestOpenHTTP(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, const char* request, int reqlen, int wait_for_start, u64 mstimeout, yapiRequestAsyncCallback callback, void* context, char* errmsg);
-static int yapiRequestOpenUSB(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, const char* request, int reqlen, u64 unused_timeout, yapiRequestAsyncCallback callback, void* context, char* errmsg);
-
-
-YRETCODE yapiPullDeviceLogEx(int devydx)
-{
-    YRETCODE res;
-    int used;
-    char rootdevice[YOCTO_SERIAL_LEN];
-    char request[512];
-    int reqlen;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char* p;
-    YAPI_DEVICE dev;
-    u32 logPos;
-    int doPull = 0;
-    yGenericDeviceSt* gen;
-    yStrRef serialref;
-    YIOHDL_internal iohdl;
-    yUrlRef url;
-    yAsbUrlProto proto;
-    int i;
-    HubSt* hub = NULL;
-
-    yEnterCriticalSection(&yContext->generic_cs);
-    gen = yContext->generic_infos + devydx;
-    if ((gen->flags & DEVGEN_LOG_ACTIVATED) &&
-        (gen->flags & DEVGEN_LOG_PENDING) &&
-        (gen->flags & DEVGEN_LOG_PULLING) == 0) {
-        doPull = 1;
-        gen->flags |= DEVGEN_LOG_PULLING;
-    }
-    logPos = gen->deviceLogPos;
-    serialref = gen->serial;
-    yLeaveCriticalSection(&yContext->generic_cs);
-    if (serialref == YSTRREF_EMPTY_STRING || !doPull) {
-        return YAPI_SUCCESS;
-    }
-    dev = wpSearchEx(serialref);
-    YSTRCPY(request, 512, "GET ");
-    p = request + 4;
-    res = yapiGetDevicePath(dev, rootdevice, p, 512 - 5, NULL, errmsg);
-    if (YISERR(res)) {
-        dbglog(errmsg);
-        if (res != YAPI_DEVICE_NOT_FOUND) {
-            yEnterCriticalSection(&yContext->generic_cs);
-            gen->flags &= ~DEVGEN_LOG_PULLING;
-            yLeaveCriticalSection(&yContext->generic_cs);
-        }
-        return res;
-    }
-#ifdef TRACE_NET_HUB
-    dbglog("TRACE pull device log\n");
-#endif
-    used = YSTRLEN(request);
-    p = request + used;
-    YSPRINTF(p, 512 - used, "logs.txt?pos=%d \r\n\r\n", logPos);
-    reqlen = YSTRLEN(request);
-    memset(&iohdl, 0, sizeof(YIOHDL_internal));
-    // compute request timeout
-    // dispatch request on correct hub (or pseudo usb HUB)
-    url = wpGetDeviceUrlRef(dev);
-    errmsg[0] = 0;
-    switch (yHashGetUrlPort(url, NULL, NULL, &proto, NULL, NULL, NULL)) {
-    case USB_URL:
-        res = yapiRequestOpenUSB(&iohdl, NULL, dev, request, reqlen, YIO_10_MINUTES_TCP_TIMEOUT, logResult, (void*)gen, errmsg);
-        break;
-    default:
-        for (i = 0; i < NBMAX_NET_HUB; i++) {
-            if (yContext->nethub[i] && yHashSameHub(yContext->nethub[i]->url, url)) {
-                hub = yContext->nethub[i];
-                break;
-            }
-        }
-        if (hub == NULL) {
-            res = YERR(YAPI_DEVICE_NOT_FOUND);
-        } else {
-            if (proto == PROTO_WEBSOCKET) {
-                res = yapiRequestOpenWS(&iohdl, hub, dev, 0, request, reqlen, YIO_10_MINUTES_TCP_TIMEOUT, logResult, (void*)gen, NULL, NULL, errmsg);
-            } else {
-                res = yapiRequestOpenHTTP(&iohdl, hub, dev, request, reqlen, 0, YIO_10_MINUTES_TCP_TIMEOUT, logResult, (void*)gen, errmsg);
-            }
-        }
-    }
-
-#ifdef TRACE_NET_HUB
-    dbglog("TRACE pull returned %d:%s\n",res,errmsg);
-#endif
-    if (YISERR(res)) {
-        yEnterCriticalSection(&yContext->generic_cs);
-        gen->flags &= ~DEVGEN_LOG_PULLING;
-        yLeaveCriticalSection(&yContext->generic_cs);
-        return res;
-    }
-    return res;
-}
-
-
-YRETCODE yapiPullDeviceLog(const char* serial)
-{
-    YAPI_DEVICE dev;
-    int devydx;
-    dev = wpSearch(serial);
-
-    devydx = wpGetDevYdx(dev % 0xffff);
-    if (devydx < 0) {
-        return YAPI_DEVICE_NOT_FOUND;
-    }
-    return yapiPullDeviceLogEx(devydx);
-}
-
-
-/*****************************************************************************
-  Function:
-    void wpSafeRegister( yUrlRef hubUrl, u8 devYdx, yStrRef serialref,yStrRef lnameref, yStrRef productref, u16 deviceid, yUrlRef devUrl,s8 beacon)
-
-  Description:
-    Register a new device into whites page (and yellow page of the module function ). This function
-    will call the arrivalCallback. This function will work for usb and TCP
-    it will check if this arrival should be dropped (if an hub is connected by usb and ip)
-
-  Parameters:
-    NetHubSt *hub       : HUB used to access the device (for USB this MUSB be NULL)
-    u8 devYdx           : the devYdy relative to the hub (for usb this MUST be MAX_YDX_PER_HUB)
-    yStrRef serialref   : the serial of the device
-    yStrRef lnameref    : the logical name of the device
-    yStrRef productref  : the product name of the device
-    u16 deviceid        : the deviceid of the device
-    yUrlRef devUrl      : the url of the device (not the one of the hub).
-    s8 beacon           : the beacon state
-{
-
- ***************************************************************************/
-void wpSafeRegister(HubSt* hub, u8 devYdx, yStrRef serialref, yStrRef lnameref, yStrRef productref, u16 deviceid, yUrlRef devUrl, s8 beacon)
-{
-    yUrlRef registeredUrl = wpGetDeviceUrlRef(serialref);
-#ifdef DEBUG_WP
-    {
-        if (hub == NULL){
-            dbglog("SAFE WP: register %s(0x%X) form USB\n",yHashGetStrPtr(serialref),serialref);
-        } else {
-            char host[YOCTO_HOSTNAME_NAME];
-            u16  port;
-            yAsbUrlType type = yHashGetUrlPort(hub->url, host, &port, NULL, NULL, NULL, NULL);
-            dbglog("SAFE WP: register %s(0x%X) from %s:%u\n",yHashGetStrPtr(serialref),serialref,host,port);
-            dbglog("url    : hub = %d  dev =%d\n",hub->url,devUrl);
-        }
-
-    }
-    dbglog("name    : %s(0x%X)\n",yHashGetStrPtr(lnameref),lnameref);
-    dbglog("product : %s(0x%X)\n",yHashGetStrPtr(productref),productref);
-    dbglog("device : %x (%d)\n",deviceid,beacon);
-#endif
-
-    if (registeredUrl != INVALID_HASH_IDX && wpSafeCheckOverwrite(registeredUrl, hub, devUrl)) {
-        wpSafeUnregister(serialref);
-    }
-    wpRegister(-1, serialref, lnameref, productref, deviceid, devUrl, beacon);
-    ypRegister(YSTRREF_MODULE_STRING, serialref, YSTRREF_mODULE_STRING, lnameref, YOCTO_AKA_YFUNCTION, -1, NULL);
-    if (hub && devYdx < MAX_YDX_PER_HUB) {
-        // Update hub-specific devYdx mapping between enus->devYdx and our wp devYdx
-        hub->devYdxMap[devYdx] = wpGetDevYdx(serialref);
-    }
-    // Forward high-level notification to API user
-    if (yContext->arrivalCallback) {
-        yEnterCriticalSection(&yContext->deviceCallbackCS);
-        yContext->arrivalCallback(serialref);
-        yLeaveCriticalSection(&yContext->deviceCallbackCS);
-    }
-}
-
-
-/*****************************************************************************
-  Function:
-    void wpSafeUpdate( yUrlRef hubUrl,u8 devYdx, yStrRef serialref,yStrRef lnameref, yUrlRef devUrl, s8 beacon)
-
-  Description:
-    Update whites page (and yellow page of the module function ). This function
-    will call the changeCallback if needed. This function will work for usb and TCP
-    it will check if this update should be dropped (if an hub is connected by usb and ip)
-
-  Parameters:
-    For TCP:
-        NetHubSt *hub       : HUB used to access the device (for USB this MUSB be NULL)
-        u8 devYdx           : the devYdy relative to the hub (for usb this MUST be MAX_YDX_PER_HUB)
-        yStrRef serialref   : the serial of the device
-        yStrRef lnameref    : the logical name of the device
-        yUrlRef devUrl      : the url of the device (not the one of the hub).
-        s8 beacon           : the beacon state
-
- ***************************************************************************/
-void wpSafeUpdate(HubSt* hub, u8 devYdx, yStrRef serialref, yStrRef lnameref, yUrlRef devUrl, s8 beacon)
-{
-    int reg;
-    yUrlRef registeredUrl = wpGetDeviceUrlRef(serialref);
-#ifdef DEBUG_WP
-    {
-        if (hub == NULL){
-            dbglog("SAFE WP: update %s(0x%X) form USB\n",yHashGetStrPtr(serialref),serialref);
-        } else {
-            char host[YOCTO_HOSTNAME_NAME];
-            u16  port;
-            yAsbUrlType type = yHashGetUrlPort(hub->url, host, &port, NULL, NULL, NULL, NULL);
-            dbglog("SAFE WP: update %s(0x%X) from %s:%u\n",yHashGetStrPtr(serialref),serialref,host,port);
-            dbglog("url    : hub = %d  dev =%d\n",hub->url,devUrl);
-        }
-    }
-    dbglog("name    : %s(0x%X)\n",yHashGetStrPtr(lnameref),lnameref);
-    dbglog("product : INVALID_HASH_IDX\n");
-    dbglog("device : %x (%d)\n",0,beacon);
-#endif
-
-    if (registeredUrl != INVALID_HASH_IDX && wpSafeCheckOverwrite(registeredUrl, hub, devUrl)) {
-#ifdef DEBUG_WP
-        dbglog("SAFE WP: drop update %s(0x%X)\n",yHashGetStrPtr(serialref),serialref);
-#endif
-        return;
-    }
-    reg = wpRegister(-1, serialref, lnameref, INVALID_HASH_IDX, 0, devUrl, beacon);
-    if (reg) {
-        if (reg & 1) {
-            ypRegister(YSTRREF_MODULE_STRING, serialref, YSTRREF_mODULE_STRING, lnameref, YOCTO_AKA_YFUNCTION, -1, NULL);
-            if (hub && devYdx < MAX_YDX_PER_HUB) {
-                // Update hub-specific devYdx mapping between enus->devYdx and our wp devYdx
-                hub->devYdxMap[devYdx] = wpGetDevYdx(serialref);
-            }
-            // Forward high-level notification to API user
-            if (yContext->changeCallback) {
-                yEnterCriticalSection(&yContext->deviceCallbackCS);
-                yContext->changeCallback(serialref);
-                yLeaveCriticalSection(&yContext->deviceCallbackCS);
-            }
-        }
-        if (reg & 2) {
-            if (yContext->beaconCallback) {
-                yEnterCriticalSection(&yContext->functionCallbackCS);
-                yContext->beaconCallback(serialref, beacon);
-                yLeaveCriticalSection(&yContext->functionCallbackCS);
-            }
-        }
-    }
-}
-
-
-void wpSafeUnregister(yStrRef serialref)
-{
-    wpPreventUnregister();
-    if (wpMarkForUnregister(serialref)) {
-        // Forward high-level notification to API user before deleting data
-        if (yContext->removalCallback) {
-            yEnterCriticalSection(&yContext->deviceCallbackCS);
-            yContext->removalCallback(serialref);
-            yLeaveCriticalSection(&yContext->deviceCallbackCS);
-        }
-    }
-    wpAllowUnregister();
-}
-
-static void parseNetWpEntry(ENU_CONTEXT* enus)
-{
-    int i;
-
-    for (i = 0; i < enus->nbKnownDevices; i++) {
-        if (enus->knownDevices[i] != INVALID_HASH_IDX &&
-            enus->knownDevices[i] == enus->serial) {
-            // mark the device as present (we sweep it later)
-#ifdef DEBUG_WP
-                dbglog("parseNetWpEntry %X (%s) was present\n",enus->serial,yHashGetStrPtr(enus->serial));
-#endif
-            enus->knownDevices[i] = INVALID_HASH_IDX;
-            break;
-        }
-    }
-
-    if (i == enus->nbKnownDevices) {
-        wpSafeRegister(enus->hub, enus->devYdx, enus->serial, enus->logicalName, enus->productName, enus->productId, enus->hubref, enus->beacon);
-    } else {
-        wpSafeUpdate(enus->hub, enus->devYdx, enus->serial, enus->logicalName, enus->hubref, enus->beacon);
-    }
-}
-
-static void unregisterNetDevice(yStrRef serialref)
-{
-    int devydx;
-
-    if (serialref == INVALID_HASH_IDX) return;
-    // Free device tcp structure, if needed
-    devydx = wpGetDevYdx(serialref);
-    if (devydx >= 0 && yContext->tcpreq[devydx]) {
-        yReqFree(yContext->tcpreq[devydx]);
-        yContext->tcpreq[devydx] = NULL;
-    }
-    wpSafeUnregister(serialref);
-}
-
-static void ypUpdateNet(ENU_CONTEXT* enus)
-{
-    if (ypRegister(enus->ypCateg, enus->serial, enus->funcId, enus->logicalName, enus->funClass, enus->funYdx, enus->advertisedValue)) {
-        // Forward high-level notification to API user
-        yFunctionUpdate(((s32)enus->funcId << 16) | enus->serial, enus->advertisedValue);
-    }
-}
-
-
-static void disable_jzon(HubSt* hub)
-{
-    if ((hub->flags & INCOMPATIBLE_JZON_ENCODING) == 0) {
-        dbglog("Disable JZON encoding for hub %\n", hub->name);
-    }
-    hub->flags |= INCOMPATIBLE_JZON_ENCODING;
-}
-
-static int yEnuJson(ENU_CONTEXT* enus, yJsonStateMachine* j)
-{
-    char* point;
-#ifdef DEBUG_NET_ENUM
-    //dbglog("%s: %s %s\n",ENU_PARSE_STATE_STR[enus->state],yJsonStateStr[j->st],j->token);
-#endif
-    switch (enus->state) {
-    case ENU_HTTP_START:
-        if (j->st != YJSON_HTTP_READ_CODE || YSTRCMP(j->token,"200")) {
-            return YAPI_IO_ERROR;
-        }
-        enus->state = ENU_JSON_START;
-        break;
-    case ENU_JSON_START:
-        if (j->st == YJSON_HTTP_READ_MSG)
-            break;
-        if (j->st == YJSON_PARSE_ARRAY)
-            return YAPI_IO_ERROR;
-        if (j->st == YJSON_PARSE_STRING)
-            return YAPI_IO_ERROR;
-        enus->state = ENU_API;
-        break;
-    case ENU_API:
-        if (j->st != YJSON_PARSE_MEMBNAME)
-            break;
-        if (YSTRCMP(j->token, "module") == 0) {
-            enus->state = ENU_MODULE_START;
-        } else if (YSTRCMP(j->token, "network") == 0) {
-            enus->state = ENU_NETWORK_START;
-        } else if (YSTRCMP(j->token,"services") == 0) {
-            enus->state = ENU_SERVICE;
-        } else {
-            yJsonSkip(j, 1);
-        }
-        break;
-    case ENU_MODULE_START:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_MODULE;
-        }
-        break;
-    case ENU_MODULE:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_API;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token,"firmwareRelease") == 0) {
-                enus->state = ENU_MODULE_FIRMWARE;
-            } else {
-                yJsonSkip(j, 1);
-            }
-        }
-        break;
-    case ENU_MODULE_FIRMWARE:
-        NETENUMLOG("firmwareRelease is set to [%s]\n", j->token);
-        YSTRCPY(enus->hub->fw_release, YOCTO_FIRMWARE_LEN,j->token);
-        enus->state = ENU_MODULE;
-        break;
-    case ENU_NETWORK_START:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_NETWORK;
-        }
-        break;
-    case ENU_NETWORK:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_API;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token, "adminPassword") == 0) {
-                enus->state = ENU_NET_ADMINPWD;
-            } else {
-                yJsonSkip(j, 1);
-            }
-        }
-        break;
-    case ENU_NET_ADMINPWD:
-        NETENUMLOG("adminpwd is set to [%s]\n",j->token);
-        enus->hub->writeProtected = (j->token[0] != 0);
-        enus->state = ENU_NETWORK;
-        break;
-    case ENU_SERVICE:
-        if (j->st != YJSON_PARSE_MEMBNAME)
-            break;
-        if (YSTRCMP(j->token,"whitePages") == 0) {
-            enus->state = ENU_WP_START;
-        } else if (YSTRCMP(j->token,"yellowPages") == 0) {
-            enus->state = ENU_YP_CONTENT;
-        } else {
-            yJsonSkip(j, 1);
-        }
-        break;
-    case ENU_WP_START:
-        if (j->st == YJSON_PARSE_ARRAY) {
-            enus->state = ENU_WP_ARRAY;
-        }
-        break;
-    case ENU_WP_ARRAY:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_WP_ENTRY;
-            enus->serial = INVALID_HASH_IDX;
-            enus->logicalName = INVALID_HASH_IDX;
-            enus->productName = INVALID_HASH_IDX;
-            enus->productId = 0;
-            enus->hubref = INVALID_HASH_IDX;
-            enus->beacon = 0;
-            enus->devYdx = -1;
-            enus->wp_state = WP_SERIAL;
-        } else if (j->st == YJSON_PARSE_ARRAY) {
-            enus->state = ENU_SERVICE;
-        } else {
-            NETENUMLOG("Unknown token %s\n",j->token);
-        }
-        break;
-    case ENU_WP_ENTRY:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            parseNetWpEntry(enus);
-            enus->state = ENU_WP_ARRAY;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token,"serialNumber") == 0) {
-                enus->state = ENU_WP_SERIAL;
-                if (enus->wp_state != WP_SERIAL) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_LOGICALNAME;
-            } else if (YSTRCMP(j->token,"logicalName") == 0) {
-                enus->state = ENU_WP_LOGICALNAME;
-                if (enus->wp_state != WP_LOGICALNAME) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_PRODUCT;
-            } else if (YSTRCMP(j->token,"productName") == 0) {
-                enus->state = ENU_WP_PRODUCTNAME;
-                if (enus->wp_state != WP_PRODUCT) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_PROD_ID;
-            } else if (YSTRCMP(j->token,"productId") == 0) {
-                enus->state = ENU_WP_PRODUCTID;
-                if (enus->wp_state != WP_PROD_ID) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_NET_URL;
-            } else if (YSTRCMP(j->token,"networkUrl") == 0) {
-                enus->state = ENU_WP_DEVURL;
-                if (enus->wp_state != WP_NET_URL) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_BEACON;
-            } else if (YSTRCMP(j->token,"beacon") == 0) {
-                enus->state = ENU_WP_BEACON;
-                if (enus->wp_state != WP_BEACON) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_INDEX;
-            } else if (YSTRCMP(j->token,"index") == 0) {
-                enus->state = ENU_WP_INDEX;
-                if (enus->wp_state != WP_INDEX) {
-                    disable_jzon(enus->hub);
-                }
-                enus->wp_state = WP_DONE;
-            } else {
-                if (enus->wp_state != WP_DONE) {
-                    disable_jzon(enus->hub);
-                }
-                yJsonSkip(j, 1);
-            }
-        }
-        break;
-    case ENU_WP_SERIAL:
-        NETENUMLOG("set serial to %s\n",j->token);
-        enus->serial = yHashPutStr(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_LOGICALNAME:
-        NETENUMLOG("set Logical name to %s\n",j->token);
-        enus->logicalName = yHashPutStr(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_PRODUCTNAME:
-        NETENUMLOG("set Product name to %s\n",j->token);
-        enus->productName = yHashPutStr(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_PRODUCTID:
-        NETENUMLOG("set productid to %s\n",j->token);
-        enus->productId = atoi(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_DEVURL:
-        NETENUMLOG("set url to %s\n",j->token);
-        if (YSTRCMP(j->token, "/api") == 0) {
-            enus->hub->serial = enus->serial;
-        }
-        enus->hubref = yHashUrlFromRef(enus->hub->url, j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_BEACON:
-        NETENUMLOG("set beacon to %s\n",j->token);
-        enus->beacon = atoi(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_WP_INDEX:
-        NETENUMLOG("set devYdx to %s\n",j->token);
-        enus->devYdx = atoi(j->token);
-        enus->state = ENU_WP_ENTRY;
-        break;
-    case ENU_YP_CONTENT:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_YP_TYPE;
-            enus->ypCateg = INVALID_HASH_IDX;
-        } else {
-            NETENUMLOG("Unknown token %s\n",j->token);
-        }
-        break;
-    case ENU_YP_TYPE:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_SERVICE;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            enus->ypCateg = yHashPutStr(j->token);
-            NETENUMLOG("Categ = %s\n",j->token);
-            enus->state = ENU_YP_TYPE_LIST;
-        } else {
-            NETENUMLOG("Unknown token %s\n",j->token);
-        }
-        break;
-    case ENU_YP_TYPE_LIST:
-        if (j->st == YJSON_PARSE_ARRAY) {
-            enus->state = ENU_YP_ARRAY;
-        } else if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_SERVICE;
-        }
-        break;
-    case ENU_YP_ARRAY:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_YP_ENTRY;
-            enus->serial = INVALID_HASH_IDX;
-            enus->logicalName = INVALID_HASH_IDX;
-            enus->funcId = INVALID_HASH_IDX;
-            enus->funClass = YOCTO_AKA_YFUNCTION;
-            enus->funYdx = -1;
-            memset(enus->advertisedValue, 0, sizeof(enus->advertisedValue));
-            enus->yp_state = YP_BASETYPE;
-        } else if (j->st == YJSON_PARSE_ARRAY) {
-            enus->state = ENU_YP_TYPE;
-        } else {
-            NETENUMLOG("what is it %s \n",j->token);
-        }
-        break;
-    case ENU_YP_ENTRY:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            ypUpdateNet(enus);
-            enus->state = ENU_YP_ARRAY;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token,"baseType") == 0) {
-                enus->state = ENU_YP_BASETYPE;
-                if (enus->yp_state != YP_BASETYPE) {
-                    disable_jzon(enus->hub);
-                }
-                enus->yp_state = YP_HARDWAREID;
-
-            } else if (YSTRCMP(j->token,"hardwareId") == 0) {
-                enus->state = ENU_YP_HARDWAREID;
-                if (enus->yp_state != YP_HARDWAREID) {
-                    disable_jzon(enus->hub);
-                }
-                enus->yp_state = YP_LOGICALNAME;
-            } else if (YSTRCMP(j->token,"logicalName") == 0) {
-                enus->state = ENU_YP_LOGICALNAME;
-                if (enus->yp_state != YP_LOGICALNAME) {
-                    disable_jzon(enus->hub);
-                }
-                enus->yp_state = YP_ADV_VAL;
-            } else if (YSTRCMP(j->token,"advertisedValue") == 0) {
-                enus->state = ENU_YP_ADVERTISEDVALUE;
-                if (enus->yp_state != YP_ADV_VAL) {
-                    disable_jzon(enus->hub);
-                }
-                enus->yp_state = YP_INDEX;
-            } else if (YSTRCMP(j->token,"index") == 0) {
-                enus->state = ENU_YP_INDEX;
-                if (enus->yp_state != YP_INDEX) {
-                    disable_jzon(enus->hub);
-                }
-                enus->yp_state = YP_DONE;
-            } else {
-                yJsonSkip(j, 1);
-                if (enus->yp_state != YP_DONE) {
-                    disable_jzon(enus->hub);
-                }
-            }
-        }
-        break;
-
-    case ENU_YP_BASETYPE:
-        NETENUMLOG("set baseType value to %s\n",j->token);
-        enus->funClass = atoi(j->token);
-        enus->state = ENU_YP_ENTRY;
-        break;
-    case ENU_YP_HARDWAREID:
-        point = strchr(j->token, '.');
-        if (!point) break; //to be safe discard this field if we do not found '.'
-        *point++ = '\0';
-        NETENUMLOG("set serial  to %s\n",j->token);
-        enus->serial = yHashPutStr(j->token);
-        NETENUMLOG("set functionid  to %s\n",point);
-        enus->funcId = yHashPutStr(point);
-        enus->state = ENU_YP_ENTRY;
-        break;
-    case ENU_YP_LOGICALNAME:
-        NETENUMLOG("set function  to %s\n",j->token);
-        enus->logicalName = yHashPutStr(j->token);
-        enus->state = ENU_YP_ENTRY;
-        break;
-    case ENU_YP_ADVERTISEDVALUE:
-        NETENUMLOG("set advertised value to %s\n",j->token);
-        YSTRNCPY(enus->advertisedValue,YOCTO_PUBVAL_LEN,j->token,YOCTO_PUBVAL_SIZE);
-        enus->state = ENU_YP_ENTRY;
-        break;
-    case ENU_YP_INDEX:
-        NETENUMLOG("set funYdx value to %s\n",j->token);
-        enus->funYdx = atoi(j->token);
-        enus->state = ENU_YP_ENTRY;
-        break;
-    default:
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int parseFullAPI(HubSt* hub, ENU_CONTEXT* enus, u8* data, u32 datalen, char* errmsg)
-{
-    yJsonStateMachine j;
-    yJsonRetCode jstate = YJSON_NEED_INPUT;
-    // init yjson parser
-    memset(&j, 0, sizeof(j));
-    j.st = YJSON_HTTP_START;
-    enus->state = ENU_HTTP_START;
-    j.src = (char*)data;
-    j.end = (char*)data + datalen;
-    // parse all we can on this buffer
-    jstate = yJsonParse(&j);
-    while (jstate == YJSON_PARSE_AVAIL) {
-        if (YISERR(yEnuJson(enus, &j))) {
-            return YERRMSG(YAPI_IO_ERROR, "Invalid json data");
-        }
-        jstate = yJsonParse(&j);
-    }
-    switch (jstate) {
-    case YJSON_NEED_INPUT:
-        return YERRMSG(YAPI_IO_ERROR, "Invalid json data (missing data)");
-    case YJSON_FAILED:
-        return YERRMSG(YAPI_IO_ERROR, "Invalid json data");
-    default:
-        return YAPI_SUCCESS;
-    }
-}
-
-
-#define ADVANCE_REF 1
-#define ADVANCE_JZON 2
-#define ADVANCE_BOTH (ADVANCE_REF + ADVANCE_JZON)
-// return a bitfield which indicate which json state machine need to advaNce
-static int yEnuJZon(ENU_CONTEXT* enus, yJsonStateMachine* j, yJsonStateMachine* z, char* errmsg)
-{
-    char* point;
-    int res = ADVANCE_BOTH;
-#if 0 //def DEBUG_NET_ENUM
-    dbglog("REF:%s: %s %s (%p)\n", ENU_PARSE_STATE_STR[enus->state], yJsonStateStr[j->st],j->token, j->src);
-    dbglog("ZON:%s: %s %s (%p)\n", ENU_PARSE_STATE_STR[enus->state], yJsonStateStr[z->st], z->token, z->src);
-#endif
-    switch (enus->state) {
-    case ENU_HTTP_START:
-        if (j->st != YJSON_HTTP_READ_CODE || YSTRCMP(j->token, "200")) {
-            return YAPI_IO_ERROR;
-        }
-        if (z->st != YJSON_HTTP_READ_CODE || YSTRCMP(z->token, "200")) {
-            return YAPI_IO_ERROR;
-        }
-        enus->state = ENU_JSON_START;
-        break;
-    case ENU_JSON_START:
-        if (j->st == YJSON_HTTP_READ_MSG)
-            break;
-        if (j->st == YJSON_PARSE_ARRAY)
-            return YAPI_IO_ERROR;
-        if (j->st == YJSON_PARSE_STRING)
-            return YAPI_IO_ERROR;
-        if (j->st != YJSON_PARSE_STRUCT || z->st != YJSON_PARSE_ARRAY)
-            return YAPI_IO_ERROR;
-        enus->state = ENU_API;
-        break;
-    case ENU_API:
-        if (j->st != YJSON_PARSE_MEMBNAME)
-            break;
-        if (YSTRCMP(j->token, "module") == 0) {
-            enus->state = ENU_MODULE_START;
-            return ADVANCE_REF;
-        } else if (YSTRCMP(j->token, "network") == 0) {
-            enus->state = ENU_NETWORK_START;
-            return ADVANCE_REF;
-        } else if (YSTRCMP(j->token, "services") == 0) {
-            enus->state = ENU_SERVICE;
-            return ADVANCE_REF;
-        } else {
-            enus->state = ENU_SKIP_FUNCTION_START;
-            return ADVANCE_REF;
-        }
-    case ENU_SKIP_FUNCTION_START:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_SKIP_FUNCTION;
-        }
-        break;
-    case ENU_SKIP_FUNCTION:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_API;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            yJsonSkip(j, 1);
-            // do not skip jzon since it's simple value (string or integer)
-        }
-        break;
-    case ENU_MODULE_START:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_MODULE;
-        }
-        break;
-    case ENU_MODULE:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_API;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token, "firmwareRelease") == 0) {
-                enus->state = ENU_MODULE_FIRMWARE;
-                return ADVANCE_REF;
-            } else {
-                yJsonSkip(j, 1);
-                // do not skip jzon since it's simple value (string or integer)
-            }
-        }
-        break;
-    case ENU_MODULE_FIRMWARE:
-        NETENUMLOG("firmwareRelease is set to [%s]\n", z->token);
-        YSTRCPY(enus->hub->fw_release, YOCTO_FIRMWARE_LEN, z->token);
-        enus->state = ENU_MODULE;
-        break;
-    case ENU_NETWORK_START:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_NETWORK;
-        }
-        break;
-    case ENU_NETWORK:
-        if (j->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_API;
-        } else if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRCMP(j->token, "adminPassword") == 0) {
-                enus->state = ENU_NET_ADMINPWD;
-                return ADVANCE_REF;
-            } else {
-                yJsonSkip(j, 1);
-                // do not skip jzon since it's simple value (string or integer)
-            }
-        }
-        break;
-    case ENU_NET_ADMINPWD:
-        NETENUMLOG("adminpwd is set to [%s]\n", z->token);
-        enus->hub->writeProtected = (z->token[0] != 0);
-        enus->state = ENU_NETWORK;
-        break;
-    case ENU_SERVICE:
-        if (j->st != YJSON_PARSE_MEMBNAME)
-            break;
-        if (YSTRCMP(j->token, "whitePages") == 0) {
-            enus->state = ENU_WP_ARRAY;
-            yJsonSkip(j, 1);
-        } else if (YSTRCMP(j->token, "yellowPages") == 0) {
-            enus->state = ENU_YP_TYPE;
-            enus->ypCateg = INVALID_HASH_IDX;
-            yJsonSkip(j, 1);
-        } else {
-            yJsonSkip(j, 1);
-        }
-        break;
-    case ENU_WP_ARRAY:
-        if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token, "[") == 0) {
-            enus->state = ENU_WP_ENTRY;
-            enus->serial = INVALID_HASH_IDX;
-            enus->logicalName = INVALID_HASH_IDX;
-            enus->productName = INVALID_HASH_IDX;
-            enus->productId = 0;
-            enus->hubref = INVALID_HASH_IDX;
-            enus->beacon = 0;
-            enus->devYdx = -1;
-            enus->wp_state = WP_SERIAL;
-        } else if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token, "]") == 0) {
-            enus->state = ENU_SERVICE;
-        } else {
-            return YERRMSG(YAPI_IO_ERROR, "Unknown token in white pages");
-        }
-        return ADVANCE_JZON;
-    case ENU_WP_ENTRY:
-        if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token,"]") == 0) {
-            parseNetWpEntry(enus);
-            enus->state = ENU_WP_ARRAY;
-        } else if (z->st != YJSON_PARSE_ARRAY) {
-            switch (enus->wp_state) {
-            case WP_SERIAL:
-                NETENUMLOG("set serial to %s\n", z->token);
-                enus->serial = yHashPutStr(z->token);
-                enus->wp_state = WP_LOGICALNAME;
-                break;
-            case WP_LOGICALNAME:
-                NETENUMLOG("set Logical name to %s\n", z->token);
-                enus->logicalName = yHashPutStr(z->token);
-                enus->wp_state = WP_PRODUCT;
-                break;
-            case WP_PRODUCT:
-                NETENUMLOG("set Product name to %s\n", z->token);
-                enus->productName = yHashPutStr(z->token);
-                enus->wp_state = WP_PROD_ID;
-                break;
-            case WP_PROD_ID:
-                NETENUMLOG("set productid to %s\n", z->token);
-                enus->productId = atoi(z->token);
-                enus->wp_state = WP_NET_URL;
-                break;
-            case WP_NET_URL:
-                NETENUMLOG("set url to %s\n", z->token);
-                if (YSTRCMP(z->token, "/api") == 0) {
-                    enus->hub->serial = enus->serial;
-                }
-                enus->hubref = yHashUrlFromRef(enus->hub->url, z->token);
-                enus->wp_state = WP_BEACON;
-                break;
-            case WP_BEACON:
-                NETENUMLOG("set beacon to %s\n", z->token);
-                enus->beacon = atoi(z->token);
-                enus->wp_state = WP_INDEX;
-                break;
-            case WP_INDEX:
-                NETENUMLOG("set devYdx to %s\n", z->token);
-                enus->devYdx = atoi(z->token);
-                enus->wp_state = WP_DONE;
-                break;
-            default:
-                break;
-            }
-        }
-        return ADVANCE_JZON;
-
-    case ENU_YP_TYPE:
-        if (z->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_SERVICE;
-        } else if (z->st == YJSON_PARSE_MEMBNAME) {
-            enus->ypCateg = yHashPutStr(z->token);
-            NETENUMLOG("Categ = %s\n", z->token);
-            enus->state = ENU_YP_TYPE_LIST;
-        } else {
-            return YERRMSG(YAPI_IO_ERROR, "Unknown token in yellow pages");
-        }
-        return ADVANCE_JZON;
-    case ENU_YP_TYPE_LIST:
-        if (z->st == YJSON_PARSE_ARRAY) {
-            enus->state = ENU_YP_ARRAY;
-        } else if (z->st == YJSON_PARSE_STRUCT) {
-            enus->state = ENU_SERVICE;
-        }
-        return ADVANCE_JZON;
-    case ENU_YP_ARRAY:
-        if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token, "[") == 0) {
-            enus->state = ENU_YP_ENTRY;
-            enus->serial = INVALID_HASH_IDX;
-            enus->logicalName = INVALID_HASH_IDX;
-            enus->funcId = INVALID_HASH_IDX;
-            enus->funClass = YOCTO_AKA_YFUNCTION;
-            enus->funYdx = -1;
-            memset(enus->advertisedValue, 0, sizeof(enus->advertisedValue));
-            enus->yp_state = YP_BASETYPE;
-
-        } else if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token, "]") == 0) {
-            enus->state = ENU_YP_TYPE;
-        } else {
-            return YERRMSG(YAPI_IO_ERROR, "Unknown token in yellow pages");
-        }
-        return ADVANCE_JZON;
-    case ENU_YP_ENTRY:
-        if (z->st == YJSON_PARSE_ARRAY && YSTRCMP(z->token, "]") == 0) {
-            ypUpdateNet(enus);
-            enus->state = ENU_YP_ARRAY;
-        } else if (z->st != YJSON_PARSE_ARRAY) {
-            switch (enus->yp_state) {
-            case YP_BASETYPE:
-                NETENUMLOG("set baseType value to %s\n", z->token);
-                enus->funClass = atoi(z->token);
-                enus->yp_state = YP_HARDWAREID;
-                break;
-            case YP_HARDWAREID:
-                point = strchr(z->token, '.');
-                if (!point) break; //to be safe discard this field if we do not found '.'
-                *point++ = '\0';
-                NETENUMLOG("set serial  to %s\n", z->token);
-                enus->serial = yHashPutStr(z->token);
-                NETENUMLOG("set functionid  to %s\n", point);
-                enus->funcId = yHashPutStr(point);
-                enus->yp_state = YP_LOGICALNAME;
-                break;
-            case YP_LOGICALNAME:
-                NETENUMLOG("set function  to %s\n", z->token);
-                enus->logicalName = yHashPutStr(z->token);
-                enus->yp_state = YP_ADV_VAL;
-                break;
-            case YP_ADV_VAL:
-                NETENUMLOG("set advertised value to %s\n", z->token);
-                YSTRNCPY(enus->advertisedValue, YOCTO_PUBVAL_LEN, z->token, YOCTO_PUBVAL_SIZE);
-                enus->yp_state = YP_INDEX;
-                break;
-            case YP_INDEX:
-                NETENUMLOG("set funYdx value to %s\n", z->token);
-                enus->funYdx = atoi(z->token);
-                enus->yp_state = YP_DONE;
-                break;
-            default:
-                break;
-            }
-        }
-        return ADVANCE_JZON;
-    default:
-        return YERRMSG(YAPI_IO_ERROR,"Unknown state");
-    }
-    return res;
-}
-
-
-static int parseJZONAPI(HubSt* hub, ENU_CONTEXT* enus, u8* data, u32 datalen, char* errmsg)
-{
-    yJsonStateMachine ref;
-    yJsonStateMachine z;
-    yJsonRetCode jstate = YJSON_NEED_INPUT;
-    yJsonRetCode zstate = YJSON_NEED_INPUT;
-    // init yjson parser
-    memset(&ref, 0, sizeof(ref));
-    ref.st = YJSON_HTTP_START;
-    enus->state = ENU_HTTP_START;
-    ref.src = (char*)hub->ref_api;
-    ref.end = (char*)hub->ref_api + hub->ref_api_size;
-
-    memset(&z, 0, sizeof(z));
-    z.st = YJSON_HTTP_START;
-    enus->state = ENU_HTTP_START;
-    z.src = (char*)data;
-    z.end = (char*)data + datalen;
-
-
-    // parse all we can on this buffer
-    jstate = yJsonParse(&ref);
-    zstate = yJsonParse(&z);
-    while (jstate == YJSON_PARSE_AVAIL && jstate == zstate) {
-        int subres = yEnuJZon(enus, &ref, &z, errmsg);
-        if (YISERR(subres)) {
-            return YERRMSG(YAPI_IO_ERROR, "Invalid json data");
-        }
-        if (subres & ADVANCE_REF) {
-            jstate = yJsonParse(&ref);
-        }
-        if (subres & ADVANCE_JZON) {
-            zstate = yJsonParse(&z);
-        }
-    }
-    switch (zstate) {
-    case YJSON_NEED_INPUT:
-        return YERRMSG(YAPI_IO_ERROR, "Invalid jzon data (missing data)");
-    case YJSON_FAILED:
-        return YERRMSG(YAPI_IO_ERROR, "Invalid jzon data");
-    default:
-        return YAPI_SUCCESS;
-    }
-}
-
-
-// connect to a network hub and do an enumeration
-// this function will do TCP IO and will do a timeout if
-// the hub is off line.
-// USE NO NOT USE THIS FUNCTION BUT yNetHubEnum INSTEAD
-static int yNetHubEnumEx(HubSt* hub, ENU_CONTEXT* enus, char* errmsg)
-{
-    u8* buffer;
-    u32 buffer_size, avail;
-    u32 response_size;
-    u8* p;
-    int res;
-    const char* base_request = "GET /api.json \r\n\r\n"; // no HTTP/1.1 suffix -> light headers
-    const char* request;
-    u64 enumTimeout;
-    RequestSt* req;
-    int use_jzon;
-
-
-    retry:
-
-    if (hub->typical_apireq_size < 2048) {
-        hub->typical_apireq_size = 2048;
-    }
-    buffer_size = hub->typical_apireq_size;
-    buffer = yMalloc(buffer_size);
-    p = buffer;
-    response_size = 0;
-    avail = buffer_size;
-
-    use_jzon = hub->fw_release[0] && (hub->flags & INCOMPATIBLE_JZON_ENCODING) == 0;
-
-    if (use_jzon) {
-        YSPRINTF((char*)buffer, buffer_size, "GET /api.json?fw=%s \r\n\r\n", hub->fw_release);
-        request = (char*)buffer;
-    } else {
-        request = base_request;
-    }
-#ifdef DEBUG_YAPI_REQ
-    int req_count = YREQ_LOG_START("yNetHubEnumEx", hub->name, request, YSTRLEN(request));
-    u64 start_tm = yapiGetTickCount();
-#endif
-
-    req = yReqAlloc(hub);
-    if (YISERR((res = yReqOpen(req, 2 * YIO_DEFAULT_TCP_TIMEOUT, 0, request, YSTRLEN(request), YIO_DEFAULT_TCP_TIMEOUT, NULL, NULL, NULL, NULL, errmsg)))) {
-        yReqFree(req);
-        yFree(buffer);
-        return res;
-    }
-    enumTimeout = yapiGetTickCount() + 10000;
-
-
-    while (yapiGetTickCount() < enumTimeout) {
-        res = yReqSelect(req, 1000, errmsg);
-        if (YISERR(res)) {
-            break;
-        }
-        res = yReqRead(req, p, avail - 4);
-        while (res > 0) {
-            response_size += res;
-            avail -= res;
-            if (avail < 256) {
-                u8* nbuf;
-                buffer_size *= 2;
-                hub->typical_apireq_size = buffer_size;
-                nbuf = yMalloc(buffer_size);
-                memcpy(nbuf, buffer, response_size);
-                yFree(buffer);
-                buffer = nbuf;
-                p = buffer + response_size;
-                avail = buffer_size - response_size;
-
-            } else {
-                p += res;
-            }
-            res = yReqRead(req, p, avail - 4);
-        }
-        if (res <= 0) {
-            res = yReqIsEof(req, errmsg);
-            if (res > 0) {
-                break;
-            }
-            if (YISERR(res)) {
-                // any specific error during select
-                yReqClose(req);
-                yReqFree(req);
-                yFree(buffer);
-                return res;
-            }
-        }
-    }
-    yReqClose(req);
-    yReqFree(req);
-    if (use_jzon) {
-        res = parseJZONAPI(hub, enus, buffer, response_size, errmsg);
-    } else {
-        res = parseFullAPI(hub, enus, buffer, response_size, errmsg);
-    }
-    if (YISERR(res)) {
-        hub->fw_release[0] = 0;
-        if (hub->ref_api) {
-            yFree(hub->ref_api);
-        }
-        hub->ref_api = NULL;
-        yFree(buffer);
-        if (use_jzon) {
-            disable_jzon(hub);
-            goto retry;
-        }
-        return res;
-    }
-    if (!use_jzon) {
-        hub->ref_api = buffer;
-        hub->ref_api_size = response_size;
-    } else {
-        yFree(buffer);
-    }
-    return YAPI_SUCCESS;
-}
-
-
-// helper for yNetHubEnumEx that will trigger TCP connection (and potentially
-// timeout) only when it is really needed.
-static int yNetHubEnum(HubSt* hub, int forceupdate, char* errmsg)
-{
-    ENU_CONTEXT enus;
-    int i, res;
-    yStrRef knownDevices[128];
-
-    //check if the expiration has expired;
-    if (!forceupdate && hub->state == NET_HUB_ESTABLISHED && hub->devListExpires > yapiGetTickCount()) {
-        return YAPI_SUCCESS;
-    }
-
-    // et base url (then entry point)
-    memset(&enus, 0, sizeof(enus));
-    enus.hub = hub;
-    enus.knownDevices = knownDevices;
-    enus.nbKnownDevices = wpGetAllDevUsingHubUrl(hub->url, enus.knownDevices, 128);
-    if (enus.nbKnownDevices > 128) {
-        return YERRMSG(YAPI_IO_ERROR,"too many device on this Net hub");
-    }
-
-
-    if (hub->mandatory) {
-        // if the hub is mandatory we will raise an error
-        // and not unregister the connected devices
-        if (hub->send_ping && hub->state != NET_HUB_ESTABLISHED) {
-            // the hub send ping notification -> we can rely on helperthread status
-            if (errmsg) {
-                YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "hub %s is not reachable", hub->name);
-            }
-            return YAPI_IO_ERROR;
-        } else {
-            // the hub does not send ping notification -> we will to a request and potentially
-            // get a tcp timeout if the hub is not reachable
-            res = yNetHubEnumEx(hub, &enus, errmsg);
-            if (YISERR(res)) {
-                return res;
-            }
-        }
-    } else {
-        // if the hub is optional we will not trigger an error but
-        // instead unregister all know device connected on this hub
-        if (hub->state == NET_HUB_ESTABLISHED) {
-            // the hub send ping notification -> we can rely on helperthread status
-            res = yNetHubEnumEx(hub, &enus, errmsg);
-            if (YISERR(res)) {
-                dbglog("error with hub %s : %s\n",hub->name,errmsg);
-            }
-        }
-    }
-
-    for (i = 0; i < enus.nbKnownDevices; i++) {
-        if (enus.knownDevices[i] != INVALID_HASH_IDX) {
-            unregisterNetDevice(knownDevices[i]);
-        }
-    }
-    if (hub->state == NET_HUB_ESTABLISHED) {
-        hub->devListExpires = yapiGetTickCount() + yContext->deviceListValidityMs;
-    } else {
-        hub->devListExpires = yapiGetTickCount() + 500;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-// initialize NetHubSt structure. no IO in this function
-static HubSt* yapiAllocHub(const char* url, char* errmsg)
-{
-    char* name;
-    int len;
-    yHash huburl;
-    yStrRef user, password;
-    HubSt* hub;
-
-    huburl = yHashUrl(url, "", 0, errmsg);
-    if (huburl == INVALID_HASH_IDX) {
-        return NULL;
-    }
-
-    hub = yMalloc(sizeof(HubSt));
-    memset(hub, 0, sizeof(HubSt));
-    memset(hub->devYdxMap, 255, sizeof(hub->devYdxMap));
-    yInitWakeUpSocket(&hub->wuce);
-    // compute an hashed url
-    hub->url = huburl;
-    len = YSTRLEN(url);
-    name = (char*)yMalloc(len+1);
-    memcpy(name, url, len + 1);
-    hub->name = name;
-    yHashGetUrlPort(huburl, NULL, NULL, &hub->proto, &user, &password, NULL);
-    yFifoInit(&(hub->not_fifo), hub->not_buffer, sizeof(hub->not_buffer));
-    yInitializeCriticalSection(&hub->access);
-
-    if (hub->proto != PROTO_WEBSOCKET) {
-        if (user != INVALID_HASH_IDX) {
-            hub->http.s_user = yHashGetStrPtr(user);
-        }
-        if (password != INVALID_HASH_IDX) {
-            hub->http.s_pwd = yHashGetStrPtr(password);
-        }
-        hub->http.lastTraffic = yapiGetTickCount();
-    } else {
-        int tcpchan;
-        memset(&hub->ws, 0, sizeof(WSNetHub));
-        hub->ws.s_next_async_id = 48;
-        hub->ws. fifo_buffer = yMalloc(2048);
-        yFifoInit(&hub->ws.mainfifo, hub->ws.fifo_buffer, 2048);
-        for (tcpchan = 0; tcpchan < MAX_ASYNC_TCPCHAN; tcpchan++) {
-            yInitializeCriticalSection(&hub->ws.chan[tcpchan].access);
-        }
-
-    }
-#ifdef TRACE_NET_HUB
-    dbglog("HUB%p: %x->%s allocated \n",hub, hub->url, hub->name);
-#endif
-
-    return hub;
-}
-
-static void yapiFreeHub(HubSt* hub)
-{
-#ifdef TRACE_NET_HUB
-    dbglog("HUB: %x->%s Deleted \n",hub->url,hub->name);
-#endif
-    yFreeWakeUpSocket(&hub->wuce);
-    if (hub->proto != PROTO_WEBSOCKET) {
-        if (hub->http.s_realm) yFree(hub->http.s_realm);
-        if (hub->http.s_nonce) yFree(hub->http.s_nonce);
-        if (hub->http.s_opaque) yFree(hub->http.s_opaque);
-        if (hub->http.notReq) {
-            yReqClose(hub->http.notReq);
-            yReqFree(hub->http.notReq);
-        }
-    } else {
-        int tcpchan;
-        for (tcpchan = 0; tcpchan < MAX_ASYNC_TCPCHAN; tcpchan++) {
-            yDeleteCriticalSection(&hub->ws.chan[tcpchan].access);
-        }
-        yFifoCleanup(&hub->ws.mainfifo);
-        yFree(hub->ws.fifo_buffer);
-    }
-    yDeleteCriticalSection(&hub->access);
-    yFifoCleanup(&hub->not_fifo);
-    if (hub->ref_api) yFree(hub->ref_api);
-    if (hub->name) yFree(hub->name);
-    memset(hub, 0, sizeof(HubSt));
-    memset(hub->devYdxMap, 255, sizeof(hub->devYdxMap));
-    hub->url = INVALID_HASH_IDX;
-    yFree(hub);
-}
-
-
-static void unregisterNetHub(yUrlRef huburl)
-{
-    int i;
-    u64 timeref;
-    int nbKnownDevices;
-    yStrRef knownDevices[128];
-    char errmsg[YOCTO_ERRMSG_LEN];
-
-
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        HubSt* hub = yContext->nethub[i];
-        if (hub && yHashSameHub(hub->url, huburl)) {
-#ifdef TRACE_NET_HUB
-            dbglog("HUB: unregister %x->%s  \n",huburl,hub->name);
-#endif
-            hub->state = NET_HUB_TOCLOSE;
-            yThreadRequestEnd(&hub->net_thread);
-            yDringWakeUpSocket(&hub->wuce, 0, errmsg);
-            // wait for the helper thread to stop monitoring these devices
-            timeref = yapiGetTickCount();
-            while (yThreadIsRunning(&hub->net_thread) && (yapiGetTickCount() - timeref < YIO_DEFAULT_TCP_TIMEOUT)) {
-                yApproximateSleep(10);
-            }
-            yThreadKill(&hub->net_thread);
-            yapiFreeHub(hub);
-            yContext->nethub[i] = NULL;
-            break;
-        }
-    }
-
-    nbKnownDevices = wpGetAllDevUsingHubUrl(huburl, knownDevices, 128);
-    for (i = 0; i < nbKnownDevices; i++) {
-        if (knownDevices[i] != INVALID_HASH_IDX) {
-            unregisterNetDevice(knownDevices[i]);
-        }
-    }
-}
-
-
-static void ssdpEntryUpdate(const char* serial, const char* urlToRegister, const char* urlToUnregister)
-{
-    if (!yContext)
-        // API not yet initialized -> drop everything
-        return;
-    if (urlToRegister) {
-        // still valid entry
-        if (yContext->hubDiscoveryCallback) {
-            yEnterCriticalSection(&yContext->deviceCallbackCS);
-            yContext->hubDiscoveryCallback(serial, urlToRegister);
-            yLeaveCriticalSection(&yContext->deviceCallbackCS);
-        }
-    }
-
-    if (yContext->detecttype & Y_DETECT_NET) {
-        if (urlToRegister) {
-            if (urlToUnregister) {
-                yapiUnregisterHub_internal(urlToUnregister);
-            }
-            yapiPreregisterHub_internal(urlToRegister, NULL);
-        }
-    }
-}
-
-
-static void initializeAllCS(yContextSt* ctx)
-{
-    //initialize enumeration CS
-    yInitializeCriticalSection(&ctx->updateDev_cs);
-    yInitializeCriticalSection(&ctx->handleEv_cs);
-    yInitializeCriticalSection(&ctx->enum_cs);
-    yInitializeCriticalSection(&ctx->io_cs);
-    yInitializeCriticalSection(&ctx->deviceCallbackCS);
-    yInitializeCriticalSection(&ctx->functionCallbackCS);
-    yInitializeCriticalSection(&ctx->generic_cs);
-#ifdef DEBUG_YAPI_REQ
-    yInitializeCriticalSection(&YREQ_CS);
-#endif
-}
-
-static void deleteAllCS(yContextSt* ctx)
-{
-    //initialize enumeration CS
-    yDeleteCriticalSection(&ctx->updateDev_cs);
-    yDeleteCriticalSection(&ctx->handleEv_cs);
-    yDeleteCriticalSection(&ctx->enum_cs);
-    yDeleteCriticalSection(&ctx->io_cs);
-    yDeleteCriticalSection(&ctx->deviceCallbackCS);
-    yDeleteCriticalSection(&ctx->functionCallbackCS);
-    yDeleteCriticalSection(&ctx->generic_cs);
-}
-
-
-/*****************************************************************************
-  API FUNCTIONS
- ****************************************************************************/
-#pragma pack(push,1)
-typedef union
-{
-    u32 raw;
-
-    struct
-    {
-        u8 a;
-        u8 b;
-        u8 c;
-        u8 d;
-    } bytes;
-} test_compile;
-#pragma pack(pop)
-
-
-static YRETCODE yapiInitAPI_internal(int detect_type, char* errmsg)
-{
-    test_compile test;
-    yContextSt* ctx;
-#ifdef PERF_API_FUNCTIONS
-    memset(&yApiPerf,0,sizeof(yApiPerf));
-#endif
-
-    if (yContext != NULL)
-        return YERRMSG(YAPI_DEVICE_BUSY,"Api already started");
-#ifdef __BORLANDC__
-#pragma warn - 8066
-#pragma warn - 8008
-#endif
-    if (sizeof(u8) != 1) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of u8");
-    if (sizeof(s8) != 1) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of s8");
-    if (sizeof(u16) != 2) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of u16");
-    if (sizeof(u32) != 4) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of u32");
-    if (sizeof(u64) != 8) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of u64");
-    if (sizeof(s16) != 2) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of s16");
-    if (sizeof(s32) != 4) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of s32");
-    if (sizeof(s64) != 8) return YERRMSG(YAPI_INVALID_ARGUMENT,"invalid definition of s64");
-    test.raw = 0xdeadbeef;
-
-    if (test.bytes.a == 0xef && test.bytes.d == 0xde) {
-        // little endian
-        if (sizeof(test_compile) != 4) return YERRMSG(YAPI_INVALID_ARGUMENT, "pragma pack is not supported");
-#ifdef CPU_BIG_ENDIAN
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid endianness. Lib is compiled for big endian but is used on little endian CPU");
-#endif
-    } else {
-        // big endian
-        if (sizeof(test_compile) != 4) return YERRMSG(YAPI_INVALID_ARGUMENT, "pragma pack is not supported");
-#ifndef CPU_BIG_ENDIAN
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid endianness. Lib is compiled for little endian but is used on big endian CPU");
-#endif
-    }
-
-#ifdef __BORLANDC__
-#pragma warn . 8008
-#pragma warn . 8066
-#endif
-
-    if (atof("1") != 1.0) {
-#if defined(BUILD_ARMHF)
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid arm architecture (try armel binaries)");
-#elif defined(BUILD_ARMEL)
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid arm architecture (try armhf binaries)");
-#else
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid architecture");
-#endif
-    }
-
-    //init safe malloc
-    ySafeMemoryInit(64*1024);
-#ifdef DEBUG_CRITICAL_SECTION
-    yInitDebugCS();
-#endif
-
-    ctx = (yContextSt*)yMalloc(sizeof(yContextSt));
-    yMemset(ctx,0,sizeof(yContextSt));
-    ctx->detecttype = detect_type;
-    ctx->deviceListValidityMs = DEFAULT_NET_DEVLIST_VALIDITY_MS;
-
-    //initialize enumeration CS
-    initializeAllCS(ctx);
-
-    //initialize white/yellow pages support
-    yHashInit();
-
-    //initialize device pool
-    ctx->devs = NULL;
-    ctx->devhdlcount = 1;
-    if (detect_type & Y_DETECT_USB) {
-        int res;
-        if (YISERR(res=yUsbInit(ctx,errmsg))) {
-            deleteAllCS(ctx);
-            yFree(ctx);
-            return (YRETCODE)res;
-        }
-    }
-
-
-    if (YISERR(yTcpInit(errmsg))) {
-        deleteAllCS(ctx);
-        yFree(ctx);
-        return YAPI_IO_ERROR;
-    }
-
-    yCreateEvent(&ctx->exitSleepEvent);
-
-    if (detect_type & Y_DETECT_NET) {
-        if (YISERR(ySSDPStart(&ctx->SSDP, ssdpEntryUpdate, errmsg))) {
-            yTcpShutdown();
-            yCloseEvent(&yContext->exitSleepEvent);
-            deleteAllCS(ctx);
-            yFree(ctx);
-            return YAPI_IO_ERROR;
-        }
-    }
-    yContext = ctx;
-#ifndef YAPI_IN_YDEVICE
-    yProgInit();
-#endif
-#if 0
-    int siz = sizeof(yDeviceSt);
-    dbglog("memset yDeviceSt struct of %d bytes\n", siz);
-
-
-    siz = offsetof(yDeviceSt, vendorid);
-    dbglog("ofs=%d instead of 0\n",siz);
-    siz = offsetof(yDeviceSt, deviceid);
-    dbglog("ofs=%d instead of 2\n",siz);
-    siz = offsetof(yDeviceSt, devrelease);
-    dbglog("ofs=%d instead of 4\n",siz);
-    siz = offsetof(yDeviceSt, nbinbterfaces);
-    dbglog("ofs=%d instead of 6\n",siz);
-    siz = offsetof(yDeviceSt, manufacturer);
-    dbglog("ofs=%d instead of 8\n",siz);
-    siz = offsetof(yDeviceSt, productname);
-    dbglog("ofs=%d instead of 28\n",siz);
-    siz = offsetof(yDeviceSt, serial);
-    dbglog("ofs=%d instead of 56\n",siz);
-    siz = offsetof(yDeviceSt, logicalname);
-    dbglog("ofs=%d instead of 76\n",siz);
-    siz = offsetof(yDeviceSt, firmware);
-    dbglog("ofs=%d instead of 96\n",siz);
-    siz = offsetof(yDeviceSt, beacon);
-    dbglog("ofs=%d instead of 118\n",siz);
-#endif
-
-    return YAPI_SUCCESS;
-}
-
-static int yTcpTrafficPending(void);
-
-
-static void yapiFreeAPI_internal(void)
-{
-    u64 timeout = yapiGetTickCount() + 1000000;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    int i;
-
-    if (yContext == NULL)
-        return;
-
-#ifdef PERF_API_FUNCTIONS
-    dumpYApiPerf();
-#endif
-
-
-    while (yapiGetTickCount() < timeout && (yUsbTrafficPending() || yTcpTrafficPending())) {
-        yapiHandleEvents_internal(errmsg);
-        yApproximateSleep(50);
-    }
-
-
-#ifndef YAPI_IN_YDEVICE
-    yProgFree();
-#endif
-    yEnterCriticalSection(&yContext->updateDev_cs);
-    yEnterCriticalSection(&yContext->handleEv_cs);
-    yEnterCriticalSection(&yContext->enum_cs);
-    if (yContext->detecttype & Y_DETECT_USB) {
-        yUsbFree(yContext,NULL);
-    }
-
-    ySSDPStop(&yContext->SSDP);
-    //unregister all Network hub
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        if (yContext->nethub[i]) {
-            unregisterNetHub(yContext->nethub[i]->url);
-        }
-    }
-
-    yHashFree();
-    yTcpShutdown();
-    yCloseEvent(&yContext->exitSleepEvent);
-
-    yLeaveCriticalSection(&yContext->updateDev_cs);
-    yLeaveCriticalSection(&yContext->handleEv_cs);
-    yLeaveCriticalSection(&yContext->enum_cs);
-    deleteAllCS(yContext);
-    ySafeMemoryDump(yContext);
-    yFree(yContext);
-    ySafeMemoryStop();
-#ifdef DEBUG_CRITICAL_SECTION
-    yFreeDebugCS();
-#endif
-
-    yContext = NULL;
-}
-
-
-static void yapiSetNetDevListValidity_internal(u64 value)
-{
-    if (!yContext) {
-        return;
-    }
-    yEnterCriticalSection(&yContext->updateDev_cs);
-    yContext->deviceListValidityMs = value;
-    yLeaveCriticalSection(&yContext->updateDev_cs);
-}
-
-
-static u64 yapiGetNetDevListValidity_internal(void)
-{
-    u64 res;
-    if (!yContext) {
-        return DEFAULT_NET_DEVLIST_VALIDITY_MS;
-    }
-    yEnterCriticalSection(&yContext->updateDev_cs);
-    res = yContext->deviceListValidityMs;
-    yLeaveCriticalSection(&yContext->updateDev_cs);
-    return res;
-}
-
-
-static void yapiRegisterLogFunction_internal(yapiLogFunction logfun)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yEnterCriticalSection(&yContext->enum_cs);
-        yContext->log = logfun;
-        yLeaveCriticalSection(&yContext->enum_cs);
-    }
-}
-
-
-static void yapiRegisterDeviceLogCallback_internal(yapiDeviceLogCallback logCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yEnterCriticalSection(&yContext->enum_cs);
-        yContext->logDeviceCallback = logCallback;
-        yLeaveCriticalSection(&yContext->enum_cs);
-    }
-}
-
-static void yapiStartStopDeviceLogCallback_internal(const char* serial, int start)
-{
-    yStrRef serialref;
-    int devydx;
-    serialref = yHashPutStr(serial);
-    devydx = wpGetDevYdx(serialref);
-    if (devydx < 0)
-        return;
-    yEnterCriticalSection(&yContext->generic_cs);
-    if (start) {
-        yContext->generic_infos[devydx].flags |= DEVGEN_LOG_ACTIVATED;
-    } else {
-        yContext->generic_infos[devydx].flags &= ~DEVGEN_LOG_ACTIVATED;
-    }
-    yLeaveCriticalSection(&yContext->generic_cs);
-    yapiPullDeviceLogEx(devydx);
-}
-
-static void yapiRegisterDeviceArrivalCallback_internal(yapiDeviceUpdateCallback arrivalCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yEnterCriticalSection(&yContext->enum_cs);
-        yContext->arrivalCallback = arrivalCallback;
-        if (arrivalCallback != NULL) {
-            // FIXME: WE SHOULD USE THE hash table to list all known devices
-#if 0
-            // call callback with already detected devices
-            yPrivDeviceSt *p=yContext->devs;
-            while(p){
-                devGetAcces(p,1);
-                if(p->dstatus == YDEV_WORKING){
-                    yStrRef serialref = yHashPutStr(p->infos.serial);
-                    yContext->arrivalCallback(serialref);
-                }
-                devReleaseAcces(p);
-                p=p->next;
-            }
-#endif
-        }
-        yLeaveCriticalSection(&yContext->enum_cs);
-    }
-}
-
-
-static void yapiRegisterDeviceRemovalCallback_internal(yapiDeviceUpdateCallback removalCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yEnterCriticalSection(&yContext->enum_cs);
-        yContext->removalCallback = removalCallback;
-        yLeaveCriticalSection(&yContext->enum_cs);
-    }
-}
-
-
-static void yapiRegisterDeviceChangeCallback_internal(yapiDeviceUpdateCallback changeCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->changeCallback = changeCallback;
-    }
-}
-
-
-static void yapiRegisterBeaconCallback_internal(yapiBeaconCallback beaconCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->beaconCallback = beaconCallback;
-    }
-}
-
-
-static void yapiRegisterDeviceConfigChangeCallback_internal(yapiDeviceUpdateCallback configChangeCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->confChangeCallback = configChangeCallback;
-    }
-}
-
-
-static void yapiRegisterFunctionUpdateCallback_internal(yapiFunctionUpdateCallback updateCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->functionCallback = updateCallback;
-    }
-}
-
-static void yapiRegisterTimedReportCallback_internal(yapiTimedReportCallback timedReportCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->timedReportCallback = timedReportCallback;
-    }
-}
-
-
-#ifdef DEBUG_NET_NOTIFICATION
-#include <direct.h>
-#include <stdio.h>
-static void dumpNotif(const char *buffer)
-{
-    FILE *f;
-    printf("%s",buffer);
-    YASSERT(YFOPEN(&f,"c:\\tmp\\api_not.txt","ab")==0);
-    fwrite(buffer,1,YSTRLEN(buffer),f);
-    fclose(f);
-}
-#endif
-
-
-static void wpUpdateTCP(HubSt* hub, const char* serial, const char* name, u8 beacon)
-{
-#define LOCALURL_LEN 64
-    int status;
-    char devUrlBuf[LOCALURL_LEN];
-    yStrRef serialref;
-    yStrRef lnameref;
-    yUrlRef devurl;
-    int devydx;
-
-    serialref = yHashPutStr(serial);
-    devydx = wpGetDevYdx(serialref);
-
-    if (devydx < 0) {
-        // drop notification until we have register the device with
-        // a real enumeration
-        return;
-    }
-
-    if (hub->serial != serialref) {
-        // Insert device into white pages
-        YSTRCPY(devUrlBuf, LOCALURL_LEN, "/bySerial/");
-        YSTRCAT(devUrlBuf, LOCALURL_LEN, serial);
-        YSTRCAT(devUrlBuf, LOCALURL_LEN, "/api");
-        devurl = yHashUrlFromRef(hub->url, devUrlBuf);
-    } else {
-        devurl = hub->url;
-    }
-    lnameref = yHashPutStr(name);
-    status = wpRegister(-1, serialref, lnameref, INVALID_HASH_IDX, 0, devurl, beacon);
-    if (status & 1) {
-        ypRegister(YSTRREF_MODULE_STRING, serialref, YSTRREF_mODULE_STRING, lnameref, YOCTO_AKA_YFUNCTION, -1, NULL);
-        // Forward high-level notification to API user
-        if (yContext->changeCallback) {
-            yEnterCriticalSection(&yContext->deviceCallbackCS);
-            yContext->changeCallback(serialref);
-            yLeaveCriticalSection(&yContext->deviceCallbackCS);
-        }
-    }
-    if (status & 2) {
-        // Forward high-level notification to API user
-        if (yContext->beaconCallback) {
-            yEnterCriticalSection(&yContext->functionCallbackCS);
-            yContext->beaconCallback(serialref, beacon);
-            yLeaveCriticalSection(&yContext->functionCallbackCS);
-        }
-    }
-}
-
-int handleNetNotification(HubSt* hub)
-{
-    u16 pos;
-    u16 end, size;
-    char buffer[128];
-    char* p;
-    u8 pkttype = 0, devydx, funydx, funclass;
-    char *serial = NULL, *name, *funcid, *children;
-    char value[YOCTO_PUBVAL_LEN];
-    u8 report[18];
-    char netstop = NOTIFY_NETPKT_STOP;
-    char escapechar = 27;
-#ifdef DEBUG_NET_NOTIFICATION
-    u32             abspos = hub->notifAbsPos;
-    char            Dbuffer[1024];
-    u8              throwbuf[1024];
-    u16             tmp;
-#endif
-
-    // search for start of notification
-    size = yFifoGetUsed(&(hub->not_fifo));
-    while (size >= NOTIFY_NETPKT_START_LEN) {
-        yPeekFifo(&(hub->not_fifo), &pkttype, 1, 0);
-        if (pkttype != NOTIFY_NETPKT_STOP) break;
-        // drop newline and loop
-        yPopFifo(&(hub->not_fifo),NULL, 1);
-        // note: keep-alive packets don't count in the notification channel position
-        size--;
-    }
-    if (size < NOTIFY_NETPKT_START_LEN) {
-        return 0;
-    }
-    // make sure we have a full notification
-    end = ySeekFifo(&(hub->not_fifo), (u8*)&netstop, 1, 0, 0, 0);
-    if (end == 0xffff) {
-        if (yFifoGetFree(&(hub->not_fifo)) == 0) {
-            dbglog("Too many invalid notifications, clearing buffer\n");
-            yFifoEmpty((&(hub->not_fifo)));
-            return 1;
-        }
-        return 0;
-    }
-    // make sure we have a full notification
-    if (0xffff != ySeekFifo(&(hub->not_fifo), (u8*)&escapechar, 1, 0, end, 0)) {
-        // drop notification that contain esc char
-        yPopFifo(&(hub->not_fifo), NULL, end + 1);
-        return 1;
-    }
-    // handle short funcvalydx notifications
-    if (pkttype >= NOTIFY_NETPKT_CONFCHGYDX && pkttype <= NOTIFY_NETPKT_TIMEAVGYDX) {
-        memset(value, 0, YOCTO_PUBVAL_LEN);
-        if (end + 1 > (u16)sizeof(buffer)) {
-            dbglog("Drop invalid short notification (too long :%d)\n", end + 1);
-            hub->notifAbsPos += end + 1;
-            return 1;
-        }
-        yPopFifo(&(hub->not_fifo), (u8*)buffer, end + 1);
-        hub->notifAbsPos += end + 1;
-        p = buffer + 1;
-        devydx = (*p++) - 'A';
-        funydx = (*p++) - '0';
-        if (funydx & 64) {
-            // high bit of devydx is on second character
-            funydx -= 64;
-            devydx += 128;
-        }
-        pos = 0;
-        switch (pkttype) {
-        case NOTIFY_NETPKT_FUNCVALYDX:
-            while (*p != 0 && *p != NOTIFY_NETPKT_STOP && pos < YOCTO_PUBVAL_LEN - 1) {
-                value[pos++] = *p++;
-            }
-            value[pos] = 0;
-#ifdef DEBUG_NET_NOTIFICATION
-                YSPRINTF(Dbuffer,512,"FuncVYDX >devYdx=%d funYdx=%d val=%s (%d)\n",
-                         devydx,funydx,value,abspos);
-                dumpNotif(Dbuffer);
-#endif
-            // Map hub-specific devydx to our devydx
-            devydx = hub->devYdxMap[devydx];
-            if (devydx < MAX_YDX_PER_HUB) {
-                Notification_funydx funInfo;
-                funInfo.raw = funydx;
-                ypUpdateYdx(devydx, funInfo, value);
-            }
-            break;
-        case NOTIFY_NETPKT_DEVLOGYDX:
-            // Map hub-specific devydx to our devydx
-            devydx = hub->devYdxMap[devydx];
-            if (devydx < MAX_YDX_PER_HUB) {
-                yEnterCriticalSection(&yContext->generic_cs);
-                if (yContext->generic_infos[devydx].flags & DEVGEN_LOG_ACTIVATED) {
-                    yContext->generic_infos[devydx].flags |= DEVGEN_LOG_PENDING;
-#ifdef DEBUG_NET_NOTIFICATION
-                        dbglog("notify device log for devydx %d\n", devydx);
-#endif
-                }
-                yLeaveCriticalSection(&yContext->generic_cs);
-            }
-            break;
-        case NOTIFY_NETPKT_CONFCHGYDX:
-            // Map hub-specific devydx to our devydx
-            devydx = hub->devYdxMap[devydx];
-            if (devydx < MAX_YDX_PER_HUB) {
-                // Forward high-level device config change notification to API user
-                if (yContext->confChangeCallback) {
-                    yStrRef serialref;
-                    yEnterCriticalSection(&yContext->generic_cs);
-                    serialref = yContext->generic_infos[devydx].serial;
-                    yLeaveCriticalSection(&yContext->generic_cs);
-                    yEnterCriticalSection(&yContext->deviceCallbackCS);
-#ifdef DEBUG_NET_NOTIFICATION
-                        dbglog("notify conf change for devydx %d\n", devydx);
-#endif
-                    yContext->confChangeCallback(serialref);
-                    yLeaveCriticalSection(&yContext->deviceCallbackCS);
-                }
-            }
-            break;
-        case NOTIFY_NETPKT_TIMEVALYDX:
-        case NOTIFY_NETPKT_TIMEAVGYDX:
-        case NOTIFY_NETPKT_TIMEV2YDX:
-            // Map hub-specific devydx to our devydx
-            devydx = hub->devYdxMap[devydx];
-            if (devydx >= MAX_YDX_PER_HUB) break;
-
-            report[pos++] = (pkttype == NOTIFY_NETPKT_TIMEVALYDX ? 0 : (pkttype == NOTIFY_NETPKT_TIMEAVGYDX ? 1 : 2));
-            while (isxdigit((u8)p[0]) && isxdigit((u8)p[1]) && pos < sizeof(report)) {
-                int hi_nib = (p[0] <= '9' ? p[0] - '0' : 10 + (p[0] & 0x4f) - 'A');
-                int lo_nib = (p[1] <= '9' ? p[1] - '0' : 10 + (p[1] & 0x4f) - 'A');
-                report[pos++] = hi_nib * 16 + lo_nib;
-                p += 2;
-            }
-#ifdef DEBUG_NET_NOTIFICATION
-                YSPRINTF(Dbuffer,512,"%s >devYdx=%d funYdx=%d (%d)\n",
-                         (pkttype == NOTIFY_NETPKT_TIMEVALYDX ? "TimeValR" : "TimeAvgR"),
-                         devydx,funydx,abspos);
-                dumpNotif(Dbuffer);
-#endif
-            if (funydx == 15) {
-                u64 t = report[1] + 0x100u * report[2] + 0x10000u * report[3] + 0x1000000u * report[4];
-                u32 ms = report[5] << 2;
-                u64 freq = 0;
-                if (pos >= 8) {
-                    ms += report[6] >> 6;
-                    freq = report[7];
-                    freq += (report[6] & 0xf) * 0x100;
-                    if (report[6] & 0x10) {
-                        freq *= 1000;
-                    }
-
-                }
-                yEnterCriticalSection(&yContext->generic_cs);
-                yContext->generic_infos[devydx].lastTimeRef = t * 1000 + ms;
-                yContext->generic_infos[devydx].lastFreq = freq;
-                yLeaveCriticalSection(&yContext->generic_cs);
-            } else {
-                Notification_funydx funInfo;
-                YAPI_FUNCTION fundesc;
-                u64 deviceTime;
-                u64 freq;
-                yEnterCriticalSection(&yContext->generic_cs);
-                deviceTime = yContext->generic_infos[devydx].lastTimeRef;
-                freq = yContext->generic_infos[devydx].lastFreq;
-                yLeaveCriticalSection(&yContext->generic_cs);
-                funInfo.raw = funydx;
-                ypRegisterByYdx(devydx, funInfo, NULL, &fundesc);
-                yFunctionTimedUpdate(fundesc, deviceTime, freq, report, pos);
-            }
-            break;
-        case NOTIFY_NETPKT_FUNCV2YDX:
-            while (*p != 0 && *p != NOTIFY_NETPKT_STOP && pos < YOCTO_PUBVAL_LEN - 1) {
-                value[pos++] = *p++;
-            }
-            value[pos] = 0;
-            // Map hub-specific devydx to our devydx
-            devydx = hub->devYdxMap[devydx];
-            if (devydx < MAX_YDX_PER_HUB) {
-                Notification_funydx funInfo;
-                unsigned char value8bit[YOCTO_PUBVAL_LEN];
-                memset(value8bit, 0, YOCTO_PUBVAL_LEN);
-                funInfo.raw = funydx;
-                if (decodeNetFuncValV2((u8*)value, &funInfo, (char*)value8bit) >= 0) {
-#ifdef DEBUG_NET_NOTIFICATION
-                        if(!funInfo.v2.typeV2) {
-                            YSPRINTF(Dbuffer,512,"FuncV2YDX >devYdx=%d funYdx=%d val=%s (%d)\n",devydx,funydx,value8bit,abspos);
-                        } else {
-                            YSPRINTF(Dbuffer,512,"FuncV2YDX >devYdx=%d funYdx=%d val=%d:%02x.%02x.%02x.%02x.%02x.%02x (%d)\n",
-                                     devydx, funInfo.v2.funydx, funInfo.v2.typeV2,
-                                     value8bit[0],value8bit[1],value8bit[2],value8bit[3],value8bit[4],value8bit[5],abspos);
-                        }
-                        dumpNotif(Dbuffer);
-#endif
-                    ypUpdateYdx(devydx, funInfo, (char *)value8bit);
-                }
-            }
-            break;
-        case NOTIFY_NETPKT_FLUSHV2YDX:
-            // To be implemented later
-            break;
-        default:
-            break;
-        }
-        return 1;
-    }
-
-    // make sure packet is a valid notification
-    pos = ySeekFifo(&(hub->not_fifo), (u8*)(NOTIFY_NETPKT_START), NOTIFY_NETPKT_START_LEN, 0, end, 0);
-    if (pos != 0) {
-        // does not start with signature, drop everything until stop marker
-#ifdef DEBUG_NET_NOTIFICATION
-        memset(throwbuf, 0, sizeof(throwbuf));
-        tmp = (end > 50 ? 50 : end);
-        yPopFifo(&(hub->not_fifo),throwbuf,tmp);
-        yPopFifo(&(hub->not_fifo),NULL,end+1-tmp);
-        Dbuffer[1023]=0;
-        YSPRINTF(Dbuffer,512,"throw %d / %d [%s]\n",
-                 end,pos,throwbuf);
-        dumpNotif(Dbuffer);
-#else
-        yPopFifo(&(hub->not_fifo),NULL, end + 1);
-#endif
-        hub->notifAbsPos += end + 1;
-        return 0;
-    }
-
-    // full packet at start of fifo
-    size = end - NOTIFY_NETPKT_START_LEN;
-    YASSERT(NOTIFY_NETPKT_MAX_LEN > size);
-    yPopFifo(&(hub->not_fifo),NULL,NOTIFY_NETPKT_START_LEN);
-    yPopFifo(&(hub->not_fifo), (u8*)buffer, size + 1);
-    buffer[size] = 0;
-    pkttype = *buffer;
-    p = buffer + 1;
-    if (pkttype == NOTIFY_NETPKT_NOT_SYNC) {
-        int testPing;
-#ifdef DEBUG_NET_NOTIFICATION
-        YSPRINTF(Dbuffer,512,"Sync from %d to %s\n",
-             hub->notifAbsPos, p);
-        dumpNotif(Dbuffer);
-#endif
-        hub->notifAbsPos = atoi(p);
-        //look if we have a \n just after the sync notification
-        // if yes this mean that the hub will send some ping notification
-        testPing = ySeekFifo(&(hub->not_fifo), (u8*)&netstop, 1, 0, 1, 0);
-        if (testPing == 0) {
-#ifdef DEBUG_NET_NOTIFICATION
-            YSPRINTF(Dbuffer,1024,"HUB: %X->%s will send ping notification\n",hub->url,hub->name);
-            dumpNotif(Dbuffer);
-#endif
-            hub->send_ping = 1;
-        }
-        return 1;
-    }
-    hub->notifAbsPos += size + 1 + NOTIFY_NETPKT_START_LEN;
-    if (pkttype != NOTIFY_NETPKT_FUNCVALYDX) {
-        serial = p;
-        p = strchr(serial,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-            YSPRINTF(Dbuffer,512,"no serialFOR %s\n",buffer);
-            dumpNotif(Dbuffer);
-#endif
-            return 0;
-        }
-        *p++ = 0;
-    }
-
-
-    switch (pkttype) {
-    case NOTIFY_NETPKT_NAME:
-        name = p;
-        p = strchr(name,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid new name (%X)\n",pkttype);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-#ifdef DEBUG_NET_NOTIFICATION
-            dbglog("NOTIFY_PKT_NAME %s : new name is \"%s\" beacon %x\n",serial,name ,*p);
-            YSPRINTF(Dbuffer,512,"NAME     >%s  name=%s beacon=%c (%d)\n",serial,name,*p,abspos);
-            dumpNotif(Dbuffer);
-#endif
-        wpUpdateTCP(hub, serial, name, (*p == '1' ? 1 : 0));
-        break;
-    case NOTIFY_NETPKT_FUNCNAME:
-        funcid = p;
-        p = strchr(funcid,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid funcid (%X:%s)\n",pkttype,serial);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-        name = p;
-#ifdef DEBUG_NET_NOTIFICATION
-            dbglog("NOTIFY_PKT_FUNCNAME %s : funcid is \"%s\" name \"%s\"\n",serial,funcid,name);
-            YSPRINTF(Dbuffer,512,"FuncNAME >%s  funcid=%s funcname=%s (%d)\n",
-                     serial,funcid,name,abspos);
-            dumpNotif(Dbuffer);
-#endif
-        ypUpdateUSB(serial, funcid, name, -1, -1,NULL);
-        break;
-    case NOTIFY_NETPKT_FUNCVAL:
-        funcid = p;
-        p = strchr(funcid,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid funcid (%X)\n",pkttype);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-        memset(value, 0,YOCTO_PUBVAL_LEN);
-        memcpy(value, p,YSTRLEN(p));
-#ifdef DEBUG_NET_NOTIFICATION
-            //dbglog("NOTIFY_PKT_FUNCVAL %s : funcid is \"%s\" value \"%s\"\n",serial,funcid,value);
-            YSPRINTF(Dbuffer,512,"FuncVAL  >%s  funcid=%s val=%s (%d)\n",
-                serial,funcid,value,abspos);
-            dumpNotif(Dbuffer);
-#endif
-        ypUpdateUSB(serial, funcid,NULL, -1, -1, value);
-        break;
-    case NOTIFY_NETPKT_FUNCNAMEYDX:
-        funcid = p;
-        p = strchr(funcid,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid funcid (%X:%s)\n",pkttype,serial);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-        name = p;
-        p = strchr(name,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid funcname (%X:%s)\n",pkttype,serial);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-        funydx = atoi(p);
-        p = strchr(p,NOTIFY_NETPKT_SEP);
-        if (p == NULL || p[1] < '0') {
-            funclass = YOCTO_AKA_YFUNCTION;
-        } else {
-            funclass = p[1] - '0';
-        }
-#ifdef DEBUG_NET_NOTIFICATION
-            YSPRINTF(Dbuffer,512,"FuncNYDX >%s  funcid=%s funcname=%s funYdx=%d (%d)\n",
-                     serial,funcid,name,funydx,abspos);
-            dumpNotif(Dbuffer);
-#endif
-        ypUpdateUSB(serial, funcid, name, funclass, funydx,NULL);
-        break;
-    case NOTIFY_NETPKT_CHILD:
-        children = p;
-        p = strchr(children,NOTIFY_NETPKT_SEP);
-        if (p == NULL) {
-#ifdef DEBUG_NET_NOTIFICATION
-                dbglog("drop: invalid children notification (%X)\n",pkttype);
-#endif
-            return 1;
-        }
-        *p++ = 0;
-#ifdef DEBUG_NET_NOTIFICATION
-            dbglog("NOTIFY_PKT_CHILDREN %s : new children is \"%s\" plug %x\n",serial,children ,*p);
-            YSPRINTF(Dbuffer,512,"CHILD    >%s  childserial=%s on-off=%c (%d)\n",
-                     serial, children,*p,abspos);
-            dumpNotif(Dbuffer);
-#endif
-        hub->devListExpires = 0;
-        if (*p == '0') {
-            unregisterNetDevice(yHashPutStr(children));
-        }
-        break;
-    case NOTIFY_NETPKT_LOG:
-#ifdef DEBUG_NET_NOTIFICATION
-            dbglog("NOTIFY_NETPKT_LOG %s\n", serial);
-#endif
-    {
-        yStrRef serialref = yHashPutStr(serial);
-        int devydx = wpGetDevYdx(serialref);
-        if (devydx >= 0) {
-            yEnterCriticalSection(&yContext->generic_cs);
-            if (yContext->generic_infos[devydx].flags & DEVGEN_LOG_ACTIVATED) {
-                yContext->generic_infos[devydx].flags |= DEVGEN_LOG_PENDING;
-#ifdef DEBUG_NET_NOTIFICATION
-                        dbglog("notify device log for %s (%d)\n", serial,devydx);
-#endif
-            }
-            yLeaveCriticalSection(&yContext->generic_cs);
-        }
-    }
-    break;
-    default:
-#ifdef DEBUG_NET_NOTIFICATION
-            dbglog("drop: invalid pkttype (%X)\n",pkttype);
-            dumpNotif("drop: invalid pkttype\n");
-#endif
-        break;
-
-    }
-    return 1;
-}
-
-static int yTcpTrafficPending(void)
-{
-    int i;
-    HubSt* hub;
-
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        hub = yContext->nethub[i];
-        if (hub == NULL || hub->url == INVALID_HASH_IDX)
-            continue;
-        if (yReqHasPending(hub)) {
-            return 1;
-        }
-    }
-    return 0;
-}
-
-void request_pending_logs(HubSt* hub)
-{
-    int i;
-    for (i = 0; i < ALLOC_YDX_PER_HUB; i++) {
-        int devydx = hub->devYdxMap[i];
-        if (devydx != 0xff) {
-            yapiPullDeviceLogEx(devydx);
-        }
-    }
-}
-
-static void* yhelper_thread(void* ctx)
-{
-    int i, towatch;
-    u8 buffer[512];
-    yThread* thread = (yThread*)ctx;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    HubSt* hub = (HubSt*)thread->ctx;
-    RequestSt *req, *selectlist[1 + ALLOC_YDX_PER_HUB];
-    u32 toread;
-    int res;
-    int first_notification_connection = 1;
-#ifdef DEBUG_NET_NOTIFICATION
-    char        Dbuffer[1024];
-#endif
-
-
-    yThreadSignalStart(thread);
-    while (!yThreadMustEnd(thread)) {
-        // Handle async connections as well in this thread
-        request_pending_logs(hub);
-        towatch = 0;
-        if (hub->state == NET_HUB_ESTABLISHED || hub->state == NET_HUB_TRYING) {
-            selectlist[towatch] = hub->http.notReq;
-            towatch++;
-        } else if (hub->state == NET_HUB_TOCLOSE) {
-            yReqClose(hub->http.notReq);
-            hub->state = NET_HUB_CLOSED;
-        } else if (hub->state == NET_HUB_DISCONNECTED) {
-            u64 now;
-            if (hub->http.notReq == NULL) {
-                hub->http.notReq = yReqAlloc(hub);
-            }
-            now = yapiGetTickCount();
-            if ((u64)(now - hub->lastAttempt) > hub->attemptDelay) {
-                char request[256];
-#ifdef TRACE_NET_HUB
-                dbglog("TRACE(%X->%s): try to open notification socket at %d\n",hub->url,hub->name, hub->notifAbsPos);
-#endif
-                // reset fifo
-                yFifoEmpty(&(hub->not_fifo));
-                if (first_notification_connection) {
-                    YSPRINTF(request, 256, "GET /not.byn HTTP/1.1\r\n\r\n");
-                } else {
-                    YSPRINTF(request, 256, "GET /not.byn?abs=%u HTTP/1.1\r\n\r\n", hub->notifAbsPos);
-                }
-                res = yReqOpen(hub->http.notReq, 2 * YIO_DEFAULT_TCP_TIMEOUT, 0, request, YSTRLEN(request), 0, NULL, NULL, NULL, NULL, errmsg);
-                if (YISERR(res)) {
-                    hub->attemptDelay = 500 << hub->retryCount;
-                    if (hub->attemptDelay > 8000)
-                        hub->attemptDelay = 8000;
-                    hub->lastAttempt = yapiGetTickCount();
-                    hub->retryCount++;
-                    yEnterCriticalSection(&hub->access);
-                    hub->errcode = ySetErr(res, hub->errmsg, errmsg, NULL, 0);
-                    yLeaveCriticalSection(&hub->access);
-
-#ifdef TRACE_NET_HUB
-                dbglog("TRACE(%X->%s): unable to open notification socket(%s)\n",hub->url,hub->name,errmsg);
-                dbglog("TRACE(%X->%s): retry in %dms (%d retries)\n",hub->url,hub->name,hub->attemptDelay,hub->retryCount);
-#endif
-                } else {
-#ifdef TRACE_NET_HUB
-                    dbglog("TRACE(%X->%s): notification socket open\n",hub->url,hub->name);
-#endif
-#ifdef DEBUG_NET_NOTIFICATION
-                    YSPRINTF(Dbuffer,1024,"HUB: %X->%s started\n",hub->url,hub->name);
-                    dumpNotif(Dbuffer);
-#endif
-                    hub->state = NET_HUB_TRYING;
-                    hub->retryCount = 0;
-                    hub->attemptDelay = 500;
-                    hub->http.lastTraffic = yapiGetTickCount();
-                    hub->send_ping = 0;
-                    selectlist[towatch++] = hub->http.notReq;
-                    first_notification_connection = 0;
-                }
-            }
-        }
-
-        // Handle async connections as well in this thread
-        for (i = 0; i < ALLOC_YDX_PER_HUB; i++) {
-            req = yContext->tcpreq[i];
-            if (req == NULL || req->hub != hub) {
-                continue;
-            }
-            if (yReqIsAsync(req)) {
-                selectlist[towatch++] = req;
-            }
-        }
-
-        if (YISERR(yReqMultiSelect(selectlist, towatch, 1000, &hub->wuce, errmsg))) {
-            dbglog("yTcpMultiSelectReq failed (%s)\n",errmsg);
-            yApproximateSleep(1000);
-        } else {
-            for (i = 0; i < towatch; i++) {
-                req = selectlist[i];
-                if (req == hub->http.notReq) {
-                    toread = yFifoGetFree(&hub->not_fifo);
-                    while (toread > 0) {
-                        if (toread >= sizeof(buffer)) toread = sizeof(buffer) - 1;
-                        res = yReqRead(req, buffer, toread);
-                        if (res > 0) {
-                            buffer[res] = 0;
-#if 0 //def DEBUG_NET_NOTIFICATION
-                            YSPRINTF(Dbuffer,1024,"HUB: %X->%s push %d [\n%s\n]\n",hub->url,hub->name,res,buffer);
-                            dumpNotif(Dbuffer);
-#endif
-                            yPushFifo(&(hub->not_fifo), (u8*)buffer, res);
-                            if (hub->state == NET_HUB_TRYING) {
-                                int eoh = ySeekFifo(&(hub->not_fifo), (u8 *)"\r\n\r\n", 4, 0, 0, 0);
-                                if (eoh != 0xffff) {
-                                    if (eoh >= 12) {
-                                        yPopFifo(&(hub->not_fifo), (u8 *)buffer, 12);
-                                        yPopFifo(&(hub->not_fifo), NULL, eoh + 4 - 12);
-                                        if (!memcmp((u8 *)buffer, (u8 *)"HTTP/1.1 200", 12)) {
-                                            hub->state = NET_HUB_ESTABLISHED;
-                                        }
-                                    }
-                                    if (hub->state != NET_HUB_ESTABLISHED) {
-                                        // invalid header received, give up
-                                        char hubname[YOCTO_HOSTNAME_NAME] = "";
-                                        hub->state = NET_HUB_TOCLOSE;
-                                        yHashGetUrlPort(hub->url, hubname, NULL, NULL, NULL, NULL, NULL);
-                                        dbglog("Network hub %s cannot provide notifications", hubname);
-                                    }
-                                }
-                            }
-                            if (hub->state == NET_HUB_ESTABLISHED) {
-                                while (handleNetNotification(hub));
-                            }
-                            hub->http.lastTraffic = yapiGetTickCount();
-                        } else {
-                            if (hub->send_ping && ((u64)(yapiGetTickCount() - hub->http.lastTraffic)) > NET_HUB_NOT_CONNECTION_TIMEOUT) {
-#ifdef TRACE_NET_HUB
-
-                                dbglog("network hub %s(%x) didn't respond for too long (%d)\n", hub->name, hub->url, res);
-#endif
-                                yReqClose(req);
-                                hub->state = NET_HUB_DISCONNECTED;
-                            }
-                            // nothing more to be read, exit loop
-                            break;
-                        }
-                        toread = yFifoGetFree(&hub->not_fifo);
-                    }
-                    res = yReqIsEof(req, errmsg);
-                    if (res != 0) {
-                        // error or remote close
-                        yReqClose(req);
-                        hub->state = NET_HUB_DISCONNECTED;
-                        if (res == 1) {
-                            // remote close
-                            YERRMSG(YAPI_IO_ERROR, "Connection closed by remote host");
-                            dbglog("Disconnected from network hub %s (%s)\n", hub->name, errmsg);
-                        } else {
-                            //error
-                            hub->attemptDelay = 500 << hub->retryCount;
-                            if (hub->attemptDelay > 8000)
-                                hub->attemptDelay = 8000;
-                            hub->lastAttempt = yapiGetTickCount();
-                            hub->retryCount++;
-                            yEnterCriticalSection(&hub->access);
-                            hub->errcode = ySetErr(res, hub->errmsg, errmsg, NULL, 0);
-                            yLeaveCriticalSection(&hub->access);
-                        }
-#ifdef DEBUG_NET_NOTIFICATION
-                        YSPRINTF(Dbuffer, 1024, "Network hub %X->%s has closed the connection for notification\n", hub->url, hub->name);
-                        dumpNotif(Dbuffer);
-#endif
-                    }
-                } else if (yReqIsAsync(req)) {
-                    res = yReqIsEof(req, errmsg);
-                    if (res != 0) {
-                        yReqClose(req);
-                    }
-                }
-            }
-        }
-    }
-
-    if (hub->state == NET_HUB_TOCLOSE) {
-        yReqClose(hub->http.notReq);
-        hub->state = NET_HUB_CLOSED;
-    }
-
-    yThreadSignalEnd(thread);
-    return NULL;
-}
-
-
-static YRETCODE yapiLockFunctionCallBack_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    yEnterCriticalSection(&yContext->functionCallbackCS);
-    return YAPI_SUCCESS;
-}
-
-
-static YRETCODE yapiUnlockFunctionCallBack_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    yLeaveCriticalSection(&yContext->functionCallbackCS);
-    return YAPI_SUCCESS;
-}
-
-
-static YRETCODE yapiLockDeviceCallBack_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    yEnterCriticalSection(&yContext->deviceCallbackCS);
-    return YAPI_SUCCESS;
-}
-
-
-static YRETCODE yapiUnlockDeviceCallBack_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    yLeaveCriticalSection(&yContext->deviceCallbackCS);
-    return YAPI_SUCCESS;
-}
-
-
-static YRETCODE yapiRegisterHubEx(const char* url, int checkacces, char* errmsg)
-{
-    int i;
-    int res;
-
-    if (!yContext) {
-        YPROPERR(yapiInitAPI_internal(0,errmsg));
-    }
-
-    if (YSTRICMP(url,"usb") == 0) {
-        if (!(yContext->detecttype & Y_DETECT_USB)) {
-            yEnterCriticalSection(&yContext->enum_cs);
-            res = yUsbInit(yContext, errmsg);
-            if (!YISERR(res)) {
-                yContext->detecttype |= Y_DETECT_USB;
-            }
-            yLeaveCriticalSection(&yContext->enum_cs);
-            YPROPERR(res);
-        }
-        if (checkacces) {
-            yEnterCriticalSection(&yContext->updateDev_cs);
-            res = yUSBUpdateDeviceList(errmsg);
-            yLeaveCriticalSection(&yContext->updateDev_cs);
-            return res;
-        }
-    } else if (YSTRICMP(url,"net") == 0) {
-        if (!(yContext->detecttype & Y_DETECT_NET)) {
-            yEnterCriticalSection(&yContext->enum_cs);
-            yContext->detecttype |= Y_DETECT_NET;
-            res = ySSDPStart(&yContext->SSDP, ssdpEntryUpdate, errmsg);
-            yLeaveCriticalSection(&yContext->enum_cs);
-            YPROPERR(res);
-        }
-        if (checkacces) {
-            res = yapiUpdateDeviceList_internal(1, errmsg);
-            return res;
-        }
-    } else {
-        HubSt* hubst = NULL;
-        int firstfree;
-        void* (*thead_handler)(void*);
-
-        hubst = yapiAllocHub(url, errmsg);
-        if (hubst == NULL) {
-            return YAPI_INVALID_ARGUMENT;
-        }
-        if (checkacces) {
-            hubst->mandatory = 1;
-        }
-        //look if we already know this
-        yEnterCriticalSection(&yContext->enum_cs);
-        firstfree = NBMAX_NET_HUB;
-        for (i = 0; i < NBMAX_NET_HUB; i++) {
-            if (yContext->nethub[i] && yHashSameHub(yContext->nethub[i]->url, hubst->url))
-                break;
-            if (firstfree == NBMAX_NET_HUB && yContext->nethub[i] == NULL) {
-                firstfree = i;
-            }
-        }
-
-
-        if (i >= NBMAX_NET_HUB && firstfree < NBMAX_NET_HUB) {
-            i = firstfree;
-            // save mapping attributed from first access
-#ifdef TRACE_NET_HUB
-            dbglog("HUB: register %x->%s \n", hubst->url, hubst->name);
-#endif
-            yContext->nethub[i] = hubst;
-            if (YISERR(res = yStartWakeUpSocket(&yContext->nethub[i]->wuce, errmsg))) {
-                yLeaveCriticalSection(&yContext->enum_cs);
-                return (YRETCODE)res;
-            }
-            if (hubst->proto == PROTO_WEBSOCKET) {
-                thead_handler = ws_thread;
-            } else {
-                thead_handler = yhelper_thread;
-            }
-            //yThreadCreate will not create a new thread if there is already one running
-            if (yThreadCreate(&yContext->nethub[i]->net_thread, thead_handler, (void*)yContext->nethub[i]) < 0) {
-                yLeaveCriticalSection(&yContext->enum_cs);
-                return YERRMSG(YAPI_IO_ERROR, "Unable to start helper thread");
-            }
-            yDringWakeUpSocket(&yContext->nethub[i]->wuce, 1, errmsg);
-        }
-        yLeaveCriticalSection(&yContext->enum_cs);
-        if (i == NBMAX_NET_HUB) {
-            yapiFreeHub(hubst);
-            return YERRMSG(YAPI_INVALID_ARGUMENT, "Too many network hub registered");
-        }
-
-        if (checkacces) {
-            // ensure the thread has been able to connect to the hub
-            u64 timeout = yapiGetTickCount() + YIO_DEFAULT_TCP_TIMEOUT;
-            while (hubst->state != NET_HUB_ESTABLISHED && hubst->state != NET_HUB_CLOSED && timeout > yapiGetTickCount()) {
-                yapiSleep(100, errmsg);
-            }
-            if (hubst->state != NET_HUB_ESTABLISHED) {
-                yEnterCriticalSection(&hubst->access);
-                res = YERRMSGSILENT(yContext->nethub[i]->errcode, yContext->nethub[i]->errmsg);
-                yLeaveCriticalSection(&hubst->access);
-                if (!YISERR(res)) {
-                    return YERRMSG(YAPI_IO_ERROR, "hub not ready");
-                }
-                unregisterNetHub(hubst->url);
-                return res;
-            }
-            yEnterCriticalSection(&yContext->updateDev_cs);
-            res = yNetHubEnum(hubst, 1, errmsg);
-            yLeaveCriticalSection(&yContext->updateDev_cs);
-            if (YISERR(res)) {
-                yapiUnregisterHub_internal(url);
-            } else if (hubst->proto != PROTO_WEBSOCKET) {
-                // for HTTP test admin pass if the hub require it
-                if (hubst->writeProtected && hubst->http.s_user && strcmp(hubst->http.s_user, "admin") == 0) {
-                    YIOHDL iohdl;
-                    const char* request = "GET /api/module/serial?serial=&. ";
-                    char* reply = NULL;
-                    int replysize = 0;
-                    int tmpres = yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, yHashGetStrPtr(hubst->serial), request, YSTRLEN(request), &reply, &replysize, NULL, NULL, errmsg);
-                    if (tmpres == YAPI_UNAUTHORIZED) {
-                        return tmpres;
-                    }
-                    if (tmpres == YAPI_SUCCESS) {
-                        yapiHTTPRequestSyncDone_internal(&iohdl, errmsg);
-                    }
-                }
-            }
-
-            return res;
-        }
-
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int pingURLOnhub(HubSt* hubst, const char* request, int mstimeout, char* errmsg)
-{
-    yJsonStateMachine j;
-    u8 buffer[1500];
-    int res;
-    yJsonRetCode jstate = YJSON_NEED_INPUT;
-    u64 globalTimeout;
-    RequestSt* req;
-
-    globalTimeout = yapiGetTickCount() + mstimeout;
-
-    req = yReqAlloc(hubst);
-    if (YISERR((res = yReqOpen(req, 2 * YIO_DEFAULT_TCP_TIMEOUT, 0, request, YSTRLEN(request), mstimeout, NULL, NULL, NULL, NULL, errmsg)))) {
-        yReqFree(req);
-        return res;
-    }
-    // init yjson parser
-    memset(&j, 0, sizeof(j));
-    j.st = YJSON_HTTP_START;
-    while (jstate == YJSON_NEED_INPUT) {
-        res = yReqSelect(req, 500, errmsg);
-        if (YISERR(res)) {
-            break;
-        }
-        res = yReqRead(req, buffer, sizeof(buffer));
-        while (res > 0) {
-            j.src = (char*)buffer;
-            j.end = (char*)buffer + res;
-            // parse all we can on this buffer
-            jstate = yJsonParse(&j);
-            while (jstate == YJSON_PARSE_AVAIL) {
-                jstate = yJsonParse(&j);
-            }
-            res = yReqRead(req, buffer, sizeof(buffer));
-        }
-        if (res <= 0) {
-            res = yReqIsEof(req, errmsg);
-            if (YISERR(res)) {
-                // any specific error during select
-                yReqClose(req);
-                yReqFree(req);
-                return res;
-            }
-            if (res == 1 && jstate == YJSON_NEED_INPUT) {
-                // connection close before end of result
-                res = YERR(YAPI_IO_ERROR);
-            }
-            if (yapiGetTickCount() >= globalTimeout) {
-                res = YERR(YAPI_TIMEOUT);
-            }
-        }
-    }
-    yReqClose(req);
-    yReqFree(req);
-
-    if (res == YAPI_SUCCESS) {
-        switch (jstate) {
-        case YJSON_NEED_INPUT:
-            return YERRMSG(YAPI_IO_ERROR,"Remote host has close the connection");
-        case YJSON_PARSE_AVAIL:
-        case YJSON_FAILED:
-            return YERRMSG(YAPI_IO_ERROR,"Invalid json data");
-        case YJSON_SUCCESS:
-            break;
-        }
-    }
-    return res;
-}
-
-static YRETCODE yapiTestHub_internal(const char* url, int mstimeout, char* errmsg)
-{
-    int freeApi = 0;
-    int res;
-
-    if (!yContext) {
-        YPROPERR(yapiInitAPI_internal(0,errmsg));
-        freeApi = 1;
-    }
-
-    if (YSTRICMP(url, "usb") == 0) {
-        res = YAPI_SUCCESS;
-    } else if (YSTRICMP(url, "net") == 0) {
-        res = YAPI_SUCCESS;
-    } else {
-        HubSt* hubst = yapiAllocHub(url, errmsg);
-        if (hubst) {
-#ifdef TRACE_NET_HUB
-            dbglog("HUB: test %x->%s \n", hubst->url, hubst->name);
-#endif
-            if (hubst->proto == PROTO_WEBSOCKET) {
-                u64 timeout;
-                if (YISERR(res = yStartWakeUpSocket(&hubst->wuce, errmsg))) {
-                    yapiFreeHub(hubst);
-                    return (YRETCODE)res;
-                }
-                //yThreadCreate will not create a new thread if there is already one running
-                if (yThreadCreate(&hubst->net_thread, ws_thread, (void*)hubst) < 0) {
-                    yapiFreeHub(hubst);
-                    return YERRMSG(YAPI_IO_ERROR, "Unable to start helper thread");
-                }
-                yDringWakeUpSocket(&hubst->wuce, 1, errmsg);
-
-                // ensure the thread has been able to connect to the hub
-                timeout = yapiGetTickCount() + mstimeout;
-                while (hubst->state != NET_HUB_ESTABLISHED && hubst->state != NET_HUB_CLOSED && timeout > yapiGetTickCount()) {
-                    yapiSleep(10, errmsg);
-                }
-                if (hubst->state != NET_HUB_ESTABLISHED) {
-                    yEnterCriticalSection(&hubst->access);
-                    res = YERRMSGSILENT(hubst->errcode, hubst->errmsg);
-                    yLeaveCriticalSection(&hubst->access);
-                    if (!YISERR(res)) {
-                        res = YERRMSG(YAPI_IO_ERROR, "hub not ready");
-                    }
-                }
-                if (!YISERR(res)) {
-                    res = pingURLOnhub(hubst, "GET /api/module/firmwareRelease.json \r\n\r\n", (int)(timeout - yapiGetTickCount()), errmsg);
-                }
-                hubst->state = NET_HUB_TOCLOSE;
-                yThreadRequestEnd(&hubst->net_thread);
-                yDringWakeUpSocket(&hubst->wuce, 0, errmsg);
-                // wait for the helper thread to stop monitoring these devices
-                yThreadKill(&hubst->net_thread);
-            } else {
-                res = pingURLOnhub(hubst, "GET /api/module/firmwareRelease.json \r\n\r\n", mstimeout, errmsg);
-            }
-            yapiFreeHub(hubst);
-        } else {
-            return YAPI_IO_ERROR;
-        }
-    }
-    if (freeApi) {
-        yapiFreeAPI_internal();
-    }
-    return res;
-}
-
-
-static YRETCODE yapiRegisterHub_internal(const char* url, char* errmsg)
-{
-    YRETCODE res;
-    res = yapiRegisterHubEx(url, 1, errmsg);
-    return res;
-}
-
-static YRETCODE yapiPreregisterHub_internal(const char* url, char* errmsg)
-{
-    YRETCODE res;
-    res = yapiRegisterHubEx(url, 0, errmsg);
-    return res;
-}
-
-static void yapiUnregisterHub_internal(const char* url)
-{
-    yUrlRef huburl;
-
-    if (!yContext) {
-        return;
-    }
-    if (YSTRICMP(url,"usb") == 0) {
-        if (yContext->detecttype & Y_DETECT_USB) {
-            yUSBReleaseAllDevices();
-            yUsbFree(yContext,NULL);
-            yContext->detecttype ^= Y_DETECT_USB;
-        }
-    } else if (YSTRICMP(url,"net") == 0) {
-        if (yContext->detecttype & Y_DETECT_NET) {
-            yContext->detecttype ^= Y_DETECT_NET;
-        }
-    } else {
-        // compute an hashed url
-        huburl = yHashUrl(url, "", 1,NULL);
-        if (huburl == INVALID_HASH_IDX) {
-            return;
-        }
-        //look if we already know this
-        yEnterCriticalSection(&yContext->enum_cs);
-        unregisterNetHub(huburl);
-        yLeaveCriticalSection(&yContext->enum_cs);
-    }
-}
-
-
-static YRETCODE yapiUpdateDeviceList_internal(u32 forceupdate, char* errmsg)
-{
-    int i;
-    YRETCODE err = YAPI_SUCCESS;
-    char suberr[YOCTO_ERRMSG_LEN];
-
-    if (yContext == NULL)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (forceupdate) {
-        yEnterCriticalSection(&yContext->updateDev_cs);
-    } else {
-        // if we do not force an update
-        if (!yTryEnterCriticalSection(&yContext->updateDev_cs)) {
-            return YAPI_SUCCESS;
-        }
-    }
-    if (yContext->detecttype & Y_DETECT_USB) {
-        err = yUSBUpdateDeviceList(errmsg);
-    }
-
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        if (yContext->nethub[i]) {
-            int subres;
-            if (YISERR(subres = yNetHubEnum(yContext->nethub[i], forceupdate, suberr)) && err == YAPI_SUCCESS) {
-                //keep first generated error
-                char buffer[YOCTO_HOSTNAME_NAME] = "";
-                u16 port;
-                err = (YRETCODE)subres;
-                yHashGetUrlPort(yContext->nethub[i]->url, buffer, &port, NULL, NULL, NULL, NULL);
-                if (errmsg) {
-                    YSPRINTF(errmsg,YOCTO_ERRMSG_LEN, "Enumeration failed for %s:%d (%s)", buffer, port, suberr);
-                }
-            }
-        }
-    }
-    yLeaveCriticalSection(&yContext->updateDev_cs);
-
-    return err;
-}
-
-
-static YRETCODE yapiHandleEvents_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    // we need only one thread to handle the event at a time
-    if (yTryEnterCriticalSection(&yContext->handleEv_cs)) {
-        YRETCODE res = (YRETCODE)yUsbIdle();
-        yLeaveCriticalSection(&yContext->handleEv_cs);
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-u64 test_pkt = 0;
-u64 test_tout = 0;
-
-static YRETCODE yapiSleep_internal(int ms_duration, char* errmsg)
-{
-    u64 now, timeout;
-    YRETCODE err = YAPI_SUCCESS;
-
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    timeout = yapiGetTickCount() + ms_duration;
-    do {
-        if (err == YAPI_SUCCESS) {
-            err = yapiHandleEvents_internal(errmsg);
-        }
-        now = yapiGetTickCount();
-        // todo: we may want to use a smaller timeout
-        if (now < timeout) {
-            if (yWaitForEvent(&yContext->exitSleepEvent, (int)(timeout - now)))
-                test_pkt++; //just for testing
-            else
-                test_tout++;
-        }
-    } while (yapiGetTickCount() < timeout);
-
-    return err;
-}
-
-#ifdef WINDOWS_API
-static int tickUseHiRes = -1;
-static u64 tickOffset = 0;
-static LARGE_INTEGER tickFrequency;
-static LARGE_INTEGER tickStart;
-#endif
-u64 YAPI_FUNCTION_EXPORT yapiGetTickCount(void)
-{
-    u64 res;
-
-#ifdef WINDOWS_API
-    LARGE_INTEGER performanceCounter;
-
-    if (tickUseHiRes < 0) {
-        if (QueryPerformanceFrequency(&tickFrequency)) {
-            tickUseHiRes = 1;
-            tickOffset = (u64)time(NULL) * 1000u;
-            QueryPerformanceCounter(&tickStart);
-        } else {
-            tickUseHiRes = 0;
-            tickOffset = (u64)time(NULL) * 1000u - GetTickCount();
-        }
-        // make sure the offset is always > 0
-        if ((s64)tickOffset <= 0) tickOffset = 1;
-    }
-    if (tickUseHiRes > 0) {
-        QueryPerformanceCounter(&performanceCounter);
-        performanceCounter.QuadPart -= tickStart.QuadPart;
-        // we add +1 because it is not nice to start with zero
-        res = performanceCounter.QuadPart * 1000 / tickFrequency.QuadPart + tickOffset;
-    } else {
-        res = GetTickCount() + tickOffset;
-    }
-#else
-    //get the current number of microseconds since January 1st 1970
-    struct timeval tim;
-    gettimeofday(&tim, NULL);
-    res = (u64)tim.tv_sec * 1000 + (tim.tv_usec / 1000);
-#endif
-
-    return res;
-}
-
-u32 yapiGetCNonce(u32 nc)
-{
-    HASH_SUM ctx;
-    u32 md5[4];
-
-#ifdef WINDOWS_API
-    LARGE_INTEGER performanceCounter;
-
-    if (tickUseHiRes > 0) {
-        QueryPerformanceCounter(&performanceCounter);
-    } else {
-        performanceCounter.QuadPart = GetTickCount();
-    }
-    MD5Initialize(&ctx);
-    MD5AddData(&ctx, (u8 *)&performanceCounter, sizeof(performanceCounter));
-#else
-    //get the current number of microseconds since January 1st 1970
-    struct timeval tim;
-
-    gettimeofday(&tim, NULL);
-    MD5Initialize(&ctx);
-    MD5AddData(&ctx, (u8 *)&tim, sizeof(tim));
-#endif
-    MD5AddData(&ctx, (u8 *)&nc, sizeof(nc));
-    MD5Calculate(&ctx, (u8 *)md5);
-
-    return md5[1];
-}
-
-static int yapiCheckLogicalName_internal(const char* name)
-{
-    char c;
-
-    if (!name) return 0;
-    if (!*name) return 1;
-    if (strlen(name) > 19) return 0;
-    while ((c = *name++) != 0) {
-        if (c < '-') return 0;
-        if (c > '-' && c < '0') return 0;
-        if (c > '9' && c < 'A') return 0;
-        if (c > 'Z' && c < '_') return 0;
-        if (c > '_' && c < 'a') return 0;
-        if (c > 'z') return 0;
-    }
-    return 1;
-}
-
-
-static u16 yapiGetAPIVersion_internal(const char** version, const char** apidate)
-{
-    if (version)
-        *version = YOCTO_API_VERSION_STR"."YOCTO_API_BUILD_NO;
-    if (apidate)
-        *apidate = YOCTO_API_BUILD_DATE;
-
-    return YOCTO_API_VERSION_BCD;
-}
-
-static void yapiSetTraceFile_internal(const char* file)
-{
-    if (file != NULL) {
-        memset(ytracefile, 0,TRACEFILE_NAMELEN);
-        YSTRNCPY(ytracefile,TRACEFILE_NAMELEN-1,file,TRACEFILE_NAMELEN-1);
-    } else {
-        ytracefile[0] = 0;
-    }
-}
-
-
-static YAPI_DEVICE yapiGetDevice_internal(const char* device_str, char* errmsg)
-{
-    char hostname[HASH_BUF_SIZE], c;
-    int i;
-    YAPI_DEVICE res;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (!strncmp(device_str, "http://", 7)) {
-        for (i = 0; i < HASH_BUF_SIZE - 1; i++) {
-            c = device_str[7 + i];
-            if (!c || c == '/') break;
-            hostname[i] = c;
-        }
-        res = wpSearchByUrl(hostname, device_str + 7 + i);
-    } else {
-        res = wpSearch(device_str);
-    }
-    if (res == -1) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    return res;
-}
-
-
-static int yapiGetAllDevices_internal(YAPI_DEVICE* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int maxdev, nbreturned;
-    yBlkHdl devhdl;
-    YAPI_DEVICE devdescr;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (buffer == NULL && neededsize == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-
-    nbreturned = 0;
-    if (buffer) {
-        // This function walks through the white pages without taking the mutex globally
-        // it is only reasonably safe because wpGetAttribute properly handles dangerous devhdl.
-        // (same principle as used by HTTPSendRec for the REST API)
-        maxdev = 0;
-        for (devhdl = yWpListHead; devhdl != INVALID_BLK_HDL; devhdl = yBlkListSeek(devhdl, 1)) {
-            devdescr = wpGetAttribute(devhdl, Y_WP_SERIALNUMBER);
-            if (devdescr < 0) continue;
-            maxdev++;
-            if (maxsize >= (int)sizeof(YAPI_DEVICE)) {
-                maxsize -= sizeof(YAPI_DEVICE);
-                *buffer++ = devdescr;
-                nbreturned++;
-            }
-        }
-        if (neededsize) *neededsize = sizeof(YAPI_DEVICE) * maxdev;
-    } else {
-        if (neededsize) *neededsize = sizeof(YAPI_DEVICE) * wpEntryCount();
-    }
-
-    return nbreturned;
-}
-
-
-static YRETCODE yapiGetDeviceInfo_internal(YAPI_DEVICE devdesc, yDeviceSt* infos, char* errmsg)
-{
-    YUSBDEV devhdl;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (devdesc < 0 || infos == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-
-    yHashGetStr(devdesc & 0xffff, infos->serial, YOCTO_SERIAL_LEN);
-    devhdl = findDevHdlFromStr(infos->serial);
-    if (devhdl != INVALID_YHANDLE) {
-        // local device, get all information straight from the source
-        devHdlInfo(devhdl, infos);
-    } else {
-        // not a local device, get available information from white pages
-        infos->vendorid = 0x24e0;
-        infos->devrelease = 0;
-        infos->nbinbterfaces = 1;
-        memcpy((u8 *)infos->manufacturer, (u8 *)"Yoctopuce", 10);
-        memset(infos->firmware, 0, YOCTO_FIRMWARE_LEN);
-        if (wpGetDeviceInfo(devdesc, &infos->deviceid, infos->productname, infos->serial, infos->logicalname, &infos->beacon) < 0) {
-            return YERR(YAPI_DEVICE_NOT_FOUND);
-        }
-    }
-
-    return YAPI_SUCCESS;
-}
-
-static YRETCODE yapiGetDevicePath_internal(YAPI_DEVICE devdesc, char* rootdevice, char* request, int requestsize, int* neededsize, char* errmsg)
-{
-    YRETCODE res;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    if (rootdevice == NULL && request == NULL && neededsize == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    res = (YRETCODE)wpGetDeviceUrl(devdesc, rootdevice, request, requestsize, neededsize);
-    if (neededsize) *neededsize += 4;
-    if (res < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    return res;
-}
-
-
-static YRETCODE yapiGetDevicePathEx_internal(const char* serial, char* rootdevice, char* request, int requestsize, int* neededsize, char* errmsg)
-{
-    YAPI_DEVICE devdescr;
-    yUrlRef url;
-    char host[YOCTO_HOSTNAME_NAME];
-    char buffer[512];
-    u16 port;
-    yAsbUrlProto proto;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    if (rootdevice == NULL && request == NULL && neededsize == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    devdescr = wpSearch(serial);
-    if (YISERR(devdescr)) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    url = wpGetDeviceUrlRef(devdescr);
-    switch (yHashGetUrlPort(url, host, &port, &proto, NULL, NULL, NULL)) {
-    case USB_URL:
-        if (rootdevice) {
-            *rootdevice = 0;
-        }
-        if (request && requestsize > 4) {
-            YSTRCPY(request, requestsize, "usb");
-        }
-        if (*neededsize) {
-            *neededsize = 4;
-        }
-        break;
-    default:
-        wpGetDeviceUrl(devdescr, rootdevice, buffer, 512, neededsize);
-        if (request) {
-
-            int len = YSPRINTF(request, requestsize, "%s://%s:%d%s", proto == PROTO_WEBSOCKET ? "ws" : "http", host, port, buffer);
-            *neededsize = len + 1;
-        }
-        if (rootdevice && YSTRCMP(rootdevice, serial) == 0) {
-            *rootdevice = 0;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static YAPI_FUNCTION yapiGetFunction_internal(const char* class_str, const char* function_str, char* errmsg)
-{
-    YAPI_FUNCTION res;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    res = ypSearch(class_str, function_str);
-    if (res < 0) {
-        if (res == -2) {
-            return YERRMSG(YAPI_DEVICE_NOT_FOUND, "No function of that class");
-        }
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    return res;
-}
-
-static int yapiGetFunctionsByClass_internal(const char* class_str, YAPI_FUNCTION prevfundesc,
-                                            YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int res;
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    if (buffer == NULL && neededsize == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-
-    res = ypGetFunctions(class_str, -1, prevfundesc, buffer, maxsize, neededsize);
-    if (res < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND); // prevfundesc is invalid or has been unplugged, restart enum
-    }
-
-    return res;
-}
-
-static int yapiGetFunctionsByDevice_internal(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                                             YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int res;
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    if (buffer == NULL && neededsize == NULL) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    res = ypGetFunctions(NULL, devdesc, prevfundesc, buffer, maxsize, neededsize);
-    if (res < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND); // prevfundesc is invalid or has been unplugged, restart enum
-    }
-    return res;
-}
-
-
-static YRETCODE yapiGetFunctionInfoEx_internal(YAPI_FUNCTION fundesc, YAPI_DEVICE* devdesc, char* serial, char* funcId, char* baseType, char* funcName, char* funcVal, char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (ypGetFunctionInfo(fundesc, serial, funcId, baseType, funcName, funcVal) < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    if (devdesc)
-        *devdesc = fundesc & 0xffff;
-
-    return YAPI_SUCCESS;
-}
-
-
-static int yapiRequestOpenUSB(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, const char* request, int reqlen, u64 unused_timeout, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    char buffer[512];
-    YRETCODE res;
-    int firsttime = 1;
-    u64 timeout;
-    int count = 0;
-
-    yHashGetStr(dev & 0xffff, buffer, YOCTO_SERIAL_LEN);
-    timeout = yapiGetTickCount() + YAPI_BLOCKING_USBOPEN_REQUEST_TIMEOUT;
-    do {
-        count++;
-        res = (YRETCODE)yUsbOpen(iohdl, buffer, errmsg);
-        if (res != YAPI_DEVICE_BUSY) break;
-        yapiHandleEvents_internal(errmsg);
-        if (firsttime) {
-            //yApproximateSleep(1);
-            firsttime = 0;
-        }
-    } while (yapiGetTickCount() < timeout);
-
-    if (res != YAPI_SUCCESS) {
-        return res;
-    }
-    if (reqlen >= 10 && reqlen <= (int)sizeof(buffer) && !memcmp(request + reqlen - 7, "&. \r\n\r\n", 7)) {
-        memcpy(buffer, request, reqlen - 7);
-        memcpy(buffer + reqlen - 7, " \r\n\r\n", 5);
-        reqlen -= 2;
-        request = buffer;
-    }
-    res = (YRETCODE)yUsbWrite(iohdl, request, reqlen, errmsg);
-    if (YISERR(res)) {
-        yUsbClose(iohdl, errmsg);
-        return res;
-    }
-    if (callback) {
-        res = (YRETCODE)yUsbSetIOAsync(iohdl, callback, context, errmsg);
-        if (YISERR(res)) {
-            yUsbClose(iohdl, errmsg);
-            return res;
-        }
-    }
-    return res;
-}
-
-
-static int yapiRequestOpenHTTP(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, const char* request, int reqlen, int wait_for_start, u64 mstimeout, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YRETCODE res;
-    int devydx;
-    RequestSt* tcpreq;
-
-    devydx = wpGetDevYdx((yStrRef)dev);
-    if (devydx < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    yEnterCriticalSection(&yContext->io_cs);
-    tcpreq = yContext->tcpreq[devydx];
-    if (tcpreq == NULL) {
-        tcpreq = yReqAlloc(hub);
-        yContext->tcpreq[devydx] = tcpreq;
-    }
-    yLeaveCriticalSection(&yContext->io_cs);
-    if (callback) {
-        if (tcpreq->hub->writeProtected) {
-            // no need to take the critical section tcpreq->hub->http.authAccess since we only read user an pass
-            if (!tcpreq->hub->http.s_user || strcmp(tcpreq->hub->http.s_user, "admin") != 0) {
-                return YERRMSG(YAPI_UNAUTHORIZED, "Access denied: admin credentials required");
-            }
-        }
-    }
-    if ((tcpreq->hub->send_ping || !tcpreq->hub->mandatory) && tcpreq->hub->state != NET_HUB_ESTABLISHED) {
-        if (errmsg) {
-            YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "hub %s is not reachable", tcpreq->hub->name);
-        }
-        return YAPI_IO_ERROR;
-    }
-
-    res = (YRETCODE)yReqOpen(tcpreq, wait_for_start, 0, request, reqlen, mstimeout, callback, context, NULL, NULL, errmsg);
-    if (res != YAPI_SUCCESS) {
-        return res;
-    }
-
-    if (callback) {
-        res = (YRETCODE)yDringWakeUpSocket(&tcpreq->hub->wuce, 2, errmsg);
-        if (res != YAPI_SUCCESS) {
-            return res;
-        }
-    }
-    iohdl->tcpreqidx = devydx;
-    iohdl->type = YIO_TCP;
-    return YAPI_SUCCESS;
-}
-
-static int yapiRequestOpenWS(YIOHDL_internal* iohdl, HubSt* hub, YAPI_DEVICE dev, int tcpchan, const char* request, int reqlen, u64 mstimeout, yapiRequestAsyncCallback callback, void* context, RequestProgress progress_cb, void* progress_ctx, char* errmsg)
-{
-    YRETCODE res;
-    int devydx;
-    RequestSt* req;
-
-    devydx = wpGetDevYdx((yStrRef)dev);
-    if (devydx < 0) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    //dbglog("yapiRequestOpenWS on %p %s\n", hub, callback ? "ASYNC": "");
-    if (callback) {
-        if (hub->writeProtected && !hub->rw_access) {
-            return YERRMSG(YAPI_UNAUTHORIZED, "Access denied: admin credentials required");
-        }
-    }
-    req = yReqAlloc(hub);
-    if ((req->hub->send_ping || !req->hub->mandatory) && req->hub->state != NET_HUB_ESTABLISHED) {
-        if (errmsg) {
-            YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "hub %s is not reachable", req->hub->name);
-        }
-        return YAPI_IO_ERROR;
-    }
-
-    if (req->hub->state != NET_HUB_ESTABLISHED) {
-        if (YISERR(req->hub->errcode)) {
-            yEnterCriticalSection(&req->hub->access);
-            res = YERRMSG(req->hub->errcode, req->hub->errmsg);
-            yLeaveCriticalSection(&req->hub->access);
-            return res;
-        }
-        if (errmsg) {
-            YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "hub %s is not ready", req->hub->name);
-        }
-        return YERRMSG(YAPI_TIMEOUT, "hub is not ready");
-    }
-
-    res = (YRETCODE)yReqOpen(req, 2 * YIO_DEFAULT_TCP_TIMEOUT, tcpchan, request, reqlen, mstimeout, callback, context, progress_cb, progress_ctx, errmsg);
-    if (res != YAPI_SUCCESS) {
-        return res;
-    }
-
-    iohdl->ws = req;
-    iohdl->type = YIO_WS;
-    return YAPI_SUCCESS;
-}
-
-
-YRETCODE yapiRequestOpen(YIOHDL_internal* iohdl, int tcpchan, const char* device, const char* request, int reqlen, yapiRequestAsyncCallback callback, void* context, yapiRequestProgressCallback progress_cb, void* progress_ctx, char* errmsg)
-{
-    YAPI_DEVICE dev;
-    char buffer[512];
-    yUrlRef url;
-    yAsbUrlProto proto;
-    int i, len;
-    u64 mstimeout = YIO_DEFAULT_TCP_TIMEOUT;
-    HubSt* hub = NULL;
-
-    if (!yContext) {
-        return YERR(YAPI_NOT_INITIALIZED);
-    }
-
-    dev = wpSearch(device);
-    if (dev == -1) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    YASSERT(iohdl != NULL);
-    memset(iohdl, 0, sizeof(YIOHDL_internal));
-    // compute request timeout
-    len = (reqlen < YOCTO_SERIAL_LEN + 32 ? reqlen : YOCTO_SERIAL_LEN + 32);
-    if (memcmp(request, "GET ", 4) == 0) {
-        if (ymemfind((u8*)request + 4, len, (u8*)"/testcb.txt", 11) >= 0) {
-            mstimeout = YIO_1_MINUTE_TCP_TIMEOUT;
-        } else if (ymemfind((u8*)request + 4, len, (u8*)"/rxmsg.json", 11) >= 0) {
-            mstimeout = YIO_1_MINUTE_TCP_TIMEOUT;
-        } else if (ymemfind((u8*)request + 4, len, (u8*)"/files.json", 11) >= 0) {
-            mstimeout = YIO_1_MINUTE_TCP_TIMEOUT;
-        } else if (ymemfind((u8*)request + 4, len, (u8*)"/flash.json", 11) >= 0) {
-            mstimeout = YIO_10_MINUTES_TCP_TIMEOUT;
-        }
-    } else {
-        if (ymemfind((u8*)request + 4, len, (u8*)"/upload.html", 12) >= 0) {
-            //fixme: use 1 minute timeout for WS
-            mstimeout = YIO_10_MINUTES_TCP_TIMEOUT;
-        }
-    }
-
-    // dispatch request on correct hub (or pseudo usb HUB)
-    url = wpGetDeviceUrlRef(dev);
-    switch (yHashGetUrlPort(url, buffer, NULL, &proto, NULL, NULL, NULL)) {
-    case USB_URL:
-        return yapiRequestOpenUSB(iohdl, NULL, dev, request, reqlen, mstimeout, callback, context, errmsg);
-    default:
-        for (i = 0; i < NBMAX_NET_HUB; i++) {
-            if (yContext->nethub[i] && yHashSameHub(yContext->nethub[i]->url, url)) {
-                hub = yContext->nethub[i];
-                break;
-            }
-        }
-        if (hub == NULL) {
-            return YERR(YAPI_DEVICE_NOT_FOUND);
-        }
-        if (proto == PROTO_WEBSOCKET) {
-            return yapiRequestOpenWS(iohdl, hub, dev, tcpchan, request, reqlen, mstimeout, callback, context, progress_cb, progress_ctx, errmsg);
-        } else {
-            return yapiRequestOpenHTTP(iohdl, hub, dev, request, reqlen, 2 * YIO_DEFAULT_TCP_TIMEOUT, mstimeout, callback, context, errmsg);
-        }
-    }
-}
-
-static int yapiRequestWaitEndUSB(YIOHDL_internal* iohdl, char** reply, int* replysize, char* errmsg)
-{
-    u64 timeout;
-    yPrivDeviceSt* p;
-    int buffpos = 0;
-    int res;
-
-
-    timeout = yapiGetTickCount() + YAPI_BLOCKING_USBREAD_REQUEST_TIMEOUT;
-    p = findDevFromIOHdl(iohdl);
-    if (p == NULL) {
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    if (p->replybuf == NULL) {
-        p->replybufsize = 2048;
-        p->replybuf = (char*)yMalloc(p->replybufsize);
-    }
-    while ((res = (YRETCODE)yUsbEOF(iohdl, errmsg)) == 0) {
-        if (yapiGetTickCount() > timeout) {
-            yUsbClose(iohdl, NULL);
-            return YERRMSG(YAPI_TIMEOUT, "Timeout during device request");
-        }
-        if (buffpos + 256 > p->replybufsize) {
-            char* newbuff;
-            p->replybufsize <<= 1;
-            newbuff = (char*)yMalloc(p->replybufsize);
-            memcpy(newbuff, p->replybuf, buffpos);
-            yFree(p->replybuf);
-            p->replybuf = newbuff;
-        }
-        res = (YRETCODE)yUsbReadBlock(iohdl, p->replybuf + buffpos, p->replybufsize - buffpos, timeout, errmsg);
-        if (YISERR(res)) {
-            yUsbClose(iohdl, NULL);
-            return res;
-        } else if (res > 0) {
-            timeout = yapiGetTickCount() + YAPI_BLOCKING_USBREAD_REQUEST_TIMEOUT;
-        }
-        buffpos += res;
-    }
-    *reply = p->replybuf;
-    *replysize = buffpos;
-    return res;
-}
-
-
-static int yapiRequestWaitEndHTTP(YIOHDL_internal* iohdl, char** reply, int* replysize, char* errmsg)
-{
-    int res;
-    RequestSt* tcpreq = yContext->tcpreq[iohdl->tcpreqidx];
-
-    res = (YRETCODE)yReqIsEof(tcpreq, errmsg);
-    while (res == 0) {
-        res = (YRETCODE)yReqSelect(tcpreq, 1000, errmsg);
-        if (YISERR(res)) {
-            yReqClose(tcpreq);
-            return res;
-        }
-        res = (YRETCODE)yReqIsEof(tcpreq, errmsg);
-    }
-    if (YISERR(res) && res != YAPI_NO_MORE_DATA) {
-        yReqClose(tcpreq);
-        return res;
-    }
-    *replysize = yReqGet(tcpreq, (u8**)reply);
-    return YAPI_SUCCESS;
-}
-
-
-static int yapiRequestWaitEndWS(YIOHDL_internal* iohdl, char** reply, int* replysize, char* errmsg)
-{
-    int res;
-    RequestSt* tcpreq = iohdl->ws;
-
-    res = (YRETCODE)yReqIsEof(tcpreq, errmsg);
-    while (res == 0) {
-        res = (YRETCODE)yReqSelect(tcpreq, 1000, errmsg);
-        if (YISERR(res)) {
-            yReqClose(tcpreq);
-            return res;
-        }
-        res = (YRETCODE)yReqIsEof(tcpreq, errmsg);
-    }
-    if (YISERR(res) && res != YAPI_NO_MORE_DATA) {
-        yReqClose(tcpreq);
-        return res;
-    }
-    *replysize = yReqGet(tcpreq, (u8**)reply);
-    return YAPI_SUCCESS;
-}
-
-
-YRETCODE yapiHTTPRequestSyncStartEx_internal(YIOHDL* iohdl, int tcpchan, const char* device, const char* request, int requestsize, char** reply, int* replysize, yapiRequestProgressCallback progress_cb, void* progress_ctx, char* errmsg)
-{
-    YRETCODE res;
-    YIOHDL_internal* internalio;
-#ifdef DEBUG_YAPI_REQ
-    int req_count = YREQ_LOG_START("SyncStartEx", device, request, requestsize);
-    u64 start_tm = yapiGetTickCount();
-#endif
-
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-
-    *reply = NULL;
-    internalio = yMalloc(sizeof(YIOHDL_internal));
-    memset((u8 *)iohdl, 0, YIOHDL_SIZE);
-    if (YISERR(res = yapiRequestOpen(internalio, tcpchan, device, request, requestsize, NULL, NULL, progress_cb, progress_ctx, errmsg))) {
-        yFree(internalio);
-    } else {
-
-        if (internalio->type == YIO_USB) {
-            res = yapiRequestWaitEndUSB(internalio, reply, replysize, errmsg);
-        } else if (internalio->type == YIO_TCP) {
-            res = yapiRequestWaitEndHTTP(internalio, reply, replysize, errmsg);
-        } else if (internalio->type == YIO_WS) {
-            res = yapiRequestWaitEndWS(internalio, reply, replysize, errmsg);
-        } else {
-            yFree(internalio);
-            return YERR(YAPI_INVALID_ARGUMENT);
-        }
-
-        yEnterCriticalSection(&yContext->io_cs);
-        *iohdl = internalio;
-        internalio->next = yContext->yiohdl_first;
-        yContext->yiohdl_first = internalio;
-        yLeaveCriticalSection(&yContext->io_cs);
-    }
-#ifdef DEBUG_YAPI_REQ
-    if (res < 0) {
-        YREQ_LOG_APPEND_ERR(req_count, "SyncStartEx", errmsg, res, start_tm);
-    } else {
-        YREQ_LOG_APPEND(req_count, "SyncStartEx", *reply, *replysize, start_tm);
-    }
-#endif
-
-    return res;
-}
-
-
-YRETCODE yapiHTTPRequestSyncDone_internal(YIOHDL* iohdl, char* errmsg)
-{
-    YIOHDL_internal *r, *p, *arg = *iohdl;
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (iohdl == NULL)
-        return YERR(YAPI_INVALID_ARGUMENT);
-
-
-    yEnterCriticalSection(&yContext->io_cs);
-    r = yContext->yiohdl_first;
-    p = NULL;
-    while (r && r != arg) {
-        p = r;
-        r = r->next;
-    }
-    if (r == NULL || r != arg) {
-        yLeaveCriticalSection(&yContext->io_cs);
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    if (p == NULL) {
-        yContext->yiohdl_first = r->next;
-    } else {
-        p->next = r->next;
-    }
-    yLeaveCriticalSection(&yContext->io_cs);
-
-
-    if (arg->type == YIO_USB) {
-        yUsbClose(arg, errmsg);
-    } else if (arg->type == YIO_TCP) {
-        RequestSt* tcpreq = yContext->tcpreq[arg->tcpreqidx];
-        yReqClose(tcpreq);
-    } else {
-        yReqClose(arg->ws);
-        yReqFree(arg->ws);
-    }
-    yFree(arg);
-    memset((u8 *)iohdl, 0, YIOHDL_SIZE);
-    return YAPI_SUCCESS;
-}
-
-
-static void asyncDrop(void* context, const u8* result, u32 resultlen, int retcode, const char* errmsg)
-{
-#ifdef DEBUG_YAPI_REQ
-    int req_count = (int)(((u8*)context) - ((u8*)NULL));
-    YREQ_LOG_APPEND(req_count, "ASync", result, resultlen, 0);
-#endif
-}
-
-
-static YRETCODE yapiHTTPRequestAsyncEx_internal(int tcpchan, const char* device, const char* request, int len, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YIOHDL_internal iohdl;
-    YRETCODE res;
-    int retryCount = 1;
-#ifdef DEBUG_YAPI_REQ
-    int yreq_count = YREQ_LOG_START("ASync", device, request, len);
-#endif
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    do {
-        if (callback == NULL) {
-            callback = asyncDrop;
-#ifdef DEBUG_YAPI_REQ
-            context = ((u8*)NULL) + yreq_count;
-#endif
-        }
-        res = yapiRequestOpen(&iohdl, tcpchan, device, request, len, callback, context, NULL,NULL, errmsg);
-        if (YISERR(res)) {
-            if (res == YAPI_UNAUTHORIZED) {
-                return res;
-            }
-
-            if (retryCount) {
-                char suberr[YOCTO_ERRMSG_LEN];
-                dbglog("ASync request for %s failed. Retrying after yapiUpdateDeviceList\n",device);
-                if (YISERR(yapiUpdateDeviceList_internal(1, suberr))) {
-                    dbglog("yapiUpdateDeviceList failled too with %s\n",errmsg);
-                    return res;
-                }
-            }
-        }
-    } while (res != YAPI_SUCCESS && retryCount--);
-
-    return res;
-}
-
-
-static int yapiHTTPRequest_internal(const char* device, const char* request, char* buffer, int buffsize, int* fullsize, char* errmsg)
-{
-    YIOHDL iohdl;
-    char* reply = NULL;
-    int replysize = 0;
-
-    if (!buffer || buffsize < 4) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    YPROPERR(yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, device, request, YSTRLEN(request), &reply, &replysize, NULL, NULL, errmsg));
-
-    if (fullsize)
-        *fullsize = replysize;
-
-    if (replysize > buffsize - 1) {
-        replysize = buffsize - 1;
-    }
-    memcpy(buffer, reply, replysize);
-    buffer[replysize] = 0;
-    YPROPERR(yapiHTTPRequestSyncDone_internal(&iohdl, errmsg));
-    return replysize;
-}
-
-static void yapiRegisterHubDiscoveryCallback_internal(yapiHubDiscoveryCallback hubDiscoveryCallback)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    if (!yContext) {
-        yapiInitAPI_internal(0, errmsg);
-    }
-    if (yContext) {
-        yContext->hubDiscoveryCallback = hubDiscoveryCallback;
-    }
-}
-
-static YRETCODE yapiTriggerHubDiscovery_internal(char* errmsg)
-{
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-    // ensure SSDP thread is started
-    YPROPERR(ySSDPStart(&yContext->SSDP,ssdpEntryUpdate,errmsg));
-    // triger SSDP discovery
-    return (YRETCODE)ySSDPDiscover(&yContext->SSDP, errmsg);
-}
-
-// used only by VirtualHub
-YRETCODE yapiGetBootloadersDevs(char* serials, unsigned int maxNbSerial, unsigned int* totalBootladers, char* errmsg)
-{
-    int nbifaces = 0;
-    yInterfaceSt* iface;
-    yInterfaceSt* runifaces = NULL;
-    int i;
-    u32 totalBoot, copyedBoot;
-    char* s = serials;
-    YRETCODE res;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if ((yContext->detecttype & Y_DETECT_USB) == 0) {
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"You must init the yAPI with Y_DETECT_USB flag");
-    }
-
-    if (YISERR(res = (YRETCODE) yyyUSBGetInterfaces(&runifaces,&nbifaces,errmsg))) {
-        return res;
-    }
-
-    totalBoot = copyedBoot = 0;
-
-    for (i = 0, iface = runifaces; i < nbifaces; i++, iface++) {
-        if (iface->deviceid != YOCTO_DEVID_BOOTLOADER)
-            continue;
-        if (serials && copyedBoot < maxNbSerial) {
-            YSTRCPY(s,YOCTO_SERIAL_LEN*2,iface->serial);
-            s += YOCTO_SERIAL_LEN;
-            copyedBoot++;
-        }
-        totalBoot++;
-    }
-    // free all tmp ifaces
-    if (runifaces) {
-        yFree(runifaces);
-    }
-    if (totalBootladers)
-        *totalBootladers = totalBoot;
-
-    return (YRETCODE)copyedBoot;
-}
-
-//used by API
-static YRETCODE yapiGetBootloaders_internal(char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    int i;
-    char* p = buffer;
-    YRETCODE res;
-    int size, total, len;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (buffer == NULL || buffersize < 1)
-        return YERR(YAPI_INVALID_ARGUMENT);
-
-    buffersize--; // reserve space for \0
-
-    size = total = 0;
-
-    if (yContext->detecttype & Y_DETECT_USB) {
-        int nbifaces = 0;
-        yInterfaceSt* iface;
-        yInterfaceSt* runifaces = NULL;
-
-        if (YISERR(res = (YRETCODE)yyyUSBGetInterfaces(&runifaces, &nbifaces, errmsg))) {
-            return res;
-        }
-
-        for (i = 0, iface = runifaces; i < nbifaces; i++, iface++) {
-            if (iface->deviceid != YOCTO_DEVID_BOOTLOADER)
-                continue;
-
-            if (buffer && size < buffersize && buffer != p) {
-                *p++ = ',';
-                size++;
-            }
-
-            len = YSTRLEN(iface->serial);
-            total += len;
-            if (buffer && size + len < buffersize) {
-                YSTRCPY(p, buffersize - size, iface->serial);
-                p += len;
-                size += len;
-            }
-        }
-        // free all tmp ifaces
-        if (runifaces) {
-            yFree(runifaces);
-        }
-
-    }
-
-
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        if (yContext->nethub[i]) {
-            char bootloaders[4 * YOCTO_SERIAL_LEN];
-            char hubserial[YOCTO_SERIAL_LEN];
-            int res, j;
-            char* serial;
-            yHashGetStr(yContext->nethub[i]->serial, hubserial, YOCTO_SERIAL_LEN);
-            res = yNetHubGetBootloaders(hubserial, bootloaders, errmsg);
-            if (YISERR(res)) {
-                return res;
-            }
-            for (j = 0, serial = bootloaders; j < res; j++, serial += YOCTO_SERIAL_LEN) {
-                if (buffer && size < buffersize && buffer != p) {
-                    *p++ = ',';
-                    size++;
-                }
-
-                len = YSTRLEN(serial);
-                total += len;
-                if (buffer && size + len < buffersize) {
-                    YSTRCPY(p, buffersize - size, serial);
-                    p += len;
-                    size += len;
-                }
-            }
-        }
-    }
-
-    //ensure buffer is null terminated;
-    *p = 0;
-    if (fullsize)
-        *fullsize = total;
-
-    return (YRETCODE)size;
-}
-
-#ifndef YAPI_IN_YDEVICE
-
-static int yapiGetSubdevices_internal(const char* serial, char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    int i;
-    char* p = buffer;
-    int size, total;
-
-    if (!yContext)
-        return YERR(YAPI_NOT_INITIALIZED);
-
-    if (buffer == NULL || buffersize < 1)
-        return YERR(YAPI_INVALID_ARGUMENT);
-
-    buffersize--; // reserve space for \0
-    size = total = 0;
-    for (i = 0; i < NBMAX_NET_HUB; i++) {
-        char hubserial[YOCTO_SERIAL_LEN];
-
-        if (yContext->nethub[i] == NULL)
-            continue;
-
-        yHashGetStr(yContext->nethub[i]->serial, hubserial, YOCTO_SERIAL_LEN);
-        if (YSTRCMP(serial, hubserial) == 0) {
-            yStrRef knownDevices[128];
-            int j, nbKnownDevices;
-            nbKnownDevices = wpGetAllDevUsingHubUrl(yContext->nethub[i]->url, knownDevices, 128);
-            total = nbKnownDevices * YOCTO_SERIAL_LEN + nbKnownDevices;
-            if (buffersize > total) {
-                int isfirst = 1;
-                for (j = 0; j < nbKnownDevices; j++) {
-                    if (knownDevices[j] == yContext->nethub[i]->serial)
-                        continue;
-                    if (!isfirst)
-                        *p++ = ',';
-                    yHashGetStr(knownDevices[j], p, YOCTO_SERIAL_LEN);
-                    p += YSTRLEN(p);
-                    isfirst = 0;
-                }
-            }
-            break;
-        }
-    }
-
-    //ensure buffer is null terminated;
-    size = (int)(p - buffer);
-    *p++ = 0;
-    if (fullsize)
-        *fullsize = total;
-
-    return size;
-}
-
-
-static const char* yapiJsonValueParseArray(yJsonStateMachine* j, const char* path, int* result, char* errmsg);
-
-
-static void skipJsonStruct(yJsonStateMachine* j)
-{
-#ifdef DEBUG_JSON_PARSE
-    dbglog("skip  %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-    yJsonParse(j);
-    do {
-#ifdef DEBUG_JSON_PARSE
-        dbglog("... %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-        yJsonSkip(j, 1);
-    } while (yJsonParse(j) == YJSON_PARSE_AVAIL && j->st != YJSON_PARSE_STRUCT);
-}
-
-
-static void skipJsonArray(yJsonStateMachine* j)
-{
-#ifdef DEBUG_JSON_PARSE
-    dbglog("skip  %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-    yJsonParse(j);
-    do {
-#ifdef DEBUG_JSON_PARSE
-        dbglog("... %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-        yJsonSkip(j, 1);
-    } while (yJsonParse(j) == YJSON_PARSE_AVAIL && j->st != YJSON_PARSE_ARRAY);
-}
-
-
-static const char* yapiJsonValueParseStruct(yJsonStateMachine* j, const char* path, int* result, char* errmsg)
-{
-    int len = 0;
-    const char* p = path;
-
-    while (*p && *p != '|') {
-        p++;
-        len++;
-    }
-
-    while (yJsonParse(j) == YJSON_PARSE_AVAIL) {
-        if (j->st == YJSON_PARSE_MEMBNAME) {
-            if (YSTRNCMP(path, j->token, len) == 0) {
-                if (*p) {
-#ifdef DEBUG_JSON_PARSE
-                    dbglog("recurse %s %s(%d):%s\n", j->token, yJsonStateStr[j->st], j->st, j->token);
-#endif
-                    yJsonParse(j);
-                    if (j->st == YJSON_PARSE_STRUCT) {
-                        return yapiJsonValueParseStruct(j, ++p, result, errmsg);
-                    } else if (j->st == YJSON_PARSE_ARRAY) {
-                        return yapiJsonValueParseArray(j, ++p, result, errmsg);
-                    } else {
-                        *result = YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid JSON struct");
-                        return "";
-                    }
-                } else {
-                    const char* start_of_json;
-#ifdef DEBUG_JSON_PARSE
-                    dbglog("found %s %s(%d):%s\n", j->token, yJsonStateStr[j->st], j->st, j->token);
-#endif
-                    yJsonParse(j);
-                    start_of_json = j->state_start;
-                    switch (j->st) {
-                    case YJSON_PARSE_STRING:
-                        while (j->next == YJSON_PARSE_STRINGCONT) {
-                            yJsonParse(j);
-                        }
-                    case YJSON_PARSE_NUM:
-                        *result = (u32)(j->state_end - start_of_json);
-                        return start_of_json;
-                    case YJSON_PARSE_STRUCT:
-                        skipJsonStruct(j);
-                        *result = (u32)(j->state_end - start_of_json);
-                        return start_of_json;
-                    case YJSON_PARSE_ARRAY:
-                        skipJsonArray(j);
-                        *result = (u32)(j->state_end - start_of_json);
-                        return start_of_json;
-                    default:
-                        *result = YERRMSG(YAPI_INVALID_ARGUMENT, "Only String and numerical target are supported");
-                        return "";
-                    }
-                }
-            } else {
-#ifdef DEBUG_JSON_PARSE
-                dbglog("skip %s %s(%d):%s\n", j->token, yJsonStateStr[j->st], j->st, j->token);
-#endif
-                yJsonSkip(j, 1);
-            }
-        }
-#ifdef DEBUG_JSON_PARSE
-        else {
-            dbglog("%s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-        }
-#endif
-    }
-    *result = YERRMSG(YAPI_INVALID_ARGUMENT, "Path not found");
-    return "";
-}
-
-
-static const char* yapiJsonValueParseArray(yJsonStateMachine* j, const char* path, int* result, char* errmsg)
-{
-    int len = 0;
-    const char* p = path;
-    char buffer[16];
-    int index, count = 0;
-    yJsonState array_type;
-
-    while (*p && *p != '|') {
-        p++;
-        len++;
-    }
-    YASSERT(len < 16);
-    memcpy(buffer, path, len);
-    buffer[len] = 0;
-    index = atoi(buffer);
-
-    if (yJsonParse(j) != YJSON_PARSE_AVAIL) {
-        *result = YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid JSON array");
-        return "";
-    }
-
-    array_type = j->st;
-    if (j->st != YJSON_PARSE_STRUCT) {
-#ifdef DEBUG_JSON_PARSE
-        dbglog("debug %s %s(%d):%s\n", j->token, yJsonStateStr[j->st], j->st, j->token);
-#endif
-        *result = YERRMSG(YAPI_NOT_SUPPORTED, "Unsupported JSON array");
-        return "";
-    }
-    do {
-        if (index == count) {
-            return yapiJsonValueParseStruct(j, ++p, result, errmsg);
-        } else {
-#ifdef DEBUG_JSON_PARSE
-            dbglog("skip  %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-            yJsonParse(j);
-            do {
-#ifdef DEBUG_JSON_PARSE
-                dbglog("... %s(%d):%s\n", yJsonStateStr[j->st], j->st, j->token);
-#endif
-                yJsonSkip(j, 1);
-            } while (yJsonParse(j) == YJSON_PARSE_AVAIL && j->st != array_type);
-        }
-        count++;
-    } while (yJsonParse(j) == YJSON_PARSE_AVAIL);
-
-    *result = YERRMSG(YAPI_INVALID_ARGUMENT, "Path not found");
-    return "";
-}
-
-
-static int yapiJsonDecodeString_internal(const char* json_string, char* output)
-{
-    yJsonStateMachine j;
-    char* p = output;
-    int maxsize = YSTRLEN(json_string);
-
-    j.src = json_string;
-    j.end = j.src + maxsize;
-    j.st = YJSON_START;
-    yJsonParse(&j);
-    do {
-        int len = YSTRLEN(j.token);
-        yMemcpy(p, j.token, len);
-        p += len;
-    } while (j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL);
-    *p = 0;
-
-    return (u32)(p - output);
-}
-
-
-int yapiJsonGetPath_internal(const char* path, const char* json_data, int json_size, int withHTTPheader, const char** output, char* errmsg)
-{
-    yJsonStateMachine j;
-    int result;
-
-    j.src = json_data;
-    j.end = j.src + json_size;
-    if (withHTTPheader) {
-        j.st = YJSON_HTTP_START;
-        if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-            return YERRMSG(YAPI_IO_ERROR, "Failed to parse HTTP header");
-        }
-        if (YSTRCMP(j.token, "200")) {
-            return YERRMSG(YAPI_IO_ERROR, "Unexpected HTTP return code");
-        }
-        if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-            return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-        }
-    } else {
-        j.st = YJSON_START;
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        *output = "";
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Not a JSON struct");
-    }
-
-    *output = yapiJsonValueParseStruct(&j, path, &result, errmsg);
-    return result;
-}
-
-
-typedef struct _fullAttrInfo
-{
-    char func[32];
-    char attr[32];
-    char value[256];
-} fullAttrInfo;
-
-
-static fullAttrInfo* parseSettings(const char* settings, int* count)
-{
-    yJsonStateMachine j;
-    int nbAttr = 0, allocAttr = 0;
-    fullAttrInfo* attrBuff = NULL;
-    char func[32];
-    char attr[32];
-
-    // Parse HTTP header
-    j.src = settings;
-    j.end = j.src + YSTRLEN(settings);
-    j.st = YJSON_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        nbAttr = -1;
-        goto exit;
-    }
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        YSTRCPY(func,32,j.token);
-        if (YSTRCMP(j.token, "services") == 0) {
-            yJsonSkip(&j, 1);
-        } else {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-                nbAttr = -1;
-                goto exit;
-            }
-            while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-                YSTRCPY(attr, 32, j.token);
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    nbAttr = -1;
-                    goto exit;
-                }
-
-                if (j.st != YJSON_PARSE_STRUCT) {
-                    if (nbAttr == allocAttr) {
-                        //grow the buffer
-                        fullAttrInfo* tmp = attrBuff;
-                        if (allocAttr) {
-                            allocAttr *= 2;
-                        } else {
-                            allocAttr = 64;
-                        }
-                        attrBuff = yMalloc(allocAttr * sizeof(fullAttrInfo));
-                        if (tmp) {
-                            memcpy(attrBuff, tmp, nbAttr * sizeof(fullAttrInfo));
-                            yFree(tmp);
-                        }
-                    }
-                    YSTRCPY(attrBuff[nbAttr].func, 32, func);
-                    YSTRCPY(attrBuff[nbAttr].attr, 32, attr);
-                    YSPRINTF(attrBuff[nbAttr].value, 256, "%s", j.token);
-                    while (j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-                        YSTRCAT(attrBuff[nbAttr].value, 256, j.token);
-                    }
-                    nbAttr++;
-                } else {
-                    do {
-                        yJsonParse(&j);
-                    } while (j.st != YJSON_PARSE_STRUCT);
-                }
-            }
-            if (j.st != YJSON_PARSE_STRUCT) {
-                nbAttr = -1;
-                goto exit;
-            }
-        }
-    }
-    if (j.st != YJSON_PARSE_STRUCT) {
-        nbAttr = -1;
-        goto exit;
-    }
-exit:
-    *count = nbAttr;
-    if (nbAttr < 0 && attrBuff) {
-        yFree(attrBuff);
-        attrBuff = NULL;
-    }
-    return attrBuff;
-}
-
-
-static YRETCODE yapiGetAllJsonKeys_internal(const char* json_buffer, char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    fullAttrInfo* attrs;
-    int attrs_count;
-    int j, totalsize = 0;
-    int len;
-    const char* sep = "";
-
-    attrs = parseSettings(json_buffer, &attrs_count);
-    if (!attrs) {
-        return YERR(YAPI_IO_ERROR);
-    }
-
-    if (buffersize < 16) {
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "buffer too small");;
-    }
-
-    buffer[0] = '[';
-    totalsize++;
-
-    for (j = 0; j < attrs_count; j++) {
-        char tmpbuf[1024];
-        char *p, *d;
-        len = YSPRINTF(tmpbuf, 1024, "%s\"%s/%s=", sep, attrs[j].func, attrs[j].attr);
-        if (len < 0) {
-            yFree(attrs);
-            return YERR(YAPI_IO_ERROR);
-        }
-        p = attrs[j].value;
-        d = tmpbuf + len;
-        while (*p && len < 1020) {
-            if (*p == '"' || *p == '\\') {
-                *d++ = '\\';
-                len++;
-            }
-            *d++ = *p++;
-            len++;
-
-        }
-        *d = 0;
-        YSTRCAT(d, 1024-len, "\"");
-        len ++;
-        YASSERT(len == YSTRLEN(tmpbuf));
-        sep = ",";
-        if (buffersize > totalsize + len) {
-            memcpy(buffer + totalsize, tmpbuf, len);
-        }
-        totalsize += len;
-    }
-
-    if (buffersize > totalsize) {
-        buffer[totalsize] = ']';
-    }
-    totalsize++;
-    *fullsize = totalsize;
-    yFree(attrs);
-    return YAPI_SUCCESS;
-}
-
-#endif
-
-void yapiRegisterRawNotificationCb(yRawNotificationCb callback)
-{
-    if (!yContext)
-        return;
-
-    yEnterCriticalSection(&yContext->enum_cs);
-    yContext->rawNotificationCb = callback;
-    yLeaveCriticalSection(&yContext->enum_cs);
-}
-
-void yapiRegisterRawReportCb(yRawReportCb callback)
-{
-    if (!yContext)
-        return;
-
-    yEnterCriticalSection(&yContext->enum_cs);
-    yContext->rawReportCb = callback;
-    yLeaveCriticalSection(&yContext->enum_cs);
-}
-
-void yapiRegisterRawReportV2Cb(yRawReportV2Cb callback)
-{
-    if (!yContext)
-        return;
-
-    yEnterCriticalSection(&yContext->enum_cs);
-    yContext->rawReportV2Cb = callback;
-    yLeaveCriticalSection(&yContext->enum_cs);
-}
-
-
-//#define YDLL_TRACE_FILE "dll_trace.txt"
-
-#ifdef YDLL_TRACE_FILE
-#include <direct.h>
-#include <stdio.h>
-
-
-typedef enum
-{
-    trcInitAPI = 0,
-    trcFreeAPI,
-    trcRegisterLogFunction,
-    trcRegisterDeviceLogCallback,
-    trcStartStopDeviceLogCallback,
-    trcRegisterDeviceArrivalCallback,
-    trcRegisterDeviceRemovalCallback,
-    trcRegisterDeviceChangeCallback,
-    trcRegisterFunctionUpdateCallback,
-    trcRegisterTimedReportCallback,
-    trcLockFunctionCallBack,
-    trcUnlockFunctionCallBack,
-    trcLockDeviceCallBack,
-    trcUnlockDeviceCallBack,
-    trcTestHub,
-    trcRegisterHub,
-    trcPreregisterHub,
-    trcUnregisterHub,
-    trcUpdateDeviceList,
-    trcHandleEvents,
-    trcSleep,
-    trcCheckLogicalName,
-    trcGetAPIVersion,
-    trcSetTraceFile,
-    trcGetDevice,
-    trcGetAllDevices,
-    trcGetDeviceInfo,
-    trcGetDevicePath,
-    trcGetDevicePathEx,
-    trcGetFunction,
-    trcGetFunctionsByClass,
-    trcGetFunctionsByDevice,
-    trcGetFunctionInfo,
-    trcGetFunctionInfoEx,
-    trcHTTPRequestSyncStartEx,
-    trcHTTPRequestSyncStart,
-    trcHTTPRequestSyncStartOutOfBand,
-    trcHTTPRequestSyncDone,
-    trcHTTPRequestAsyncEx,
-    trcHTTPRequestAsync,
-    trcHTTPRequestAsyncOutOfBand,
-    trcHTTPRequest,
-    trcRegisterHubDiscoveryCallback,
-    trcTriggerHubDiscovery,
-    trcGetBootloaders,
-    trcJsonDecodeString,
-    trcJsonGetPath,
-    trcGetAllJsonKeys,
-    trcCheckFirmware,
-    trcUpdateFirmware,
-    trcUpdateFirmwareEx,
-    trcGetSubdevices,
-    trcGetMem,
-    trcFreeMem,
-    trcGetSubDevcies,
-    trcRegisterDeviceConfigChangeCallback,
-} TRC_FUN;
-
-static const char * trc_funname[] =
-{
-    "initApi",
-    "freeApi",
-    "RegLog",
-    "RegDeviceLog",
-    "StartStopDevLog",
-    "RegDeviceArrival",
-    "RegDeviceRemoval",
-    "RegDeviceChange",
-    "RegUpdateCallback",
-    "RegTimedCallback",
-    "LockFunCback",
-    "UnLockFunCback",
-    "LockDeviceCback",
-    "UnLockDeviceCback",
-    "TestHub",
-    "RegHub",
-    "PreRegHub",
-    "UnRegHub",
-    "UpDL",
-    "HE",
-    "Sl",
-    "CheckLName",
-    "GetAPIVersion",
-    "SetTrcFile",
-    "GDev",
-    "GAllDev",
-    "GDevInfo",
-    "GDevPath",
-    "GDevPathEx",
-    "GFun",
-    "GFunByClass",
-    "GFunByDev",
-    "GFunInfo",
-    "GFunInfoEx",
-    "ReqSyncStartEx",
-    "ReqSyncStart",
-    "ReqSyncStartOB",
-    "ReqSyncDone",
-    "ReqAsyncEx",
-    "ReqAsync",
-    "ReqAsyncOB",
-    "Req",
-    "RegHubDiscovery",
-    "THubDiscov",
-    "GBoot",
-    "JsonDecStr",
-    "JsonGetPath",
-    "GAllJsonK",
-    "CkFw",
-    "UpFw",
-    "UpFwEx",
-    "GetSubdev",
-    "getmem",
-    "freemem",
-    "getsubdev",
-    "RegDeviceConfChg",
-};
-
-static const char *dlltracefile = YDLL_TRACE_FILE;
-
-static void write_line(const char *ptr, int len)
-{
-    FILE *f;
-    if (YFOPEN(&f,dlltracefile,"a+") != 0) {
-        return;
-    }
-    fwrite(ptr,1,len,f);
-    fclose(f);
-
-}
-
-static u64 trc_basetime = 0;
-
-static void trace_dll(u64 t, char prefix, TRC_FUN trcfun, const char *action)
-{
-    char buffer[512];
-    if (trc_basetime == 0) {
-        trc_basetime = t;
-    }
-    int len = YSPRINTF(buffer, 512, "%"FMTu64"%c%s%s\n", (t-trc_basetime), prefix, trc_funname[trcfun], action);
-    write_line(buffer, len);
-}
-
-#define YDLL_CALL_ENTER(funname)    TRC_FUN trcfun = funname;\
-                                    u64 dll_start, dll_stop;\
-                                    char dbg_msg[128];\
-                                    dll_start = yapiGetTickCount();\
-                                    trace_dll(dll_start, '>' ,trcfun, "");
-
-#define YDLL_CALL_LEAVEVOID()        dll_stop = yapiGetTickCount();\
-                                            YSPRINTF(dbg_msg, 128, ":%"FMTs64, (dll_stop - dll_start)); \
-                                            trace_dll(dll_start, '<' ,trcfun, dbg_msg);
-
-#define YDLL_CALL_LEAVE(value)     dll_stop = yapiGetTickCount();\
-                                            YSPRINTF(dbg_msg, 128, ":%d=%"FMTx64, (dll_stop - dll_start), (int)(value), (u64)(value)); \
-                                            trace_dll(dll_start, '<' ,trcfun, dbg_msg);
-#define YDLL_CALL_LEAVEPTR(value)     dll_stop = yapiGetTickCount();\
-                                            YSPRINTF(dbg_msg, 128, ":%p", (dll_stop - dll_start), (value)); \
-                                            trace_dll(dll_start, '<' ,trcfun, dbg_msg);
-#else
-#define YDLL_CALL_ENTER(funname)
-#define YDLL_CALL_LEAVEVOID()
-#define YDLL_CALL_LEAVE(value)
-#define YDLL_CALL_LEAVEPTR(value)
-#endif
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiInitAPI(int detect_type, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcInitAPI);
-    res = yapiInitAPI_internal(detect_type, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-void YAPI_FUNCTION_EXPORT yapiFreeAPI(void)
-{
-    YDLL_CALL_ENTER(trcFreeAPI);
-    yapiFreeAPI_internal();
-    YDLL_CALL_LEAVEVOID();
-}
-
-
-void YAPI_FUNCTION_EXPORT yapiSetNetDevListValidity(int sValidity)
-{
-    YDLL_CALL_ENTER(trcRegisterLogFunction);
-    yapiSetNetDevListValidity_internal(sValidity * 1000);
-    YDLL_CALL_LEAVEVOID();
-}
-
-int YAPI_FUNCTION_EXPORT yapiGetNetDevListValidity(void)
-{
-    int res;
-    YDLL_CALL_ENTER(trcRegisterLogFunction);
-    res = (int)(yapiGetNetDevListValidity_internal() / 1000);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-void YAPI_FUNCTION_EXPORT yapiRegisterLogFunction(yapiLogFunction logfun)
-{
-    YDLL_CALL_ENTER(trcRegisterLogFunction);
-    yapiRegisterLogFunction_internal(logfun);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceLogCallback(yapiDeviceLogCallback logCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceLogCallback);
-    yapiRegisterDeviceLogCallback_internal(logCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiStartStopDeviceLogCallback(const char* serial, int start)
-{
-    YDLL_CALL_ENTER(trcStartStopDeviceLogCallback);
-    yapiStartStopDeviceLogCallback_internal(serial, start);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceArrivalCallback(yapiDeviceUpdateCallback arrivalCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceArrivalCallback);
-    yapiRegisterDeviceArrivalCallback_internal(arrivalCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceRemovalCallback(yapiDeviceUpdateCallback removalCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceRemovalCallback);
-    yapiRegisterDeviceRemovalCallback_internal(removalCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceChangeCallback(yapiDeviceUpdateCallback changeCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceChangeCallback);
-    yapiRegisterDeviceChangeCallback_internal(changeCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterBeaconCallback(yapiBeaconCallback beaconCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceChangeCallback);
-    yapiRegisterBeaconCallback_internal(beaconCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceConfigChangeCallback(yapiDeviceUpdateCallback configChangeCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterDeviceConfigChangeCallback);
-    yapiRegisterDeviceConfigChangeCallback_internal(configChangeCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterFunctionUpdateCallback(yapiFunctionUpdateCallback updateCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterFunctionUpdateCallback);
-    yapiRegisterFunctionUpdateCallback_internal(updateCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterTimedReportCallback(yapiTimedReportCallback timedReportCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterTimedReportCallback);
-    yapiRegisterTimedReportCallback_internal(timedReportCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiLockFunctionCallBack(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcLockFunctionCallBack);
-    res = yapiLockFunctionCallBack_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUnlockFunctionCallBack(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcUnlockFunctionCallBack);
-    res = yapiUnlockFunctionCallBack_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiLockDeviceCallBack(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcLockDeviceCallBack);
-    res = yapiLockDeviceCallBack_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUnlockDeviceCallBack(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcUnlockDeviceCallBack);
-    res = yapiUnlockDeviceCallBack_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiTestHub(const char* url, int mstimeout, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcTestHub);
-    res = yapiTestHub_internal(url, mstimeout, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiRegisterHub(const char* url, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcRegisterHub);
-    res = yapiRegisterHub_internal(url, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiPreregisterHub(const char* url, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcPreregisterHub);
-    res = yapiPreregisterHub_internal(url, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-void YAPI_FUNCTION_EXPORT yapiUnregisterHub(const char* url)
-{
-    YDLL_CALL_ENTER(trcUnregisterHub);
-    yapiUnregisterHub_internal(url);
-    YDLL_CALL_LEAVEVOID();
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateDeviceList(u32 forceupdate, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcUpdateDeviceList);
-    res = yapiUpdateDeviceList_internal(forceupdate, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHandleEvents(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHandleEvents);
-    res = yapiHandleEvents_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiSleep(int ms_duration, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcSleep);
-    res = yapiSleep_internal(ms_duration, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-int YAPI_FUNCTION_EXPORT yapiCheckLogicalName(const char* name)
-{
-    int res;
-    YDLL_CALL_ENTER(trcCheckLogicalName);
-    res = yapiCheckLogicalName_internal(name);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-u16 YAPI_FUNCTION_EXPORT yapiGetAPIVersion(const char** version, const char** apidate)
-{
-    u16 res;
-    YDLL_CALL_ENTER(trcGetAPIVersion);
-    res = yapiGetAPIVersion_internal(version, apidate);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-void YAPI_FUNCTION_EXPORT yapiSetTraceFile(const char* file)
-{
-    YDLL_CALL_ENTER(trcSetTraceFile);
-    yapiSetTraceFile_internal(file);
-    YDLL_CALL_LEAVEVOID();
-}
-
-YAPI_DEVICE YAPI_FUNCTION_EXPORT yapiGetDevice(const char* device_str, char* errmsg)
-{
-    YAPI_DEVICE res;
-    YDLL_CALL_ENTER(trcGetDevice);
-    res = yapiGetDevice_internal(device_str, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-int YAPI_FUNCTION_EXPORT yapiGetAllDevices(YAPI_DEVICE* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int res;
-    YDLL_CALL_ENTER(trcGetAllDevices);
-    res = yapiGetAllDevices_internal(buffer, maxsize, neededsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDeviceInfo(YAPI_DEVICE devdesc, yDeviceSt* infos, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetDeviceInfo);
-    res = yapiGetDeviceInfo_internal(devdesc, infos, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDevicePath(YAPI_DEVICE devdesc, char* rootdevice, char* request, int requestsize, int* neededsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetDevicePath);
-    res = yapiGetDevicePath_internal(devdesc, rootdevice, request, requestsize, neededsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDevicePathEx(const char* serial, char* rootdevice, char* request, int requestsize, int* neededsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetDevicePathEx);
-    res = yapiGetDevicePathEx_internal(serial, rootdevice, request, requestsize, neededsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YAPI_FUNCTION YAPI_FUNCTION_EXPORT yapiGetFunction(const char* class_str, const char* function_str, char* errmsg)
-{
-    YAPI_FUNCTION res;
-    YDLL_CALL_ENTER(trcGetFunction);
-    res = yapiGetFunction_internal(class_str, function_str, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-int YAPI_FUNCTION_EXPORT yapiGetFunctionsByClass(const char* class_str, YAPI_FUNCTION prevfundesc,
-                                                 YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int res;
-    YDLL_CALL_ENTER(trcGetFunctionsByClass);
-    res = yapiGetFunctionsByClass_internal(class_str, prevfundesc, buffer, maxsize, neededsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-int YAPI_FUNCTION_EXPORT yapiGetFunctionsByDevice(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                                                  YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    int res;
-    YDLL_CALL_ENTER(trcGetFunctionsByDevice);
-    res = yapiGetFunctionsByDevice_internal(devdesc, prevfundesc, buffer, maxsize, neededsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetFunctionInfo(YAPI_FUNCTION fundesc, YAPI_DEVICE* devdesc, char* serial, char* funcId, char* funcName, char* funcVal, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetFunctionInfo);
-    res = yapiGetFunctionInfoEx_internal(fundesc, devdesc, serial, funcId, NULL, funcName, funcVal, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetFunctionInfoEx(YAPI_FUNCTION fundesc, YAPI_DEVICE* devdesc, char* serial, char* funcId, char* baseType, char* funcName, char* funcVal, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetFunctionInfoEx);
-    res = yapiGetFunctionInfoEx_internal(fundesc, devdesc, serial, funcId, baseType, funcName, funcVal, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStartEx(YIOHDL* iohdl, const char* device, const char* request, int requestsize, char** reply, int* replysize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestSyncStartEx);
-    res = yapiHTTPRequestSyncStartEx_internal(iohdl, 0, device, request, requestsize, reply, replysize, NULL, NULL, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStart(YIOHDL* iohdl, const char* device, const char* request, char** reply, int* replysize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestSyncStart);
-    res = yapiHTTPRequestSyncStartEx_internal(iohdl, 0, device, request, YSTRLEN(request), reply, replysize, NULL, NULL, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStartOutOfBand(YIOHDL* iohdl, int channel, const char* device, const char* request, int requestsize, char** reply, int* replysize, yapiRequestProgressCallback progress_cb, void* progress_ctx, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestSyncStartOutOfBand);
-    res = yapiHTTPRequestSyncStartEx_internal(iohdl, channel, device, request, requestsize, reply, replysize, progress_cb, progress_ctx, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncDone(YIOHDL* iohdl, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestSyncDone);
-    res = yapiHTTPRequestSyncDone_internal(iohdl, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsyncEx(const char* device, const char* request, int len, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestAsyncEx);
-    res = yapiHTTPRequestAsyncEx_internal(0, device, request, len, callback, context, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsync(const char* device, const char* request, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestAsync);
-    res = yapiHTTPRequestAsyncEx_internal(0, device, request, YSTRLEN(request), callback, context, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsyncOutOfBand(int channel, const char* device, const char* request, int requestsize, yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcHTTPRequestAsyncOutOfBand);
-    res = yapiHTTPRequestAsyncEx_internal(channel, device, request, YSTRLEN(request), callback, context, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-int YAPI_FUNCTION_EXPORT yapiHTTPRequest(const char* device, const char* request, char* buffer, int buffsize, int* fullsize, char* errmsg)
-{
-    int res;
-    YDLL_CALL_ENTER(trcHTTPRequest);
-    res = yapiHTTPRequest_internal(device, request, buffer, buffsize, fullsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-void YAPI_FUNCTION_EXPORT yapiRegisterHubDiscoveryCallback(yapiHubDiscoveryCallback hubDiscoveryCallback)
-{
-    YDLL_CALL_ENTER(trcRegisterHubDiscoveryCallback);
-    yapiRegisterHubDiscoveryCallback_internal(hubDiscoveryCallback);
-    YDLL_CALL_LEAVEVOID();
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiTriggerHubDiscovery(char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcTriggerHubDiscovery);
-    res = yapiTriggerHubDiscovery_internal(errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetBootloaders(char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetBootloaders);
-    res = yapiGetBootloaders_internal(buffer, buffersize, fullsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-#ifndef YAPI_IN_YDEVICE
-
-int YAPI_FUNCTION_EXPORT yapiJsonDecodeString(const char* json_string, char* output)
-{
-    int res;
-    YDLL_CALL_ENTER(trcJsonDecodeString);
-    res = yapiJsonDecodeString_internal(json_string, output);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-int YAPI_FUNCTION_EXPORT yapiJsonGetPath(const char* path, const char* json_data, int json_size, const char** result, char* errmsg)
-{
-    int res;
-    char* tmp;
-    YDLL_CALL_ENTER(trcJsonGetPath);
-    res = yapiJsonGetPath_internal(path, json_data, json_size, 0, result, errmsg);
-    YDLL_CALL_LEAVE(res);
-    if (res > 0) {
-        tmp = yMalloc(res);
-        memcpy(tmp, *result, res);
-        *result = tmp;
-    }
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetAllJsonKeys(const char* json_buffer, char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetAllJsonKeys);
-    res = yapiGetAllJsonKeys_internal(json_buffer, buffer, buffersize, fullsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YAPI_FUNCTION_EXPORT void* yapiGetMem(int size)
-{
-    void* res;
-    YDLL_CALL_ENTER(trcGetMem);
-    res = yMalloc(size);
-    YDLL_CALL_LEAVEPTR(res);
-    return res;
-}
-
-YAPI_FUNCTION_EXPORT void yapiFreeMem(void* ptr)
-{
-    YDLL_CALL_ENTER(trcFreeMem);
-    yFree(ptr);
-    YDLL_CALL_LEAVEVOID()
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiCheckFirmware(const char* serial, const char* rev, const char* path, char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcCheckFirmware);
-    res = yapiCheckFirmware_internal(serial, rev, 0, path, buffer, buffersize, fullsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateFirmware(const char* serial, const char* firmwarePath, const char* settings, int startUpdate, char* msg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcUpdateFirmware);
-    res = yapiUpdateFirmware_internal(serial, firmwarePath, settings, 0, startUpdate, msg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateFirmwareEx(const char* serial, const char* firmwarePath, const char* settings, int force, int startUpdate, char* msg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcUpdateFirmwareEx);
-    res = yapiUpdateFirmware_internal(serial, firmwarePath, settings, force, startUpdate, msg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetSubdevices(const char* serial, char* buffer, int buffersize, int* fullsize, char* errmsg)
-{
-    YRETCODE res;
-    YDLL_CALL_ENTER(trcGetSubdevices);
-    res = yapiGetSubdevices_internal(serial, buffer, buffersize, fullsize, errmsg);
-    YDLL_CALL_LEAVE(res);
-    return res;
-}
-
-#endif
-
-/*****************************************************************************
- Same function but defined with stdcall
- ****************************************************************************/
-#if defined(WINDOWS_API) && defined(__32BITS__) && defined(_MSC_VER)
-
-//typedef void YAPI_FUNCTION_EXPORT(_stdcall *vb6_yapiLogFunction)(BSTR log, u32 loglen);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiDeviceUpdateCallback)(YAPI_DEVICE devdescr);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiFunctionUpdateCallback)(YAPI_FUNCTION fundescr, BSTR value);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiTimedReportCallback)(YAPI_FUNCTION fundesc, double timestamp, const u8* bytes, u32 len);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiHubDiscoveryCallback)(BSTR serial, BSTR url);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiDeviceLogCallback)(YAPI_DEVICE devdescr, BSTR line);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiRequestAsyncCallback)(void* context, int retcode, BSTR result, u32 resultlen);
-typedef void YAPI_FUNCTION_EXPORT (_stdcall *vb6_yapiLogFunction)(BSTR log, u32 loglen);
-
-
-typedef struct vb6_callback
-{
-    vb6_yapiRequestAsyncCallback callback;
-    void* context;
-} vb_callback_cache_entry;
-
-static vb_callback_cache_entry vb_callback_cache[NB_MAX_DEVICES];
-
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiStartStopDeviceLogCallback(const char* serial, int start);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiInitAPI(int type, char* errmsg);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiFreeAPI(void);
-//void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterLogFunction(vb6_yapiLogFunction logfun);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceLogCallback(vb6_yapiDeviceLogCallback logCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceArrivalCallback(vb6_yapiDeviceUpdateCallback arrivalCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceRemovalCallback(vb6_yapiDeviceUpdateCallback removalCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceChangeCallback(vb6_yapiDeviceUpdateCallback changeCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceConfigChangeCallback(vb6_yapiDeviceUpdateCallback configChangeCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterFunctionUpdateCallback(vb6_yapiFunctionUpdateCallback updateCallback);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterTimedReportCallback(vb6_yapiTimedReportCallback timedReportCallback);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiLockFunctionCallBack(char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnlockFunctionCallBack(char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiLockDeviceCallBack(char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnlockDeviceCallBack(char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterHub(const char* rooturl, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiPreregisterHub(const char* rooturl, char* errmsg);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnregisterHub(const char* url);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUpdateDeviceList(u32 forceupdate, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHandleEvents(char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiSleep(int duration_ms, char* errmsg);
-u64 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetTickCount(void);
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiCheckLogicalName(const char* name);
-u16 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAPIVersion(BSTR* version, BSTR* apidate);
-u16 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAPIVersionEx(char* version, char* apidate);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiSetTraceFile(const char* file);
-YAPI_DEVICE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDevice(const char* device_str, char* errmsg);
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAllDevices(YAPI_DEVICE* buffer, int maxsize, int* neededsize, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDeviceInfo(YAPI_DEVICE devdesc, yDeviceSt* infos, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDevicePath(YAPI_DEVICE devdesc, char* rootdevice, char* path, int pathsize, int* neededsize, char* errmsg);
-YAPI_FUNCTION YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunction(const char* class_str, const char* function_str, char* errmsg);
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionsByClass(const char* class_str, YAPI_FUNCTION prevfundesc, YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg);
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionsByDevice(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc, YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionInfo(YAPI_FUNCTION fundesc, YAPI_DEVICE* devdesc, char* serial, char* funcId, char* funcName, char* funcVal, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncStartEx(YIOHDL* iohdl, const char* device, const char* request, int requestsize, char** reply, int* replysize, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncStart(YIOHDL* iohdl, const char* device, const char* request, char** reply, int* replysize, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncDone(YIOHDL* iohdl, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestAsync(const char* device, const char* request, vb6_yapiRequestAsyncCallback callback, void* context, char* errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestAsyncEx(const char* device, const char* request, int requestsize, vb6_yapiRequestAsyncCallback callback, void* context, char* errmsg);
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequest(const char* device, const char* request, char* buffer, int buffsize, int* fullsize, char* errmsg);
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterHubDiscoveryCallback(vb6_yapiHubDiscoveryCallback hubDiscoveryCallback);
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiTriggerHubDiscovery(char* errmsg);
-
-static BSTR vb6_version = NULL;
-static BSTR vb6_apidate = NULL;
-
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiStartStopDeviceLogCallback(const char* serial, int start)
-{
-    yapiStartStopDeviceLogCallback(serial, start);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiInitAPI(int type, char* errmsg)
-{
-    return yapiInitAPI(type, errmsg);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiFreeAPI(void)
-{
-    yapiFreeAPI();
-    if (vb6_version) {
-        SysFreeString(vb6_version);
-        vb6_version = NULL;
-    }
-    if (vb6_apidate) {
-        SysFreeString(vb6_apidate);
-        vb6_apidate = NULL;
-    }
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterLogFunction(vb6_yapiLogFunction logfun);
-
-static BSTR newBSTR(const char* str)
-{
-    int len = YSTRLEN(str);
-    int newlen = MultiByteToWideChar(CP_ACP, 0, str, len, NULL, 0);
-    BSTR newstring = SysAllocStringLen(0, newlen);
-    MultiByteToWideChar(CP_ACP, 0, str, len, newstring, newlen);
-    return newstring;
-}
-
-// stdcall implementation of yapiRegisterLogFunction
-static vb6_yapiLogFunction vb6_yapiLogFunctionFWD = NULL;
-
-void yapiLogFunctionCdeclToStd(const char* log, u32 loglen)
-{
-    if (vb6_yapiLogFunctionFWD) {
-        BSTR bstrstr = newBSTR(log);
-        vb6_yapiLogFunctionFWD(bstrstr, loglen);
-        SysFreeString(bstrstr);
-    }
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterLogFunction(vb6_yapiLogFunction logfun)
-{
-    vb6_yapiLogFunctionFWD = logfun;
-    if (logfun) {
-        yapiRegisterLogFunction(yapiLogFunctionCdeclToStd);
-    } else {
-        yapiRegisterLogFunction(NULL);
-    }
-}
-
-
-static vb6_yapiDeviceLogCallback vb6_yapiRegisterDeviceLogCallbackFWD = NULL;
-
-void yapiRegisterDeviceLogCallbackFWD(YAPI_DEVICE devdescr, const char* line)
-{
-    if (vb6_yapiRegisterDeviceLogCallbackFWD) {
-        BSTR bstrstr = newBSTR(line);
-        vb6_yapiRegisterDeviceLogCallbackFWD(devdescr, bstrstr);
-        SysFreeString(bstrstr);
-    }
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceLogCallback(vb6_yapiDeviceLogCallback logCallback)
-{
-    vb6_yapiRegisterDeviceLogCallbackFWD = logCallback;
-    if (logCallback) {
-        yapiRegisterDeviceLogCallback(yapiRegisterDeviceLogCallbackFWD);
-    } else {
-        yapiRegisterDeviceLogCallback(NULL);
-    }
-}
-
-static vb6_yapiDeviceUpdateCallback vb6_yapiRegisterDeviceArrivalCallbackFWD = NULL;
-
-void yapiRegisterDeviceArrivalCallbackFWD(YAPI_DEVICE devdescr)
-{
-    if (vb6_yapiRegisterDeviceArrivalCallbackFWD)
-        vb6_yapiRegisterDeviceArrivalCallbackFWD(devdescr);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceArrivalCallback(vb6_yapiDeviceUpdateCallback arrivalCallback)
-{
-    vb6_yapiRegisterDeviceArrivalCallbackFWD = arrivalCallback;
-    if (arrivalCallback) {
-        yapiRegisterDeviceArrivalCallback(yapiRegisterDeviceArrivalCallbackFWD);
-    } else {
-        yapiRegisterDeviceArrivalCallback(NULL);
-    }
-}
-
-static vb6_yapiDeviceUpdateCallback vb6_yapiRegisterDeviceRemovalCallbackFWD = NULL;
-
-void yapiRegisterDeviceRemovalCallbackFWD(YAPI_DEVICE devdescr)
-{
-    if (vb6_yapiRegisterDeviceRemovalCallbackFWD)
-        vb6_yapiRegisterDeviceRemovalCallbackFWD(devdescr);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceRemovalCallback(vb6_yapiDeviceUpdateCallback removalCallback)
-{
-    vb6_yapiRegisterDeviceRemovalCallbackFWD = removalCallback;
-    if (removalCallback) {
-        yapiRegisterDeviceRemovalCallback(yapiRegisterDeviceRemovalCallbackFWD);
-    } else {
-        yapiRegisterDeviceRemovalCallback(NULL);
-    }
-}
-
-static vb6_yapiDeviceUpdateCallback vb6_yapiRegisterDeviceChangeCallbackFWD = NULL;
-
-void yapiRegisterDeviceChangeCallbackFWD(YAPI_DEVICE devdescr)
-{
-    if (vb6_yapiRegisterDeviceChangeCallbackFWD)
-        vb6_yapiRegisterDeviceChangeCallbackFWD(devdescr);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceChangeCallback(vb6_yapiDeviceUpdateCallback changeCallback)
-{
-    vb6_yapiRegisterDeviceChangeCallbackFWD = changeCallback;
-    if (changeCallback) {
-        yapiRegisterDeviceChangeCallback(yapiRegisterDeviceChangeCallbackFWD);
-    } else {
-        yapiRegisterDeviceChangeCallback(NULL);
-    }
-}
-
-static vb6_yapiDeviceUpdateCallback vb6_yapiRegisterDeviceConfigChangeCallbackFWD = NULL;
-
-void yapiRegisterDeviceConfigChangeCallbackFWD(YAPI_DEVICE devdescr)
-{
-    if (vb6_yapiRegisterDeviceConfigChangeCallbackFWD)
-        vb6_yapiRegisterDeviceConfigChangeCallbackFWD(devdescr);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterDeviceConfigChangeCallback(vb6_yapiDeviceUpdateCallback configChangeCallback)
-{
-    vb6_yapiRegisterDeviceConfigChangeCallbackFWD = configChangeCallback;
-    if (configChangeCallback) {
-        yapiRegisterDeviceConfigChangeCallback(yapiRegisterDeviceConfigChangeCallbackFWD);
-    } else {
-        yapiRegisterDeviceConfigChangeCallback(NULL);
-    }
-}
-
-static vb6_yapiFunctionUpdateCallback vb6_yapiRegisterFunctionUpdateCallbackFWD = NULL;
-
-void yapiRegisterFunctionUpdateCallbackFWD(YAPI_FUNCTION fundescr, const char* value)
-{
-    if (vb6_yapiRegisterFunctionUpdateCallbackFWD && value) {
-        BSTR bstrstr = newBSTR(value);
-        vb6_yapiRegisterFunctionUpdateCallbackFWD(fundescr, bstrstr);
-        SysFreeString(bstrstr);
-    }
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterFunctionUpdateCallback(vb6_yapiFunctionUpdateCallback updateCallback)
-{
-    vb6_yapiRegisterFunctionUpdateCallbackFWD = updateCallback;
-    if (updateCallback) {
-        yapiRegisterFunctionUpdateCallback(yapiRegisterFunctionUpdateCallbackFWD);
-    } else {
-        yapiRegisterFunctionUpdateCallback(NULL);
-    }
-}
-
-static vb6_yapiTimedReportCallback vb6_yapiRegisterTimedReportCallbackFWD = NULL;
-
-void yapiRegisterTimedReportCallbackFWD(YAPI_FUNCTION fundesc, double timestamp, const u8* bytes, u32 len, double duration)
-{
-    if (vb6_yapiRegisterTimedReportCallbackFWD)
-        vb6_yapiRegisterTimedReportCallbackFWD(fundesc, timestamp, bytes, len);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterTimedReportCallback(vb6_yapiTimedReportCallback timedReportCallback)
-{
-    vb6_yapiRegisterTimedReportCallbackFWD = timedReportCallback;
-    if (timedReportCallback) {
-        yapiRegisterTimedReportCallback(yapiRegisterTimedReportCallbackFWD);
-    } else {
-        yapiRegisterTimedReportCallback(NULL);
-    }
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiLockFunctionCallBack(char* errmsg)
-{
-    return yapiLockFunctionCallBack(errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnlockFunctionCallBack(char* errmsg)
-{
-    return yapiUnlockFunctionCallBack(errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiLockDeviceCallBack(char* errmsg)
-{
-    return yapiLockDeviceCallBack(errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnlockDeviceCallBack(char* errmsg)
-{
-    return yapiUnlockDeviceCallBack(errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterHub(const char* rooturl, char* errmsg)
-{
-    return yapiRegisterHub(rooturl, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiPreregisterHub(const char* rooturl, char* errmsg)
-{
-    return yapiPreregisterHub(rooturl, errmsg);
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUnregisterHub(const char* url)
-{
-    yapiUnregisterHub(url);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiUpdateDeviceList(u32 forceupdate, char* errmsg)
-{
-    return yapiUpdateDeviceList(forceupdate, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHandleEvents(char* errmsg)
-{
-    return yapiHandleEvents(errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiSleep(int duration_ms, char* errmsg)
-{
-    return yapiSleep(duration_ms, errmsg);
-}
-
-u64 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetTickCount(void)
-{
-    return yapiGetTickCount();
-}
-
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiCheckLogicalName(const char* name)
-{
-    return yapiCheckLogicalName(name);
-}
-
-u16 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAPIVersion(BSTR* version, BSTR* apidate)
-{
-    const char *versionA, *apidateA;
-    u16 res = yapiGetAPIVersion(&versionA, &apidateA);
-    *version = newBSTR(versionA);
-    *apidate = newBSTR(apidateA);
-    return res;
-}
-
-u16 YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAPIVersionEx(char* version, char* apidate)
-{
-    const char *versionA, *apidateA;
-    u16 res = yapiGetAPIVersion(&versionA, &apidateA);
-    YSTRCPY(version, YOCTO_ERRMSG_LEN, versionA);
-    YSTRCPY(apidate, YOCTO_ERRMSG_LEN, apidateA);
-    return res;
-}
-
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiSetTraceFile(const char* file)
-{
-    yapiSetTraceFile(file);
-}
-
-YAPI_DEVICE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDevice(const char* device_str, char* errmsg)
-{
-    return yapiGetDevice(device_str, errmsg);
-}
-
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetAllDevices(YAPI_DEVICE* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    return yapiGetAllDevices(buffer, maxsize, neededsize, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDeviceInfo(YAPI_DEVICE devdesc, yDeviceSt* infos, char* errmsg)
-{
-    return yapiGetDeviceInfo(devdesc, infos, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetDevicePath(YAPI_DEVICE devdesc, char* rootdevice, char* path, int pathsize, int* neededsize, char* errmsg)
-{
-    return yapiGetDevicePath(devdesc, rootdevice, path, pathsize, neededsize, errmsg);
-}
-
-YAPI_FUNCTION YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunction(const char* class_str, const char* function_str, char* errmsg)
-{
-    return yapiGetFunction(class_str, function_str, errmsg);
-}
-
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionsByClass(const char* class_str, YAPI_FUNCTION prevfundesc, YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    return yapiGetFunctionsByClass(class_str, prevfundesc, buffer, maxsize, neededsize, errmsg);
-}
-
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionsByDevice(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc, YAPI_FUNCTION* buffer, int maxsize, int* neededsize, char* errmsg)
-{
-    return yapiGetFunctionsByDevice(devdesc, prevfundesc, buffer, maxsize, neededsize, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiGetFunctionInfo(YAPI_FUNCTION fundesc, YAPI_DEVICE* devdesc, char* serial, char* funcId, char* funcName, char* funcVal, char* errmsg)
-{
-    return yapiGetFunctionInfo(fundesc, devdesc, serial, funcId, funcName, funcVal, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncStartEx(YIOHDL* iohdl, const char* device, const char* request, int requestsize, char** reply, int* replysize, char* errmsg)
-{
-    return yapiHTTPRequestSyncStartEx(iohdl, device, request, requestsize, reply, replysize, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncStart(YIOHDL* iohdl, const char* device, const char* request, char** reply, int* replysize, char* errmsg)
-{
-    return yapiHTTPRequestSyncStart(iohdl, device, request, reply, replysize, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestSyncDone(YIOHDL* iohdl, char* errmsg)
-{
-    return yapiHTTPRequestSyncDone(iohdl, errmsg);
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestAsync(const char* device, const char* request, vb6_yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    return vb6_yapiHTTPRequestAsyncEx(device, request, YSTRLEN(request), callback, context, errmsg);
-}
-
-static void vb6_callback_fwd(void* context, const u8* result, u32 resultlen, int retcode, const char* errmsg)
-{
-    YAPI_DEVICE devydx = (YAPI_DEVICE)context;
-    void* vb6_context = vb_callback_cache[devydx].context;
-    BSTR bstrstr = newBSTR((char*)result);
-    vb_callback_cache[devydx].callback(vb6_context, retcode, bstrstr, resultlen);
-    SysFreeString(bstrstr);
-}
-
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequestAsyncEx(const char* device, const char* request, int requestsize, vb6_yapiRequestAsyncCallback callback, void* context, char* errmsg)
-{
-    YAPI_DEVICE devydx = wpSearch(device);
-    vb_callback_cache[devydx].callback = callback;
-    vb_callback_cache[devydx].context = context;
-    return yapiHTTPRequestAsyncEx(device, request, requestsize, vb6_callback_fwd, (void*)devydx, errmsg);
-}
-
-int YAPI_FUNCTION_EXPORT __stdcall vb6_yapiHTTPRequest(const char* device, const char* request, char* buffer, int buffsize, int* fullsize, char* errmsg)
-{
-    return yapiHTTPRequest(device, request, buffer, buffsize, fullsize, errmsg);
-}
-
-static vb6_yapiHubDiscoveryCallback vb6_yapiHubDiscoveryCallbackFWD = NULL;
-
-void yapiHubDiscoverCdeclToStdllbackFWD(const char* serial, const char* url)
-{
-    if (vb6_yapiHubDiscoveryCallbackFWD) {
-        BSTR bstrserial = newBSTR(serial);
-        BSTR bstrurl = newBSTR(url);
-        vb6_yapiHubDiscoveryCallbackFWD(bstrserial, bstrurl);
-        SysFreeString(bstrurl);
-        SysFreeString(bstrserial);
-    }
-}
-
-void YAPI_FUNCTION_EXPORT __stdcall vb6_yapiRegisterHubDiscoveryCallback(vb6_yapiHubDiscoveryCallback hubDiscoveryCallback)
-{
-    vb6_yapiHubDiscoveryCallbackFWD = hubDiscoveryCallback;
-    if (hubDiscoveryCallback) {
-        yapiRegisterHubDiscoveryCallback(yapiHubDiscoverCdeclToStdllbackFWD);
-    } else {
-        yapiRegisterHubDiscoveryCallback(NULL);
-    }
-}
-
-YRETCODE YAPI_FUNCTION_EXPORT __stdcall vb6_yapiTriggerHubDiscovery(char* errmsg)
-{
-    return yapiTriggerHubDiscovery(errmsg);
-}
-
-
-#endif
--- a/Sources/cpplib/yapi/yapi.h
+++ /dev/null
@@ -1,1111 +0,0 @@
-/*********************************************************************
- *
- * $Id: yapi.h 33735 2018-12-14 16:06:53Z seb $
- *
- * Declaration of public entry points to the low-level API
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YAPI_H
-#define YAPI_H
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-#include "ydef.h"
-
-#if defined(WINDOWS_API) && defined(GENERATE_DLL)
-#define YAPI_FUNCTION_EXPORT __declspec(dllexport)
-#else
-#define YAPI_FUNCTION_EXPORT
-#endif
-
-// Timeout for blocking requests to the devices, in milliseconds
-#define YAPI_BLOCKING_USBOPEN_REQUEST_TIMEOUT    2000
-#define YAPI_BLOCKING_USBREAD_REQUEST_TIMEOUT    8000
-#define YAPI_BLOCKING_NET_REQUEST_TIMEOUT       30000
-
-/*****************************************************************************
- CALLBACK TYPES
- ****************************************************************************/
-
-// prototype of the Log callback
-typedef void YAPI_FUNCTION_EXPORT(*yapiLogFunction)(const char *log,u32 loglen);
-
-// prototype of the device arrival/update/removal callback
-typedef void YAPI_FUNCTION_EXPORT(*yapiDeviceUpdateCallback)(YAPI_DEVICE devdescr);
-
-// prototype of the device beacon change callback
-typedef void YAPI_FUNCTION_EXPORT(*yapiBeaconCallback)(YAPI_DEVICE devdescr, int beacon);
-
-
-// prototype of functions change callback
-// value :
-//       if null     : notify a new logical name
-//       if not null : notify a new value, (a pointer to a  YOCTO_PUBVAL_LEN bytes null terminated string)
-typedef void YAPI_FUNCTION_EXPORT(*yapiFunctionUpdateCallback)(YAPI_FUNCTION fundescr,const char *value);
-
-// prototype of timed report callback
-typedef void YAPI_FUNCTION_EXPORT(*yapiTimedReportCallback)(YAPI_FUNCTION fundesc, double timestamp,const u8 *bytes, u32 len, double duration);
-
-// prototype of the ssdp hub discovery callback
-typedef void YAPI_FUNCTION_EXPORT(*yapiHubDiscoveryCallback)(const char *serial, const char *url);
-
-typedef void YAPI_FUNCTION_EXPORT(*yapiDeviceLogCallback)(YAPI_FUNCTION fundescr,const char *line);
-
-
-/*****************************************************************************
- API FUNCTION DECLARATION
- ****************************************************************************/
-
-
-void YAPI_FUNCTION_EXPORT yapiStartStopDeviceLogCallback(const char *serial,int start);
-
-
-
-
-
-/*****************************************************************************
-  Function:
-    YRETCODE yInitAPI(int type,char *errmsg)
-
-  Description:
-    Initializes  and Allocate structures needed for the YoctoAPI
-
-  Parameters:
-    type: Y_DETECT_USB will auto-detect only USB connected devices
-          Y_DETECT_NET will auto-detect only Network devices
-          Y_DETECT_ALL will auto-detect devices on all usable protocol
-    errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-  Returns:
-    on ERROR  : error code
-    on SUCCES : YAPI_SUCCESS
-
-  Remarks:
-    This function must be called first and only one time.
-    Network devices can be used when Y_DETECT_NET is not specified when
-    manually registering network hubs; auto-detection only applies to
-    Bonjour-based and NBNS-based discovery.
-  ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiInitAPI(int type,char *errmsg);
-
-#define Y_DETECT_NONE           0
-#define Y_DETECT_USB            1
-#define Y_DETECT_NET            2
-#define Y_RESEND_MISSING_PKT    4
-#define Y_DETECT_ALL   (Y_DETECT_USB | Y_DETECT_NET)
-
-#define Y_DEFAULT_PKT_RESEND_DELAY 50
-
-
-/*****************************************************************************
-  Function:
-    void yFreeAPI(void)
-
-  Description:
-    Release Allocate structures needed for the YoctoAPI
-
-  Parameters:
-    None
-
-  Returns:
-    None
-
-  Remarks:
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiFreeAPI(void);
-
-
-
-/*****************************************************************************
-Function:
-void YAPI_FUNCTION_EXPORT yapiSetNetDevListValidity(int sValidity);
-u64 YAPI_FUNCTION_EXPORT yapiGetNetDevListValidity(void);
-
-Description:
-These function are used to dynamically change the network device list validity.
-By default it's 10 seconds, but with some GSM case you may want to grow this
-value in order to reduce network traffic. Arrival/Removal are not affected
-by these functions.
-
-Note: the YAPI must be already initalized otherwise the value will be discarded.
-
-***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiSetNetDevListValidity(int sValidity);
-int YAPI_FUNCTION_EXPORT yapiGetNetDevListValidity(void);
-
-
-/*****************************************************************************
-  Function:
-    void  yapiRegisterLogFunction(yapiLogFunction logfun);
-
-  Description:
-    Register log function for yapi. This function is used mainly for debug purpose.
-    To unregister your callback you can call this function with a NULL pointer.
-
-  Parameters:
-    logfun : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterLogFunction(yapiLogFunction logfun);
-
-/*****************************************************************************
-
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceLogCallback(yapiDeviceLogCallback logCallback);
-
-/*****************************************************************************
-  Function:
-    void  yapiRegisterDeviceArrivalCallback(yapiDeviceUpdateCallback arrivalCallback);
-
-  Description:
-    Register a callback function for device arrival. This function is only used to
-    notify event you should return as soon as possible of the callback. you should
-    also not call yapiUpdateDeviceList from the callback.
-    To unregister your callback you can call this function with a NULL pointer.
-
-  Parameters:
-    arrivalCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceArrivalCallback(yapiDeviceUpdateCallback arrivalCallback);
-
-/*****************************************************************************
-  Function:
-    void  yapiRegisterDeviceRemovalCallback(yapiDeviceUpdateCallback removalCallback);
-
-  Description:
-    Register a callback function for device removal. This function is only used to
-    notify event you should return as soon as possible of the callback. you should
-    also not call yapiUpdateDeviceList from the callback.
-    To unregister your callback you can call this function with a NULL pointer.
-
-  Parameters:
-    removalCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceRemovalCallback(yapiDeviceUpdateCallback removalCallback);
-
-/*****************************************************************************
-  Function:
-    void  yapiRegisterDeviceChangeCallback(yapiDeviceUpdateCallback changeCallback);
-
-  Description:
-    Register a callback function for a device that change his logical name. This function
-    is only used to notify event you should return as soon as possible of the callback.
-    you should also not call yapiUpdateDeviceList from the callback. To unregister
-    your callback you can call this function with a NULL pointer.
-
-  Parameters:
-    changeCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceChangeCallback(yapiDeviceUpdateCallback changeCallback);
-
-void YAPI_FUNCTION_EXPORT yapiRegisterBeaconCallback(yapiBeaconCallback beaconCallback);
-
-/*****************************************************************************
-  Function:
-    void  yapiRegisterDeviceConfigChangeCallback(yapiDeviceUpdateCallback configChangeCallback);
-
-  Description:
-    Register a callback function, to be called when a persistent settings in
-    a device configuration has been changed (e.g. change of unit, etc).
-    To unregister your callback you can call this function with a NULL pointer.
-
-  Parameters:
-    configChangeCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterDeviceConfigChangeCallback(yapiDeviceUpdateCallback configChangeCallback);
-
-/*****************************************************************************
-  Function:
-    void yapiRegisterFunctionUpdateCallback(yapiFunctionUpdateCallback updateCallback);
-
-  Description:
-    Register a callback function for device function notification (value change,
-    configuration change...). This function is only used to notify event you should
-    return as soon as possible of the callback. To unregister your callback you can
-    call this function with a NULL pointer.
-
-  Parameters:
-    updateCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterFunctionUpdateCallback(yapiFunctionUpdateCallback updateCallback);
-
-/*****************************************************************************
-  Function:
-      void YAPI_FUNCTION_EXPORT yapiRegisterTimedReportCallback(yapiTimedReportCallback timedReportCallback);
-
-  Description:
-    Register a callback function for device function timed report. This function
-    is only used to notify event you should return as soon as possible of the
-    callback. To unregister your callback you can call this function with a NULL
-    pointer.
-
-  Parameters:
-    timedReportCallback : a function to register or NULL to unregister the callback
-
-  Returns:
-    None
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterTimedReportCallback(yapiTimedReportCallback timedReportCallback);
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiLockFunctionCallBack( char *errmsg);
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUnlockFunctionCallBack(char *errmsg);
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiLockDeviceCallBack( char *errmsg);
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiUnlockDeviceCallBack(char *errmsg);
-
-
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yapiTestHub(const char *rooturl, int mstimeout, char *errmsg)
-
- Description:
-   Test if a network URL can be used for yapiRegisterHub and yapiPreregisterHub. This
-   function will not register the hub but will test that the hub is reachable and that
-   authentication parameters are correct. This function will return before  mstimeout (or
-   2 * mstimeout if the hub use authentication)
-
- Parameters:
-   rooturl: The network URL of the hub, for instance "http://192.168.2.34", or "usb"
-   mstimeout: The number of ms that the function has to test the URL
-   errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR  : error code
-   on SUCCES : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiTestHub(const char *rooturl, int mstimeout, char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yRegisterHub(const char *rooturl,char *errmsg)
-
- Description:
-   Register a network URL to be scanned for devices when yUpdateDeviceList
-   is called. To enable USB detection you could use  "usb" as rooturl. This
-   is will return an error (and not register the hub) the url is not reachable
-
- Parameters:
-   rooturl: The network URL of the hub, for instance "http://192.168.2.34", or "usb"
-   errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR  : error code
-   on SUCCES : YAPI_SUCCESS
-
- Remarks:
-    if you have initialized the API with Y_DETECT_USB it is not necessary to
-    manually to call this function with "usb"
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiRegisterHub(const char *rooturl, char *errmsg);
-
-
-/*****************************************************************************
- Function:
- YRETCODE yPreregisterHub(const char *rooturl,char *errmsg)
-
- Description:
- Register a network URL to be scanned for devices when yUpdateDeviceList
- is called. To enable USB detection you could use  "usb" as rooturl. it is
- not considered as an error to give an url that is not reachable.
-
- Parameters:
- rooturl: The network URL of the hub, for instance "http://192.168.2.34", or "usb"
- errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
- on ERROR  : error code
- on SUCCES : YAPI_SUCCESS
-
- Remarks:
- if you have initialized the API with Y_DETECT_USB it is not necessary to
- manually to call this function with "usb"
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiPreregisterHub(const char *rooturl, char *errmsg);
-
-
-
-
-/*****************************************************************************
- Function:
- YRETCODE yUnregisterHub(const char *rooturl)
-
- Description:
- Unregister a network URL  that has been register by yapiPreRegisterHub or yapiRegisterHub
-
- Parameters:
- rooturl: The network URL of the hub, for instance "http://192.168.2.34", or "usb"
-
- Returns:
-
- Remarks:
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiUnregisterHub(const char *url);
-
-
-
-/*****************************************************************************
-  Function:
-    int yUpdateDeviceList(char *errmsg)
-
-  Description:
-    Detect or redetect all Yocto devices. This function can be called multiples
-    times to refresh the devices list.
-
-  Parameters:
-    errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-  Returns:
-    on ERROR   : an error code
-    on SUCCES : YAPI_SUCCESS
-
-  Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateDeviceList(u32 forceupdate, char *errmsg);
-
-
-/*****************************************************************************
- Function:
- YRETCODE yapiHandleEvents(char *errmsg)
-
- Description:
- Perform periodic polling tasks on USB queues, invoke callbacks, etc
- This function can be called either from application main loop (if any)
- or from a dedicated thread in a multithreaded application.
-
- Parameters:
- errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
- on ERROR   : error code
- on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHandleEvents(char *errmsg);
-
-
-/*****************************************************************************
- Function:
- YRETCODE yapiSleep(int duration_ms,char *errmsg)
-
- Description:
- Perform periodic polling tasks on USB queues, invoke callbacks, etc
- This function can be called either from application main loop (if any)
- or from a dedicated thread in a multi threaded application.
-
- Parameters:
- errmsg: a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
- on ERROR   : error code
- on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiSleep(int duration_ms, char *errmsg);
-
-
-/*****************************************************************************
- Function:
- u64 yGetTickCount()
-
- Description:
- Return a the current value of a monotone millisecond-based time counter
-
- Returns:
- Monotone millisecond-based time counter
-
- Remarks:
- ***************************************************************************/
-u64 YAPI_FUNCTION_EXPORT yapiGetTickCount(void);
-
-
-/*****************************************************************************
- Function:
- int yCheckLogicalName(const char *name)
-
- Description:
- Verifies if a given logical name is valid or not for this API
-
- Parameters:
- name: the logicalName to verify
-
- Returns:
- true (1) or false (0)
-
- Remarks:
-
- *****************************************************************************/
-int YAPI_FUNCTION_EXPORT yapiCheckLogicalName(const char *name);
-
-/*****************************************************************************
- Function:
- u16 yGetAPIVersion(char **version,char **subversion)
-
- Description:
- Return API Version
-
- Parameters:
- version: if not NULL this pointer will be updated with the version of the api
- build: if not NULL this pointer will be updated with the subversion of the api
- date : if not NULL this pointer will be updated with the date of the api
-
- Returns:
- Return the BCD encoded version number of the API
-
- Remarks:
- ***************************************************************************/
-u16 YAPI_FUNCTION_EXPORT yapiGetAPIVersion(const char **version,const char **apidate);
-
-
-//
-/*****************************************************************************
- Function:
- YRETCODE SetTraceFile(const char *file)
-
- Description:
- Enable low-level traces of the API into a specified file
-
- Parameters:
- file: the full path of the log file to use
-
- Remarks:
- This function is typically called even before yInitAPI.
- It is optional, and should only be called when low-level logs
- are desirable.
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiSetTraceFile(const char *file);
-
-
-/*****************************************************************************
- Function:
-   YAPI_DEVICE yGetDevice(const char *device_str,char *errmsg)
-
- Description:
-   return a device descriptor identifying a device provided by serial number,
-   logical name or URL. The descriptor can later be used with yGetDeviceInfo
-   to retrieve all properties of the device. The function will fail if there
-   is no connected device matching the requested device string.
-
- Parameters:
-   device_str : string referring to a Yocto device (serial number, logical name or URL)
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   check the result with the YISERR(retcode)
-   on ERROR   : error code
-   on SUCCESS : a valid YAPI_DEVICE descriptor
-
- Example:
-   char      errmsg[YOCTO_ERRMSG_LEN];
-   YAPI_DEVICE   mydevice = yGetDevice("logicalname");
-   yDeviceSt infos;
-   if(mydevice < 0 || yGetDeviceInfo(mydevice, &infos, errmsg) < 0) {
-      // handle error
-   }
-
- ***************************************************************************/
-YAPI_DEVICE YAPI_FUNCTION_EXPORT yapiGetDevice(const char *device_str,char *errmsg);
-
-
-/*****************************************************************************
-  Function:
-    int yGetAllDevices(YAPI_DEVICE *buffer,int maxsize,int *neededsize,char *errmsg)
-
-  Description:
-    fill buffer with device descriptors that can be used to access device details.
-    If buffer == NULL the function will only set neededsize so that the caller can
-    allocate a buffer of the right size and call again the function with a buffer
-    of correct size.
-
-  Parameters:
-    buffer     : buffer to be filled with devices descriptors
-    maxize     : size in byte of buffer
-    neededsize : size in byte of buffer to pass to this function to get all devices
-    errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-  Returns:
-   check the ressult with the YISERR(retcode)
-    on ERROR   : error code
-    on SUCCESS : nb of devices descriptors written into buffer
-
-  Example:
-    char    errmsg[YOCTO_ERRMSG_LEN];
-    YAPI_DEVICE *buffer;
-    int     nbdev, buffsize;
-    if(yGetAllDevices(NULL,0,&buffsize,errmsg) >= 0) {
-        buffer = (YAPI_DEVICE *)malloc(buffsize);
-        nbdev = yGetAllDevices(buffer,buffsize,&buffsize,errmsg);
-    }
-
- ***************************************************************************/
-int YAPI_FUNCTION_EXPORT yapiGetAllDevices(YAPI_DEVICE *buffer,int maxsize,int *neededsize,char *errmsg);
-
-
-/*****************************************************************************
-  Function:
-   YRETCODE yGetDeviceInfo(YAPI_DEVICE devhdl, yDeviceSt *infos, char *errmsg)
-
-  Description:
-    Get all information about a single device given by its descriptor,
-    as returned by yGetDevice or yGetAllDevices.
-
-  Parameters:
-    devdesc: device object returned by yGetDevice or yGetAllDevices
-    errmsg:  a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-  Returns:
-    on ERROR   : error code
-    on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-    the call may fail if the device pointed by devhdl has been disconnected
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDeviceInfo(YAPI_DEVICE devdesc,yDeviceSt *infos,char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yapiGetDevicePath(YAPI_DEVICE devdesc, char *rootdevice, char *path, int pathsize, int *neededsize, char *errmsg);
-
- Description:
-   return the rootdevice and the path to access a device.
-
- Parameters:
-   devdesc     : device descriptor returned by yapiGetAllDevices or yapiGetDevice
-   rootdevice  : a pointer to a buffer of YOCTO_SERIAL_LEN characters for receiving the rootdevice
-   path        : a pointer to a buffer of for storing the base path to add to your HTTP request
-   pathtsize   : size of the path buffer
-   neededsize  : size of the path buffer needed to be complete (may be NULL)
-   errmsg      : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDevicePath(YAPI_DEVICE devdesc, char *rootdevice, char *path, int pathsize, int *neededsize, char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yapiGetDevicePathEx(const char * serial, char *rootdevice, char *path, int pathsize, int *neededsize, char *errmsg);
-
- Description:
-   return the rootdevice and the path to access a device.
-
- Parameters:
-   serila      : the serial number of the device
-   rootdevice  : a pointer to a buffer of YOCTO_SERIAL_LEN characters for receiving the rootdevice
-   path        : a pointer to a buffer of for storing the base path to add to your HTTP request
-   pathtsize   : size of the path buffer
-   neededsize  : size of the path buffer needed to be complete (may be NULL)
-   errmsg      : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetDevicePathEx(const char * serial, char *rootdevice, char *request, int requestsize, int *neededsize, char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YAPI_FUNCTION yGetFunction(const char *class_str,const char *func_str,char *errmsg)
-
- Description:
-   return a function descriptor identifying a function provided by full hardware id,
-   logical name or mixed. The descriptor can later be used with yGetFunctionInfo
-   to retrieve all yellow-page information or to access the function. This function
-   fails if there is no connected device with the requested function identification.
-
- Parameters:
-   class_str  : string referring to the function class
-   func_str   : string referring to a Yocto function (hardware id, logical name, etc.)
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   check the ressult with the YISERR(retcode)
-   on ERROR   : error code
-   on SUCCESS : a valid YAPI_FUNCTION descriptor
-
- Example:
-   char      errmsg[YOCTO_ERRMSG_LEN];
-   YAPI_FUNCTION myfunction = yGetFunction("functionname");
-   if(myfunction < 0 || yGetFunctionInfo(mydevice, &infos, errmsg) < 0) {
-       // handle error
-   }
-
- ***************************************************************************/
-YAPI_FUNCTION YAPI_FUNCTION_EXPORT yapiGetFunction(const char *class_str, const char *function_str,char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   int yGetFunctionsByClass(const char *class_str, YAPI_FUNCTION prevfundesc,
-                            YAPI_FUNCTION *buffer,int maxsize,int *neededsize,char *errmsg);
-   int yGetFunctionsByDevice(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                             YAPI_FUNCTION *buffer,int maxsize,int *neededsize,char *errmsg);
-
- Description:
-   fill buffer with function descriptors that can be used to access functions.
-   If buffer == NULL the function will only set neededsize so that the caller can
-   allocate a buffer of the right size and call again the function with a buffer
-   of correct size.
-
- Parameters:
-   class_str  : string referring to the function class
- or
-   devdesc    : device descriptor returned by yGetDevice or yGetAllDevices
-   prevfundesc: 0 when calling for the first time, or last function descriptor previously received
-   buffer     : buffer to be filled with function descriptors
-   maxize     : size in byte of buffer
-   neededsize : size in byte of buffer to pass to this function to get all functions
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   check the result with the YISERR(retcode)
-   on ERROR   : error code
-   on SUCCESS : nb of function descriptors written into buffer
-
- Example:
-   char    errmsg[YOCTO_ERRMSG_LEN];
-   YAPI_FUNCTION *buffer;
-   int     nbfunc, buffsize;
-   if(yGetFunctionsByClass("Relay",0,NULL,0,&buffsize,errmsg) >= 0) {
-       buffer = (YAPI_FUNCTION *)malloc(buffsize);
-       nbfunc = yGetFunctionsByClass("Relay",0,buffer,buffsize,&buffsize,errmsg);
-   }
-
- ***************************************************************************/
-int YAPI_FUNCTION_EXPORT yapiGetFunctionsByClass(const char *class_str, YAPI_FUNCTION prevfundesc,
-                                          YAPI_FUNCTION *buffer,int maxsize,int *neededsize,char *errmsg);
-int YAPI_FUNCTION_EXPORT yapiGetFunctionsByDevice(YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                                           YAPI_FUNCTION *buffer,int maxsize,int *neededsize,char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yGetFunctionInfo(YAPI_FUNCTION fundesc,YAPI_DEVICE *devdesc,char *serial,char *funcId,char *funcName,char *funcVal,char *errmsg)
-
- Description:
-   Get all yellow-page information about a single function given by its descriptor,
-   as returned by yGetFunction, yGetFunctionsByClass or yGetFunctionsByDevice.
-
- Parameters:
-   fundesc : function descriptor returned by yGetFunction or yGetFunctionsByXXX
-   devdesc : a pointer to a device descriptor to be filled with the device hosting the function
-   serial  : a pointer to a buffer of YOCTO_SERIAL_LEN characters, or NULL
-   funcId  : a pointer to a buffer of YOCTO_FUNCTION_LEN characters, or NULL
-   funcName: a pointer to a buffer of YOCTO_LOGICAL_LEN characters, or NULL
-   funcVal : a pointer to a buffer of 7 characters, or NULL
-   errmsg  : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetFunctionInfo(YAPI_FUNCTION fundesc,YAPI_DEVICE *devdesc,char *serial,char *funcId,char *funcName,char *funcVal,char *errmsg);
-
-/*****************************************************************************
- Function:
-   YRETCODE yGetFunctionInfo(YAPI_FUNCTION fundesc,YAPI_DEVICE *devdesc,char *serial,char *funcId,char *funcName,char *funcVal,char *errmsg)
-
- Description:
-   Get all yellow-page information about a single function given by its descriptor,
-   as returned by yGetFunction, yGetFunctionsByClass or yGetFunctionsByDevice.
-
- Parameters:
-   fundesc : function descriptor returned by yGetFunction or yGetFunctionsByXXX
-   devdesc : a pointer to a device descriptor to be filled with the device hosting the function
-   serial  : a pointer to a buffer of YOCTO_SERIAL_LEN characters, or NULL
-   funcId  : a pointer to a buffer of YOCTO_FUNCTION_LEN characters, or NULL
-   baseType: a pointer to a buffer of YOCTO_FUNCTION_LEN characters, or NULL
-   funcName: a pointer to a buffer of YOCTO_LOGICAL_LEN characters, or NULL
-   funcVal : a pointer to a buffer of 7 characters, or NULL
-   errmsg  : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetFunctionInfoEx(YAPI_FUNCTION fundesc, YAPI_DEVICE *devdesc, char *serial, char *funcId, char *baseType, char *funcName, char *funcVal, char *errmsg);
-
-
- /*****************************************************************************
-  Function:
-    int yapiHTTPRequestSyncStartEx(YIOHDL *iohdl, const char *device, const char *request, int requestsize, char **reply, int *replysize, char *errmsg);
-
-  Description:
-    Open a HTTP request to a given device, send a query and receive the HTTP header and
-    page content into the buffer. The buffer with result will be returned by reference,
-    so that the caller can use it or copy it. Do not free reply buffer manually, but
-    always call yapiHTTPRequestSyncDone when finished.
-
-  Parameters:
-    iohdl      : the request handle that will be initialized
-    device     : a string that contain one of the flowing value: serial, logicalname, url
-    request    : the HTTP request (HTTP header + body, in case of POST) of the page/file to retrieve
-    requestsize: the length of the HTTP request
-    reply      : a pointer to the reply buffer, returned by reference
-    replysize  : the length of the reply buffer, returned by reference
-    errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-  Returns:
-    on SUCCESS : YAPI_SUCCESS
-    on ERROR   : return the YRETCODE
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStartEx(YIOHDL *iohdl, const char *device, const char *request, int requestsize, char **reply, int *replysize, char *errmsg);
-
-/*****************************************************************************
-Function:
-int yapiHTTPRequestSyncStartOutOfBand(YIOHDL *iohdl, const char *device, const char *request, int requestsize, char **reply, int *replysize, yapiRequestProgressCallback progress_cb, void *progress_ctx, char *errmsg);
-
-Description:
-Open a HTTP request to a given device, send a query and receive the HTTP header and
-page content into the buffer. The buffer with result will be returned by reference,
-so that the caller can use it or copy it. Do not free reply buffer manually, but
-always call yapiHTTPRequestSyncDone when finished.
-
-Parameters:
-iohdl        : the request handle that will be initialized
-channel      : channel to use for the request
-device       : a string that contain one of the flowing value: serial, logicalname, url
-request      : the HTTP request (HTTP header + body, in case of POST) of the page/file to retrieve
-requestsize  : the length of the HTTP request
-reply        : a pointer to the reply buffer, returned by reference
-replysize    : the length of the reply buffer, returned by reference
-progress_cb  : a callback that is called to report progress
-progress_ctx : context passed to progress_cb
-errmsg       : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-Returns:
-on SUCCESS : YAPI_SUCCESS
-on ERROR   : return the YRETCODE
-
-***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStartOutOfBand(YIOHDL *iohdl, int channel, const char *device, const char *request, int requestsize, char **reply, int *replysize, yapiRequestProgressCallback progress_cb, void *progress_ctx, char *errmsg);
-
-
-/*****************************************************************************
- Function:
- int yapiHTTPRequestSyncStart(YIOHDL *iohdl, const char *device, const char *request, char **reply, int *replysize, char *errmsg);
-
- Description:
- Open a HTTP request to a given device, send a query and receive the HTTP header and
- page content into the buffer. The buffer with result will be returned by reference,
- so that the caller can use it or copy it. Do not free reply buffer manually, but
- always call yapiHTTPRequestSyncDone when finished.
-
- Parameters:
- iohdl      : the request handle that will be initialized
- device     : a string that contain one of the flowing value: serial, logicalname, url
- request    : the HTTP request (HTTP header) of the page/file to retrieve
- reply      : a pointer to the reply buffer, returned by reference
- replysize  : the length of the reply buffer, returned by reference
- errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
- on SUCCESS : YAPI_SUCCESS
- on ERROR   : return the YRETCODE
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncStart(YIOHDL *iohdl, const char *device, const char *request, char **reply, int *replysize, char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   int yapiHTTPRequestSyncDone(YIOHDL *iohdl, char *errmsg)
-
- Description:
-   Terminate a call to yapiHTTPRequestSyncStart and free corresponding resources.
-   No other request can take place to the device until this function is called.
-
- Parameters:
-   iohdl      : the request handle returned by yapiHTTPRequestSyncStart
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on SUCCESS : YAPI_SUCCESS
-   on ERROR   : return the YRETCODE
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestSyncDone(YIOHDL *iohdl, char *errmsg);
-
-
-/*****************************************************************************
- Function:
-   YRETCODE yapiHTTPRequestAsync(const char *device, const char *request, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
- Description:
-   Execute a HTTP request to a given device, and leave it to the API to complete the request.
-
- Parameters:
-   device     : a string that contain one of the flowing value: serial, logicalname, url
-   request    : the HTTP request (HTTP header) of the page/file to retrieve
-   callback   : RESERVED FOR FUTURE USE
-   context    : RESERVED FOR FUTURE USE
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : an error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-   we match the device string in this order: serial,logicalname,url
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsync(const char *device, const char *request, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
-/*****************************************************************************
- Function:
-   YRETCODE yapiHTTPRequestAsync(const char *device, const char *request, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
- Description:
-   Execute a HTTP request to a given device, and leave it to the API to complete the request.
-
- Parameters:
-   device     : a string that contain one of the flowing value: serial, logicalname, url
-   request    : the HTTP request (HTTP header + body, in case of POST) of the page/file to retrieve
-   requestsize: the length of the HTTP request
-   callback   : RESERVED FOR FUTURE USE
-   context    : RESERVED FOR FUTURE USE
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   on ERROR   : an error code
-   on SUCCESS : YAPI_SUCCESS
-
- Remarks:
-   we match the device string in this order: serial,logicalname,url
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsyncEx(const char *device, const char *request, int requestsize, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
-
-/*****************************************************************************
-Function:
-YRETCODE yapiHTTPRequestAsync(const char *device, const char *request, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
-Description:
-Execute a HTTP request to a given device, and leave it to the API to complete the request.
-
-Parameters:
-channel    : channel to use for the request
-device     : a string that contain one of the flowing value: serial, logicalname, url
-request    : the HTTP request (HTTP header + body, in case of POST) of the page/file to retrieve
-requestsize: the length of the HTTP request
-callback   : RESERVED FOR FUTURE USE
-context    : RESERVED FOR FUTURE USE
-errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
-Returns:
-on ERROR   : an error code
-on SUCCESS : YAPI_SUCCESS
-
-Remarks:
-we match the device string in this order: serial,logicalname,url
-
-***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiHTTPRequestAsyncOutOfBand(int channel, const char *device, const char *request, int requestsize, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-
-
-
-
-/*****************************************************************************
- Function:
-   int yHTTPRequest(char *device,char *request, char* buffer,int buffsize,int *fullsize,char *errmsg)
-
- Description:
-   Open a HTTP request to a given device, send a query and receive the HTTP header and
-   page content into the buffer. If the content is bigger than buffsize, buffer will contain
-   no more than buffsize. If not NULL full size will be updated with the size of the full content.
-
- Parameters:
-   device     : a string that contain one of the flowing value: serial, logicalname, url
-   request    : the HTTP request (HTTP header) of the page/file to retrieve
-   buffer     : a buffer to fill with result
-   buffsize   : the size of the buffer
-   fullsize   : (optional) an integer to update with the full size of the data
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   check the result with the YISERR(retcode)
-   on SUCCESS : return the number of byte written into buffer (excluding the terminating '\0' character)
-   on ERROR   : return the YRETCODE
-
- Remarks:
-   we always null terminate the returning buffer
-
- ***************************************************************************/
-int YAPI_FUNCTION_EXPORT yapiHTTPRequest(const char *device, const char *request, char* buffer,int buffsize,int *fullsize, char *errmsg);
-
-/*****************************************************************************
- Function:
-   void yapiRegisterHubDiscoveryCallback(yapiHubDiscoveryCallback hubDiscoveryCallback);
-
- Description:
-   register a callback function that will be called on every network hub  (or VirtualHub)
-   that send an SSDP announce or respond to a SSDP search
-
- Parameters:
-   hubDiscoveryCallback : the function to call when an network hub his detected by ssdp or null to
-                          unregister the previous callback
-
- Returns:
-
- Remarks:
-
- ***************************************************************************/
-void YAPI_FUNCTION_EXPORT yapiRegisterHubDiscoveryCallback(yapiHubDiscoveryCallback hubDiscoveryCallback);
-
-/*****************************************************************************
- Function:
-   YRETCODE YAPI_FUNCTION_EXPORT yapiTriggerHubDiscovery(char *errmsg);
-
- Description:
-   Send an SSDP Msearch Request to force all online hub to announce itself again.
-
- Parameters:
-   errmsg     : a pointer to a buffer of YOCTO_ERRMSG_LEN bytes to store any error message
-
- Returns:
-   check the result with the YISERR(retcode)
-   on ERROR   : return the YRETCODE
-
- Remarks:
-
- ***************************************************************************/
-YRETCODE YAPI_FUNCTION_EXPORT yapiTriggerHubDiscovery(char *errmsg);
-
-
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetSubdevices(const char *serial, char *buffer, int buffersize, int *fullsize, char *errmsg);
-
-/*****************************************************************************
-  Flash API
- ***************************************************************************/
-
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetAllJsonKeys(const char *jsonbuffer, char *out_buffer, int out_buffersize, int *fullsize, char *errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT yapiCheckFirmware(const char *serial, const char *rev, const char *path, char *buffer, int buffersize, int *fullsize, char *errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT yapiGetBootloaders(char *buffer, int buffersize, int *fullsize, char *errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateFirmware(const char *serial, const char *firmwarePath, const char *settings, int startUpdate, char *errmsg);
-YRETCODE YAPI_FUNCTION_EXPORT yapiUpdateFirmwareEx(const char *serial, const char *firmwarePath, const char *settings, int force, int startUpdate, char *errmsg);
-
-int YAPI_FUNCTION_EXPORT yapiJsonDecodeString(const char *json_string, char *output);
-int YAPI_FUNCTION_EXPORT yapiJsonGetPath(const char *path, const char *json_data, int json_size, const char  **result, char *errmsg);
-
-
-/*****************************************************************************
-  helper for delphi
- ***************************************************************************/
-YAPI_FUNCTION_EXPORT void* yapiGetMem(int size);
-YAPI_FUNCTION_EXPORT void yapiFreeMem(void *ptr);
-
-
-typedef  void (*yRawNotificationCb)(USB_Notify_Pkt*);
-typedef  void (*yRawReportCb)(YAPI_DEVICE serialref, USB_Report_Pkt_V1 *report, int pktsize);
-typedef  void (*yRawReportV2Cb)(YAPI_DEVICE serialref, USB_Report_Pkt_V2 *report, int pktsize);
-void yapiRegisterRawNotificationCb(yRawNotificationCb callback);
-void yapiRegisterRawReportCb(yRawReportCb callback);
-void yapiRegisterRawReportV2Cb(yRawReportV2Cb callback);
-
-
-
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
-
-
--- a/Sources/cpplib/yapi/ydef.h
+++ /dev/null
@@ -1,1055 +0,0 @@
-/*********************************************************************
- *
- * $Id: ydef.h 33735 2018-12-14 16:06:53Z seb $
- *
- * Standard definitions common to all yoctopuce projects
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef  YOCTO_DEF_H
-#define  YOCTO_DEF_H
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-
-#if defined(_WIN32)
-// Windows C compiler
-#define WINDOWS_API
-
-#ifdef _WIN64
-#define __64BITS__
-#define __WIN64__
-#else
-#define __32BITS__
-#endif
-
-#ifdef _MSC_VER
-typedef unsigned char           u8;
-typedef signed char             s8;
-typedef unsigned short int      u16;
-typedef signed short int        s16;
-typedef unsigned long int       u32;
-typedef signed long int         s32;
-typedef unsigned long long      u64;
-typedef signed long long        s64;
-#define VARIABLE_SIZE
-#define FMTs64 "lld"
-#define FMTu64 "llu"
-#define FMTx64 "llx"
-
-#else
-
-#ifdef __BORLANDC__
-typedef unsigned __int8         u8;
-typedef __int8                  s8;
-typedef unsigned __int16        u16;
-typedef __int16                 s16;
-typedef unsigned __int32        u32;
-typedef __int32                 s32;
-typedef unsigned __int64        u64;
-typedef __int64                 s64;
-#else
-typedef unsigned char           u8;
-typedef signed char             s8;
-typedef unsigned short int      u16;
-typedef signed short int        s16;
-typedef unsigned int            u32;
-typedef signed int              s32;
-typedef unsigned long long      u64;
-typedef signed long long        s64;
-#endif
-
-#define VARIABLE_SIZE           0
-#define FMTs64 "lld"
-#define FMTu64 "llu"
-#define FMTx64 "llx"
-
-#endif
-// end of WINDOWS_API
-
-
-#elif defined(__C30__)
-// Microchip C30
-#define MICROCHIP_API
-#define __16BITS__
-
-typedef unsigned char           u8;
-typedef signed char             s8;
-typedef unsigned short int      u16;
-typedef signed short int        s16;
-typedef unsigned long int       u32;
-typedef signed long int         s32;
-typedef unsigned long long      u64;
-typedef signed long long        s64;
-#define VARIABLE_SIZE           0
-#define FMTs64 "lld"
-#define FMTu64 "llu"
-#define FMTx64 "llx"
-// end of MICROCHIP_API
-
-#elif defined(__APPLE__)
-#include <TargetConditionals.h>
-
-#if TARGET_IPHONE_SIMULATOR
-//#warning IOS simulator platform
-#define IOS_API
-#elif TARGET_OS_IPHONE
-//#warning IOS platform
-#define IOS_API
-#elif TARGET_OS_MAC
-#define OSX_API
-
-#if defined(__i386__)
-#define __32BITS__
-#elif defined(__x86_64__)
-#define OSX_API
-#define __64BITS__
-#else
-#error Unsupported MAC OS X architecture
-#endif
-
-#else
-#error Unsupported Apple target
-#endif
-
-// Mac OS X C compiler
-typedef unsigned char           u8;
-typedef signed char             s8;
-typedef unsigned short int      u16;
-typedef signed short int        s16;
-typedef unsigned int            u32;
-typedef signed int              s32;
-#ifdef __LP64__
-typedef unsigned long           u64;
-typedef signed long             s64;
-#else
-typedef unsigned long long      u64;
-typedef signed long long        s64;
-#endif
-#define VARIABLE_SIZE           0
-#define FMTs64 "ld"
-#define FMTu64 "lu"
-#define FMTx64 "lx"
-#include <pthread.h>
-#include <errno.h>
-// end of OSX_API OR IOS_API
-
-
-#elif defined(__linux__)
-// gcc compiler on Linux
-#define LINUX_API
-
-#if defined(__i386__)
-#define __32BITS__
-#define FMTs64 "lld"
-#define FMTu64 "llu"
-#define FMTx64 "llx"
-#elif defined(__x86_64__) || defined(__aarch64__)
-#define __64BITS__
-#define FMTs64 "ld"
-#define FMTu64 "lu"
-#define FMTx64 "lx"
-#else
-#define __32BITS__
-#define FMTs64 "lld"
-#define FMTu64 "llu"
-#define FMTx64 "llx"
-#endif
-
-#include <stdint.h>
-typedef uint8_t                 u8;
-typedef int8_t                  s8;
-typedef uint16_t                u16;
-typedef int16_t                 s16;
-typedef uint32_t                u32;
-typedef int32_t                 s32;
-typedef uint64_t                u64;
-typedef int64_t                 s64;
-#define VARIABLE_SIZE           0
-#include <pthread.h>
-#include <errno.h>
-
-#else
-#warning UNSUPPORTED ARCHITECTURE, please edit yocto_def.h !
-#endif
-// end of LINUX_API
-
-
-typedef u32   yTime;            /* measured in milliseconds */
-typedef u32   u31;              /* shorter unsigned integers */
-typedef s16   yHash;
-typedef u16   yBlkHdl;          /* (yHash << 1) + [0,1] */
-typedef yHash yStrRef;
-typedef yHash yUrlRef;
-typedef s32   YAPI_DEVICE;      /* yStrRef of serial number */
-typedef s32   YAPI_FUNCTION;    /* yStrRef of serial + (ystrRef of funcId << 16) */
-
-#define INVALID_HASH_IDX    -1  /* To use for yHash, yStrRef, yApiRef types */
-#define INVALID_BLK_HDL     0   /* To use for yBlkHdl type */
-
-#ifdef MICROCHIP_API
-typedef u8              YSOCKET;
-typedef s8              YYSBIO;
-typedef s8              YTRNKIO;
-#else
-// we have hard coded the type of SOCKET to
-// prevent to mess up with user own code
-#if defined(WINDOWS_API)
-#if defined(__64BITS__)
-typedef u64             YSOCKET;
-#else
-typedef u32             YSOCKET;
-#endif
-#else
-typedef int             YSOCKET;
-#endif
-typedef s32             YUSBIO;
-typedef s32             YUSBDEV;
-#endif
-
-#define YIO_INVALID      0
-#define YIO_USB          1
-#define YIO_TCP          2
-#define YIO_YSB          3
-#define YIO_TRUNK        4
-#define YIO_WS           5
-
-#define YIO_DEFAULT_USB_TIMEOUT      2000u
-#define YIO_DEFAULT_TCP_TIMEOUT     20000u
-#define YIO_1_MINUTE_TCP_TIMEOUT    60000u
-#define YIO_10_MINUTES_TCP_TIMEOUT 600000u
-#define YIO_IDLE_TCP_TIMEOUT         5000u
-
-#ifdef MICROCHIP_API
-// same as yhub devhdl
-typedef s16 YIOHDL;
-#else
-// make sure this union is no more than 8 bytes, YIOHDL is allocated used in all foreign APIs
-typedef void *YIOHDL;
-#endif
-
-#define YIOHDL_SIZE (sizeof(YIOHDL))
-
-#define INVALID_YHANDLE (-1)
-
-#define S8(x)   ((s8)(x))
-#define S16(x)  ((s16)(x))
-#define S32(x)  ((s32)(x))
-#define S64(x)  ((s64)(x))
-#define U8(x)   ((u8)(x))
-#define U16(x)  ((u16)(x))
-#define U32(x)  ((u32)(x))
-#define U64(x)  ((u64)(x))
-
-#define U8ADDR(x)  ((u8 *)&(x))
-#define U16ADDR(x) ((u16 *)&(x))
-
-#define ADDRESSOF(x)    (&(x))
-#define PTRVAL(x)       (*(x))
-
-#if defined(__PIC24FJ256DA206__)
-#define _FAR __eds__
-#else
-#define _FAR
-#endif
-
-#if defined(MICROCHIP_API) || defined(VIRTUAL_HUB)
-#define YAPI_IN_YDEVICE
-#define YSTATIC
-#else
-#define YSTATIC static
-#endif
-
-
-//#define DEBUG_CRITICAL_SECTION
-
-#ifdef DEBUG_CRITICAL_SECTION
-#if defined(WINDOWS_API)
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <WinBase.h>
-#endif
-typedef enum  {
-    YCS_UNALLOCATED=0,
-    YCS_ALLOCATED=1,
-    YCS_DELETED=2
-} YCS_STATE;
-
-typedef enum  {
-    YCS_NONE=0,
-    YCS_INIT=1,
-    YCS_LOCK=2,
-    YCS_LOCKTRY=3,
-    YCS_RELEASE=4,
-    YCS_DELETE=5
-} YCS_ACTION;
-
-typedef struct {
-    int         thread;
-    const char* fileid;
-    int         lineno;
-    YCS_ACTION  action;
-} YCS_LOC;
-
-#define YCS_NB_TRACE 5
-
-typedef struct {
-    volatile u32                 no;
-    volatile YCS_STATE           state;
-    volatile int                 lock;
-#if defined(WINDOWS_API)
-    CRITICAL_SECTION             cs;
-#else
-    pthread_mutex_t              cs;
-#endif
-    YCS_LOC             last_actions[YCS_NB_TRACE];
-} yCRITICAL_SECTION_ST;
-
-typedef yCRITICAL_SECTION_ST* yCRITICAL_SECTION;
-
-void yInitDebugCS();
-void yFreeDebugCS();
-void yDbgInitializeCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *cs);
-void yDbgEnterCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *cs);
-int yDbgTryEnterCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *cs);
-void yDbgLeaveCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *cs);
-void yDbgDeleteCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *cs);
-
-#define yInitializeCriticalSection(cs)  yDbgInitializeCriticalSection(__FILE_ID__,__LINE__,cs)
-#define yEnterCriticalSection(cs)       yDbgEnterCriticalSection(__FILE_ID__,__LINE__,cs)
-#define yTryEnterCriticalSection(cs)    yDbgTryEnterCriticalSection(__FILE_ID__,__LINE__,cs)
-#define yLeaveCriticalSection(cs)       yDbgLeaveCriticalSection(__FILE_ID__,__LINE__,cs)
-#define yDeleteCriticalSection(cs)      yDbgDeleteCriticalSection(__FILE_ID__,__LINE__,cs)
-
-#else
-#if defined(MICROCHIP_API)
-#define yCRITICAL_SECTION               u8
-#define yInitializeCriticalSection(cs)
-#define yEnterCriticalSection(cs)
-#define yTryEnterCriticalSection(cs)    1
-#define yLeaveCriticalSection(cs)
-#define yDeleteCriticalSection(cs)
-#else
-
-typedef void* yCRITICAL_SECTION;
-void yInitializeCriticalSection(yCRITICAL_SECTION *cs);
-void yEnterCriticalSection(yCRITICAL_SECTION *cs);
-int yTryEnterCriticalSection(yCRITICAL_SECTION *cs);
-void yLeaveCriticalSection(yCRITICAL_SECTION *cs);
-void yDeleteCriticalSection(yCRITICAL_SECTION *cs);
-#endif
-#endif
-
-
-typedef enum {
-    YAPI_SUCCESS          = 0,      // everything worked all right
-    YAPI_NOT_INITIALIZED  = -1,     // call yInitAPI() first !
-    YAPI_INVALID_ARGUMENT = -2,     // one of the arguments passed to the function is invalid
-    YAPI_NOT_SUPPORTED    = -3,     // the operation attempted is (currently) not supported
-    YAPI_DEVICE_NOT_FOUND = -4,     // the requested device is not reachable
-    YAPI_VERSION_MISMATCH = -5,     // the device firmware is incompatible with this API version
-    YAPI_DEVICE_BUSY      = -6,     // the device is busy with another task and cannot answer
-    YAPI_TIMEOUT          = -7,     // the device took too long to provide an answer
-    YAPI_IO_ERROR         = -8,     // there was an I/O problem while talking to the device
-    YAPI_NO_MORE_DATA     = -9,     // there is no more data to read from
-    YAPI_EXHAUSTED        = -10,    // you have run out of a limited resource, check the documentation
-    YAPI_DOUBLE_ACCES     = -11,    // you have two process that try to access to the same device
-    YAPI_UNAUTHORIZED     = -12,    // unauthorized access to password-protected device
-    YAPI_RTC_NOT_READY    = -13,    // real-time clock has not been initialized (or time was lost)
-    YAPI_FILE_NOT_FOUND   = -14     // the file is not found
-} YRETCODE;
-
-#define YISERR(retcode)   ((retcode) < 0)
-
-// Yoctopuce arbitrary constants
-#define YOCTO_API_VERSION_STR       "1.10"
-#define YOCTO_API_VERSION_BCD       0x0110
-#include "yversion.h"
-#define YOCTO_DEFAULT_PORT          4444
-#define YOCTO_VXI_PORT              4445
-#define YOCTO_VENDORID              0x24e0
-#define YOCTO_DEVID_FACTORYBOOT     1
-#define YOCTO_DEVID_BOOTLOADER      2
-#define YOCTO_DEVID_HIGHEST         0xfefe
-#define YAPI_HASH_BUF_SIZE          28
-#define YOCTO_CALIB_TYPE_OFS        30
-
-// Other special ports
-#define PORTMAPPER_PORT             111
-
-// Known baseclases
-#define YOCTO_AKA_YFUNCTION         0
-#define YOCTO_AKA_YSENSOR           1
-#define YOCTO_N_BASECLASSES         2
-
-// Standard buffer sizes
-#define YOCTO_ERRMSG_LEN            256
-#define YOCTO_MANUFACTURER_LEN      20
-#define YOCTO_SERIAL_LEN            20
-#define YOCTO_BASE_SERIAL_LEN        8
-#define YOCTO_PRODUCTNAME_LEN       28
-#define YOCTO_FIRMWARE_LEN          22
-#define YOCTO_LOGICAL_LEN           20
-#define YOCTO_FUNCTION_LEN          20
-#define YOCTO_UNIT_LEN              10
-#define YOCTO_PUBVAL_SIZE            6 // Size of the data (can be non null terminated)
-#define YOCTO_PUBVAL_LEN            16 // Temporary storage, >= YOCTO_PUBVAL_SIZE+2
-#define YOCTO_REPORT_LEN             9 // Max size of a timed report, including isAvg flag
-#define YOCTO_SERIAL_SEED_SIZE       (YOCTO_SERIAL_LEN - YOCTO_BASE_SERIAL_LEN - 1)
-
-// delay before reload of network hub
-#define DEFAULT_NET_DEVLIST_VALIDITY_MS 10000
-
-// websocket key from specification v13
-#define YOCTO_WEBSOCKET_MAGIC             "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
-#define YOCTO_WEBSOCKET_MAGIC_LEN         36
-
-
-// firmware description
-typedef union {
-    u8      asBytes[YOCTO_FIRMWARE_LEN];
-    struct {
-        char    buildVersion[YOCTO_FIRMWARE_LEN-2];
-        u16     yfsSignature;
-    } data;
-} yFirmwareSt;
-
-// device description
-typedef struct {
-    u16     vendorid;
-    u16     deviceid;
-    u16     devrelease;
-    u16     nbinbterfaces;
-    char    manufacturer[YOCTO_MANUFACTURER_LEN];
-    char    productname[YOCTO_PRODUCTNAME_LEN];
-    char    serial[YOCTO_SERIAL_LEN];
-    char    logicalname[YOCTO_LOGICAL_LEN];
-    char    firmware[YOCTO_FIRMWARE_LEN];
-    u8      beacon;
-    u8      pad;
-} yDeviceSt;
-
-// definitions for USB protocol
-
-#ifndef C30
-#define Nop()
-#pragma pack(push,1)
-#endif
-
-#define USB_PKT_SIZE            64
-#define YPKT_USB_VERSION_NO_RETRY_BCD    0x0207
-#define YPKT_USB_VERSION_NO_CONFCHG_BCD  0x0208
-#define YPKT_USB_VERSION_BCD             0x0209
-#define TO_SAFE_U16(safe,unsafe)        {(safe).low = (unsafe)&0xff; (safe).high=(unsafe)>>8;}
-#define FROM_SAFE_U16(safe,unsafe)      {(unsafe) = (safe).low |((u16)((safe).high)<<8);}
-
-typedef struct {
-    u8 low;
-    u8 high;
-} SAFE_U16;
-
-#ifndef CPU_BIG_ENDIAN
-
-#define YPKTNOMSK   (0x7)
-typedef struct {
-    u8 pktno    : 3;
-    u8 stream   : 5;
-    u8 pkt      : 2;
-    u8 size     : 6;
-} YSTREAM_Head;
-#else
-#define YPKTNOMSK   (0x7)
-typedef struct {
-    u8 stream   : 5;
-    u8 pktno    : 3;
-    u8 size     : 6;
-    u8 pkt      : 2;
-} YSTREAM_Head;
-#endif
-#define YPKT_STREAM         0
-#define YPKT_CONF           1
-
-//
-// YPKT_CONF packets format
-//
-
-#define USB_CONF_RESET      0
-#define USB_CONF_START      1
-
-typedef union{
-    struct{
-        SAFE_U16  api;
-        u8  ok;
-        u8  ifaceno;
-        u8  nbifaces;
-    } reset;
-    struct{
-        u8  nbifaces;
-        u8  ack_delay;
-    } start;
-} USB_Conf_Pkt;
-
-//
-// YPKT_STREAM packets can encompass multiple streams
-//
-
-#define YSTREAM_EMPTY          0
-#define YSTREAM_TCP            1
-#define YSTREAM_TCP_CLOSE      2
-#define YSTREAM_NOTICE         3
-#define YSTREAM_REPORT         4
-#define YSTREAM_META           5
-#define YSTREAM_REPORT_V2      6
-#define YSTREAM_NOTICE_V2      7
-#define YSTREAM_TCP_NOTIF      8
-#define YSTREAM_TCP_ASYNCCLOSE 9
-
-// Data in YSTREAM_NOTICE stream
-
-#define NOTIFY_1STBYTE_MAXTINY  63
-#define NOTIFY_1STBYTE_MINSMALL 128
-
-#define NOTIFY_PKT_NAME        0
-#define NOTIFY_PKT_PRODNAME    1
-#define NOTIFY_PKT_CHILD       2
-#define NOTIFY_PKT_FIRMWARE    3
-#define NOTIFY_PKT_FUNCNAME    4
-#define NOTIFY_PKT_FUNCVAL     5
-#define NOTIFY_PKT_STREAMREADY 6
-#define NOTIFY_PKT_LOG         7
-#define NOTIFY_PKT_FUNCNAMEYDX 8
-#define NOTIFY_PKT_PRODINFO    9
-#define NOTIFY_PKT_CONFCHANGE  10
-
-#define NOTIFY_V2_LEGACY       0       // unused (reserved for compatibility with legacy notifications)
-#define NOTIFY_V2_6RAWBYTES    1       // largest type: data is always 6 bytes
-#define NOTIFY_V2_TYPEDDATA    2       // other types: first data byte holds the decoding format
-#define NOTIFY_V2_FLUSHGROUP   3       // no data associated
-// Higher values not allowed (Notification_funydx.raw must stay <= 63)
-
-// New types of generic notifications
-#define PUBVAL_LEGACY                       0   // 0-6 ASCII characters (normally sent as YSTREAM_NOTICE)
-#define PUBVAL_1RAWBYTE                     1   // 1 raw byte  (=2 characters)
-#define PUBVAL_2RAWBYTES                    2   // 2 raw bytes (=4 characters)
-#define PUBVAL_3RAWBYTES                    3   // 3 raw bytes (=6 characters)
-#define PUBVAL_4RAWBYTES                    4   // 4 raw bytes (=8 characters)
-#define PUBVAL_5RAWBYTES                    5   // 5 raw bytes (=10 characters)
-#define PUBVAL_6RAWBYTES                    6   // 6 hex bytes (=12 characters) (sent as V2_6RAWBYTES)
-#define PUBVAL_C_LONG                       7   // 32-bit C signed integer
-#define PUBVAL_C_FLOAT                      8   // 32-bit C float
-#define PUBVAL_YOCTO_FLOAT_E3               9   // 32-bit Yocto fixed-point format (e-3)
-
-typedef struct{
-    char        serial[YOCTO_SERIAL_LEN];
-    u8          type;
-}Notification_header;
-
-#ifdef _MSC_VER
-#pragma warning( push )
-#pragma warning( disable : 4200 )
-#endif
-
-typedef union {
-    // This definition must match packet generated in yoctoPacket.c
-    u8          raw;                    // originally shifted by NOTIFY_1STBYTE_MINSMALL for smallnot
-    struct {
-#ifndef CPU_BIG_ENDIAN
-        u8      funydx:4;
-        u8      typeV2:3;               // note: high bit MUST stay zero to ensure raw value <= 63 for tiny notifications
-        u8      isSmall:1;
-#else
-        u8      isSmall:1;
-        u8      typeV2:3;
-        u8      funydx:4;
-#endif
-    } v2;
-}Notification_funydx;
-
-typedef struct{
-    // This definition must match packet generated in yoctoPacket.c
-    Notification_funydx funInfo;
-    char        pubval[VARIABLE_SIZE]; // deduce actual size from YSTREAM_head
-}Notification_tiny;
-
-typedef struct{
-    // This definition must match packet generated in yoctoPacket.c
-    Notification_funydx funInfo;
-    u8          devydx;
-    char        pubval[VARIABLE_SIZE]; // deduce actual size from YSTREAM_head
-}Notification_small;
-
-#ifdef _MSC_VER
-#pragma warning( pop )
-#endif
-
-typedef struct{
-    char        name[YOCTO_LOGICAL_LEN];
-    u8          beacon;
-}Notification_name;
-
-typedef char    Notification_product[YOCTO_PRODUCTNAME_LEN];
-
-typedef struct {
-    char        name[YOCTO_PRODUCTNAME_LEN];
-    SAFE_U16    deviceid;
-}Notification_prodinfo;
-
-typedef struct {
-    char        childserial[YOCTO_SERIAL_LEN];
-    u8          onoff;
-    u8          devydx;
-}Notification_child;
-
-typedef struct {
-    char        firmware[YOCTO_FIRMWARE_LEN];
-    SAFE_U16    vendorid;
-    SAFE_U16    deviceid;
-}Notification_firmware;
-
-typedef struct {
-    char        funcid[YOCTO_FUNCTION_LEN];
-    char        funcname[YOCTO_LOGICAL_LEN];
-}Notification_funcname;
-
-typedef struct {
-    char        funcid[YOCTO_FUNCTION_LEN];
-    char        pubval[YOCTO_PUBVAL_SIZE];
-}Notification_funcval;
-
-typedef struct {
-    char        funcidshort[YOCTO_FUNCTION_LEN-1];
-    u8          funclass;       // 0..YOCTO_N_BASECLASSES-1
-    char        funcname[YOCTO_LOGICAL_LEN];
-    u8          funydx;
-}Notification_funcnameydx;
-
-typedef union {
-    u8                  firstByte;
-    Notification_tiny   tinypubvalnot;
-    Notification_small  smallpubvalnot;
-    struct {
-        Notification_header head;
-        union {
-            Notification_name           namenot;
-            Notification_product        productname;
-            Notification_prodinfo       productinfo;
-            Notification_child          childserial;
-            Notification_firmware       firmwarenot;
-            Notification_funcname       funcnamenot;
-            Notification_funcval        pubvalnot;
-            Notification_funcnameydx    funcnameydxnot;
-            u8                          raw;
-        };
-    };
-} USB_Notify_Pkt;
-
-#define NOTIFY_NETPKT_NAME        '0'
-#define NOTIFY_NETPKT_PRODNAME    '1'
-#define NOTIFY_NETPKT_CHILD       '2'
-#define NOTIFY_NETPKT_FIRMWARE    '3'
-#define NOTIFY_NETPKT_FUNCNAME    '4'
-#define NOTIFY_NETPKT_FUNCVAL     '5'
-#define NOTIFY_NETPKT_STREAMREADY '6'
-#define NOTIFY_NETPKT_LOG         '7'
-#define NOTIFY_NETPKT_FUNCNAMEYDX '8'
-#define NOTIFY_NETPKT_PRODINFO    '9'
-#define NOTIFY_NETPKT_CONFCHGYDX  's'
-#define NOTIFY_NETPKT_FLUSHV2YDX  't'
-#define NOTIFY_NETPKT_FUNCV2YDX   'u'
-#define NOTIFY_NETPKT_TIMEV2YDX   'v'
-#define NOTIFY_NETPKT_DEVLOGYDX   'w'
-#define NOTIFY_NETPKT_TIMEVALYDX  'x'
-#define NOTIFY_NETPKT_FUNCVALYDX  'y'
-#define NOTIFY_NETPKT_TIMEAVGYDX  'z'
-#define NOTIFY_NETPKT_NOT_SYNC    '@'
-
-#define NOTIFY_NETPKT_VERSION   "01"
-#define NOTIFY_NETPKT_START     "YN01"
-#define NOTIFY_NETPKT_START_LEN 4
-#define NOTIFY_NETPKT_STOP      '\n'
-#define NOTIFY_NETPKT_SEP       ','
-#define NOTIFY_NETPKT_MAX_LEN   (NOTIFY_NETPKT_START_LEN+1+YOCTO_SERIAL_LEN+1+YOCTO_FUNCTION_LEN+1+YOCTO_LOGICAL_LEN+1+1)
-
-#define NOTIFY_PKT_NAME_LEN             (sizeof(Notification_header) + sizeof(Notification_name))
-#define NOTIFY_PKT_PRODNAME_LEN         (sizeof(Notification_header) + sizeof(Notification_product))
-#define NOTIFY_PKT_PRODINFO_LEN         (sizeof(Notification_header) + sizeof(Notification_prodinfo))
-#define NOTIFY_PKT_CHILD_LEN            (sizeof(Notification_header) + sizeof(Notification_child))
-#define NOTIFY_PKT_FIRMWARE_LEN         (sizeof(Notification_header) + sizeof(Notification_firmware))
-#define NOTIFY_PKT_STREAMREADY_LEN      (sizeof(Notification_header) + sizeof(u8))
-#define NOTIFY_PKT_LOG_LEN              (sizeof(Notification_header) + sizeof(u8))
-#define NOTIFY_PKT_FUNCNAME_LEN         (sizeof(Notification_header) + sizeof(Notification_funcname))
-#define NOTIFY_PKT_FUNCVAL_LEN          (sizeof(Notification_header) + sizeof(Notification_funcval))
-#define NOTIFY_PKT_FUNCNAMEYDX_LEN      (sizeof(Notification_header) + sizeof(Notification_funcnameydx))
-#define NOTIFY_PKT_CONFCHG_LEN          (sizeof(Notification_header) + sizeof(u8))
-#define NOTIFY_PKT_TINYVAL_MAXLEN       (sizeof(Notification_tiny) + YOCTO_PUBVAL_SIZE)
-
-// Data in YSTREAM_REPORT stream
-//
-// Reports are always first in a packet, which
-// makes it easy to filter packets that contain
-// reports only, and interpret them as fixed offsets
-
-typedef struct {
-    union {
-      struct {
-#ifndef CPU_BIG_ENDIAN
-        u8  funYdx:4;   // (LOWEST NIBBLE) function index on device, 0xf==timestamp
-        u8  extraLen:3; // Number of extra data bytes in addition to first one
-        u8  isAvg:1;    // (HIGHEST BIT) 0:one immediate value (1-4 bytes), 1:min/avg/max (2+4+2 bytes)
-#else
-        u8  isAvg:1;    // (HIGHEST BIT) 0:one immediate value (1-4 bytes), 1:min/avg/max (2+4+2 bytes)
-        u8  extraLen:3; // Number of extra data bytes in addition to first one
-        u8  funYdx:4;   // (LOWEST NIBBLE) function index on device, 0xf==timestamp
-#endif
-      };
-      u8    head;
-    };
-    u8  data[1];        // Payload itself (numbers in little-endian format)
-} USB_Report_Pkt_V1;
-
-typedef struct {
-    union {
-      struct {
-#ifndef CPU_BIG_ENDIAN
-        u8  funYdx:4;   // (LOWEST NIBBLE) function index on device, 0xf==timestamp
-        u8  extraLen:4; // Number of extra data bytes in addition to data[0]
-#else
-        u8  extraLen:4; // Number of extra data bytes in addition to data[0]
-        u8  funYdx:4;   // (LOWEST NIBBLE) function index on device, 0xf==timestamp
-#endif
-      };
-      u8    head;
-    };
-    union {
-      // When extraLen >= 4 && funYdx != 0xf : first data byte describes the payload
-      struct {
-#ifndef CPU_BIG_ENDIAN
-        u8  avgExtraLen:2;      // Number of extra bytes in the first value (average value, signed MeasureVal)
-        u8  minDiffExtraLen:2;  // Number of extra bytes to encode the 2nd value (avg - min, always > 0)
-        u8  maxDiffExtraLen:2;  // Number of extra bytes to encode the 3rd value (max - avg, always > 0)
-        u8  reserved:2;         // unused, currently set to 0
-#else
-        u8  reserved:2;         // unused, currently set to 0
-        u8  maxDiffExtraLen:2;  // Number of extra bytes to encode the 3rd value (max - avg)
-        u8  minDiffExtraLen:2;  // Number of extra bytes to encode the 2nd value (avg - min)
-        u8  avgExtraLen:2;      // Number of extra bytes in the first value (average)
-#endif
-      };
-      // When extraLen <= 3 (up to 4 bytes of data): live report value (1-4 bytes)
-      u8  data[1];        // Payload itself (numbers in little-endian format)
-    };
-} USB_Report_Pkt_V2;
-
-// data format in USB_Report_Pkt_V2:
-//
-
-
-#define MAX_ASYNC_TCPCHAN 4
-
-
-// Data in YSTREAM_META stream
-
-#define USB_META_UTCTIME                1
-#define USB_META_DLFLUSH                2
-#define USB_META_ACK_D2H_PACKET         3
-#define USB_META_WS_ANNOUNCE            4
-#define USB_META_WS_AUTHENTICATION      5
-#define USB_META_WS_ERROR               6
-#define USB_META_ACK_UPLOAD             7
-
-#define USB_META_UTCTIME_SIZE           5u
-#define USB_META_DLFLUSH_SIZE           1u
-#define USB_META_ACK_D2H_PACKET_SIZE    2u
-#define USB_META_WS_ANNOUNCE_SIZE       (8 + YOCTO_SERIAL_LEN)
-#define USB_META_WS_AUTHENTICATION_SIZE 28u
-#define USB_META_WS_ERROR_SIZE          4u
-#define USB_META_ACK_UPLOAD_SIZE        6u
-
-#define USB_META_WS_PROTO_V1            1 // adding authentication support
-#define USB_META_WS_PROTO_V2            2 // adding API packets throttling
-
-#define USB_META_WS_AUTH_FLAGS_VALID    1 // set it if the sha1 and nonce are pertinent
-#define USB_META_WS_AUTH_FLAGS_RW       2 // set it if RW access are granted
-
-typedef union {
-    struct {
-        u8  metaType;      // =USB_META_UTCTIME
-        u8  unixTime[4];   // actually a DWORD in little-endian format
-    } utcTime;
-    struct {
-        u8  metaType;      // =USB_META_DLFLUSH (flush datalogger)
-    } dlFlush;
-    struct {
-        u8  metaType;      // =USB_META_ACK_D2H_PACKET (ack last device to host packet)
-        u8  pktno;         // = last pktno that the host has received
-    } pktAck;
-    struct {
-        u8  metaType;      // =USB_META_WS_ANNOUNCE (ack last device to host packet)
-        u8  version;       // the version of the authentication
-        u16 maxtcpws;      // maximum TCP window size, in multiples of 16 bytes
-        u32 nonce;         // nonce append to password (in capital hex)
-        char serial[YOCTO_SERIAL_LEN];
-    } announce;
-    struct {
-        u8  metaType;      // =USB_META_WS_AUTHENTICATION (authenticate traffic)
-        u8  version;       // the version of the authentication
-        u16 flags;         // reserved bits
-        u32 nonce;         // nonce append to password (in capital hex)
-        u8  sha1[20];      // sha1 signature
-    } auth;
-    struct {
-        u8  metaType;      // =USB_META_WS_ANNOUNCE (ack last device to host packet)
-        u8  reserved;      // reserved (must be 0)
-        u16 htmlcode;      // HTML error code
-    } error;
-    struct {
-        u8  metaType;      // =USB_META_ACK_UPLOAD (ack upload progress every KB)
-        u8  tcpchan;       // TCP channel index (as of proto v2, only available on tcpchan 0)
-        u8 totalBytes[4];  // actually a DWORD in little-endian format, number of bytes received so far
-    } uploadAck;
-} USB_Meta_Pkt;
-
-
-
-typedef union {
-     struct {
-#ifdef CPU_BIG_ENDIAN
-        u8      stream : 5;           // Encapsulated protocol
-        u8      tcpchan : 3;          // Encapsulated TCP subchannel
-#else
-        u8      tcpchan : 3;          // Encapsulated TCP subchannel
-        u8      stream : 5;           // Encapsulated protocol
-#endif
-    };
-    u8 encaps;
-} WSStreamHead;
-
-
-
-
-//
-// SSDP global definitions for hubs
-//
-
-#define YSSDP_PORT 1900
-#define YSSDP_MCAST_ADDR_STR  "239.255.255.250"
-#define YSSDP_MCAST_ADDR (0xFAFFFFEF)
-#define YSSDP_URN_YOCTOPUCE "urn:yoctopuce-com:device:hub:1"
-
-// prototype of the async request completion callback
-typedef void (*yapiRequestAsyncCallback)(void *context, const u8 *result, u32 resultlen, int retcode, const char *errmsg);
-// prototype of the request progress callback
-typedef void (*yapiRequestProgressCallback)(void *context, u32 acked, u32 totalbytes);
-
-
-
-//
-// PROG packets are only used in bootloader (USB DeviceID=0001/0002)
-//
-
-#define PROG_NOP         0 // nothing to do
-#define PROG_REBOOT      1 // reset the device
-#define PROG_ERASE       2 // erase completely the device
-#define PROG_PROG        3 // program the device
-#define PROG_VERIF       4 // program the device
-#define PROG_INFO        5 // get device info
-#define PROG_INFO_EXT    6 // get extended device info (flash bootloader only)
-
-#define MAX_BYTE_IN_PACKET          (60)
-#define MAX_INSTR_IN_PACKET         (MAX_BYTE_IN_PACKET/3)
-
-#define ERASE_BLOCK_SIZE_INSTR      512               // the minimal erase size in nb instr
-#define PROGRAM_BLOCK_SIZE_INSTR    64                // the minimal program size in nb instr
-//define some addresses in bytes too
-#define ERASE_BLOCK_SIZE_BADDR      (ERASE_BLOCK_SIZE_INSTR*2)
-#define PROGRAM_BLOCK_SIZE_BADDR    (PROGRAM_BLOCK_SIZE_INSTR*2)
-
-
-typedef union {
-    u8  raw[64];
-    u16 words[32];
-    struct {
-#ifndef CPU_BIG_ENDIAN
-        u8  size : 5;
-        u8  type : 3;
-#else
-        u8  type : 3;
-        u8  size : 5;
-#endif
-        u8  addres_high;
-        u16 adress_low;
-        u8  data[MAX_BYTE_IN_PACKET];
-    } pkt;
-    struct {
-#ifndef CPU_BIG_ENDIAN
-        u8   size : 5;
-        u8   type : 3;
-#else
-        u8   type : 3;
-        u8   size : 5;
-#endif
-        u8   pad;
-        u16  pr_blk_size;
-        u16  devidl;
-        u16  devidh;
-        u32  settings_addr;
-        u32  last_addr;
-        u32  config_start;
-        u32  config_stop;
-        u16  er_blk_size;
-    } pktinfo;
-    struct {
-#ifndef CPU_BIG_ENDIAN
-        u8   size : 5;
-        u8   type : 3;
-#else
-        u8   type : 3;
-        u8   size : 5;
-#endif
-        u8   dwordpos_lo;
-#ifndef CPU_BIG_ENDIAN
-        u16  pageno : 14;
-        u16  dwordpos_hi : 2;
-#else
-        u8  pageno_lo;
-        u8  misc_hi;
-#endif
-        union {
-            u16  npages;    // for PROG_ERASE
-            u16  btsign;    // for PROG_REBOOT
-            u8   data[MAX_BYTE_IN_PACKET]; // for PROG_PROG
-        } opt;
-    } pkt_ext;
-    struct {
-#ifndef CPU_BIG_ENDIAN
-        u8   size : 5;
-        u8   type : 3;
-#else
-        u8   type : 3;
-        u8   size : 5;
-#endif
-        u8   version;
-        u16  pr_blk_size;
-        u16  devidl;
-        u16  devidh;
-        u32  settings_addr;
-        u32  last_addr;
-        u32  config_start;
-        u32  config_stop;
-        u16  er_blk_size;
-        u16  ext_jedec_id;
-        u16  ext_page_size;
-        u16  ext_total_pages;
-        u16  first_code_page;
-        u16  first_yfs3_page;
-    } pktinfo_ext;
-} USB_Prog_Packet;
-
-#ifndef CPU_BIG_ENDIAN
-#define SET_PROG_POS_PAGENO(PKT_EXT, PAGENO, POS)  {\
-                                (PKT_EXT).dwordpos_lo = (POS) & 0xff;\
-                                (PKT_EXT).dwordpos_hi = ((POS) >> 8) & 3;\
-                                (PKT_EXT).pageno = (PAGENO) & 0x3fff;}
-#define GET_PROG_POS_PAGENO(PKT_EXT, PAGENO, POS)  {\
-                                POS = (PKT_EXT).dwordpos_lo + ((u32)(PKT_EXT).dwordpos_hi <<8);\
-                                PAGENO = (PKT_EXT).pageno;}
-
-#define INTEL_U16(NUM)  (NUM)
-#define INTEL_U32(NUM) (NUM)
-#else
-#define SET_PROG_POS_PAGENO(PKT_EXT, PAGENO, POS)  {\
-                                (PKT_EXT).dwordpos_lo = (POS) & 0xff;\
-                                (PKT_EXT).pageno_lo = (PAGENO) & 0xff;\
-                                (PKT_EXT).misc_hi = (((PAGENO) >>8) & 0x3f)+ (((POS) & 0x300) >>2) ;}
-#define GET_PROG_POS_PAGENO(PKT_EXT, PAGENO, POS)  {\
-                                POS = (PKT_EXT).dwordpos_lo + (((u16)(PKT_EXT).misc_hi << 2) & 0x300);\
-                                PAGENO = (PKT_EXT).pageno_lo + (((u16)(PKT_EXT).misc_hi & 0x3f) << 8);}
-#define INTEL_U16(NUM) ((((NUM) & 0xff00) >> 8) | (((NUM)&0xff) << 8))
-#define INTEL_U32(NUM) ((((NUM) >> 24) & 0xff) | (((NUM) << 8) & 0xff0000) | (((NUM) >> 8) & 0xff00) | (((NUM) << 24) & 0xff000000 ))
-
-#endif
-
-
-
-#define START_APPLICATION_SIGN   0
-#define START_BOOTLOADER_SIGN   ('b'| ('T'<<8))
-#define START_AUTOFLASHER_SIGN  ('b'| ('F'<<8))
-
-
-typedef union {
-    u8              data[USB_PKT_SIZE];
-    u16             data16[USB_PKT_SIZE/2];
-    u32             data32[USB_PKT_SIZE/4];
-    YSTREAM_Head    first_stream;
-    USB_Prog_Packet prog;
-    struct{
-        YSTREAM_Head    head;
-        USB_Conf_Pkt    conf;
-    } confpkt;
-} USB_Packet;
-
-#ifndef C30
-#pragma pack(pop)
-#endif
-
-//device identifications PIC24FJ256DA210 family
-#define FAMILY_PIC24FJ256DA210 0X41
-#define PIC24FJ128DA206     0x08
-#define PIC24FJ128DA106     0x09
-#define PIC24FJ128DA210     0x0A
-#define PIC24FJ128DA110     0x0B
-#define PIC24FJ256DA206     0x0C
-#define PIC24FJ256DA106     0x0D
-#define PIC24FJ256DA210     0x0E
-#define PIC24FJ256DA110     0x0F
-
-//device identifications PIC24FJ64GB004 family
-#define FAMILY_PIC24FJ64GB004 0x42
-#define PIC24FJ32GB002      0x03
-#define PIC24FJ64GB002      0x07
-#define PIC24FJ32GB004      0x0B
-#define PIC24FJ64GB004      0x0F
-
-// Spansion Flash JEDEC id
-#define JEDEC_SPANSION_4MB  0x16
-#define JEDEC_SPANSION_8MB  0x17
-
-#define YESC                (27u)
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
--- a/Sources/cpplib/yapi/yfifo.c
+++ /dev/null
@@ -1,529 +0,0 @@
-/*********************************************************************
- *
- * $Id: yfifo.c 33735 2018-12-14 16:06:53Z seb $
- *
- * Implementation of a generic fifo queue
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__  "yfifo"
-
-#include "ydef.h"
-
-#if defined(MICROCHIP_API)
-#include "api.h"
-#else
-#include "yfifo.h"
-#include "yproto.h"
-#endif
-
-void yFifoInitEx(
-#ifdef DEBUG_FIFO
-    const char* fileid, int line,
-#endif
-    yFifoBuf *buf, u8 *buffer, u16 bufflen)
-{
-    memset(buf,0,sizeof(yFifoBuf));
-    buf->buff = buffer;
-    buf->buffsize = bufflen;
-    buf->head = buf->tail = buffer;
-#ifdef DEBUG_FIFO
-    buf->line   = line;
-    buf->fileid = fileid;
-#endif
-#ifdef YFIFO_USE_MUTEX
-    yInitializeCriticalSection(&(buf->cs));
-#endif
-}
-
-#ifndef MICROCHIP_API
-void yFifoCleanup(yFifoBuf *buf)
-{
-#ifdef YFIFO_USE_MUTEX
-    yDeleteCriticalSection(&(buf->cs));
-#endif
-    memset(buf,0,sizeof(yFifoBuf));
-}
-#endif
-
-#ifdef YFIFO_USE_MUTEX
-
-void yFifoEnterCS(yFifoBuf *buf)
-{
-    yEnterCriticalSection(&(buf->cs));
-}
-
-void yFifoLeaveCS(yFifoBuf *buf)
-{
-    yLeaveCriticalSection(&(buf->cs));
-}
-#endif
-
-void yFifoEmptyEx(yFifoBuf *buf)
-{
-    buf->datasize = 0;
-    buf->head = buf->tail =  buf->buff;
-}
-
-#ifdef YFIFO_USE_MUTEX
-
-void yFifoEmpty(yFifoBuf *buf)
-{
-    yFifoEnterCS(buf);
-    yFifoEmptyEx(buf);
-    yFifoLeaveCS(buf);
-}
-#endif
-
-u16 yPushFifoEx(yFifoBuf *buf, const u8 *data, u16 datalen)
-{
-    u16 freespace = buf->buffsize - buf->datasize;
-
-    if (datalen > freespace) {
-        // not enough space available in
-        // buffer to handle correctly this packet
-        // (we do not handle partial packet since usb packet are
-        // max 64byte long)
-        return 0;
-    }
-    //append data to our fifo buffer
-    if (buf->tail + datalen <= YFIFOEND(buf)) {
-        memcpy(buf->tail, data, datalen);
-        buf->tail += datalen;
-        if (buf->tail == YFIFOEND(buf))
-            buf->tail = buf->buff;
-    } else {
-        u16 cplen = (u16)(YFIFOEND(buf) - buf->tail);
-        memcpy(buf->tail, data, cplen);
-        memcpy(buf->buff, data + cplen, datalen - cplen);
-        buf->tail = buf->buff + (datalen - cplen);
-    }
-    // This must remain very last, so that datasize always remain
-    // the number of bytes really available in buffer (may be polled
-    // from within interrupt handlers)
-    buf->datasize += datalen;
-#ifdef DEBUG_FIFO
-    buf->totalPushed += datalen;
-#endif
-    return datalen;
-}
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 yPushFifo(yFifoBuf *buf, const u8 *data, u16 datalen)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yPushFifoEx(buf,data,datalen);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-u16 yPopFifoEx(yFifoBuf *buf, u8 *data, u16 datalen)
-{
-    if (datalen > buf->datasize)
-        datalen = buf->datasize;
-    if (buf->head + datalen > YFIFOEND(buf)) {
-        //need to handle wrap
-        u16 firstpart = (u16)(YFIFOEND(buf) - buf->head);
-        if (data) {
-            memcpy(data, buf->head, firstpart);
-            memcpy(data + firstpart, buf->buff, datalen - firstpart);
-        }
-
-        buf->head = buf->buff + (datalen - firstpart);
-    } else {
-        if (data) {
-            memcpy(data, buf->head, datalen);
-        }
-        buf->head += datalen;
-        if (buf->head == YFIFOEND(buf))
-            buf->head -= buf->buffsize;
-    }
-    // This must remain very last, so that buffsize-datasize always
-    // remain the number of bytes really free in buffer (may be polled
-    // from within interrupt handlers)
-    buf->datasize -= datalen;
-#ifdef DEBUG_FIFO
-    buf->totalPopded += datalen;
-#endif
-    return datalen;
-}
-
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 yPopFifo(yFifoBuf *buf, u8 *data, u16 datalen)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yPopFifoEx(buf,data,datalen);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-
-static u16 yForceFifoEx(yFifoBuf *buf, const u8 *data, u16 datalen)
-{
-    u16 freespace;
-    freespace = buf->buffsize - buf->datasize;
-
-    if(datalen > buf->buffsize) {
-        return 0;
-    }
-
-    if (datalen > freespace) {
-        // not enough space, drop oldest data
-        yPopFifoEx(buf, NULL, datalen - freespace);
-    }
-    return yPushFifoEx(buf, data, datalen);
-}
-
-u16 yForceFifo(yFifoBuf *buf, const u8 *data, u16 datalen, u32 *absCounter)
-{
-    u16 res;
-
-#ifndef MICROCHIP_API
-    yFifoEnterCS(buf);
-#endif
-
-    res = yForceFifoEx(buf,data,datalen);
-    *absCounter += res;
-
-#ifndef MICROCHIP_API
-    yFifoLeaveCS(buf);
-#endif
-
-    return res;
-}
-
-u16 yPeekFifoEx(yFifoBuf *buf, u8 *data, u16 datalen, u16 startofs)
-{
-    u8 *ptr ;
-    if(startofs > buf->datasize){
-        return 0;
-    }
-
-    if (datalen + startofs > buf->datasize)
-        datalen = buf->datasize - startofs;
-
-    ptr=buf->head+startofs;
-    if(ptr >= YFIFOEND(buf)){
-        ptr -= buf->buffsize;
-    }
-    if (ptr + datalen > YFIFOEND(buf)) {
-        //need to handle wrap
-        u16 firstpart = (u16)(YFIFOEND(buf) - ptr);
-        if (data) {
-            memcpy(data, ptr, firstpart);
-            memcpy(data + firstpart, buf->buff, datalen - firstpart);
-        }
-    } else {
-        if (data) {
-            memcpy(data, ptr, datalen);
-        }
-    }
-    return datalen;
-}
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 yPeekFifo(yFifoBuf *buf, u8 *data, u16 datalen, u16 startofs)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yPeekFifoEx(buf,data,datalen,startofs);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-
-u16 yPeekContinuousFifoEx(yFifoBuf *buf, u8 **ptr, u16 startofs)
-{
-    u8 *lptr;
-
-    if(startofs >= buf->datasize) {
-        return 0;
-    }
-
-    lptr = buf->head + startofs;
-    if(lptr >= YFIFOEND(buf)) {
-        // wrap
-        if(ptr) {
-            *ptr = lptr - buf->buffsize;
-        }
-        return buf->datasize - startofs;
-    } else {
-        // no wrap
-        u16 toend = (u16)(YFIFOEND(buf) - lptr);
-        if(ptr) {
-            *ptr = lptr;
-        }
-        return (toend < buf->datasize ? toend : buf->datasize);
-    }
-
-}
-
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 yPeekContinuousFifo(yFifoBuf *buf, u8 **ptr, u16 startofs)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yPeekContinuousFifoEx(buf,ptr,startofs);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-
-u16 ySeekFifoEx(yFifoBuf *buf, const u8* pattern, u16 patlen,  u16 startofs, u16 searchlen, u8 bTextCompare)
-{
-    u8 *ptr;
-    u16 patidx;
-    u16 firstmatch = 0xffff;
-
-    // pattern bigger than our buffer size -> not found
-    if (startofs + patlen > buf->datasize) {
-        return 0xffff;
-    }
-    // adjust searchlen and ptr to our buffer
-    // size and position
-    if (searchlen == 0 || searchlen > buf->datasize - startofs)
-        searchlen = buf->datasize - startofs;
-    ptr = buf->head + startofs;
-    if (ptr >= YFIFOEND(buf))
-        ptr -= buf->buffsize;
-
-    patidx = 0;
-    while (searchlen > 0 && patidx < patlen) {
-        u16 bletter = *ptr;
-        u16 pletter = pattern[patidx];
-
-        if (bTextCompare && pletter >= 'A' && bletter >= 'A' && pletter <= 'z' && bletter <= 'z') {
-            pletter &= ~32;
-            bletter &= ~32;
-        }
-        if (pletter == bletter) {
-            if(patidx == 0) {
-                firstmatch = startofs;
-            }
-            patidx++;
-        } else if(patidx > 0) {
-            // rescan this character as first pattern character
-            patidx = 0;
-            continue;
-        }
-        startofs++;
-        searchlen--;
-        ptr++;
-        if (ptr >= YFIFOEND(buf))
-            ptr -= buf->buffsize;
-
-    }
-    if (patidx == patlen) {
-        return firstmatch;
-    }
-    return 0xffff;
-}
-
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 ySeekFifo(yFifoBuf *buf, const u8* pattern, u16 patlen,  u16 startofs, u16 searchlen, u8 bTextCompare)
-{
-    u16 res;
-
-    yFifoEnterCS(buf);
-    res = ySeekFifoEx(buf,pattern,patlen,startofs,searchlen,bTextCompare);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-u16 yFifoGetUsedEx(yFifoBuf *buf)
-{
-    return buf->datasize;
-}
-
-#ifdef YFIFO_USE_MUTEX
-
-u16 yFifoGetUsed(yFifoBuf *buf)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yFifoGetUsedEx(buf);
-    yFifoLeaveCS(buf);
-    return res;
-}
-#endif
-
-u16 yFifoGetFreeEx(yFifoBuf *buf)
-{
-    return buf->buffsize-buf->datasize;
-}
-
-#ifdef YFIFO_USE_MUTEX
-u16 yFifoGetFree(yFifoBuf *buf)
-{
-    u16 res;
-    yFifoEnterCS(buf);
-    res = yFifoGetFreeEx(buf);
-    yFifoLeaveCS(buf);
-    return res;
-}
-
-#endif
-
-#ifndef REDUCE_COMMON_CODE
-void yxtoa(u32 x, char *buf, u16 len)
-{
-    buf[len] = 0;
-    while(len > 0) {
-        unsigned b = x & 0xf;
-        buf[--len] = (b>9u) ? b+'a'-10 : b+'0';
-        x >>= 4;
-    }
-}
-#endif
-
-#if defined(USE_TYPED_NOTIFICATIONS) || !defined(MICROCHIP_API)
-
-// Decode a standard (V1) or typed notification (V2), possibly not null terminated,
-// to its text representation (always null terminated)
-//
-void decodePubVal(Notification_funydx funInfo, const char *funcval, char *buffer)
-{
-    const unsigned char *p = (const unsigned char *)funcval;
-    u16     funcValType;
-    s32     numVal;
-    float   floatVal;
-    int     i;
-
-    if(funInfo.v2.typeV2 == NOTIFY_V2_6RAWBYTES || funInfo.v2.typeV2 == NOTIFY_V2_TYPEDDATA) {
-        if(funInfo.v2.typeV2 == NOTIFY_V2_6RAWBYTES) {
-            funcValType = PUBVAL_6RAWBYTES;
-        } else {
-            funcValType = *p++;
-        }
-        switch(funcValType) {
-            case PUBVAL_LEGACY:
-                // fallback to legacy handling, just in case
-                break;
-            case PUBVAL_1RAWBYTE:
-            case PUBVAL_2RAWBYTES:
-            case PUBVAL_3RAWBYTES:
-            case PUBVAL_4RAWBYTES:
-            case PUBVAL_5RAWBYTES:
-            case PUBVAL_6RAWBYTES:
-                // 1..6 hex bytes
-                for(i = 0; i < funcValType; i++) {
-                    unsigned c = *p++;
-                    unsigned b = c >> 4;
-                    buffer[2*i]   = (b>9u) ? b+'a'-10 : b+'0';
-                    b = c & 0xf;
-                    buffer[2*i+1] = (b>9u) ? b+'a'-10 : b+'0';
-                }
-                buffer[2*i] = 0;
-                return;
-            case PUBVAL_C_LONG:
-            case PUBVAL_YOCTO_FLOAT_E3:
-                // 32bit integer in little endian format or Yoctopuce 10-3 format
-                numVal = *p++;
-                numVal += (s32)*p++ << 8;
-                numVal += (s32)*p++ << 16;
-                numVal += (s32)*p++ << 24;
-#ifdef MICROCHIP_API
-                if(funcValType == PUBVAL_C_LONG) {
-                    s32toa(numVal, buffer);
-                } else {
-                    dectoa(numVal, buffer, YOCTO_PUBVAL_LEN-1, 1);
-                }
-#else
-                if(funcValType == PUBVAL_C_LONG) {
-                    YSPRINTF(buffer, YOCTO_PUBVAL_LEN, "%d", numVal);
-                } else {
-                    char *endp;
-                    YSPRINTF(buffer, YOCTO_PUBVAL_LEN, "%.3f", numVal/1000.0);
-                    endp = buffer + strlen(buffer);
-                    while(endp > buffer && endp[-1] == '0') {
-                        *--endp = 0;
-                    }
-                    if(endp > buffer && endp[-1] == '.') {
-                        *--endp = 0;
-                    }
-                }
-#endif
-                return;
-            case PUBVAL_C_FLOAT:
-                // 32bit (short) float
-                memcpy(&floatVal, p, sizeof(floatVal));
-#ifdef MICROCHIP_API
-                dectoa(floatVal*1000.0, buffer, YOCTO_PUBVAL_LEN-1, 1);
-#else
-                {
-                    char largeBuffer[64];
-                    char *endp;
-                    YSPRINTF(largeBuffer, 64, "%.6f", floatVal);
-                    endp = largeBuffer + strlen(largeBuffer);
-                    while(endp > largeBuffer && endp[-1] == '0') {
-                        *--endp = 0;
-                    }
-                    if(endp > largeBuffer && endp[-1] == '.') {
-                        *--endp = 0;
-                    }
-                    YSTRCPY(buffer, YOCTO_PUBVAL_LEN, largeBuffer);
-                }
-#endif
-                return;
-            default:
-                buffer[0] = '?';
-                buffer[1] = 0;
-                return;
-        }
-    }
-
-    // Legacy handling: just pad with NUL up to 7 chars
-    for(i = 0; i < 6; i++,p++) {
-        u8 c = *p;
-        if(!c) break;
-        buffer[i] = c;
-    }
-    buffer[i] = 0;
-}
-
-#endif
--- a/Sources/cpplib/yapi/yfifo.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/*********************************************************************
- *
- * $Id: yfifo.h 24925 2016-06-29 15:26:26Z mvuilleu $
- *
-  * Declaration of a generic fifo queue
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#ifndef YFIFO_H
-#define YFIFO_H
-#include "ydef.h"
-
-#ifndef MICROCHIP_API
-#define YFIFO_USE_MUTEX
-#endif
-
-//#define DEBUG_FIFO
-
-#if defined(WINDOWS_API) && defined(YFIFO_USE_MUTEX)
-#if defined(__BORLANDC__)
-#pragma warn -8019
-#include <windows.h>
-#pragma warn +8019
-#else
-#include <windows.h>
-#endif
-#endif
-
-typedef struct {
-    u16 buffsize;
-    u16 datasize;
-    u8 *buff;
-    u8 *head;
-    u8 *tail;
-#ifdef YFIFO_USE_MUTEX
-	yCRITICAL_SECTION cs;
-#endif
-#ifdef DEBUG_FIFO
-	const char* fileid;
-	int 		line;
-    u32 		totalPushed;
-    u32 		totalPopded;
-#endif
-} yFifoBuf;
-
-#define YFIFOEND(fifobuf)   ((fifobuf)->buff + (fifobuf)->buffsize)
-
-
-#ifdef DEBUG_FIFO
-void 	yFifoInitEx(const char* fileid,int line, yFifoBuf *buf, u8 *buffer, u16 bufflen);
-#define yFifoInit(fifo,buffer,len)  yFifoInitEx(__FILE_ID__,__LINE__,fifo,buffer,len);
-#else
-void 	yFifoInitEx(yFifoBuf *buf, u8 *buffer, u16 bufflen);
-#define yFifoInit(fifo,buffer,len)  yFifoInitEx(fifo,buffer,len);
-#endif
-
-#ifdef MICROCHIP_API
-#define yFifoCleanup(fifo) memset(fifo, 0, sizeof(yFifoBuf))
-#else
-void yFifoCleanup(yFifoBuf *buf);
-#endif
-
-// Ex version do not have muxtex
-void yFifoEmptyEx(yFifoBuf *buf);
-u16  yPushFifoEx(yFifoBuf *buf, const u8 *data, u16 datalen);
-u16  yPopFifoEx(yFifoBuf *buf, u8 *data, u16 datalen);
-u16  yPeekFifoEx(yFifoBuf *buf, u8 *data, u16 datalen, u16 startofs);
-u16  yPeekContinuousFifoEx(yFifoBuf *buf, u8 **ptr, u16 startofs);
-u16  ySeekFifoEx(yFifoBuf *buf, const u8* pattern, u16 patlen,  u16 startofs, u16 searchlen, u8 bTextCompare);
-u16  yFifoGetUsedEx(yFifoBuf *buf);
-u16  yFifoGetFreeEx(yFifoBuf *buf);
-u16  yForceFifo(yFifoBuf *buf, const u8 *data, u16 datalen, u32 *absCounter);
-
-#ifdef YFIFO_USE_MUTEX
-// mutex non-Ex function call yFifoEnterCs and yFifoLeaveCs
-// before calling Ex version
-
-void yFifoEnterCS(yFifoBuf *buf);
-void yFifoLeaveCS(yFifoBuf *buf);
-void yFifoEmpty(yFifoBuf *buf);
-u16  yPushFifo(yFifoBuf *buf, const u8 *data, u16 datalen);
-u16  yPopFifo(yFifoBuf *buf, u8 *data, u16 datalen);
-u16  yPeekFifo(yFifoBuf *buf, u8 *data, u16 datalen, u16 startofs);
-u16  yPeekContinuousFifo(yFifoBuf *buf, u8 **ptr,u16 startofs);
-u16  ySeekFifo(yFifoBuf *buf, const u8* pattern, u16 patlen,  u16 startofs, u16 searchlen, u8 bTextCompare);
-u16  yFifoGetUsed(yFifoBuf *buf);
-u16  yFifoGetFree(yFifoBuf *buf);
-
-#else
-// no mutex -> map function to Ex version
-#define yFifoEnterCS(buf)
-#define yFifoLeaveCS(buf)
-#define yFifoEmpty(buf)                                                     yFifoEmptyEx(buf)
-#define yPushFifo(buf,data, datalen)                                        yPushFifoEx(buf,data,datalen)
-#define yPopFifo(buf, data, datalen)                                        yPopFifoEx(buf,data,datalen)
-#define yPeekFifo(buf, data, datalen, startofs)                             yPeekFifoEx(buf,data,datalen,startofs)
-#define yPeekContinuousFifo(buf,ptr,startofs)                               yPeekContinuousFifoEx(buf,ptr,startofs)
-#define ySeekFifo(buf, pattern, patlen,  startofs, searchlen, bTextCompare) ySeekFifoEx(buf,pattern,patlen,startofs,searchlen,bTextCompare)
-#define yFifoGetUsed(buf)                                                   yFifoGetUsedEx(buf)
-#define yFifoGetFree(buf)                                                   yFifoGetFreeEx(buf)
-#endif
-
-// Misc functions needed in yapi, hubs and devices
-void yxtoa(u32 x, char *buf, u16 len);
-void decodePubVal(Notification_funydx funInfo, const char *funcval, char *buffer);
-
-#endif
--- a/Sources/cpplib/yapi/yhash.c
+++ /dev/null
@@ -1,2124 +0,0 @@
-/*********************************************************************
- *
- * $Id: yhash.c 33735 2018-12-14 16:06:53Z seb $
- *
- * Simple hash tables and device/function information store
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "yhash"
-#include "yhash.h"
-#include <string.h>
-
-#ifdef MICROCHIP_API
-__eds__ __attribute__((far, __section__(".yfar1"))) YHashSlot yHashTable[NB_MAX_HASH_ENTRIES];
-#include <Yocto/yapi_ext.h>
-#else
-#include <stdio.h>
-#include <stdlib.h>
-#include "yproto.h"
-#ifdef WINDOWS_API
-#include <Windows.h>
-#endif
-#define __eds__
-static YHashSlot yHashTable[NB_MAX_HASH_ENTRIES];
-yCRITICAL_SECTION yHashMutex;
-yCRITICAL_SECTION yFreeMutex;
-yCRITICAL_SECTION yWpMutex;
-yCRITICAL_SECTION yYpMutex;
-#endif
-
-//#define DEBUG_YHASH
-#ifdef DEBUG_YHASH
-#define HLOGF(x)             dbglog x;
-#else
-#define HLOGF(x)
-#endif
-
-#ifndef MICROCHIP_API
-static u16 usedDevYdx[NB_MAX_DEVICES / 16];
-static u16 nextDevYdx = 0;
-#endif
-static u8 nextCatYdx = 1;
-static u16 nextHashEntry = 256;
-
-static yBlkHdl devYdxPtr[NB_MAX_DEVICES];
-static yBlkHdl funYdxPtr[NB_MAX_DEVICES];
-
-#ifndef MICROCHIP_API
-char SerialNumberStr[YOCTO_SERIAL_LEN] = "";
-#endif
-yStrRef SerialRef = INVALID_HASH_IDX;
-
-yBlkHdl yWpListHead = INVALID_BLK_HDL;
-yBlkHdl yYpListHead = INVALID_BLK_HDL;
-
-// =======================================================================
-//   Small block (16 bytes) allocator, for white pages and yellow pages
-// =======================================================================
-
-#define BLK(hdl)    (yHashTable[(hdl)>>1].blk[(hdl)&1])
-#define WP(hdl)     (BLK(hdl).wpEntry)
-#define YC(hdl)     (BLK(hdl).ypCateg)
-#define YP(hdl)     (BLK(hdl).ypEntry)
-#define YA(hdl)     (BLK(hdl).ypArray)
-
-yBlkHdl freeBlks = INVALID_BLK_HDL;
-
-static yBlkHdl yBlkAlloc(void)
-{
-    yBlkHdl res;
-
-    yEnterCriticalSection(&yFreeMutex);
-    if (freeBlks != INVALID_BLK_HDL) {
-        res = freeBlks;
-        freeBlks = BLK(freeBlks).nextPtr;
-    } else {
-        yEnterCriticalSection(&yHashMutex);
-        YASSERT(nextHashEntry < NB_MAX_HASH_ENTRIES);
-        res = ((nextHashEntry++) << 1) + 1;
-        yLeaveCriticalSection(&yHashMutex);
-        BLK(res).blkId = 0;
-        BLK(res).nextPtr = INVALID_BLK_HDL;
-        freeBlks = res--;
-        HLOGF(("yBlkAlloc() uses bucket 0x%x\n",nextHashEntry));
-    }
-    HLOGF(("yBlkAlloc() returns blkHdl 0x%x\n",res));
-    BLK(res).blkId = 0;
-    BLK(res).nextPtr = INVALID_BLK_HDL;
-    yLeaveCriticalSection(&yFreeMutex);
-
-    return res;
-}
-
-static void yBlkFree(yBlkHdl hdl)
-{
-    HLOGF(("Free blkHdl 0x%x\n",hdl));
-    yEnterCriticalSection(&yFreeMutex);
-    BLK(hdl).ydx = 0;
-    BLK(hdl).blkId = 0;
-    BLK(hdl).nextPtr = freeBlks;
-    freeBlks = hdl;
-    yLeaveCriticalSection(&yFreeMutex);
-}
-
-u16 yBlkListLength(yBlkHdl hdl)
-{
-    u16 res = 0;
-
-    while (hdl != INVALID_BLK_HDL) {
-        res++;
-        hdl = BLK(hdl).nextPtr;
-    }
-    return res;
-}
-
-yBlkHdl yBlkListSeek(yBlkHdl hdl, u16 pos)
-{
-    while (hdl != INVALID_BLK_HDL && pos > 0) {
-        hdl = BLK(hdl).nextPtr;
-        pos--;
-    }
-    return hdl;
-}
-
-// =======================================================================
-//   Tiny Hash table support
-// =======================================================================
-
-static u16 fletcher16(const u8* data, u16 len, u16 virtlen)
-{
-    u16 sum1 = 0xff, sum2 = 0xff - len, plen = 0;
-
-    // process data
-    while (len > 0) {
-        u16 tlen = len > 21 ? 21 : len;
-        len -= tlen;
-        plen += tlen;
-        do {
-            sum1 += *data++;
-            sum2 += sum1;
-        } while (--tlen);
-        sum1 = (sum1 & 0xff) + (sum1 >> 8);
-        sum2 = (sum2 & 0xff) + (sum2 >> 8);
-    }
-    // process zero-padding
-    plen = virtlen - plen;
-    while (plen > 0) {
-        u16 tlen = plen > 21 ? 21 : plen;
-        plen -= tlen;
-        sum2 += sum1 * tlen;
-        sum2 = (sum2 & 0xff) + (sum2 >> 8);
-    }
-    sum1 = (sum1 & 0xff) + (sum1 >> 8);
-    sum2 = (sum2 & 0xff) + (sum2 >> 8);
-    return ((sum1 & 0xff) << 8) | (sum2 & 0xff);
-}
-
-void yHashInit(void)
-{
-    yStrRef empty, Module, module, HubPort, Sensor;
-    u16 i;
-
-    HLOGF(("yHashInit\n"));
-    for (i = 0; i < 256; i++)
-        yHashTable[i].next = 0;
-    for (i = 0; i < NB_MAX_DEVICES; i++)
-        devYdxPtr[i] = INVALID_BLK_HDL;
-    for (i = 0; i < NB_MAX_DEVICES; i++)
-        funYdxPtr[i] = INVALID_BLK_HDL;
-#ifndef MICROCHIP_API
-    nextDevYdx = 0;
-    nextCatYdx = 1;
-    nextHashEntry = 256;
-    yWpListHead = INVALID_BLK_HDL;
-    yYpListHead = INVALID_BLK_HDL;
-    freeBlks = INVALID_BLK_HDL;
-    memset((u8 *)usedDevYdx, 0, sizeof(usedDevYdx));
-    yInitializeCriticalSection(&yHashMutex);
-    yInitializeCriticalSection(&yFreeMutex);
-    yInitializeCriticalSection(&yWpMutex);
-    yInitializeCriticalSection(&yYpMutex);
-#endif
-
-    // Always init hast table with empty string and Module string
-    // This ensures they always get the same magic hash value
-    empty = yHashPutStr("");
-    Module = yHashPutStr("Module");
-    module = yHashPutStr("module");
-    HubPort = yHashPutStr("HubPort");
-    Sensor = yHashPutStr("Sensor");
-    if (empty != YSTRREF_EMPTY_STRING ||
-        Module != YSTRREF_MODULE_STRING ||
-        module != YSTRREF_mODULE_STRING ||
-        HubPort != YSTRREF_HUBPORT_STRING ||
-        Sensor != YSTRREF_SENSOR_STRING) {
-        // This should never ever happen, something is really weird
-        // No log is possible here (called within yapiInitAPI), so
-        // the best we can do to help debugging is a tight loop.
-#ifdef MICROCHIP_API
-		while(1);
-#else
-        YPANIC;
-#endif
-    }
-    SerialRef = yHashPutStr(SerialNumberStr);
-
-    yYpListHead = yBlkAlloc();
-    YC(yYpListHead).catYdx = 0;
-    YC(yYpListHead).blkId = YBLKID_YPCATEG;
-    YC(yYpListHead).name = YSTRREF_MODULE_STRING;
-    YC(yYpListHead).entries = INVALID_BLK_HDL;
-}
-
-#ifndef MICROCHIP_API
-void yHashFree(void)
-{
-    HLOGF(("yHashFree\n"));
-    yDeleteCriticalSection(&yHashMutex);
-    yDeleteCriticalSection(&yFreeMutex);
-    yDeleteCriticalSection(&yWpMutex);
-    yDeleteCriticalSection(&yYpMutex);
-}
-#endif
-
-static yHash yHashPut(const u8* buf, u16 len, u8 testonly)
-{
-    u16 hash, i;
-    yHash yhash, prevhash = INVALID_HASH_IDX;
-    __eds__ u8* p;
-
-    hash = fletcher16(buf, len, HASH_BUF_SIZE);
-    yhash = hash & 0xff;
-
-    yEnterCriticalSection(&yHashMutex);
-
-    if (yHashTable[yhash].next != 0) {
-        // first entry is allocated, search chain
-        do {
-            if (yHashTable[yhash].hash == hash) {
-                // hash match, perform exact comparison
-                p = yHashTable[yhash].buff;
-                for (i = 0; i < len; i++) if (p[i] != buf[i]) break;
-                if (i == len) {
-                    // data match, verify padding zeroes for a full match
-                    while (i < HASH_BUF_SIZE) if (p[i++] != 0) break;
-                    if (i == HASH_BUF_SIZE) {
-                        // full match
-                        HLOGF(("yHash found at 0x%x\n", yhash));
-                        goto exit_ok;
-                    }
-                }
-            }
-            // not a match, try next entry in chain
-            prevhash = yhash;
-            yhash = yHashTable[yhash].next;
-        } while (yhash != -1);
-        // not found in chain
-        if (testonly) goto exit_error;
-        YASSERT(nextHashEntry < NB_MAX_HASH_ENTRIES);
-        yhash = nextHashEntry++;
-    } else {
-        // first entry not allocated
-        if (testonly) {
-        exit_error:
-            HLOGF(("yHash entry not found\n", yhash));
-            yLeaveCriticalSection(&yHashMutex);
-            return -1;
-        }
-    }
-
-    // create new entry
-    yHashTable[yhash].hash = hash;
-    yHashTable[yhash].next = -1;
-    p = yHashTable[yhash].buff;
-    for (i = 0; i < len; i++) p[i] = buf[i];
-    while (i < HASH_BUF_SIZE) p[i++] = 0;
-    if (prevhash != INVALID_HASH_IDX) {
-        yHashTable[prevhash].next = yhash;
-    }
-    HLOGF(("yHash added at 0x%x\n", yhash));
-
-exit_ok:
-    yLeaveCriticalSection(&yHashMutex);
-    return yhash;
-}
-
-yHash yHashPutBuf(const u8* buf, u16 len)
-{
-    if (len > HASH_BUF_SIZE) len = HASH_BUF_SIZE;
-    return yHashPut(buf, len, 0);
-}
-
-yHash yHashPutStr(const char* str)
-{
-    u16 len = (u16)YSTRLEN(str);
-
-    if (len > HASH_BUF_SIZE) len = HASH_BUF_SIZE;
-    HLOGF(("yHashPutStr('%s'):\n",str));
-    return yHashPut((const u8 *)str, len, 0);
-}
-
-yHash yHashTestBuf(const u8* buf, u16 len)
-{
-    if (len > HASH_BUF_SIZE) len = HASH_BUF_SIZE;
-    return yHashPut(buf, len, 1);
-}
-
-yHash yHashTestStr(const char* str)
-{
-    u16 len = (u16)YSTRLEN(str);
-
-    if (len > HASH_BUF_SIZE) len = HASH_BUF_SIZE;
-    HLOGF(("yHashTestStr('%s'):\n",str));
-    return yHashPut((const u8 *)str, len, 1);
-}
-
-void yHashGetBuf(yHash yhash, u8* destbuf, u16 bufsize)
-{
-    __eds__ u8* p;
-
-    HLOGF(("yHashGetBuf(0x%x)\n",yhash));
-    YASSERT(yhash >= 0);
-#ifdef MICROCHIP_API
-    if(yhash >= nextHashEntry || yHashTable[yhash].next == 0) {
-        // should never happen !
-        memset(destbuf, 0, bufsize);
-        return;
-    }
-#else
-    YASSERT(yhash < nextHashEntry);
-    YASSERT(yHashTable[yhash].next != 0); // 0 means unallocated, -1 means end of chain
-#endif
-    if (bufsize > HASH_BUF_SIZE) bufsize = HASH_BUF_SIZE;
-    p = yHashTable[yhash].buff;
-    while (bufsize-- > 0) {
-        *destbuf++ = *p++;
-    }
-}
-
-void yHashGetStr(yHash yhash, char* destbuf, u16 bufsize)
-{
-    HLOGF(("yHashGetStr(0x%x):\n",yhash));
-    yHashGetBuf(yhash, (u8 *)destbuf, bufsize);
-    destbuf[bufsize - 1] = 0;
-}
-
-#ifdef MICROCHIP_API
-// safe since this is a single-thread environment
-static char shared_hashbuf[HASH_BUF_SIZE+1];
-#endif
-
-u16 yHashGetStrLen(yHash yhash)
-{
-#ifdef MICROCHIP_API
-    u16  i;
-#endif
-
-    HLOGF(("yHashGetStrLen(0x%x)\n",yhash));
-    YASSERT(yhash >= 0);
-#ifdef MICROCHIP_API
-    if(yhash >= nextHashEntry || yHashTable[yhash].next == 0) {
-        // should never happen
-        return 0;
-    }
-    for(i = 0; i < HASH_BUF_SIZE; i++) {
-        if(!yHashTable[yhash].buff[i]) break;
-    }
-    return i;
-#else
-    YASSERT(yhash < nextHashEntry);
-    YASSERT(yHashTable[yhash].next != 0); // 0 means unallocated
-    return (u16)YSTRLEN((char *)yHashTable[yhash].buff);
-#endif
-}
-
-char* yHashGetStrPtr(yHash yhash)
-{
-#ifdef MICROCHIP_API
-    u16  i;
-#endif
-
-    HLOGF(("yHashGetStrPtr(0x%x)\n",yhash));
-    YASSERT(yhash >= 0);
-    YASSERT(yhash < nextHashEntry);
-    YASSERT(yHashTable[yhash].next != 0); // 0 means unallocated
-#ifdef MICROCHIP_API
-    for(i = 0; i < HASH_BUF_SIZE; i++) {
-        char c = yHashTable[yhash].buff[i];
-        if(!c) break;
-        shared_hashbuf[i] = c;
-    }
-    shared_hashbuf[i] = 0;
-    return shared_hashbuf;
-#else
-    return (char *)yHashTable[yhash].buff;
-#endif
-}
-
-#ifndef MICROCHIP_API
-
-/**
-* parse the rootUrl string and update the path field of the yAbsUrl structure passed
-in argument
-*/
-static int yComputeRelPath(yAbsUrl* absurl, const char* rootUrl, u8 testonly)
-{
-    int i, len;
-    while (*rootUrl == '/') rootUrl++;
-    for (i = 0; i < YMAX_HUB_URL_DEEP && *rootUrl;) {
-        for (len = 0; rootUrl[len] && rootUrl[len] != '/'; len++);
-        if ((len != 8 || memcmp(rootUrl, "bySerial", 8) != 0) &&
-            (len != 3 || memcmp(rootUrl, "api", 3) != 0)) {
-            absurl->path[i] = yHashPut((const u8 *)rootUrl, len, testonly);
-            if (absurl->path[i] == INVALID_HASH_IDX) return -1;
-            i++;
-        }
-        rootUrl += len;
-        while (*rootUrl == '/') rootUrl++;
-    }
-    if (*rootUrl && testonly) return -1;
-    return 0;
-}
-
-/**
-* create and register a new url with the host form urlref and the path from
-rootUrl.
-return: the yUrlRef for the new created url
-*/
-yUrlRef yHashUrlFromRef(yUrlRef urlref, const char* rootUrl)
-{
-    yAbsUrl huburl;
-
-    // set all path as invalid
-    HLOGF(("yHashUrlFromRef('%s')\n", rootUrl));
-    yHashGetBuf(urlref, (u8 *)&huburl, sizeof(huburl));
-    memset(huburl.path, 0xff, sizeof(huburl.path));
-
-    if (yComputeRelPath(&huburl, rootUrl, 0) < 0) {
-        return INVALID_HASH_IDX;
-    }
-    return yHashPut((const u8 *)&huburl, sizeof(huburl), 0);
-}
-
-
-/**
- * if testonly is non zero it do not add the hash if the hash has not been already recorded
- * in this case we return INVALID_HASH_IDX
- */
-yUrlRef yHashUrl(const char* url, const char* rootUrl, u8 testonly, char* errmsg)
-{
-    yAbsUrl huburl;
-    int len, hostlen, domlen, iptest = 0;
-    const char *end, *p;
-    const char *pos, *posplus;
-    const char* host = NULL;
-    char buffer[8];
-
-    // set all hash as invalid
-    HLOGF(("yHashUrl('%s','%s')\n",url,rootUrl));
-    memset(&huburl, 0xff, sizeof(huburl));
-    huburl.proto = PROTO_AUTO;
-    if (*url) {
-        if (YSTRNCMP(url, "http://", 7) == 0) {
-            url += 7;
-            huburl.proto = PROTO_HTTP;
-        } else if (YSTRNCMP(url, "ws://", 5) == 0) {
-            url += 5;
-            huburl.proto = PROTO_WEBSOCKET;
-        }
-        // search for any authentication info
-        for (p = url; *p && *p != '@' && *p != '/'; p++);
-        if (*p == '@') {
-            for (p = url; *p != ':' && *p != '@'; p++);
-            if (*p != ':') {
-                if (errmsg) YSTRCPY(errmsg, YOCTO_ERRMSG_LEN, "missing authentication parameter");
-                return INVALID_HASH_IDX;
-            }
-            len = (int)(p - url);
-            if (len > HASH_BUF_SIZE) {
-                if (errmsg) YSTRCPY(errmsg, YOCTO_ERRMSG_LEN, "username too long");
-                return INVALID_HASH_IDX;
-            }
-            huburl.user = yHashPutBuf((const u8*)url, len);
-            HLOGF(("user=%s\n", yHashGetStrPtr(huburl.user)));
-            url = ++p;
-            while (*p != '@') p++;
-            len = (int)(p - url);
-            if (len > HASH_BUF_SIZE) {
-                if (errmsg) YSTRCPY(errmsg, YOCTO_ERRMSG_LEN, "password too long");
-                return INVALID_HASH_IDX;
-            }
-            huburl.password = yHashPutBuf((const u8*)url, len);
-            HLOGF(("passwd=%s\n", yHashGetStrPtr(huburl.password)));
-            url = ++p;
-        }
-        end = strchr(url, '/');
-        if (end) {
-            p = posplus = end + 1;
-            while (*p && *p != '/') p++;
-            len = (int)(p - posplus);
-            if (len > 0) {
-                if (len > HASH_BUF_SIZE) {
-                    if (errmsg) YSTRCPY(errmsg, YOCTO_ERRMSG_LEN, "subdomain too long");
-                    return INVALID_HASH_IDX;
-                }
-                huburl.subdomain = yHashPutBuf((const u8*)posplus, len);
-                HLOGF(("subdomain=%s\n", yHashGetStrPtr(huburl.subdomain)));
-            }
-        } else {
-            end = url + strlen(url);
-        }
-        pos = strchr(url, ':');
-        posplus = pos + 1;
-        if (pos && pos < end) {
-            len = (int)(end - posplus);
-            if (len > 7) {
-                if (errmsg) YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,"invalid port");
-                return INVALID_HASH_IDX;
-            }
-            memcpy(buffer, posplus, len);
-            buffer[len] = '\0';
-            huburl.byip.port = atoi(buffer);
-            end = pos;
-        } else {
-            huburl.byip.port = YOCTO_DEFAULT_PORT;
-        }
-        HLOGF(("port=%d\n", huburl.byip.port));
-
-        pos = strchr(url, '.');
-        posplus = pos + 1;
-        if (pos && pos < end) {
-            hostlen = (int)(pos - url);
-            if (hostlen > HASH_BUF_SIZE) {
-                if (errmsg) YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,"hostname too long");
-                return INVALID_HASH_IDX;
-            }
-            host = url;
-            url = posplus;
-        } else {
-            hostlen = 0;
-        }
-        if (hostlen && hostlen <= 3) {
-            memcpy(buffer, host, hostlen);
-            buffer[hostlen] = 0;
-            iptest = atoi(buffer);
-        }
-        if (iptest && iptest < 256 && (end - host) < 16) {
-            // this is probably an ip
-            huburl.byip.ip = yHashPutBuf((const u8*)host, (u16)(end - host));
-            HLOGF(("ip=%s\n", yHashGetStrPtr(huburl.byip.ip)));
-        } else {
-            domlen = (int)(end - url);
-            if (domlen > HASH_BUF_SIZE) {
-                if (errmsg) YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,"domain name too long");
-                return INVALID_HASH_IDX;
-            }
-            if (hostlen) {
-                huburl.byname.host = yHashPutBuf((const u8*)host, hostlen);
-                HLOGF(("host=%s\n", yHashGetStrPtr(huburl.byip.ip)));
-            } else {
-                huburl.byname.host = INVALID_HASH_IDX;
-            }
-            huburl.byname.domaine = yHashPutBuf((const u8*)url, domlen);
-            HLOGF(("domain(host)=%s\n", yHashGetStrPtr(huburl.byip.ip)));
-        }
-    }
-    if (yComputeRelPath(&huburl, rootUrl, testonly) < 0) {
-        return INVALID_HASH_IDX;
-    }
-    return yHashPut((const u8 *)&huburl, sizeof(huburl), testonly);
-}
-
-// return port , get hash of the url an a pointer to a buffer of YOCTO_HOSTNAME_NAME len
-yAsbUrlType yHashGetUrlPort(yUrlRef urlref, char* url, u16* port, yAsbUrlProto* proto, yStrRef* user, yStrRef* password, yStrRef* subdomain)
-{
-    yAbsUrl absurl;
-
-    // set all path as invalid
-    yHashGetBuf(urlref, (u8 *)&absurl, sizeof(absurl));
-    if (proto) *proto = absurl.proto;
-    if (user) *user = absurl.user;
-    if (password) *password = absurl.password;
-    if (subdomain) *subdomain = absurl.subdomain;
-
-    if (absurl.byusb.invalid1 == INVALID_HASH_IDX && absurl.byusb.invalid2 == INVALID_HASH_IDX) {
-        // we have an USB address
-        if (url) {
-            *url = '\0';
-        }
-        if (port) *port = 0;
-        return USB_URL;
-    } else if (absurl.byip.invalid == INVALID_HASH_IDX) {
-        // we have an ip address
-        if (url) {
-            yHashGetStr(absurl.byip.ip, url, 16);
-        }
-        if (port) *port = absurl.byip.port;
-        return IP_URL;
-    } else {
-        char* p = url;
-        if (url) {
-            // we have an hostname
-            if (absurl.byname.host != INVALID_HASH_IDX) {
-                yHashGetStr(absurl.byname.host, p,YOCTO_HOSTNAME_NAME);
-                p = url + YSTRLEN(url);
-                *p++ = '.';
-            }
-            yHashGetStr(absurl.byname.domaine, p, (u16)(YOCTO_HOSTNAME_NAME - (p - url)));
-        }
-        if (port) *port = absurl.byname.port;
-        return NAME_URL;
-    }
-}
-
-int yHashSameHub(yUrlRef url_a, yUrlRef url_b)
-{
-    yAbsUrl absurl_a;
-    yAbsUrl absurl_b;
-
-    // set all path as invalid
-    yHashGetBuf(url_a, (u8 *)&absurl_a, sizeof(absurl_a));
-    yHashGetBuf(url_b, (u8 *)&absurl_b, sizeof(absurl_b));
-    if (absurl_a.byname.domaine == absurl_b.byname.domaine &&
-        absurl_a.byname.host == absurl_b.byname.host &&
-        absurl_a.byname.port == absurl_b.byname.port)
-        return 1;
-    return 0;
-}
-
-#endif
-
-// Return a hash-encoded URL for a local USB/YSB device
-yUrlRef yHashUrlUSB(yHash serial)
-{
-    yAbsUrl huburl;
-    // set all hash as invalid
-    memset(&huburl, 0xff, sizeof(huburl));
-    huburl.proto = PROTO_AUTO;
-    // for USB we store only the serial number since
-    // we access all devices directly
-    huburl.byusb.serial = serial;
-    return yHashPut((const u8 *)&huburl, sizeof(huburl), 0);
-}
-
-// Return a hash-encoded URL for our local /api
-yUrlRef yHashUrlAPI(void)
-{
-    yAbsUrl huburl;
-    // set all hash as invalid
-    memset(&huburl, 0xff, sizeof(huburl));
-    huburl.proto = PROTO_AUTO;
-    return yHashPut((const u8 *)&huburl, sizeof(huburl), 0);
-}
-
-// =======================================================================
-//   White pages support
-// =======================================================================
-
-static void ypUnregister(yStrRef serial); //forward declaration
-
-static int wpLockCount = 0;
-static int wpSomethingUnregistered = 0;
-
-static void wpExecuteUnregisterUnsec(void)
-{
-    yBlkHdl prev = INVALID_BLK_HDL, next;
-    yBlkHdl hdl, funHdl, nextHdl;
-    // Note: do not use u16 below, because of GCC optimization bug
-    //       which does not properly handle u16->u64 extension on OSX
-    unsigned devYdx;
-
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        next = WP(hdl).nextPtr;
-        if (WP(hdl).flags & YWP_MARK_FOR_UNREGISTER) {
-#ifdef  DEBUG_WP
-            {
-                char host[YOCTO_HOSTNAME_NAME];
-                u16  port;
-                yAsbUrlType type = yHashGetUrlPort( WP(hdl).url,host,&port,NULL,NULL,NULL,NULL);
-                switch(type){
-                case USB_URL:
-                    dbglog("WP: unregister %s(0x%X) form USB\n",yHashGetStrPtr(WP(hdl).serial),WP(hdl).serial);
-                    break;
-                default:
-                    dbglog("WP: unregister %s(0x%X) from %s:%u\n",yHashGetStrPtr(WP(hdl).serial),WP(hdl).serial,host,port);
-                }
-            }
-#endif
-
-
-            // first remove YP entry
-            ypUnregister(WP(hdl).serial);
-            // entry mark as to remove
-            if (prev == INVALID_BLK_HDL) {
-                yWpListHead = next;
-            } else {
-                WP(prev).nextPtr = next;
-            }
-            devYdx = WP(hdl).devYdx;
-            funHdl = funYdxPtr[devYdx];
-            while (funHdl != INVALID_BLK_HDL) {
-                YASSERT(YA(funHdl).blkId == YBLKID_YPARRAY);
-                nextHdl = YA(funHdl).nextPtr;
-                yBlkFree(funHdl);
-                funHdl = nextHdl;
-            }
-            funYdxPtr[devYdx] = INVALID_BLK_HDL;
-            devYdxPtr[devYdx] = INVALID_BLK_HDL;
-#ifndef MICROCHIP_API
-            if ((unsigned)nextDevYdx > devYdx) {
-                nextDevYdx = devYdx;
-            }
-            usedDevYdx[devYdx >> 4] &= ~ (u16)(1 << (devYdx & 15));
-            //dbglog("wpUnregister serial=%X devYdx=%d (next=%d)\n", WP(hdl).serial, devYdx, nextDevYdx);
-            freeDevYdxInfos(devYdx);
-#endif
-            yBlkFree(hdl);
-        } else {
-            prev = hdl;
-        }
-        hdl = next;
-    }
-}
-
-#ifndef DEBUG_WP_LOCK
-
-void wpPreventUnregisterEx(void)
-{
-    yEnterCriticalSection(&yWpMutex);
-    YASSERT(wpLockCount < 128);
-    wpLockCount++;
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-void wpAllowUnregisterEx(void)
-{
-    yEnterCriticalSection(&yWpMutex);
-    YASSERT(wpLockCount > 0);
-    wpLockCount--;
-    if (wpSomethingUnregistered && !wpLockCount) {
-        wpExecuteUnregisterUnsec();
-        wpSomethingUnregistered = 0;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-#else
-
-void wpPreventUnregisterDbg(const char *file, u32 line)
-{
-    yEnterCriticalSection(&yWpMutex);
-    dbglog("wpPreventUnregisterDbg: %s:%d\n",file,line);
-    YASSERT(wpLockCount < 128);
-    wpLockCount++;
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-void wpAllowUnregisterDbg(const char *file, u32 line)
-{
-    yEnterCriticalSection(&yWpMutex);
-    dbglog("wpAllowUnregisterDbg: %s:%d\n",file,line);
-    YASSERT(wpLockCount > 0);
-    wpLockCount--;
-    if(wpSomethingUnregistered && !wpLockCount) {
-        wpExecuteUnregisterUnsec();
-    }
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-#endif
-
-// return :
-//      0 -> no change
-//      1 -> update logical name
-//      2 -> update beacon
-//      3 -> update beacon and logical name
-
-int wpRegister(int devYdx, yStrRef serial, yStrRef logicalName, yStrRef productName, u16 productId, yUrlRef devUrl, s8 beacon)
-{
-    yBlkHdl prev = INVALID_BLK_HDL;
-    yBlkHdl hdl;
-    int changed = 0;
-
-    yEnterCriticalSection(&yWpMutex);
-
-    YASSERT(devUrl != INVALID_HASH_IDX);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == serial) break;
-        prev = hdl;
-        hdl = WP(prev).nextPtr;
-    }
-    if (hdl == INVALID_BLK_HDL) {
-        hdl = yBlkAlloc();
-        changed = 3;
-#ifndef MICROCHIP_API
-        if (devYdx == -1) devYdx = nextDevYdx;
-        YASSERT(!(usedDevYdx[devYdx>>4] & (1 << (devYdx&15))));
-        usedDevYdx[devYdx >> 4] |= 1 << (devYdx & 15);
-        if (nextDevYdx == devYdx) {
-            nextDevYdx++;
-            while (usedDevYdx[nextDevYdx >> 4] & (1 << (nextDevYdx & 15))) {
-                if (nextDevYdx >= NB_MAX_DEVICES) break;
-                nextDevYdx++;
-            }
-        }
-        //dbglog("wpRegister serial=%X devYdx=%d\n", serial, devYdx);
-        initDevYdxInfos(devYdx, serial);
-#endif
-        YASSERT(devYdx < NB_MAX_DEVICES);
-        devYdxPtr[devYdx] = hdl;
-        WP(hdl).devYdx = (u8)devYdx;
-        WP(hdl).blkId = YBLKID_WPENTRY;
-        WP(hdl).serial = serial;
-        WP(hdl).name = YSTRREF_EMPTY_STRING;
-        WP(hdl).product = YSTRREF_EMPTY_STRING;
-        WP(hdl).url = devUrl;
-        WP(hdl).devid = 0;
-        WP(hdl).flags = 0;
-        if (prev == INVALID_BLK_HDL) {
-            yWpListHead = hdl;
-        } else {
-            WP(prev).nextPtr = hdl;
-        }
-#ifdef MICROCHIP_API
-    } else if(devYdx != -1 && WP(hdl).devYdx != devYdx) {
-        // allow change of devYdx based on hub role
-        u16 oldDevYdx = WP(hdl).devYdx;
-        if(oldDevYdx < NB_MAX_DEVICES) {
-            funYdxPtr[devYdx] = funYdxPtr[oldDevYdx];
-            funYdxPtr[oldDevYdx] = INVALID_BLK_HDL;
-            devYdxPtr[devYdx] = hdl;
-        }
-        devYdxPtr[oldDevYdx] = INVALID_BLK_HDL;
-        WP(hdl).devYdx  = (u8)devYdx;
-#endif
-    }
-    if (logicalName != INVALID_HASH_IDX) {
-        if (WP(hdl).name != logicalName) {
-            changed |= 1;
-            WP(hdl).name = logicalName;
-        }
-    }
-    if (productName != INVALID_HASH_IDX) WP(hdl).product = productName;
-    if (productId != 0) WP(hdl).devid = productId;
-    WP(hdl).url = devUrl;
-    if (beacon >= 0) {
-        u16 newval = (beacon > 0 ? YWP_BEACON_ON : 0);
-        if ((WP(hdl).flags & YWP_BEACON_ON) != newval) {
-            changed |= 2;
-        }
-        WP(hdl).flags = newval;
-    } else {
-        WP(hdl).flags &= ~YWP_MARK_FOR_UNREGISTER;
-    }
-
-#ifdef DEBUG_WP
-    {
-        char host[YOCTO_HOSTNAME_NAME];
-        u16  port;
-        yAsbUrlType type = yHashGetUrlPort(devUrl,host,&port, NULL, NULL, NULL, NULL);
-        switch(type){
-        case USB_URL:
-            dbglog("WP: register %s(0x%X) form USB (res=%d)\n",yHashGetStrPtr(serial),serial,changed);
-            break;
-        default:
-            dbglog("WP: register %s(0x%X) from %s:%u (res=%d)\n",yHashGetStrPtr(serial),serial,host,port,changed);
-        }
-    }
-#endif
-
-    yLeaveCriticalSection(&yWpMutex);
-    return changed;
-}
-
-
-yStrRef wpGetAttribute(yBlkHdl hdl, yWPAttribute attridx)
-{
-    yStrRef res = YSTRREF_EMPTY_STRING;
-
-    yEnterCriticalSection(&yWpMutex);
-    if (WP(hdl).blkId == YBLKID_WPENTRY) {
-        switch (attridx) {
-        case Y_WP_SERIALNUMBER: res = WP(hdl).serial;
-            break;
-        case Y_WP_LOGICALNAME: res = WP(hdl).name;
-            break;
-        case Y_WP_PRODUCTNAME: res = WP(hdl).product;
-            break;
-        case Y_WP_PRODUCTID: res = WP(hdl).devid;
-            break;
-        case Y_WP_NETWORKURL: res = WP(hdl).url;
-            break;
-        case Y_WP_BEACON: res = (WP(hdl).flags & YWP_BEACON_ON ? 1 : 0);
-            break;
-        case Y_WP_INDEX: res = WP(hdl).devYdx;
-            break;
-        }
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return res;
-}
-
-void wpGetSerial(yBlkHdl hdl, char* serial)
-{
-    yEnterCriticalSection(&yWpMutex);
-    if (WP(hdl).blkId == YBLKID_WPENTRY) {
-        yHashGetStr(WP(hdl).serial, serial, YOCTO_SERIAL_LEN);
-    }
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-void wpGetLogicalName(yBlkHdl hdl, char* logicalName)
-{
-    yEnterCriticalSection(&yWpMutex);
-    if (WP(hdl).blkId == YBLKID_WPENTRY) {
-        yHashGetStr(WP(hdl).name, logicalName, YOCTO_LOGICAL_LEN);
-    }
-    yLeaveCriticalSection(&yWpMutex);
-}
-
-int wpMarkForUnregister(yStrRef serial)
-{
-    yBlkHdl next;
-    yBlkHdl hdl;
-    int retval = 0;
-    yEnterCriticalSection(&yWpMutex);
-
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        next = WP(hdl).nextPtr;
-        if (WP(hdl).serial == serial) {
-            if ((WP(hdl).flags & YWP_MARK_FOR_UNREGISTER) == 0) {
-                WP(hdl).flags |= YWP_MARK_FOR_UNREGISTER;
-                wpSomethingUnregistered = 1;
-                retval = 1;
-            }
-            break;
-        }
-        hdl = next;
-    }
-
-#ifdef  DEBUG_WP
-    {
-        char host[YOCTO_HOSTNAME_NAME];
-        u16  port;
-            if (retval) {
-                yAsbUrlType type = yHashGetUrlPort( WP(hdl).url,host,&port, NULL, NULL, NULL, NULL);
-            switch(type){
-            case USB_URL:
-                dbglog("WP: mark for unregister %s(0x%X) form USB\n",yHashGetStrPtr(serial),serial);
-                break;
-            default:
-                dbglog("WP: mark for unregister %s(0x%X) from %s:%u\n",yHashGetStrPtr(serial),serial,host,port);
-            }
-        }else{
-            dbglog("WP: mark for unregister %s(0x%X) witch is unregistered!\n",yHashGetStrPtr(serial),serial);
-        }
-    }
-#endif
-
-    yLeaveCriticalSection(&yWpMutex);
-    return retval;
-}
-
-u16 wpEntryCount(void)
-{
-    return yBlkListLength(yWpListHead);
-}
-
-int wpGetDevYdx(yStrRef serial)
-{
-    yBlkHdl hdl;
-    int res = -1;
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == serial) {
-            res = WP(hdl).devYdx;
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return res;
-}
-
-YAPI_DEVICE wpSearchEx(yStrRef strref)
-{
-    yBlkHdl hdl, byname;
-    YAPI_DEVICE res = -1;
-
-    byname = INVALID_BLK_HDL;
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == strref) {
-            res = strref;
-            break;
-        }
-        if (WP(hdl).name == strref) byname = hdl;
-        hdl = WP(hdl).nextPtr;
-    }
-    if (hdl == INVALID_BLK_HDL && byname != INVALID_BLK_HDL) {
-        res = WP(byname).serial;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return res;
-}
-
-YAPI_DEVICE wpSearch(const char* device_str)
-{
-    yStrRef strref = yHashTestStr(device_str);
-    if (strref == INVALID_HASH_IDX)
-        return -1;
-    return wpSearchEx(strref);
-}
-
-
-YAPI_DEVICE wpSearchByNameHash(yStrRef strref)
-{
-    yBlkHdl hdl;
-    YAPI_DEVICE res = -1;
-
-    if (strref == INVALID_HASH_IDX)
-        return -1;
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).name == strref) {
-            res = WP(hdl).serial;
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return res;
-}
-
-#ifndef MICROCHIP_API
-
-YAPI_DEVICE wpSearchByUrl(const char* host, const char* rootUrl)
-{
-    yStrRef apiref;
-    yBlkHdl hdl;
-    YAPI_DEVICE res = -1;
-
-    apiref = yHashUrl(host, rootUrl, 1,NULL);
-    if (apiref == INVALID_HASH_IDX) return -1;
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).url == apiref) {
-            res = WP(hdl).serial;
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return res;
-}
-
-int wpGetAllDevUsingHubUrl(yUrlRef hubUrl, yStrRef* buffer, int sizeInStrRef)
-{
-    yBlkHdl hdl;
-    int count = 0;
-    yAbsUrl hubAbsUrl;
-    yHashGetBuf(hubUrl, (u8 *)&hubAbsUrl, sizeof(hubAbsUrl));
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        yAbsUrl absurl;
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        yHashGetBuf(WP(hdl).url, (u8 *)&absurl, sizeof(absurl));
-        if (absurl.byname.domaine == hubAbsUrl.byname.domaine &&
-            absurl.byname.host == hubAbsUrl.byname.host &&
-            absurl.byname.port == hubAbsUrl.byname.port) {
-            if (sizeInStrRef) {
-                *buffer++ = WP(hdl).serial;
-                sizeInStrRef--;
-            }
-            count++;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-
-    return count;
-}
-
-
-yUrlRef wpGetDeviceUrlRef(YAPI_DEVICE devdesc)
-{
-    yBlkHdl hdl;
-    yUrlRef urlref = INVALID_HASH_IDX;
-
-    yEnterCriticalSection(&yWpMutex);
-
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == (u16)devdesc) {
-            urlref = WP(hdl).url;
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-
-    yLeaveCriticalSection(&yWpMutex);
-
-    return urlref;
-}
-
-int wpGetDeviceUrl(YAPI_DEVICE devdesc, char* roothubserial, char* request, int requestsize, int* neededsize)
-{
-    yBlkHdl hdl;
-    yUrlRef hubref = INVALID_HASH_IDX;
-    yStrRef strref = INVALID_HASH_IDX;
-    yAbsUrl absurl, huburl;
-    char serial[YOCTO_SERIAL_LEN];
-    int fullsize, len, idx;
-
-    yEnterCriticalSection(&yWpMutex);
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == (u16)devdesc) {
-            hubref = WP(hdl).url;
-            // store device serial;
-            strref = WP(hdl).serial;
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yWpMutex);
-    if (hubref == INVALID_HASH_IDX)
-        return -1;
-
-    yHashGetBuf(hubref, (u8 *)&absurl, sizeof(absurl));
-    if (absurl.byusb.invalid1 == INVALID_HASH_IDX && absurl.byusb.invalid2 == INVALID_HASH_IDX) {
-        // local device
-        strref = absurl.byusb.serial;
-        if (strref == 0) strref = devdesc & 0xffff; // ourself
-    } else if (absurl.path[0] != INVALID_HASH_IDX) {
-        // sub device, need to find serial of its root hub
-        memcpy(&huburl, &absurl, sizeof(absurl));
-
-        for (idx = 0; idx < YMAX_HUB_URL_DEEP && huburl.path[idx] != INVALID_HASH_IDX; idx++)
-            huburl.path[idx] = INVALID_HASH_IDX;
-        // search white pages by url
-        hubref = yHashTestBuf((u8 *)&huburl, sizeof(huburl));
-        strref = INVALID_HASH_IDX;
-        yEnterCriticalSection(&yWpMutex);
-        hdl = yWpListHead;
-        while (hdl != INVALID_BLK_HDL) {
-            YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-            if (WP(hdl).url == hubref) {
-                strref = WP(hdl).serial;
-                break;
-            }
-            hdl = WP(hdl).nextPtr;
-        }
-        yLeaveCriticalSection(&yWpMutex);
-        if (strref == INVALID_HASH_IDX) return -1;
-    }
-
-    // extract root device serial
-    if (roothubserial) {
-        yHashGetStr(strref, roothubserial, YOCTO_SERIAL_LEN);
-    }
-    if (!request) requestsize = 0;
-
-    if (absurl.path[0] != INVALID_HASH_IDX) {
-        if (requestsize > 10) {
-            memcpy(request, "/bySerial/", 10);
-            request += 10;
-            requestsize -= 10;
-        }
-        fullsize = 11; // null-terminated slash
-    } else {
-        if (requestsize > 1) {
-            *request++ = '/';
-            requestsize--;
-        }
-        fullsize = 2; // null-terminated slash
-    }
-    // build relative url
-    idx = 0;
-    while ((strref = absurl.path[idx]) != INVALID_HASH_IDX) {
-        yHashGetStr(strref, serial, YOCTO_SERIAL_LEN);
-        len = (int)strlen(serial) + 1;
-        fullsize += len;
-        if (requestsize > 0 && requestsize > len) {
-            memcpy(request, serial, len - 1);
-            request[len - 1] = '/';
-            request += len;
-            requestsize -= len;
-        }
-        idx++;
-    }
-    if (neededsize != NULL) *neededsize = fullsize;
-    // null-terminate request
-    if (requestsize > 0) *request = 0;
-
-    return 0;
-}
-
-#endif
-
-int wpGetDeviceInfo(YAPI_DEVICE devdesc, u16* deviceid, char* productname, char* serial, char* logicalname, u8* beacon)
-{
-    yBlkHdl hdl;
-
-    yEnterCriticalSection(&yWpMutex);
-
-    hdl = yWpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-        if (WP(hdl).serial == (u16)devdesc) {
-            // entry found
-            if (deviceid) *deviceid = WP(hdl).devid;
-            if (productname) yHashGetStr(WP(hdl).product, productname, YOCTO_PRODUCTNAME_LEN);
-            if (serial) yHashGetStr(WP(hdl).serial, serial, YOCTO_SERIAL_LEN);
-            if (logicalname) yHashGetStr(WP(hdl).name, logicalname, YOCTO_LOGICAL_LEN);
-            if (beacon) *beacon = (WP(hdl).flags & YWP_BEACON_ON ? 1 : 0);
-            break;
-        }
-        hdl = WP(hdl).nextPtr;
-    }
-
-    yLeaveCriticalSection(&yWpMutex);
-
-    return (hdl != INVALID_BLK_HDL ? 0 : -1);
-}
-
-
-// =======================================================================
-//   Yellow pages support
-// =======================================================================
-
-// return 1 on change 0 if value are the same as the cache
-int ypRegister(yStrRef categ, yStrRef serial, yStrRef funcId, yStrRef funcName, int funClass, int funYdx, const char* funcVal)
-{
-    yBlkHdl prev = INVALID_BLK_HDL;
-    yBlkHdl hdl;
-    yBlkHdl cat_hdl;
-    yBlkHdl yahdl;
-    u16 i, cnt;
-    int devYdx, changed = 0;
-    const u16* funcValWords = (const u16 *)funcVal;
-
-    yEnterCriticalSection(&yYpMutex);
-
-    // locate category node
-    hdl = yYpListHead;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(YC(hdl).blkId == YBLKID_YPCATEG);
-        if (YC(hdl).name == categ) break;
-        prev = hdl;
-        hdl = YC(prev).nextPtr;
-    }
-    if (hdl == INVALID_BLK_HDL) {
-        hdl = yBlkAlloc();
-        YC(hdl).catYdx = nextCatYdx++;
-        YC(hdl).blkId = YBLKID_YPCATEG;
-        YC(hdl).name = categ;
-        YC(hdl).entries = INVALID_BLK_HDL;
-        if (prev == INVALID_BLK_HDL) {
-            yYpListHead = hdl;
-        } else {
-            YC(prev).nextPtr = hdl;
-        }
-    }
-    cat_hdl = hdl;
-
-    // locate entry node
-    prev = INVALID_BLK_HDL;
-    hdl = YC(cat_hdl).entries;
-    while (hdl != INVALID_BLK_HDL) {
-        YASSERT(YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND);
-        if (YP(hdl).serialNum == serial && YP(hdl).funcId == funcId) break;
-        prev = hdl;
-        hdl = YP(prev).nextPtr;
-    }
-    if (hdl == INVALID_BLK_HDL) {
-        changed = 1; // new entry-> changed
-        hdl = yBlkAlloc();
-        if (funClass < 0 || funClass >= YOCTO_N_BASECLASSES) {
-            funClass = 0;
-        }
-        YP(hdl).blkId = YBLKID_YPENTRY + funClass;
-        YP(hdl).serialNum = serial;
-        YP(hdl).funcId = funcId;
-        YP(hdl).funcName = YSTRREF_EMPTY_STRING;
-        YP(hdl).funInfo.raw = 15;
-        for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-            YP(hdl).funcValWords[i] = 0;
-        }
-        if (prev == INVALID_BLK_HDL) {
-            YC(cat_hdl).entries = hdl;
-        } else {
-            YP(prev).nextPtr = hdl;
-        }
-    }
-    if (funcName != INVALID_HASH_IDX) {
-        if (YP(hdl).funcName != funcName) {
-            changed = 1;
-            YP(hdl).funcName = funcName;
-        }
-    }
-    if (categ != YSTRREF_MODULE_STRING) {
-        if (funYdx >= 0 && funYdx < 15) {
-            YP(hdl).funInfo.v2.funydx = funYdx;
-        } else {
-            funYdx = YP(hdl).funInfo.v2.funydx;
-        }
-        devYdx = wpGetDevYdx(serial);
-        if (devYdx >= 0) {
-            cnt = funYdx;
-            if (cnt == 255) {
-                // unknown funYdx, prepare to allocate new one
-                funYdx = 0;
-            }
-            prev = INVALID_BLK_HDL;
-            yahdl = funYdxPtr[devYdx];
-            while (yahdl != INVALID_BLK_HDL) {
-                YASSERT(YA(yahdl).blkId == YBLKID_YPARRAY);
-                if (cnt < 6) break;
-                if (cnt < 255) {
-                    // known funYdx
-                    cnt -= 6;
-                } else {
-                    // unknown funYdx
-                    funYdx += 6;
-                }
-                prev = yahdl;
-                yahdl = YA(prev).nextPtr;
-            }
-            if (cnt == 255) {
-                // unknown funYdx, allocate a free bucket
-                cnt = 0;
-                if (prev != INVALID_BLK_HDL) {
-                    for (i = 0; i < 6; i++) {
-                        if (YA(prev).entries[i] == INVALID_BLK_HDL) {
-                            yahdl = prev;
-                            cnt = i;
-                            funYdx = funYdx - 6 + i;
-                            break;
-                        }
-                    }
-                }
-                if (funYdx < 15) {
-                    YP(hdl).funInfo.v2.funydx = funYdx;
-                }
-            }
-            while (yahdl == INVALID_BLK_HDL) {
-                yahdl = yBlkAlloc();
-                YA(yahdl).blkId = YBLKID_YPARRAY;
-                for (i = 0; i < 6; i++) YA(yahdl).entries[i] = INVALID_BLK_HDL;
-                if (prev == INVALID_BLK_HDL) {
-                    funYdxPtr[devYdx] = yahdl;
-                } else {
-                    YA(prev).nextPtr = yahdl;
-                }
-                if (cnt < 6) break;
-                cnt -= 6;
-                prev = yahdl;
-                yahdl = YA(prev).nextPtr;
-            }
-            YA(yahdl).entries[cnt] = hdl;
-        }
-        if (funcVal != NULL) {
-            for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-                if (YP(hdl).funcValWords[i] != funcValWords[i]) {
-                    changed = 1;
-                    YP(hdl).funcValWords[i] = funcValWords[i];
-                }
-            }
-        }
-    }
-    yLeaveCriticalSection(&yYpMutex);
-    return changed;
-}
-
-// return 1 on change 0 if value are the same as the cache
-// WARNING: funcVal MUST BE WORD-ALIGNED
-int ypRegisterByYdx(u8 devYdx, Notification_funydx funInfo, const char* funcVal, YAPI_FUNCTION* fundesc)
-{
-    yBlkHdl hdl;
-    u16 i;
-    int funYdx = funInfo.v2.funydx;
-    int changed = 0;
-    const u16* funcValWords = (const u16 *)funcVal;
-
-    yEnterCriticalSection(&yYpMutex);
-
-    // Ignore unknown devYdx
-    if (devYdxPtr[devYdx] != INVALID_BLK_HDL) {
-        hdl = funYdxPtr[devYdx];
-        while (hdl != INVALID_BLK_HDL && funYdx >= 6) {
-            //          YASSERT(YA(hdl).blkId == YBLKID_YPARRAY);
-            if (YA(hdl).blkId != YBLKID_YPARRAY) {
-                yLeaveCriticalSection(&yYpMutex);
-                return 0; // discard invalid block silently
-            }
-            hdl = YA(hdl).nextPtr;
-            funYdx -= 6;
-        }
-        // Ignore unknown funYdx
-        if (hdl != INVALID_BLK_HDL) {
-            YASSERT(YA(hdl).blkId == YBLKID_YPARRAY);
-            hdl = YA(hdl).entries[funYdx];
-            if (hdl != INVALID_BLK_HDL) {
-                YASSERT(YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND);
-                if (funcVal) {
-                    // apply value change
-                    for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-                        if (YP(hdl).funcValWords[i] != funcValWords[i]) {
-                            YP(hdl).funcValWords[i] = funcValWords[i];
-                            changed = 1;
-                        }
-                    }
-                    if (YP(hdl).funInfo.raw != funInfo.raw) {
-                        YP(hdl).funInfo.raw = funInfo.raw;
-                        changed = 1;
-                    }
-                }
-                if (fundesc) {
-                    *fundesc = YP(hdl).hwId;
-                }
-            }
-        }
-    }
-
-    yLeaveCriticalSection(&yYpMutex);
-
-    return changed;
-}
-
-// return -1 on error
-// WARNING: funcVal MUST BE WORD-ALIGNED
-int ypGetAttributesByYdx(u8 devYdx, u8 funYdx, yStrRef* serial, yStrRef* logicalName, yStrRef* funcId, yStrRef* funcName, Notification_funydx* funcInfo, char* funcVal)
-{
-    yBlkHdl hdl;
-    u16 i;
-    int res = -1;
-    u16* funcValWords = (u16 *)funcVal;
-
-    yEnterCriticalSection(&yYpMutex);
-
-    // Ignore unknown devYdx
-    if (devYdxPtr[devYdx] != INVALID_BLK_HDL) {
-        if (logicalName) {
-            hdl = devYdxPtr[devYdx];
-            *logicalName = WP(hdl).name;
-        }
-        hdl = funYdxPtr[devYdx];
-        while (hdl != INVALID_BLK_HDL && funYdx >= 6) {
-            if (YA(hdl).blkId != YBLKID_YPARRAY) {
-                yLeaveCriticalSection(&yYpMutex);
-                return -1; // discard invalid block silently
-            }
-            hdl = YA(hdl).nextPtr;
-            funYdx -= 6;
-        }
-        // Ignore unknown funYdx
-        if (hdl != INVALID_BLK_HDL) {
-            YASSERT(YA(hdl).blkId == YBLKID_YPARRAY);
-            hdl = YA(hdl).entries[funYdx];
-            if (hdl != INVALID_BLK_HDL) {
-                YASSERT(YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND);
-                if (serial) {
-                    *serial = YP(hdl).serialNum;
-                }
-                if (funcId) {
-                    *funcId = YP(hdl).funcId;
-                }
-                if (funcName) {
-                    *funcName = YP(hdl).funcName;
-                }
-                if (funcInfo) {
-                    funcInfo->raw = YP(hdl).funInfo.raw;
-                }
-                if (funcVal) {
-                    // apply value change
-                    for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-                        funcValWords[i] = YP(hdl).funcValWords[i];
-                    }
-                }
-                res = 0;
-            }
-        }
-    }
-    yLeaveCriticalSection(&yYpMutex);
-    return res;
-}
-
-
-void ypGetCategory(yBlkHdl hdl, char* name, yBlkHdl* entries)
-{
-    // category records are never freed
-    if (name) yHashGetStr(YC(hdl).name, name, YOCTO_FUNCTION_LEN);
-    if (entries) *entries = YC(hdl).entries;
-}
-
-int ypGetAttributes(yBlkHdl hdl, yStrRef* serial, yStrRef* funcId, yStrRef* funcName, Notification_funydx* funcInfo, char* funcVal)
-{
-    yStrRef serialref = YSTRREF_EMPTY_STRING;
-    yStrRef funcidref = YSTRREF_EMPTY_STRING;
-    yStrRef funcnameref = YSTRREF_EMPTY_STRING;
-    u16 i;
-    int res = -1;
-    u16* funcValWords = (u16 *)funcVal;
-
-    yEnterCriticalSection(&yYpMutex);
-    if (YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND) {
-        serialref = YP(hdl).serialNum;
-        funcidref = YP(hdl).funcId;
-        funcnameref = YP(hdl).funcName;
-        if (funcVal != NULL) {
-            // intentionally not null terminated !
-            for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-                funcValWords[i] = YP(hdl).funcValWords[i];
-            }
-        }
-        if (funcInfo)
-            *funcInfo = YP(hdl).funInfo;
-        res = YP(hdl).funInfo.v2.funydx;
-    } else {
-        if (funcInfo)
-            funcInfo->raw = 0;
-        if (funcVal) *funcVal = 0;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    if (serial != NULL) *serial = serialref;
-    if (funcId != NULL) *funcId = funcidref;
-    if (funcName != NULL) *funcName = funcnameref;
-
-    return res;
-}
-
-int ypGetType(yBlkHdl hdl)
-{
-    int res = -1;
-
-    yEnterCriticalSection(&yYpMutex);
-    if (YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND) {
-        res = YP(hdl).blkId - YBLKID_YPENTRY;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    return res;
-}
-
-static void ypUnregister(yStrRef serial)
-{
-    yBlkHdl prev, next;
-    yBlkHdl cat_hdl, hdl;
-
-    yEnterCriticalSection(&yYpMutex);
-
-    // scan all category nodes
-    cat_hdl = yYpListHead;
-    while (cat_hdl != INVALID_BLK_HDL) {
-        YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-        hdl = YC(cat_hdl).entries;
-        prev = INVALID_BLK_HDL;
-        // scan all yp entries
-        while (hdl != INVALID_BLK_HDL) {
-            YASSERT(YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND);
-            next = YP(hdl).nextPtr;
-            if (YP(hdl).serialNum == serial) {
-                // entry found, remove it
-                if (prev == INVALID_BLK_HDL) {
-                    YC(cat_hdl).entries = next;
-                } else {
-                    YP(prev).nextPtr = next;
-                }
-                yBlkFree(hdl);
-                // continue search on next entries
-            } else {
-                prev = hdl;
-            }
-            hdl = next;
-        }
-        cat_hdl = YC(cat_hdl).nextPtr;
-    }
-
-    yLeaveCriticalSection(&yYpMutex);
-}
-
-#ifndef MICROCHIP_API
-
-YAPI_FUNCTION ypSearch(const char* class_str, const char* func_or_name)
-{
-    yStrRef categref = INVALID_HASH_IDX;
-    yStrRef devref, funcref;
-    yBlkHdl cat_hdl, hdl, byname;
-    int abstract = 0;
-    const char* dotpos = func_or_name;
-    char categname[HASH_BUF_SIZE];
-    YAPI_FUNCTION res = -1;
-    YAPI_FUNCTION best_name = -1;
-    int i;
-
-    // first search for the category node
-    if (!strcmp(class_str, "Function")) {
-        cat_hdl = INVALID_BLK_HDL;
-    } else if (!strcmp(class_str, "Sensor")) {
-        abstract = YOCTO_AKA_YSENSOR;
-        cat_hdl = INVALID_BLK_HDL;
-    } else {
-        categref = yHashTestStr(class_str);
-        if (categref == INVALID_HASH_IDX)
-            return -2; // no device of this type so far
-        yEnterCriticalSection(&yYpMutex);
-        cat_hdl = yYpListHead;
-        while (cat_hdl != INVALID_BLK_HDL) {
-            YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-            if (YC(cat_hdl).name == categref) break;
-            cat_hdl = YC(cat_hdl).nextPtr;
-        }
-        yLeaveCriticalSection(&yYpMutex);
-        if (cat_hdl == INVALID_BLK_HDL)
-            return -2; // no device of this type so far
-    }
-
-    // analyse function string
-    while (*dotpos && *dotpos != '.') dotpos++;
-    if (!*dotpos) {
-        // search for a function by pure logical name
-        funcref = yHashTestStr(func_or_name);
-        if (funcref == INVALID_HASH_IDX)
-            return -1;
-        yEnterCriticalSection(&yYpMutex);
-        if (categref != INVALID_HASH_IDX) {
-            // search within defined function category
-            hdl = YC(cat_hdl).entries;
-            while (hdl != INVALID_BLK_HDL) {
-                if (YP(hdl).funcName == funcref) {
-                    res = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                    break;
-                }
-                hdl = YP(hdl).nextPtr;
-            }
-        } else {
-            // search by pure logical name within abstract basetype
-            hdl = INVALID_BLK_HDL;
-            for (cat_hdl = yYpListHead; cat_hdl != INVALID_BLK_HDL; cat_hdl = YC(cat_hdl).nextPtr) {
-                YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-                hdl = YC(cat_hdl).entries;
-                while (hdl != INVALID_BLK_HDL) {
-                    // check functions matching abstract baseclass, skip others
-                    if ((abstract == YOCTO_AKA_YFUNCTION || YP(hdl).blkId == YBLKID_YPENTRY + abstract) && YP(hdl).funcName == funcref) {
-                        res = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                        break;
-                    }
-                    hdl = YP(hdl).nextPtr;
-                }
-                if (hdl != INVALID_BLK_HDL) break;
-            }
-        }
-        yLeaveCriticalSection(&yYpMutex);
-        if (hdl != INVALID_BLK_HDL) return res;
-        // not found, fallback to assuming that str_func is a logical name or serial number
-        // of a module with an implicit function name (like serial.module for instance)
-        devref = funcref;
-        categname[0] = class_str[0] | 0x20; // lowercase first letter
-        for (i = 1; (categname[i] = class_str[i]) != 0; i++);
-        funcref = yHashTestStr(categname);
-        if (funcref == INVALID_HASH_IDX)
-            return -1;
-    } else {
-        if (dotpos == func_or_name) {
-            // format is ".funcid"
-            devref = INVALID_HASH_IDX;
-        } else {
-            // format is "device.funcid"
-            devref = yHashTestBuf((u8 *)func_or_name, (u16)(dotpos - func_or_name));
-            if (devref == INVALID_HASH_IDX)
-                return -1;
-        }
-        funcref = yHashTestStr(dotpos + 1);
-        if (funcref == INVALID_HASH_IDX)
-            return -1;
-    }
-
-    if (devref != INVALID_HASH_IDX) {
-        // locate function identified by devref.funcref by first resolving devref
-        byname = INVALID_BLK_HDL;
-        yEnterCriticalSection(&yWpMutex);
-        hdl = yWpListHead;
-        while (hdl != INVALID_BLK_HDL) {
-            YASSERT(WP(hdl).blkId == YBLKID_WPENTRY);
-            if (WP(hdl).serial == devref) break;
-            if (WP(hdl).name == devref) byname = hdl;
-            hdl = WP(hdl).nextPtr;
-        }
-        yLeaveCriticalSection(&yWpMutex);
-        if (hdl == INVALID_BLK_HDL) {
-            if (byname == INVALID_BLK_HDL)
-                return -1;
-            // device found by logicalname
-            devref = WP(byname).serial;
-        }
-    }
-    // device found, now we can search for function by serial.funcref
-    yEnterCriticalSection(&yYpMutex);
-    if (categref != INVALID_HASH_IDX) {
-        // search within defined function category
-        hdl = YC(cat_hdl).entries;
-        while (hdl != INVALID_BLK_HDL) {
-            if (devref == INVALID_HASH_IDX || YP(hdl).serialNum == devref) {
-                if (YP(hdl).funcId == funcref) {
-                    res = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                    break;
-                }
-                if (best_name == -1 && YP(hdl).funcName == funcref) {
-                    best_name = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                }
-            }
-            hdl = YP(hdl).nextPtr;
-        }
-    } else {
-        // search by pure logical name within abstract basetype
-        for (cat_hdl = yYpListHead; cat_hdl != INVALID_BLK_HDL; cat_hdl = YC(cat_hdl).nextPtr) {
-            YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-            hdl = YC(cat_hdl).entries;
-            while (hdl != INVALID_BLK_HDL) {
-                // check functions matching abstract baseclass, skip others
-                if ((abstract == YOCTO_AKA_YFUNCTION || YP(hdl).blkId == YBLKID_YPENTRY + abstract) && (devref == INVALID_HASH_IDX || YP(hdl).serialNum == devref)) {
-                    if (YP(hdl).funcId == funcref) {
-                        res = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                        break;
-                    }
-                    if (best_name != -1 && YP(hdl).funcName == funcref) {
-                        best_name = YP(hdl).serialNum + ((u32)(YP(hdl).funcId) << 16);
-                    }
-                }
-                hdl = YP(hdl).nextPtr;
-            }
-            if (hdl != INVALID_BLK_HDL) break;
-        }
-    }
-    if (res == -1 && best_name != -1) {
-        res = best_name;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    return res;
-}
-
-
-int ypGetFunctions(const char* class_str, YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                   YAPI_FUNCTION* buffer, int maxsize, int* neededsize)
-{
-    yStrRef categref = INVALID_HASH_IDX;
-    yBlkHdl cat_hdl, hdl;
-    int abstract = 0;
-    int maxfun = 0, nbreturned = 0;
-    YAPI_FUNCTION fundescr = 0;
-    int use = (prevfundesc == 0); // if prefuncdesc == 0  use any functions
-
-    if (class_str) {
-        if (!strcmp(class_str, "Function")) {
-            abstract = YOCTO_AKA_YFUNCTION;
-        } else if (!strcmp(class_str, "Sensor")) {
-            abstract = YOCTO_AKA_YSENSOR;
-        } else {
-            categref = yHashTestStr(class_str);
-            if (categref == INVALID_HASH_IDX) {
-                if (*neededsize) *neededsize = 0;
-                return 0;
-            }
-        }
-    }
-    yEnterCriticalSection(&yYpMutex);
-    for (cat_hdl = yYpListHead; cat_hdl != INVALID_BLK_HDL; cat_hdl = YC(cat_hdl).nextPtr) {
-        YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-        if (categref == INVALID_HASH_IDX) {
-            // search any type of function, but skip Module
-            if (YC(cat_hdl).name == YSTRREF_MODULE_STRING) continue;
-        } else {
-            // search for a specific function type
-            if (YC(cat_hdl).name != categref) continue;
-        }
-        hdl = YC(cat_hdl).entries;
-        while (hdl != INVALID_BLK_HDL) {
-            // if an abstract baseclass is specified, skip others
-            if (abstract && YP(hdl).blkId != YBLKID_YPENTRY + abstract) {
-                hdl = YP(hdl).nextPtr;
-                continue;
-            }
-            if (devdesc == -1 || YP(hdl).serialNum == (u16)devdesc) {
-                if (!use && prevfundesc == fundescr) {
-                    use = 1;
-                }
-                fundescr = YP(hdl).hwId;
-                if (use) {
-                    maxfun++;
-                    if (maxsize >= (int)sizeof(YAPI_FUNCTION)) {
-                        maxsize -= sizeof(YAPI_FUNCTION);
-                        if (buffer) {
-                            *buffer++ = fundescr;
-                            nbreturned++;
-                        }
-                    }
-                }
-            }
-            hdl = YP(hdl).nextPtr;
-        }
-        // if we were looking for a specific category, we found it
-        if (categref != INVALID_HASH_IDX) break;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    if (neededsize) *neededsize = sizeof(YAPI_FUNCTION) * maxfun;
-    return nbreturned;
-}
-
-
-// This function should only be called after seizing ypMutex
-static yBlkHdl functionSearch(YAPI_FUNCTION fundesc)
-{
-    yBlkHdl cat_hdl, hdl;
-    yStrRef funcref, categref;
-    char funcname[YOCTO_FUNCTION_LEN], *p;
-
-    funcref = (u16)(fundesc >> 16);
-    yHashGetStr(funcref, funcname, YOCTO_FUNCTION_LEN);
-    funcname[0] &= ~0x20; // uppercase first letter
-    for (p = funcname + 1; *p > '9'; p++);
-    *p = 0;
-    categref = yHashTestStr(funcname);
-    if (categref == INVALID_HASH_IDX)
-        return INVALID_BLK_HDL; // no device of this type so far, should never happen
-
-    cat_hdl = yYpListHead;
-    while (cat_hdl != INVALID_BLK_HDL) {
-        YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-        if (YC(cat_hdl).name == categref) break;
-        cat_hdl = YC(cat_hdl).nextPtr;
-    }
-    if (cat_hdl == INVALID_BLK_HDL)
-        return INVALID_BLK_HDL; // no device of this type so far, should never happen
-
-    hdl = YC(cat_hdl).entries;
-    while (hdl != INVALID_BLK_HDL) {
-        if (YP(hdl).hwId == fundesc) {
-            return hdl;
-        }
-        hdl = YP(hdl).nextPtr;
-    }
-    return INVALID_BLK_HDL; // device not found, most probably unplugged
-}
-
-int ypGetFunctionInfo(YAPI_FUNCTION fundesc, char* serial, char* funcId, char* baseType, char* funcName, char* funcVal)
-{
-    yBlkHdl hdl;
-    u16 i;
-    u16* funcValWords = (u16 *)funcVal;
-
-    yEnterCriticalSection(&yYpMutex);
-    hdl = functionSearch(fundesc);
-    if (hdl != INVALID_BLK_HDL) {
-        if (serial) yHashGetStr(YP(hdl).serialNum, serial, YOCTO_SERIAL_LEN);
-        if (funcId) yHashGetStr(YP(hdl).funcId, funcId, YOCTO_FUNCTION_LEN);
-        if (baseType) {
-            int type = YOCTO_AKA_YFUNCTION;
-            if (YP(hdl).blkId >= YBLKID_YPENTRY && YP(hdl).blkId <= YBLKID_YPENTRYEND) {
-                type = YP(hdl).blkId - YBLKID_YPENTRY;
-            }
-            if (type == YOCTO_AKA_YSENSOR) {
-                YSTRCPY(baseType, YOCTO_FUNCTION_LEN, "Sensor");
-            } else {
-                YSTRCPY(baseType, YOCTO_FUNCTION_LEN, "Function");
-            }
-        }
-        if (funcName) yHashGetStr(YP(hdl).funcName, funcName, YOCTO_LOGICAL_LEN);
-        if (funcVal != NULL) {
-            // null-terminate
-            for (i = 0; i < YOCTO_PUBVAL_SIZE / 2; i++) {
-                funcValWords[i] = YP(hdl).funcValWords[i];
-            }
-            funcVal[6] = 0;
-        }
-    } else {
-        if (funcVal != NULL) funcVal[0] = 0;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    return (hdl == INVALID_BLK_HDL ? -1 : 0);
-}
-
-#endif
-
-
-int ypGetFunctionsEx(yStrRef categref, YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                     YAPI_FUNCTION* buffer, int maxsize, int* neededsize)
-{
-    yBlkHdl cat_hdl, hdl;
-    int abstract = 0;
-    int maxfun = 0, nbreturned = 0;
-    YAPI_FUNCTION fundescr = 0;
-    int use = (prevfundesc == 0); // if prefuncdesc == 0  use any functions
-
-    if (categref == YSTRREF_SENSOR_STRING) {
-        abstract = YOCTO_AKA_YSENSOR;
-    }
-    yEnterCriticalSection(&yYpMutex);
-    for (cat_hdl = yYpListHead; cat_hdl != INVALID_BLK_HDL; cat_hdl = YC(cat_hdl).nextPtr) {
-        YASSERT(YC(cat_hdl).blkId == YBLKID_YPCATEG);
-        if (categref == INVALID_HASH_IDX) {
-            // search any type of function, but skip Module
-            if (YC(cat_hdl).name == YSTRREF_MODULE_STRING) continue;
-        } else {
-            // search for a specific function type
-            if (YC(cat_hdl).name != categref) continue;
-        }
-        hdl = YC(cat_hdl).entries;
-        while (hdl != INVALID_BLK_HDL) {
-            // if an abstract baseclass is specified, skip others
-            if (abstract && YP(hdl).blkId != YBLKID_YPENTRY + abstract) {
-                hdl = YP(hdl).nextPtr;
-                continue;
-            }
-            if (devdesc == -1 || YP(hdl).serialNum == (u16)devdesc) {
-                if (!use && prevfundesc == fundescr) {
-                    use = 1;
-                }
-                fundescr = YP(hdl).hwId;
-                if (use) {
-                    maxfun++;
-                    if (maxsize >= (int)sizeof(YAPI_FUNCTION)) {
-                        maxsize -= sizeof(YAPI_FUNCTION);
-                        if (buffer) {
-                            *buffer++ = fundescr;
-                            nbreturned++;
-                        }
-                    }
-                }
-            }
-            hdl = YP(hdl).nextPtr;
-        }
-        // if we were looking for a specific category, we found it
-        if (categref != INVALID_HASH_IDX) break;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    if (neededsize) *neededsize = sizeof(YAPI_FUNCTION) * maxfun;
-    return nbreturned;
-}
-
-
-s16 ypFindBootloaders(yStrRef* serials, u16 maxSerials)
-{
-    yBlkHdl cat_hdl, hdl;
-    s16 res = 0;
-
-    // first search for the category node
-    yEnterCriticalSection(&yYpMutex);
-    cat_hdl = yYpListHead;
-    while (cat_hdl != INVALID_BLK_HDL) {
-        if (YC(cat_hdl).name == YSTRREF_HUBPORT_STRING) break;
-        cat_hdl = YC(cat_hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-    if (cat_hdl == INVALID_BLK_HDL)
-        return -2; // no hubPort registered so far
-
-    yEnterCriticalSection(&yYpMutex);
-    hdl = YC(cat_hdl).entries;
-    while (hdl != INVALID_BLK_HDL) {
-        if (YP(hdl).funcValWords[0] == WORD_TEXT_PR && YP(hdl).funcValWords[1] == WORD_TEXT_OG) {
-            if (res++ < maxSerials) {
-                *serials++ = YP(hdl).funcName;
-            }
-        }
-        hdl = YP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-
-    return res;
-}
-
-#ifdef MICROCHIP_API
-int ypGetBootDevHdl(const char *serial)
-{
-    yBlkHdl cat_hdl, hdl;
-    yStrRef serialRef;
-    char    funcid[9];
-    s16     devYdx;
-
-    serialRef = yHashTestStr(serial);
-    if(serialRef == INVALID_HASH_IDX)
-        return -1; // unknown serial
-
-    // search for the category node
-    yEnterCriticalSection(&yYpMutex);
-    cat_hdl = yYpListHead;
-    while(cat_hdl != INVALID_BLK_HDL) {
-        if(YC(cat_hdl).name == YSTRREF_HUBPORT_STRING) break;
-        cat_hdl = YC(cat_hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-    if(cat_hdl == INVALID_BLK_HDL)
-        return -2; // no hubPort registered so far
-
-    yEnterCriticalSection(&yYpMutex);
-    hdl = YC(cat_hdl).entries;
-    while(hdl != INVALID_BLK_HDL) {
-        if(YP(hdl).funcName == serialRef &&
-           YP(hdl).funcValWords[0] == WORD_TEXT_PR &&
-           YP(hdl).funcValWords[1] == WORD_TEXT_OG) {
-            break;
-        }
-        hdl = YP(hdl).nextPtr;
-    }
-    yLeaveCriticalSection(&yYpMutex);
-    if(hdl == INVALID_BLK_HDL)
-        return -3; // serial not connected in PROG mode
-
-    yHashGetStr(YP(hdl).funcId, funcid, sizeof(funcid));
-    if(funcid[7] <'1' || funcid[7] > '4')
-        return -3; // invalid function id
-    devYdx = wpGetDevYdx(YP(hdl).serialNum);
-    if(devYdx == hubDevYdx) {
-        // The 3 root ports use devhdl 0-2
-        return funcid[7] - '1';
-    }
-
-    // ports on shield use hub devYdx+(1..4)
-    return devYdx + funcid[7] - '0';
-}
-#endif
-
-
-// Network notification format: 7x7bit (mapped to 7 chars in range 32..159)
-//                              used to represent 1 flag (RAW6BYTES) + 6 bytes
-// INPUT:  [R765432][1076543][2107654][3210765][4321076][5432107][6543210]
-// OUTPUT: [R][-byte 0][-byte 1-][-byte 2-][-byte 3-][-byte 4-][-byte 5-]
-//
-// return the effective number of bytes produced; if < 6 remaining are padded with 0
-// input and output buffer may be the same one
-// encoding function is defined in yhub.c
-//
-int decodeNetFuncValV2(const u8* p, Notification_funydx* funInfo, char* funcVal)
-{
-    u16 ch = *p;
-    int len = 0;
-
-    if (ch < 32 || ch > 32 + 127) {
-        return -1;
-    }
-    // get the 7 first bits
-    ch -= 32;
-    funInfo->v2.typeV2 = (ch & 0x40 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA);
-    // clear flag
-    ch &= 0x3f;
-    while (len < YOCTO_PUBVAL_SIZE) {
-        u8 newCh = *++p;
-        if (newCh == 0 || newCh == NOTIFY_NETPKT_STOP) {
-            memset(funcVal + len, 0, YOCTO_PUBVAL_SIZE - len);
-            break;
-        }
-        if (newCh < 32 || newCh > 32 + 127) {
-            return -1;
-        }
-        newCh -= 32;
-        ch = (ch << 7) + newCh;
-        funcVal[len] = (ch >> (5 - len));
-        len++;
-    }
-    return len;
-}
--- a/Sources/cpplib/yapi/yhash.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/*********************************************************************
- *
- * $Id: yhash.h 29741 2018-01-25 17:18:34Z seb $
- *
- * Simple hash tables and device/function information store
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YHASH_H
-#define YHASH_H
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-#include "ydef.h"
-
-//#define DEBUG_WP_LOCK
-//#define DEBUG_WP
-
-#define HASH_BUF_SIZE 28
-#define HASH_BUF_POW   5 /* HASH_BUF_POW = log_2(HASH_BUF_SIZE+2+2) */
-#ifdef MICROCHIP_API
-#define NB_MAX_HASH_ENTRIES 1023     /* keep hash table size <32KB on Yocto-Hub */
-#define NB_MAX_DEVICES        80     /* base hub + up to 15 shields (up to 4 slave ports) */
-#else
-#define NB_MAX_HASH_ENTRIES 8192
-#define NB_MAX_DEVICES       256
-#endif
-
-#define YSTRREF_EMPTY_STRING   0x00ff /* yStrRef value for the empty string    */
-#define YSTRREF_MODULE_STRING  0x0020 /* yStrRef value for the string 'Module' */
-#define YSTRREF_mODULE_STRING  0x00a3 /* yStrRef value for the string 'module' */
-#define YSTRREF_HUBPORT_STRING 0x00d6 /* yStrRef value for the string 'HubPort' */
-#define YSTRREF_SENSOR_STRING  0x0001 /* yStrRef value for the string 'Sensor' */
-
-#ifndef CPU_BIG_ENDIAN
-#define WORD_TEXT_PR           0x5250
-#define WORD_TEXT_OG           0x474f
-#else
-#define WORD_TEXT_PR           0x5052
-#define WORD_TEXT_OG           0x4f47
-#endif
-
-typedef enum {
-    Y_WP_SERIALNUMBER,
-    Y_WP_LOGICALNAME,
-    Y_WP_PRODUCTNAME,
-    Y_WP_PRODUCTID,
-    Y_WP_NETWORKURL,
-    Y_WP_BEACON,
-    Y_WP_INDEX
-} yWPAttribute;
-
-#define YBLKID_WPENTRY    0xf0
-#define YBLKID_YPCATEG    0xf1
-#define YBLKID_YPARRAY    0xf2
-#define YBLKID_YPENTRY    0xf3
-#define YBLKID_YPENTRYEND (YBLKID_YPENTRY+YOCTO_N_BASECLASSES-1)
-
-typedef struct {
-    u8          devYdx;
-    u8          blkId;
-    yBlkHdl     nextPtr;
-    yStrRef     serial;
-    yStrRef     name;
-    yStrRef     product;
-    u16         devid;
-    yUrlRef     url;
-    u16         flags;
-} yWhitePageEntry;
-
-// WP entry flags
-#define YWP_MARK_FOR_UNREGISTER 0x02
-#define YWP_BEACON_ON           0x01
-
-typedef struct {
-    u8          posYdx;
-    u8          blkId;
-    yBlkHdl     nextPtr;
-    yBlkHdl     entries[6];
-} yYellowPageArray;
-
-typedef struct {
-    Notification_funydx funInfo;
-    u8          blkId;
-    yBlkHdl     nextPtr;
-    union {
-      struct {
-#ifndef CPU_BIG_ENDIAN
-        yStrRef serialNum;
-        yStrRef funcId;
-#else
-        yStrRef funcId;
-        yStrRef serialNum;
-#endif
-      };
-      YAPI_FUNCTION hwId;
-    };
-    yStrRef     funcName;
-    union {
-        char    funcVal[YOCTO_PUBVAL_SIZE];
-        u16     funcValWords[YOCTO_PUBVAL_SIZE/2];
-    };
-} yYellowPageEntry;
-
-typedef struct {
-    u8          catYdx;
-    u8          blkId;
-    yBlkHdl     nextPtr;
-    yStrRef     name;
-    yBlkHdl     entries;
-} yYellowPageCateg;
-
-typedef union{
-    struct {
-        u16     hash;
-        yHash   next;
-        u8      buff[HASH_BUF_SIZE];
-    };
-    union {
-        struct {
-            u8      ydx;
-            u8      blkId;
-            yBlkHdl nextPtr;
-        };
-        yWhitePageEntry     wpEntry;
-        yYellowPageEntry    ypEntry;
-        yYellowPageCateg    ypCateg;
-        yYellowPageArray    ypArray;
-    } blk[2];
-} YHashSlot;
-
-extern char SerialNumberStr[YOCTO_SERIAL_LEN];
-extern yStrRef SerialRef;
-extern yBlkHdl yWpListHead;
-extern yBlkHdl yYpListHead;
-
-#define YMAX_HUB_URL_DEEP           7
-#define YOCTO_HOSTNAME_NAME         (HASH_BUF_SIZE*2+2)
-
-typedef enum {
-    USB_URL,
-    IP_URL,
-    NAME_URL
-} yAsbUrlType;
-
-typedef enum {
-    PROTO_AUTO = 0,
-    PROTO_HTTP,
-    PROTO_WEBSOCKET
-} yAsbUrlProto;
-
-
-
-typedef struct{
-    union{
-        struct{
-            yStrRef   host;
-            yStrRef   domaine;
-            u16       port;
-        } byname;
-        struct{
-            yStrRef   ip;
-            yHash     invalid;
-            u16       port;
-        } byip;
-        struct{
-            yHash     invalid1;
-            yHash     invalid2;
-            yStrRef   serial;
-        } byusb;
-    };
-    u16 proto;
-    yStrRef user;
-    yStrRef password;
-    yStrRef subdomain;
-    yStrRef path[YMAX_HUB_URL_DEEP];
-} yAbsUrl;
-
-void  yHashInit(void);
-yHash yHashPutBuf(const u8 *buf, u16 len);
-yHash yHashPutStr(const char *str);
-yHash yHashTestBuf(const u8 *buf, u16 len);
-yHash yHashTestStr(const char *str);
-void  yHashGetBuf(yHash yhash, u8 *destbuf, u16 bufsize);
-void  yHashGetStr(yHash yhash, char *destbuf, u16 bufsize);
-u16   yHashGetStrLen(yHash yhash);
-char  *yHashGetStrPtr(yHash yhash);
-#ifndef MICROCHIP_API
-yUrlRef yHashUrlFromRef(yUrlRef urlref, const char *rootUrl);
-yUrlRef yHashUrl(const char *host, const char *rootUrl, u8 testonly, char *errmsg);
-yAsbUrlType  yHashGetUrlPort(yUrlRef urlref, char *url, u16 *port, yAsbUrlProto *proto, yStrRef *user, yStrRef *password, yStrRef *subdomain);
-int yHashSameHub(yUrlRef url_a, yUrlRef url_b);
-void  yHashFree(void);
-#endif
-yUrlRef yHashUrlUSB(yHash serial);
-yUrlRef yHashUrlAPI(void);
-u16     yBlkListLength(yBlkHdl hdl);
-yBlkHdl yBlkListSeek(yBlkHdl hdl, u16 pos);
-int     wpRegister(int devYdx, yStrRef serial, yStrRef logicalName, yStrRef productName, u16 productId, yUrlRef devUrl, s8 beacon);
-yStrRef wpGetAttribute(yBlkHdl hdl, yWPAttribute attridx);
-void    wpGetSerial(yBlkHdl hdl, char *serial);
-void    wpGetLogicalName(yBlkHdl hdl, char *logicalName);
-#ifdef DEBUG_WP_LOCK
-void    wpPreventUnregisterDbg(const char *file, u32 line);
-void    wpAllowUnregisterDbg(const char *file, u32 line);
-#define wpPreventUnregister()   wpPreventUnregisterDbg(__FILE__,__LINE__)
-#define wpAllowUnregister()     wpAllowUnregisterDbg(__FILE__,__LINE__)
-#else
-void    wpPreventUnregisterEx(void);
-void    wpAllowUnregisterEx(void);
-#define wpPreventUnregister()   wpPreventUnregisterEx()
-#define wpAllowUnregister()     wpAllowUnregisterEx()
-#endif
-int     wpMarkForUnregister(yStrRef serial);
-int     wpGetDevYdx(yStrRef serial);
-YAPI_DEVICE wpSearchByNameHash(yStrRef strref);
-#ifndef MICROCHIP_API
-u16     wpEntryCount(void);
-YAPI_DEVICE wpSearchEx(yStrRef strref);
-YAPI_DEVICE wpSearch(const char *device_str);
-YAPI_DEVICE wpSearchByUrl(const char *host, const char *rootUrl);
-int     wpGetAllDevUsingHubUrl( yUrlRef hubUrl, yStrRef *buffer,int sizeInStrRef);
-
-yUrlRef wpGetDeviceUrlRef(YAPI_DEVICE devdesc);
-int     wpGetDeviceUrl(YAPI_DEVICE devdesc, char *roothubserial, char *request, int requestsize, int *neededsize);
-YAPI_FUNCTION ypSearch(const char *class_str, const char *func_str);
-int     ypGetFunctions(const char *class_str, YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc,
-                       YAPI_FUNCTION *buffer,int maxsize,int *neededsize);
-int     ypGetFunctionInfo(YAPI_FUNCTION fundesc, char *serial, char *funcId, char *baseType, char *funcName, char *funcVal);
-#endif
-int     ypGetFunctionsEx(yStrRef categref, YAPI_DEVICE devdesc, YAPI_FUNCTION prevfundesc, YAPI_FUNCTION *buffer, int maxsize, int *neededsize);
-int     wpGetDeviceInfo(YAPI_DEVICE devdesc, u16 *deviceid, char *productname, char *serial, char *logicalname, u8 *beacon);
-int     ypRegister(yStrRef categ, yStrRef serial, yStrRef funcId, yStrRef funcName, int funClass, int funYdx, const char *funcVal);
-// WARNING: funcVal MUST BE WORD-ALIGNED
-int     ypRegisterByYdx(u8 devYdx, Notification_funydx funInfo, const char *funcVal, YAPI_FUNCTION *fundesc);
-// WARNING: funcVal MUST BE WORD-ALIGNED
-int     ypGetAttributesByYdx(u8 devYdx, u8 funYdx, yStrRef *serial, yStrRef *logicalName, yStrRef *funcId, yStrRef *funcName, Notification_funydx *funcInfo, char *funcVal);
-void    ypGetCategory(yBlkHdl hdl, char *name, yBlkHdl *entries);
-int     ypGetAttributes(yBlkHdl hdl, yStrRef *serial, yStrRef *funcId, yStrRef *funcName, Notification_funydx *funcInfo, char *funcVal);
-int     ypGetType(yBlkHdl hdl);
-int     ypGetBootDevHdl(const char *serial);
-s16     ypFindBootloaders(yStrRef *serials, u16 maxSerials);
-int     decodeNetFuncValV2(const u8 *p, Notification_funydx *funInfo, char *funcVal);
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
-
-
--- a/Sources/cpplib/yapi/yjni.c
+++ /dev/null
@@ -1,575 +0,0 @@
-/*********************************************************************
- *
- * $Id: yjni.c 32916 2018-11-02 11:07:34Z seb $
- *
- * Implementation of public entry points to the low-level API
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__  "yjni"
-
-#include "yapi.h"
-#include "yproto.h"
-#include "yhash.h"
-#include "yjson.h"
-#include "yprog.h"
-
-#ifdef YAPI_WITH_JNI
-
-#include <jni.h>
-#include <stdio.h>
-#include "yjni.h"
-
-
-
- jint throwYAPI_Exception( JNIEnv *env, char *message )
-{
-    jclass exClass;
-    char *className = "com/yoctopuce/YoctoAPI/YAPI_Exception" ;
-    dbglog("Exception:%s\n", message);
-    exClass = (*env)->FindClass( env, className );
-    return (*env)->ThrowNew( env, exClass, message );
-}
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    getAPIVersion
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_getAPIVersion(JNIEnv *env, jclass thisObj)
-{
-    const char *version;
-    const char *apidate;
-    yapiGetAPIVersion(&version, &apidate);
-
-    return (*env)->NewStringUTF(env, version);
-}
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    reserveUSBAccess
- * Signature: ()V;
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_reserveUSBAccess(JNIEnv *env, jclass thisObj)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-
-    res = yapiInitAPI(Y_DETECT_USB, errmsg);
-    if(YISERR(res)) {
-        throwYAPI_Exception(env, errmsg);
-    }
-}
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    releaseUSBAccess
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_releaseUSBAccess(JNIEnv *env, jclass thisObj)
-{
-    yapiFreeAPI();
-}
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    getBootloaders
- * Signature: ()Ljava/util/String;
- */
-JNIEXPORT jobject JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_getBootloaders(JNIEnv *env, jclass thisObj)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char buffer[1024];
-    char *p;
-    int fullsize;
-    YRETCODE res;
-    jobject result;
-
-
-    res = yapiGetBootloaders(buffer, 1024, &fullsize, errmsg);
-    if(YISERR(res)) {
-        throwYAPI_Exception(env, errmsg);
-        return NULL;
-    }
-    if (res == fullsize) {
-        return (*env)->NewStringUTF(env, buffer);
-    }
-
-    p = yMalloc(fullsize+1);
-    memset(p, 0, fullsize+1);
-    res = yapiGetBootloaders(buffer, fullsize, &fullsize, errmsg);
-    if(YISERR(res)) {
-        yFree(p);
-        throwYAPI_Exception(env, errmsg);
-        return NULL;
-    }
-    result = (*env)->NewStringUTF(env, buffer);
-    yFree(p);
-    return result;
-}
-
-
-static jobject allocWPEntry(JNIEnv *env, yDeviceSt *infos)
-{
-    jstring logicalName;
-    jstring productName;
-    jint productId;
-    jstring networkUrl;
-    jint beacon;
-    jstring serialNumber;
-    jobject res;
-    jmethodID constructor;
-
-
-    jclass cls = (*env)->FindClass(env, "com/yoctopuce/YoctoAPI/WPEntry");
-    if (cls == 0) {
-        throwYAPI_Exception(env, "Unable to find class WPEntry");
-        return NULL;
-    }
-
-    constructor = (*env)->GetMethodID(env, cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;ILjava/lang/String;)V");
-    if (constructor == 0) {
-        throwYAPI_Exception(env, "Unable to find constructor for WPEntry");
-        return NULL;
-    }
-
-    logicalName = (*env)->NewStringUTF(env, infos->logicalname);
-    productName = (*env)->NewStringUTF(env, infos->productname);
-    networkUrl = (*env)->NewStringUTF(env, "");
-    serialNumber = (*env)->NewStringUTF(env, infos->serial);
-    productId = infos->vendorid;
-    beacon = 0; //fixme : use real beacon vallue
-
-    res = (*env)->NewObject(env, cls, constructor, logicalName, productName, productId, networkUrl, beacon, serialNumber);
-    return res;
-
-}
-
-
-
-static jobject allocYPEntry(JNIEnv *env, const char *classname, const char *serial, const char *funcId, const char *logicalName, const char *advertisedValue, int baseType, int funIdx)
-{
-    jstring j_classname;
-    jstring j_serial;
-    jstring j_funcId;
-    jstring j_logicalName;
-    jstring j_advertisedValue;
-    jmethodID constructor;
-
-    jclass cls = (*env)->FindClass(env, "com/yoctopuce/YoctoAPI/YPEntry");
-    if (cls == 0) {
-        throwYAPI_Exception(env, "Unable to find class WPEntry");
-        return NULL;
-    }
-    constructor = (*env)->GetMethodID(env, cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;II)V");
-    if (constructor == 0) {
-        throwYAPI_Exception(env, "Unable to find constructor for YPEntry");
-        return NULL;
-    }
-    j_classname = (*env)->NewStringUTF(env, classname);
-    j_serial = (*env)->NewStringUTF(env, serial);
-    j_funcId = (*env)->NewStringUTF(env, funcId);
-    j_logicalName = (*env)->NewStringUTF(env, logicalName);
-    j_advertisedValue = (*env)->NewStringUTF(env, advertisedValue);
-    return (*env)->NewObject(env, cls, constructor, j_classname, j_serial, j_funcId, j_logicalName, j_advertisedValue, baseType, funIdx);
-}
-
-
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    updateDeviceList
- * Signature: (Ljava/util/ArrayList;Ljava/util/HashMap;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_updateDeviceList(JNIEnv *env, jclass thisObj, jobject wpArray, jobject ypArray)
-{
-    char    errmsg[YOCTO_ERRMSG_LEN];
-    YAPI_DEVICE *buffer, *dev_ptr;
-    int     nbdev, buffsize, i;
-    yBlkHdl categ;
-
-    jobject wpEntry, ypEntry;
-    jclass arrayList_class;
-    jmethodID arrayList_add;
-
-    if (yapiUpdateDeviceList(1, errmsg) < 0) {
-        throwYAPI_Exception(env, errmsg);
-        return;
-    }
-
-    // populate white pages
-    if (yapiGetAllDevices(NULL, 0, &buffsize, errmsg) < 0) {
-        throwYAPI_Exception(env, errmsg);
-        return;
-    }
-    buffer = (YAPI_DEVICE *)yMalloc(buffsize);
-    nbdev = yapiGetAllDevices(buffer, buffsize, &buffsize, errmsg);
-
-    arrayList_class = (*env)->FindClass(env, "java/util/ArrayList");
-    if (arrayList_class == 0) {
-        throwYAPI_Exception(env, "Unable to find class ArrayList");
-        return;
-    }
-
-    arrayList_add = (*env)->GetMethodID(env, arrayList_class, "add", "(Ljava/lang/Object;)Z");
-    if (arrayList_add == 0) {
-        throwYAPI_Exception(env, "Unable to find add method of ArrayList");
-        return;
-    }
-
-    dev_ptr = buffer;
-    for (i = 0 ; i < nbdev; i++, dev_ptr++) {
-        yDeviceSt dev_info;
-        if (yapiGetDeviceInfo(*dev_ptr, &dev_info, errmsg) < 0) {
-            throwYAPI_Exception(env, errmsg);
-            return;
-        }
-        wpEntry = allocWPEntry(env, &dev_info);
-        if (wpEntry ==NULL) {
-            return;
-        }
-        (*env)->CallBooleanMethod(env, wpArray, arrayList_add, wpEntry);
-    }
-    yFree(buffer);
-
-    // populate Yellow pages
-    categ = yYpListHead;
-    for (categ = yYpListHead; categ != INVALID_BLK_HDL; categ = yBlkListSeek(categ, 1)) {
-        char categname[YOCTO_FUNCTION_LEN];
-        yBlkHdl entry;
-
-        ypGetCategory(categ, categname, &entry);
-        if (YSTRCMP(categname,"Module")==0){
-            continue;
-        }
-
-        // add all Yellow pages
-        for (; entry != INVALID_BLK_HDL; entry = yBlkListSeek(entry, 1)) {
-            yStrRef serial, funcId, funcName;
-            Notification_funydx funcInfo;
-            int  yidx, baseType;
-            char pubRaw[YOCTO_PUBVAL_SIZE];
-            char pubDecoded[YOCTO_PUBVAL_LEN];
-            yidx =  ypGetAttributes(entry, &serial, &funcId, &funcName, &funcInfo, pubRaw);
-            baseType = ypGetType(entry);
-            decodePubVal(funcInfo, pubRaw, pubDecoded);
-            ypEntry = allocYPEntry(env, categname, yHashGetStrPtr(serial), yHashGetStrPtr(funcId), yHashGetStrPtr(funcName),
-                pubDecoded, baseType, yidx);
-            if (ypEntry == NULL) {
-                return;
-            }
-            (*env)->CallBooleanMethod(env, ypArray, arrayList_add, ypEntry);
-        }
-    }
-
-}
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    devRequestSync
- * Signature: (Ljava/lang/String;[B)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_devRequestSync(JNIEnv *env, jclass thisObj, jstring serial_java, jbyteArray request_java)
-{
-    char        errmsg[YOCTO_ERRMSG_LEN];
-    YRETCODE    res;
-    YIOHDL      iohdl;
-    char        *reply;
-    int         replysize = 0;
-    const char  *serial = NULL;
-    jbyte       *request_bytes = NULL;
-    jsize       length;
-    jbyteArray  result = NULL;
-
-    // get serial
-    serial = (*env)->GetStringUTFChars(env, serial_java, NULL);
-    if (NULL == serial) {
-        throwYAPI_Exception(env, "Invalid String");
-        goto exit;
-    }
-
-    // get request
-    request_bytes = (*env)->GetByteArrayElements(env, request_java, NULL);
-    if (NULL == request_bytes) {
-        throwYAPI_Exception(env, "Invalid Byte Array");
-        goto exit;
-    }
-    length = (*env)->GetArrayLength(env, request_java);
-
-    if(YISERR(res = yapiHTTPRequestSyncStartEx(&iohdl, serial, (const char *)request_bytes, length, &reply, &replysize, errmsg))) {
-        throwYAPI_Exception(env, errmsg);
-        goto exit;
-    }
-    if (replysize < 0 || reply == NULL) {
-        replysize = 0;
-    }
-
-   // compute return value
-   result = (*env)->NewByteArray(env, replysize);  // allocate
-   if (NULL == result) {
-        throwYAPI_Exception(env, "Unable to allocate bytes array");
-        goto exit;
-    }
-
-    if (replysize > 0) {
-        (*env)->SetByteArrayRegion(env, result, 0 , replysize, (jbyte*)reply); // copy
-    }
-
-    if(YISERR(res=yapiHTTPRequestSyncDone(&iohdl, errmsg))) {
-        throwYAPI_Exception(env, errmsg);
-    }
-
-exit:
-    if (serial != NULL) {
-        (*env)->ReleaseStringUTFChars(env, serial_java, serial);  // release resources
-    }
-
-    if (request_bytes != NULL) {
-       (*env)->ReleaseByteArrayElements(env, request_java, request_bytes, 0); // release resources
-    }
-    return result;
-}
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    devRequestAsync
- * Signature: (Ljava/lang/String;[BLcom/yoctopuce/YoctoAPI/YGenericHub/RequestAsyncResult;Ljava/lang/Object;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_devRequestAsync(JNIEnv *env, jclass thisObj, jstring serial_java, jbyteArray request_java, jobject callback, jobject context)
-{
-    char        errmsg[YOCTO_ERRMSG_LEN];
-    YRETCODE    res;
-    const char  *serial = NULL;
-    jbyte       *request_bytes = NULL;
-    jsize       length;
-
-    // get serial
-    serial = (*env)->GetStringUTFChars(env, serial_java, NULL);
-    if (NULL == serial) {
-        throwYAPI_Exception(env, "Invalid String");
-        goto exit;
-    }
-
-    // get request
-    request_bytes = (*env)->GetByteArrayElements(env, request_java, NULL);
-    if (NULL == request_bytes) {
-        throwYAPI_Exception(env, "Invalid Byte Array");
-        goto exit;
-    }
-    length = (*env)->GetArrayLength(env, request_java);
-
-
-    if(YISERR(res=yapiHTTPRequestAsyncEx(serial, (const char *)request_bytes, length, NULL, NULL, errmsg))) {
-        throwYAPI_Exception(env, errmsg);
-        goto exit;
-    }
-    //Todo: handle correctly callback
-
-exit:
-    if (serial != NULL) {
-        (*env)->ReleaseStringUTFChars(env, serial_java, serial);  // release resources
-    }
-
-    if (request_bytes != NULL) {
-       (*env)->ReleaseByteArrayElements(env, request_java, request_bytes, 0); // release resources
-    }
-}
-
-
-static JavaVM *jvm;
-
-static jobject jObj;
-
-static JNIEnv* getThreadEnv()
-{
-    JNIEnv *env;
-    // double check it's all ok
-    int getEnvStat = (*jvm)->GetEnv(jvm, (void**)&env, JNI_VERSION_1_6);
-    if (getEnvStat == JNI_EDETACHED) {
-        dbglog("GetEnv: not attached\n");
-        if ((*jvm)->AttachCurrentThread(jvm, (void **) &env, NULL) != 0) {
-             dbglog("Failed to attach\n");
-             return NULL;
-        }
-    } else if (getEnvStat == JNI_OK) {
-        //dbglog("attached\n");
-    } else if (getEnvStat == JNI_EVERSION) {
-         dbglog("GetEnv: version not supported\n");
-         return NULL;
-    }
-    return env;
-}
-
-
-static void jFunctionUpdateCallbackFwd(YAPI_FUNCTION fundesc,const char *value)
-{
-    char serial[YOCTO_SERIAL_LEN];
-    char funcId[YOCTO_FUNCTION_LEN];
-    jstring j_serial;
-    jstring j_funcId;
-    jstring j_value;
-    jclass yUSBHub_class;
-    jmethodID yUSBHub_handleValueNotification;
-    JNIEnv *env;
-
-    if (value==NULL){
-        return;
-    }
-
-    env = getThreadEnv();
-    if (env == NULL){
-        return;
-    }
-
-    ypGetFunctionInfo(fundesc, serial, funcId,NULL, NULL, NULL);
-    j_serial = (*env)->NewStringUTF(env, serial);
-    j_funcId = (*env)->NewStringUTF(env, funcId);
-    j_value = (*env)->NewStringUTF(env, value);
-
-    yUSBHub_class = (*env)->FindClass(env, "com/yoctopuce/YoctoAPI/YUSBHub");
-    if (yUSBHub_class == 0) {
-        dbglog("Unable to find class YUSBHub\n");
-        return;
-    }
-
-
-    yUSBHub_handleValueNotification = (*env)->GetMethodID(env, yUSBHub_class, "handleValueNotification", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
-    if (yUSBHub_handleValueNotification == 0) {
-        dbglog("Unable to find add method of handleValueNotification\n");
-        return;
-    }
-
-    (*env)->CallVoidMethod(env, jObj, yUSBHub_handleValueNotification, j_serial, j_funcId, j_value);
-}
-
-static void jFunctionTimedReportCallbackFwd(YAPI_FUNCTION fundesc, double timestamp, const u8 *bytes, u32 len, double duration)
-{
-    char serial[YOCTO_SERIAL_LEN];
-    char funcId[YOCTO_FUNCTION_LEN];
-    jstring j_serial;
-    jstring j_funcId;
-    jbyteArray  result = NULL;
-    jclass yUSBHub_class;
-    jmethodID YUSBHub_handleTimedNotification;
-    JNIEnv *env;
-
-    env = getThreadEnv();
-    if (env == NULL){
-        return;
-    }
-
-    ypGetFunctionInfo(fundesc, serial, funcId, NULL, NULL, NULL);
-    j_serial = (*env)->NewStringUTF(env, serial);
-    j_funcId = (*env)->NewStringUTF(env, funcId);
-
-    yUSBHub_class = (*env)->FindClass(env, "com/yoctopuce/YoctoAPI/YUSBHub");
-    if (yUSBHub_class == 0) {
-        dbglog("Unable to find class YUSBHub\n");
-        return;
-    }
-
-    YUSBHub_handleTimedNotification = (*env)->GetMethodID(env, yUSBHub_class, "handleTimedNotification", "(Ljava/lang/String;Ljava/lang/String;DD[B)V");
-    if (YUSBHub_handleTimedNotification == 0) {
-        dbglog("Unable to find add method of handleTimedNotification\n");
-        return;
-    }
-
-
-   // compute return value
-   result = (*env)->NewByteArray(env, len);  // allocate
-   if (NULL == result) {
-        dbglog("Unable to allocate bytes array");
-        return;
-    }
-
-    (*env)->SetByteArrayRegion(env, result, 0 , len, (jbyte*) bytes);  // copy
-    (*env)->CallVoidMethod(env, jObj, YUSBHub_handleTimedNotification, j_serial, j_funcId, timestamp, duration, result);
-}
-
-
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    startNotifications
- * Signature: (Lcom/yoctopuce/YoctoAPI/YUSBHub;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_startNotifications(JNIEnv * env, jclass thisObj, jobject yUSBHubRef)
-{
-
-    if ((*env)->GetJavaVM(env, &jvm) != 0) {
-        throwYAPI_Exception(env, "GetJavaVM: Unable to get VM");
-        return;
-    }
-    jObj = (*env)->NewGlobalRef(env, yUSBHubRef);
-    yapiRegisterFunctionUpdateCallback(jFunctionUpdateCallbackFwd);
-    yapiRegisterTimedReportCallback(jFunctionTimedReportCallbackFwd);
-}
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    stopNotifications
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_stopNotifications(JNIEnv * env, jclass thisObj)
-{
-    yapiRegisterFunctionUpdateCallback(NULL);
-    yapiRegisterTimedReportCallback(NULL);
-    (*env)->DeleteGlobalRef(env, jObj);
-    jObj = NULL;
-    jvm = NULL;
-}
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    usbProcess
- * Signature: (Lcom/yoctopuce/YoctoAPI/YUSBHub;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_usbProcess(JNIEnv *env, jclass thisObj, jobject yUSBHubRef)
-{
-    char        errmsg[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-
-    if(YISERR(res=yapiHandleEvents(errmsg))) {
-        throwYAPI_Exception(env, errmsg);
-    }
-}
-
-
-
-#endif
--- a/Sources/cpplib/yapi/yjni.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*********************************************************************
- *
- * $Id: yjni.h 21719 2015-10-09 14:44:06Z seb $
- *
- * Declaration of public entry points to the low-level API
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class com_yoctopuce_YoctoAPI_YJniWrapper */
-
-#ifndef _Included_com_yoctopuce_YoctoAPI_YJniWrapper
-#define _Included_com_yoctopuce_YoctoAPI_YJniWrapper
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    getAPIVersion
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_getAPIVersion
-  (JNIEnv *, jclass);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    reserveUSBAccess
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_reserveUSBAccess
-  (JNIEnv *, jclass);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    releaseUSBAccess
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_releaseUSBAccess
-  (JNIEnv *, jclass);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    getBootloaders
- * Signature: ()Ljava/util/ArrayList;
- */
-JNIEXPORT jobject JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_getBootloaders
-  (JNIEnv *, jclass);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    updateDeviceList
- * Signature: (Ljava/util/ArrayList;Ljava/util/ArrayList;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_updateDeviceList
-  (JNIEnv *, jclass, jobject, jobject);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    devRequestSync
- * Signature: (Ljava/lang/String;[B)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_devRequestSync
-  (JNIEnv *, jclass, jstring, jbyteArray);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    devRequestAsync
- * Signature: (Ljava/lang/String;[BLcom/yoctopuce/YoctoAPI/YGenericHub/RequestAsyncResult;Ljava/lang/Object;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_devRequestAsync
-  (JNIEnv *, jclass, jstring, jbyteArray, jobject, jobject);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    startNotifications
- * Signature: (Lcom/yoctopuce/YoctoAPI/YUSBHub;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_startNotifications
-  (JNIEnv *, jclass, jobject);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    stopNotifications
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_stopNotifications
-  (JNIEnv *, jclass);
-
-/*
- * Class:     com_yoctopuce_YoctoAPI_YJniWrapper
- * Method:    usbProcess
- * Signature: (Lcom/yoctopuce/YoctoAPI/YUSBHub;)V
- */
-JNIEXPORT void JNICALL Java_com_yoctopuce_YoctoAPI_YJniWrapper_usbProcess
-  (JNIEnv *, jclass, jobject);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
--- a/Sources/cpplib/yapi/yjson.c
+++ /dev/null
@@ -1,490 +0,0 @@
-/*********************************************************************
- *
- * $Id: yjson.c 29354 2017-11-29 17:09:16Z seb $
- *
- * Simple JSON parser (actually a slightly enhanced lexer)
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__  "yjson"
-#include <string.h>
-#include "yjson.h"
-
-#ifdef MICROCHIP_API
-#define atoi      parseUInt
-#else
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef WINDOWS_API
-#if defined(__BORLANDC__)
-#pragma warn -8019
-#include <windows.h>
-#pragma warn +8019
-#else
-#include <windows.h>
-#endif
-#endif
-#endif
-
-#ifdef DEBUG_JSON_PARSE
-const char* yJsonStateStr[] = {
-    "YJSON_HTTP_START",       // about to parse HTTP header, up to first space before return code
-    "YJSON_HTTP_READ_CODE",   // reading HTTP return code
-    "YJSON_HTTP_READ_MSG",    // reading HTTP return message
-    "YJSON_HTTP_SKIP",        // skipping rest of HTTP header until double-CRLF
-    "YJSON_START",            // about to parse JSON reply
-    "YJSON_PARSE_ANY",        // parsing anything to come
-    "YJSON_PARSE_SYMBOL",     // parsing a symbol (boolean)
-    "YJSON_PARSE_NUM",        // parsing a number
-    "YJSON_PARSE_STRING",     // parsing a quoted string
-    "YJSON_PARSE_STRINGQ",    // parsing a quoted string, within quoted character
-    "YJSON_PARSE_STRINGCONT", // parsing the continuation of a quoted string
-    "YJSON_PARSE_STRINGCONTQ",// parsing the continuation of a quoted string, within quoted character
-    "YJSON_PARSE_ARRAY",      // parsing an unnamed array
-    "YJSON_PARSE_STRUCT",     // parsing a named structure
-    "YJSON_PARSE_MEMBSTART",  // parsing a structure member (before name)
-    "YJSON_PARSE_MEMBNAME",   // parsing a structure member name
-    "YJSON_PARSE_MEMBCOL",    // parsing the colon between member name and value
-    "YJSON_PARSE_DONE",       // parse completed, end of input data (or end of container)
-    "YJSON_PARSE_ERROR"       // dead end, parse error encountered
-};
-#endif
-
-yJsonRetCode yJsonParse(yJsonStateMachine *j)
-{
-    yJsonRetCode    res;
-    yJsonState      st = j->st;
-    _FAR const char *src = j->src;
-    _FAR const char *end = j->end;
-    char            *pt = j->pt;
-    char            *ept = j->token + sizeof(j->token) - 1;
-    unsigned char   c=0;
-
-skip:
-    res = YJSON_NEED_INPUT;
-    if(st == YJSON_HTTP_START || st == YJSON_START || st == YJSON_PARSE_ANY) {
-        j->next = YJSON_PARSE_SPECIAL;
-    } else if(j->next != YJSON_PARSE_SPECIAL) {
-        st = j->next;
-        j->next = YJSON_PARSE_SPECIAL;
-    }
-
-    while(1) {
-        switch(st) {
-            case YJSON_HTTP_START:       // about to parse HTTP header, up to first space before return code
-                while(src < end && (c = *src) != ' ' && c != 'O' && c != '\r') src++;
-                if(src >= end) goto done;
-                if(c == ' ') src++; // skip space
-                pt = j->token;
-                st = YJSON_HTTP_READ_CODE;
-                // fall through
-            case YJSON_HTTP_READ_CODE:   // reading HTTP return code
-                while(src < end && pt < ept && (c = *src) != ' ' && c != 'O' && c != '\r') {
-                    if(c < '0' || c > '9') goto push_error;
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                if(pt >= ept) goto push_error;
-                if(c == ' ') src++; // skip space
-                else if(c == 'O' && pt == j->token) {
-                    // Handle short status "OK" as "HTTP/1.1 200 OK"
-                    *pt++ = '2';*pt++ = '0';*pt++ = '0';
-                }
-                *pt = 0;
-                pt = j->token;
-                j->next = YJSON_HTTP_READ_MSG;
-                res = YJSON_PARSE_AVAIL;
-                goto done;
-            case YJSON_HTTP_READ_MSG:    // reading HTTP return message
-                while(src < end && pt < ept && (c = *src) != '\r' && c != '\n') {
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                *pt = 0;
-                pt = j->token;
-                j->next = YJSON_HTTP_SKIP;
-                res = YJSON_PARSE_AVAIL;
-                goto done;
-            case YJSON_HTTP_SKIP:        // skipping rest of HTTP header until double-CRLF
-                while(src < end && pt < j->token+2) {
-                    c = *src++;
-                    if(c == '\n') *pt++ = '\n';
-                    else if(c != '\r') pt = j->token;
-                }
-                if(src >= end) goto done;
-                st = YJSON_START;
-                // fall through
-            case YJSON_START:            // about to parse JSON reply
-                j->depth = 0;
-                j->skipcnt = 0;
-                j->skipdepth = YJSON_MAX_DEPTH;
-                // fall through
-            case YJSON_PARSE_ANY:        // parsing anything to come
-                while(src < end && ((c = *src) == ' ' || c == '\r' || c == '\n')) src++;
-                if(src >= end) goto done;
-                pt = j->token;
-                if(c == '{') {
-#ifndef YAPI_IN_YDEVICE
-                    j->state_start = src;
-#endif
-                    src++; st = YJSON_PARSE_STRUCT;
-
-                }
-                else if(c == '[') {
-#ifndef YAPI_IN_YDEVICE
-                    j->state_start = src;
-#endif
-                    src++; st = YJSON_PARSE_ARRAY;
-                }
-                else if(c == '"') {
-#ifndef YAPI_IN_YDEVICE
-                    j->state_start = src;
-#endif
-                    src++; st = YJSON_PARSE_STRING;
-                }
-                else if(c=='-' || (c >= '0' && c <= '9')) {
-#ifndef YAPI_IN_YDEVICE
-                    j->state_start = src;
-#endif
-                    st = YJSON_PARSE_NUM;
-                }
-                else if(c >= 'A' && c <= 'z') {
-#ifndef YAPI_IN_YDEVICE
-                    j->state_start = src;
-#endif
-                    st = YJSON_PARSE_SYMBOL;
-                }
-                else if(j->depth > 0 && c == ']') { st = YJSON_PARSE_DONE; }
-                else goto push_error;
-                // continue into the selected state
-                continue;
-            case YJSON_PARSE_SYMBOL:     // parsing a symbol (boolean)
-                while(src < end && pt < ept && (c = *src) >= 'A' && c <= 'z') {
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                if(pt >= ept) goto push_error;
-            token_done:
-                *pt = 0;
-                j->next = YJSON_PARSE_DONE;
-#ifndef YAPI_IN_YDEVICE
-                j->state_end = src;
-#endif
-                res = YJSON_PARSE_AVAIL;
-                goto done;
-            case YJSON_PARSE_NUM:        // parsing a number
-                while(src < end && pt < ept && ( (c = *src)=='-' || (c >= '0' && c <= '9') ))  {
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                if(pt >= ept) goto push_error;
-                goto token_done;
-            case YJSON_PARSE_STRING:     // parsing a quoted string
-            case YJSON_PARSE_STRINGCONT: // parsing the continuation of a quoted string
-                while(src < end && pt < ept && (c = *src) != '"' && c != '\\') {
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                if(pt >= ept) {
-                    *pt = 0;
-                    pt = j->token;
-                    j->next = YJSON_PARSE_STRINGCONT;
-                    res = YJSON_PARSE_AVAIL;
-                    goto done;
-                }
-                src++; // skip double-quote or backslash
-                if(c == '"') goto token_done;
-                if (st == YJSON_PARSE_STRING) {
-                    st = YJSON_PARSE_STRINGQ;
-                } else {
-                    st = YJSON_PARSE_STRINGCONTQ;
-                }
-                // fall through
-            case YJSON_PARSE_STRINGQ:    // parsing a quoted string, within quoted character
-            case YJSON_PARSE_STRINGCONTQ:// parsing the continuation of a quoted string, within quoted character
-                if(src >= end) goto done;
-                c = *src++;
-                switch(c) {
-                    case 'r': *pt++ = '\r'; break;
-                    case 'n': *pt++ = '\n'; break;
-                    case 't': *pt++ = '\t'; break;
-                    default: *pt++ = c;
-                }
-                if (st == YJSON_PARSE_STRINGQ) {
-                    st = YJSON_PARSE_STRING;
-                } else {
-                    st = YJSON_PARSE_STRINGCONT;
-                }
-                // continue string parsing;
-                continue;
-            case YJSON_PARSE_ARRAY:      // parsing an unnamed array
-                while(src < end && (*src == ' ' || *src == '\r' || *src == '\n')) src++;
-                if(src >= end) goto done;
-                if(*src == ']') {
-                    j->next = YJSON_PARSE_DONE;
-                }else{
-                    j->next = YJSON_PARSE_ANY;
-                }
-                c = '[';
-                goto nest;
-            case YJSON_PARSE_STRUCT:     // parsing a named structure
-                j->next = YJSON_PARSE_MEMBSTART;
-                c = '{';
-            nest:
-                if(j->depth >= YJSON_MAX_DEPTH) goto push_error;
-                j->stack[j->depth++] = st;
-                *pt++ = c;
-                *pt = 0;
-                res = YJSON_PARSE_AVAIL;
-                goto done;
-            case YJSON_PARSE_MEMBSTART:  // parsing a structure member (before name)
-                while(src < end && ((c = *src) == ' ' || c == '\r' || c == '\n')) src++;
-                if(src >= end) goto done;
-                if(c == '}') {
-                    st = YJSON_PARSE_DONE;
-                    continue;
-                }
-                if(c != '"') goto push_error;
-                src++;
-                pt = j->token;
-                st = YJSON_PARSE_MEMBNAME;
-                // fall through
-            case YJSON_PARSE_MEMBNAME:   // parsing a structure member name
-                while(src < end && pt < ept && (c = *src) != '"') {
-                    *pt++ = c;
-                    src++;
-                }
-                if(src >= end) goto done;
-                if(pt >= ept) goto push_error;
-                src++;
-                *pt = 0;
-                j->next = YJSON_PARSE_MEMBCOL;
-                res = YJSON_PARSE_AVAIL;
-                goto done;
-            case YJSON_PARSE_MEMBCOL:    // parsing the colon between member name and value
-                while(src < end && ((c = *src) == ' ' || c == '\r' || c == '\n')) src++;
-                if(src >= end) goto done;
-                if(c != ':') goto push_error;
-                src++;
-                st = YJSON_PARSE_ANY;
-                continue; // continue parse
-            case YJSON_PARSE_DONE:       // parse completed, end of input data
-                while(src < end && ((c = *src) == ' ' || c == '\r' || c == '\n')) src++;
-                pt = j->token;
-                if(j->depth > 0) {
-                    if(src >= end) goto done;
-                    if(j->stack[j->depth-1] == YJSON_PARSE_STRUCT) {
-                        if(c == ',') { src++; st = YJSON_PARSE_MEMBSTART; }
-                        else if(c == '}') goto un_nest;
-                        else goto push_error;
-                    } else { // YJSON_PARSE_ARRAY
-                        if(c == ',') { src++; st = YJSON_PARSE_ANY; }
-                        else if(c == ']') {
-            un_nest:
-                            *pt++ = *src++;
-                            st = j->stack[--(j->depth)];
-                            goto token_done;
-                        }
-                        else goto push_error;
-                    }
-                    continue; // continue to parse nested block
-                }
-                if(src < end) goto push_error; // unexpected content at end of JSON data
-                *pt = 0;
-                res = YJSON_SUCCESS;
-                goto done;
-                // save current state if possible, and trigger an error
-            push_error:
-                if(j->depth < YJSON_MAX_DEPTH)
-                    j->stack[j->depth++] = st;
-                st = YJSON_PARSE_ERROR;
-                // fall through
-            case YJSON_PARSE_ERROR:      // dead end, parse error encountered
-                res = YJSON_FAILED;
-                goto done;
-            case YJSON_PARSE_SPECIAL:    // should never happen
-                res = YJSON_FAILED;
-                goto done;
-        }
-    }
-done:
-    if(st >= YJSON_START  && res == YJSON_PARSE_AVAIL) {
-        if(j->skipdepth <= j->depth) {
-            if(j->skipdepth == j->depth) {
-                j->skipdepth = YJSON_MAX_DEPTH;
-            }
-            goto skip;
-        }
-        if(j->skipcnt > 0) {
-            if(st == YJSON_PARSE_STRUCT || st == YJSON_PARSE_ARRAY) {
-                j->skipdepth = j->depth-1;
-            }
-            j->skipcnt--;
-            goto skip;
-        }
-    }
-    j->st = st;
-    j->src = src;
-    j->pt = pt;
-    return res;
-}
-
-void yJsonSkip(yJsonStateMachine *j, int nitems)
-{
-    j->skipcnt += nitems;
-}
-
-#if 0
-void yJsonInitEx(yJsonStateMachineEx *j, const char *jzon, int jzon_len, const char *ref, int ref_len)
-{
-
-    memset(j, 0, sizeof(yJsonStateMachineEx));
-    j->jzon.src = jzon;
-    j->jzon.end = jzon + jzon_len;
-    j->jzon.st = YJSON_START;
-    if (ref) {
-        j->ref.src = ref;
-        j->ref.end = ref + ref_len;
-        j->ref.st = YJSON_START;
-    }
-    j->sst = JZON_PARSE_SYNCRO;
-}
-
-
-yJsonRetCode yJsonParseEx(yJsonStateMachineEx *j)
-{
-    yJsonRetCode  ref_res;
-    if (j->ref.src == NULL) {
-        ref_res = yJsonParse(&j->jzon);
-        j->st = j->jzon.st;
-        j->next = j->jzon.next;
-        memcpy(j->token, j->jzon.token, sizeof(j->token));
-        return ref_res;
-    }
-
-    switch (j->sst) {
-    case JZON_PARSE_SYNCRO:
-        ref_res = yJsonParse(&j->ref);
-        if (ref_res != YJSON_PARSE_AVAIL) {
-            return ref_res;
-        }
-        ref_res = yJsonParse(&j->jzon);
-        if (ref_res != YJSON_PARSE_AVAIL) {
-            return ref_res;
-        }
-        switch (j->ref.st) {
-        case YJSON_PARSE_STRUCT:
-            if (j->jzon.st == YJSON_PARSE_ARRAY) {
-                j->sst = JZON_PARSE_ONLY_REF;
-            }
-            j->sst_stack[j->depth++] = j->sst;
-            // no break on purpose
-        case YJSON_PARSE_MEMBNAME:
-            j->st = j->ref.st;
-            j->next = j->ref.next;
-            memcpy(j->token, j->ref.token, sizeof(j->token));
-            break;
-        case YJSON_PARSE_STRING:
-            // skip value with potential continuation
-            while (j->ref.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j->ref) == YJSON_PARSE_AVAIL);
-            if (j->jzon.next == YJSON_PARSE_STRINGCONT) {
-                j->sst = JZON_PARSE_ONLY_YZON;
-            }
-            //no break on purpose
-        default:
-            j->st = j->jzon.st;
-            j->next = j->jzon.next;
-            memcpy(j->token, j->jzon.token, sizeof(j->token));
-            if (j->next == YJSON_PARSE_DONE) {
-                j->sst = j->sst_stack[j->depth - 1];
-            }
-            break;
-        }
-        break;
-    case JZON_PARSE_ONLY_REF:
-        ref_res = yJsonParse(&j->ref);
-        if (ref_res != YJSON_PARSE_AVAIL) {
-            return -1;
-        }
-        j->st = j->ref.st;
-        j->next = j->ref.next;
-        memcpy(j->token, j->ref.token, sizeof(j->token));
-        if (j->ref.st == YJSON_PARSE_MEMBNAME) {
-            j->sst = JZON_PARSE_SYNCRO;
-        }
-        break;
-    case JZON_PARSE_ONLY_YZON:
-        ref_res = yJsonParse(&j->jzon);
-        if (ref_res != YJSON_PARSE_AVAIL) {
-            return -1;
-        }
-        j->st = j->jzon.st;
-        j->next = j->jzon.next;
-        memcpy(j->token, j->jzon.token, sizeof(j->token));
-        if (j->jzon.next != YJSON_PARSE_STRINGCONT) {
-            j->sst = JZON_PARSE_SYNCRO;
-        }
-        break;
-    }
-
-    return YJSON_PARSE_AVAIL;
-}
-
-
-void yJsonSkipEx(yJsonStateMachineEx *j, int nitems)
-{
-    if (j->ref.src == NULL) {
-        j->jzon.skipcnt += nitems;
-        return;
-    }
-    switch (j->sst) {
-    case JZON_PARSE_SYNCRO:
-        j->ref.skipcnt += nitems;
-        j->jzon.skipcnt += nitems;
-        break;
-
-    case JZON_PARSE_ONLY_REF:
-        j->ref.skipcnt += nitems;
-        break;
-    case JZON_PARSE_ONLY_YZON:
-        j->jzon.skipcnt += nitems;
-        break;
-    }
-}
-#endif
-
--- a/Sources/cpplib/yapi/yjson.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*********************************************************************
- *
- * $Id: yjson.h 27215 2017-04-21 10:07:14Z seb $
- *
- * Simple JSON parser (actually a slightly enhanced lexer)
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YJSON_H
-#define YJSON_H
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-#include "ydef.h"
-
-//#define DEBUG_JSON_PARSE
-#define YJSON_MAX_DEPTH     6
-
-typedef enum {
-    YJSON_HTTP_START,       // about to parse HTTP header, up to first space before return code
-    YJSON_HTTP_READ_CODE,   // reading HTTP return code
-    YJSON_HTTP_READ_MSG,    // reading HTTP return message
-    YJSON_HTTP_SKIP,        // skipping rest of HTTP header until double-CRLF
-    YJSON_START,            // about to parse JSON reply
-    YJSON_PARSE_ANY,        // parsing anything to come
-    YJSON_PARSE_SYMBOL,     // parsing a symbol (boolean)
-    YJSON_PARSE_NUM,        // parsing a number
-    YJSON_PARSE_STRING,     // parsing a quoted string
-    YJSON_PARSE_STRINGQ,    // parsing a quoted string, within quoted character
-    YJSON_PARSE_STRINGCONT, // parsing the continuation of a quoted string
-    YJSON_PARSE_STRINGCONTQ,// parsing the continuation of a quoted string, within quoted character
-    YJSON_PARSE_ARRAY,      // parsing an unnamed array
-    YJSON_PARSE_STRUCT,     // parsing a named structure
-    YJSON_PARSE_MEMBSTART,  // parsing a structure member (before name)
-    YJSON_PARSE_MEMBNAME,   // parsing a structure member name
-    YJSON_PARSE_MEMBCOL,    // parsing the colon between member name and value
-    YJSON_PARSE_DONE,       // parse completed, end of input data (or end of container)
-    YJSON_PARSE_ERROR,      // dead end, parse error encountered
-    YJSON_PARSE_SPECIAL = -1
-} yJsonState;
-
-#ifdef DEBUG_JSON_PARSE
-extern const char* yJsonStateStr[];
-#endif
-
-
-
-typedef struct {
-    _FAR const char *src;               // pointer to source buffer to parse (initialized by caller)
-    _FAR const char *end;               // pointer to end of source data (initialized by caller)
-    yJsonState  st;                     // current state (initialized by caller)
-    yJsonState  next;                   // next state (when returning with parse_avail)
-    yJsonState  stack[YJSON_MAX_DEPTH]; // state stack for handling nested structures
-    int         depth;                  // state stack depth
-    char        token[62];              // parse buffer, also used to return tokens
-    char        *pt;                    // pointer in token buffer
-    int         skipcnt;                // number of items to skip
-    int         skipdepth;              // stack depth at which skipping started
-#ifndef YAPI_IN_YDEVICE
-    _FAR const char *state_start;       // pointer to the start of the current state
-    _FAR const char *state_end;         // pointer to end of of the current state
-#endif
-} yJsonStateMachine;
-
-
-typedef enum {
-    YJSON_NEED_INPUT,       // caller need to provide fresh input data
-    YJSON_PARSE_AVAIL,      // caller need to process current state and token
-    YJSON_SUCCESS,          // caller can take a break
-    YJSON_FAILED            // caller should consider using better input data
-} yJsonRetCode;
-
-// Parse JSON input stream until more data is needed or a token is returned
-yJsonRetCode yJsonParse(yJsonStateMachine *j);
-
-// Mark next n JSON items in stream to be skipped (including content, in case items are containers)
-void         yJsonSkip(yJsonStateMachine *j, int nitems);
-
-#if 0
-
-    typedef enum {
-        JZON_PARSE_SYNCRO = 0,
-        JZON_PARSE_ONLY_REF,
-        JZON_PARSE_ONLY_YZON
-    } yJzonSyncroState;
-
-    typedef struct {
-        int         depth;                  // state stack depth
-        yJzonSyncroState sst;
-        yJzonSyncroState sst_stack[YJSON_MAX_DEPTH];
-        yJsonState  st;                     // current state (initialized by caller)
-        yJsonState  next;                   // next state (when returning with parse_avail)
-        char        token[62];              // parse buffer, also used to return tokens
-        yJsonStateMachine  jzon;       // reference state machine (initialized by caller)
-        yJsonStateMachine  ref;       // reference state machine (initialized by caller)
-    } yJsonStateMachineEx;
-
-    void yJsonInitEx(yJsonStateMachineEx *j, const char *jzon, int jzon_len, const char *ref, int ref_len);
-
-    // Parse JSON input stream until more data is needed or a token is returned
-    yJsonRetCode yJsonParseEx(yJsonStateMachineEx *j);
-
-    // Mark next n JSON items in stream to be skipped (including content, in case items are containers)
-    void         yJsonSkipEx(yJsonStateMachineEx *j, int nitems);
-#endif
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
-
-
--- a/Sources/cpplib/yapi/ykey.c
+++ /dev/null
@@ -1,700 +0,0 @@
-/*********************************************************************
- *
- * $Id: ykey.c 24251 2016-04-26 13:38:08Z seb $
- *
- * Implementation of standard key computations
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__  "ydef"
-#include "ykey.h"
-
-#ifdef MICROCHIP_API
-#include "Yocto/yocto.h"
-#include "Yocto/yapi_ext.h"
-#define ntohl(dw) swapl(dw)
-#else
-#include <string.h>
-#include "yproto.h"
-#endif
-
-static char btohexa_low_high(u8 b)
-{
-    b >>= 4;
-    return (b>9u) ? b+'a'-10 : b+'0';
-}
-
-static char btohexa_low_low(u8 b)
-{
-    b &= 0x0F;
-    return (b>9u) ? b+'a'-10 : b+'0';
-}
-
-void bin2str(char *to, const u8 *p, u16 len, u8 addnull)
-{
-    for (; len--; p++) {
-    	*to++ = btohexa_low_high(*p);
-    	*to++ = btohexa_low_low(*p);
-    }
-    if(addnull) *to = '\0';
-}
-
-#if !defined(MICROCHIP_API) || defined(HTTP_ON_NET)
-
-//#define DEBUG_HTTP_AUTHENTICATION
-
-// compute the ha1 (in binary form)
-void ComputeAuthHA1(u8 *ha1, const char *user, const char *pass, const char *realm)
-{
-    HASH_SUM ctx;
-
-    MD5Initialize(&ctx);
-    MD5AddData(&ctx, (u8*)user, YSTRLEN(user));
-    MD5AddData(&ctx, (u8*)":", 1);
-    MD5AddData(&ctx, (u8*)realm, YSTRLEN(realm));
-    MD5AddData(&ctx, (u8*)":", 1);
-    MD5AddData(&ctx, (u8*)pass, YSTRLEN(pass));
-    MD5Calculate(&ctx, ha1);
-#ifdef DEBUG_HTTP_AUTHENTICATION
-    {
-        char     tmpha[HTTP_AUTH_MD5_STRLEN + 1];
-        bin2str(tmpha, ha1, HTTP_AUTH_MD5_SIZE, 1);
-        dbglog("Compute HA1 u=%s r=%s p=%s -> %s\n", user, realm, pass, tmpha);
-    }
-#endif
-}
-
-// compute the ha2 (in binary form)
-void ComputeAuthHA2(u8 *ha2, const char *method, const char *uri)
-{
-    HASH_SUM ctx;
-
-    MD5Initialize(&ctx);
-    MD5AddData(&ctx, (u8*)method, YSTRLEN(method));
-    MD5AddData(&ctx, (u8*)":",  1);
-    MD5AddData(&ctx, (u8*)uri,    YSTRLEN(uri));
-    MD5Calculate(&ctx, ha2);
-#ifdef DEBUG_HTTP_AUTHENTICATION
-    {
-        char     tmpha[HTTP_AUTH_MD5_STRLEN + 1];
-        bin2str(tmpha, ha2, HTTP_AUTH_MD5_SIZE, 1);
-        dbglog("Compute HA2 m=%s u=%s -> %s\n", method, uri, tmpha);
-    }
-#endif
-}
-
-
-// Return stringified MD5 hash for the specified parameters
-void ComputeAuthResponse(char *buf, const u8 *ha1, const char *nonce, const char *nc,  const char *cnonce, const u8* ha2)
-{
-    u8       hash[HTTP_AUTH_MD5_SIZE];
-    char     tmpha[HTTP_AUTH_MD5_STRLEN+1];
-    HASH_SUM ctx;
-
-    MD5Initialize(&ctx);
-    // convert ha1 into str before using it
-    bin2str(tmpha, ha1, HTTP_AUTH_MD5_SIZE,1);
-    MD5AddData(&ctx, (u8*)tmpha,  HTTP_AUTH_MD5_STRLEN);
-    MD5AddData(&ctx, (u8*)":",  1);
-    MD5AddData(&ctx, (u8*)nonce,  YSTRLEN(nonce));
-    MD5AddData(&ctx, (u8*)":",  1);
-    if(nc && cnonce) {
-        MD5AddData(&ctx, (u8*)nc,     YSTRLEN(nc));
-        MD5AddData(&ctx, (u8*)":",  1);
-        MD5AddData(&ctx, (u8*)cnonce, YSTRLEN(cnonce));
-        MD5AddData(&ctx, (u8*)":auth:",  6);
-    }
-    bin2str(tmpha, ha2, HTTP_AUTH_MD5_SIZE,1);
-    MD5AddData(&ctx, (u8*)tmpha, HTTP_AUTH_MD5_STRLEN);
-    MD5Calculate(&ctx,hash);
-    bin2str(buf, hash, HTTP_AUTH_MD5_SIZE,1);
-#ifdef DEBUG_HTTP_AUTHENTICATION
-    {
-        char     tmpha1[HTTP_AUTH_MD5_STRLEN + 1];
-        bin2str(tmpha1, ha1, HTTP_AUTH_MD5_SIZE, 1);
-        if (nc && cnonce) {
-            dbglog("Auth Resp ha1=%s nonce=%s nc=%s cnouce=%s ha2=%s -> %s\n",
-                tmpha1, nonce, nc, cnonce, tmpha, buf);
-        } else {
-            dbglog("Auth Resp ha1=%s nonce=%s (no nc/cnounce) ha2=%s -> %s\n",
-                tmpha1, nonce, tmpha, buf);
-        }
-    }
-#endif
-}
-
-
-// Return stringified sha1 hash for the specified parameters
-int CheckWSAuth(u32 nonce, const u8 *ha1, const u8 *to_verify, u8 *out)
-{
-    char     tmpbuff[HTTP_AUTH_MD5_STRLEN + 8 + 1];
-    const u8 * sha1;
-    int res;
-
-    // convert ha1 into str before using it
-    bin2str(tmpbuff, ha1, HTTP_AUTH_MD5_SIZE, 1);
-#ifdef DEBUG_HTTP_AUTHENTICATION
-    dbglog("ha1=%s\n", tmpbuff);
-#endif
-    // convert ha1 into str before using it
-#ifdef CPU_BIG_ENDIAN
-    nonce = INTEL_U32(nonce);
-#endif
-    bin2str(tmpbuff + HTTP_AUTH_MD5_STRLEN, (u8*) &nonce, 4, 1);
-#ifdef DEBUG_HTTP_AUTHENTICATION
-    dbglog("full=%s\n", tmpbuff);
-#endif
-    sha1 = ySHA1(tmpbuff);
-    if (out) {
-        memcpy(out, sha1, 20);
-    }
-    if (to_verify == NULL) {
-        return 0;
-    }
-    res = memcmp(sha1, to_verify, 20)==0;
-    return res;
-}
-
-// Parse a request header, return 0 if a valid WWW-Authenticate header and set args to corresponding fields
-// - Request is patched in place to null-terminate each field.
-// - If return value is 0, at least method,realm and qop are set to non-NULL value
-// - qop is set to an empty string if not specified in thq authenticate header
-int yParseWWWAuthenticate(char *replybuf, int replysize, char **method, char **realm, char **qop, char **nonce, char **opaque)
-{
-    int     pos = 0;
-    char    *p=replybuf, *start;
-
-    while(pos < replysize) {
-        while(pos < replysize && replybuf[pos] != '\r') pos++;
-        if(pos < replysize && replybuf[++pos] == '\n') pos++;
-        // new line, look for authorization header (always at least 25 chars)
-        if(pos+25 >= replysize) return -1;
-        if(YSTRNICMP(replybuf+pos, "WWW-Authenticate:", 17) != 0) continue;
-        // header found, keep a pointer to content and make sure it is complete
-        pos += 17;
-        p = replybuf + pos;
-        while(pos < replysize && replybuf[pos] != '\r') pos++;
-        break;
-    }
-    if(pos >= replysize) return -1;
-    replybuf[pos] = 0;
-    // we now have a full null-terminated authentication header to parse at p
-    while(*p == ' ') p++;
-    start = p;
-    while(*p && *p != ' ') p++;
-    // we expect at least a realm after the method name
-    if(!*p) return -1;
-    // method found, followed by something. Set default realm and qop to an empty string
-    *method = start;
-    *realm  = replybuf+pos;
-    *qop    = replybuf+pos;
-    // null-terminate the method name, and proceed to named parameters
-    *p++ = 0;
-    while(*p) {
-        while(*p == ' ' || *p == ',') p++;
-        if(!*p) break;
-        if(YSTRNICMP(p,"realm=\"",7) == 0) {
-            p += 7;
-            start = p;
-            while(*p && *p != '\"') p++;
-            if(!*p) return -1;
-            *p++ = 0; // replace quote by NUL
-            *realm = start;
-        } else if(YSTRNICMP(p,"qop=\"",5) == 0) {
-            p += 5;
-            start = p;
-            while(*p && *p != '\"') p++;
-            if(!*p) return -1;
-            *p++ = 0; // replace quote by NUL
-            *qop = start;
-        } else if(YSTRNICMP(p,"nonce=\"",7) == 0) {
-            p += 7;
-            start = p;
-            while(*p && *p != '\"') p++;
-            if(!*p) return -1;
-            *p++ = 0; // replace quote by NUL
-            *nonce = start;
-        } else if(YSTRNICMP(p,"opaque=\"",8) == 0) {
-            p += 8;
-            start = p;
-            while(*p && *p != '\"') p++;
-            if(!*p) return -1;
-            *p++ = 0; // replace quote by NUL
-            *opaque = start;
-        } else {
-            // skip unknown tag
-            while(*p && *p != ',') p++;
-        }
-    }
-    // if no non-empty realm has been specified, the authentication header is not valid
-    if(!**realm) return -1;
-
-    return 0;
-}
-
-extern u32 yapiGetCNonce(u32 nc);
-
-// Write an authorization header in the buffer provided
-// method and uri can be provided in the same memory zone as destination if needed
-void yDigestAuthorization(char *buf, int bufsize, const char *user, const char *realm, const u8 *ha1,
-                          const char *nonce, const char *opaque, u32 *nc, const char *method, const char *uri)
-{
-    u32     cnonce;
-    char    ncbuf[9], cnoncebuf[9];
-    u8      ha2[HTTP_AUTH_MD5_SIZE];
-    int     len;
-
-    ComputeAuthHA2(ha2, method, uri);
-    YSTRCPY(buf, bufsize, "Authorization: Digest username=\"");
-    YSTRCAT(buf, bufsize, user);
-    YSTRCAT(buf, bufsize, "\", realm=\"");
-    YSTRCAT(buf, bufsize, realm);
-    YSTRCAT(buf, bufsize, "\", nonce=\"");
-    YSTRCAT(buf, bufsize, nonce);
-    YSTRCAT(buf, bufsize, "\", uri=\"");
-    YSTRCAT(buf, bufsize, uri);
-    if(nc) {
-        (*nc)++;
-        cnonce = yapiGetCNonce(*nc);
-        yxtoa(*nc, ncbuf, sizeof(ncbuf)-1);
-        yxtoa(cnonce, cnoncebuf, sizeof(cnoncebuf)-1);
-        len = (int)strlen(buf);
-        buf += len;
-        bufsize -= len;
-        YSTRCAT(buf, bufsize, "\", qop=auth, nc=");
-        YSTRCAT(buf, bufsize, ncbuf);
-        YSTRCAT(buf, bufsize, ", cnonce=\"");
-        YSTRCAT(buf, bufsize, cnoncebuf);
-    }
-    YSTRCAT(buf, bufsize, "\", response=\"");
-    len = (int)strlen(buf);
-    buf += len;
-    bufsize -= len;
-    ComputeAuthResponse(buf, ha1, nonce, (nc?ncbuf:NULL), (nc?cnoncebuf:NULL), ha2);
-    if(opaque) {
-        len = (int)strlen(buf);
-        buf += len;
-        bufsize -= len;
-        YSTRCAT(buf, bufsize, "\", opaque=\"");
-        YSTRCAT(buf, bufsize, opaque);
-    }
-    YSTRCAT(buf, bufsize, "\"\r\n");
-}
-
-// State variables used during key computation
-typedef struct {
-    int iter;
-    int pos;
-    u32 inner[5];
-    u32 outer[5];
-    u32 shau[5];
-    u32 shaw[80];
-    u8  res[32];
-} WPA_CALC_STATE;
-
-static WPA_CALC_STATE wpak = { -1 };
-
-const u32 sha1_init[5] = { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 };
-
-static void initshaw(const char *s, u16 ofs, u8 pad, u16 xinit)
-{
-    int ii, j = -1, k = 0;
-    int n = (int)strlen(s);
-
-    for(ii = 0; ii < 64; ii++) {
-        int i = ofs + ii;
-        u8  c = 0;
-        if (i < n) {
-            c = s[i];
-        } else if (pad) {
-            if (pad & 0x80) {
-                if (i == n) c = pad;
-            } else {
-                if (i == n + 3) c = pad;
-                else if (i == n + 4) c = 0x80;
-            }
-        }
-        if (k == 0) {
-            j++;
-            wpak.shaw[j] = 0;
-            k = 32;
-        }
-        k -= 8;
-        wpak.shaw[j] |= ((u32)c << k);
-    }
-    if(pad) {
-        if(pad == 0x80) {
-            if(n <= ofs+55) {
-                wpak.shaw[15] = 8 * n;
-            }
-        } else {
-            wpak.shaw[15] = 8 * (n + 68);
-        }
-    }
-    if(xinit) {
-        u32 xdw = ((u32)xinit << 16) | xinit;
-        for (j = 0; j < 16; j++) {
-            wpak.shaw[j] ^= xdw;
-        }
-    }
-}
-
-static void itershaw(const u32 *s)
-{
-    u32 a, b, c, d, e, t;
-    int k;
-
-    a = s[0];
-    b = s[1];
-    c = s[2];
-    d = s[3];
-    e = s[4];
-    for (k = 16; k < 80; k++) {
-        t = wpak.shaw[k - 3] ^ wpak.shaw[k - 8] ^ wpak.shaw[k - 14] ^ wpak.shaw[k - 16];
-        wpak.shaw[k] = (t << 1) | (t >> 31);
-    }
-    for (k = 0; k < 20; k++) {
-        t = ((a << 5) | (a >> 27)) + e + wpak.shaw[k] + 0x5A827999 + ((b & c) | ((~b) & d));
-        e = d;
-        d = c;
-        c = (b << 30) | (b >> 2);
-        b = a;
-        a = t;
-    }
-    for (k = 20; k < 40; k++) {
-        t = ((a << 5) | (a >> 27)) + e + wpak.shaw[k] + 0x6ED9EBA1 + (b^c^d);
-        e = d;
-        d = c;
-        c = (b << 30) | (b >> 2);
-        b = a;
-        a = t;
-    }
-    for (k = 40; k < 60; k++) {
-        t = ((a << 5) | (a >> 27)) + e + wpak.shaw[k] + 0x8F1BBCDC + ((b & c) | (b & d) | (c & d));
-        e = d;
-        d = c;
-        c = (b << 30) | (b >> 2);
-        b = a;
-        a = t;
-    }
-    for (k = 60; k < 80; k++) {
-        t = ((a << 5) | (a >> 27)) + e + wpak.shaw[k] + 0xCA62C1D6 + (b^c^d);
-        e = d;
-        d = c;
-        c = (b << 30) | (b >> 2);
-        b = a;
-        a = t;
-    }
-    wpak.shaw[0] = s[0] + a;
-    wpak.shaw[1] = s[1] + b;
-    wpak.shaw[2] = s[2] + c;
-    wpak.shaw[3] = s[3] + d;
-    wpak.shaw[4] = s[4] + e;
-}
-
-u8  *ySHA1(const char *text)
-{
-    int ofs = 0, n = (int)strlen(text);
-
-    memcpy((u8 *)wpak.shau, (u8 *)sha1_init, sizeof(wpak.shau));
-    do {
-        initshaw(text, ofs, 0x80, 0);
-        itershaw(wpak.shau);
-        memcpy((u8 *)wpak.shau, (u8 *)wpak.shaw, sizeof(wpak.shau));
-        ofs += 64;
-    } while(n > ofs-9);
-#ifndef CPU_BIG_ENDIAN
-    for(ofs = 0; ofs < 5; ofs++) {
-        wpak.shau[ofs] = ntohl(wpak.shau[ofs]);
-    }
-#endif
-
-    return (u8 *)wpak.shau;
-}
-
-void yInitPsk(const char *pass, const char *ssid)
-{
-    // precompute part of sha used in the loops
-    initshaw(pass, 0, 0, 0x3636);
-    itershaw(sha1_init);
-    memcpy(wpak.inner, wpak.shaw, sizeof(wpak.inner));
-
-    initshaw(pass, 0, 0, 0x5c5c);
-    itershaw(sha1_init);
-    memcpy(wpak.outer, wpak.shaw, sizeof(wpak.outer));
-
-    // prepare to compute first 20 bytes
-    wpak.pos = 0;
-    wpak.iter = 0;
-    memset(wpak.shau, 0, sizeof(wpak.shau));
-    initshaw(ssid, 0, 1, 0);
-}
-
-int yIterPsk(u8 *res, const char *ssid)
-{
-    int k;
-
-    if(wpak.iter < 0) return -1;
-    if(wpak.iter >= 8192) return 0;
-    itershaw(wpak.inner);
-    wpak.shaw[5] = 0x80000000;
-    for (k = 6; k < 15; k++) {
-        wpak.shaw[k] = 0;
-    }
-    wpak.shaw[15] = 8 * (64 + 20);
-    itershaw(wpak.outer);
-    wpak.shau[0] ^= wpak.shaw[0];
-    wpak.shau[1] ^= wpak.shaw[1];
-    wpak.shau[2] ^= wpak.shaw[2];
-    wpak.shau[3] ^= wpak.shaw[3];
-    wpak.shau[4] ^= wpak.shaw[4];
-    wpak.iter++;
-    // after 4096 loops, move to 2nd half of sha1
-    if((wpak.iter & 4095) == 0) {
-        for(k = 0; k < 5 && wpak.pos < 32; k++) {
-            wpak.res[wpak.pos++] = (wpak.shau[k] >> 24) & 0xff;
-            wpak.res[wpak.pos++] = (wpak.shau[k] >> 16) & 0xff;
-            wpak.res[wpak.pos++] = (wpak.shau[k] >> 8) & 0xff;
-            wpak.res[wpak.pos++] = wpak.shau[k] & 0xff;
-        }
-        if(wpak.iter == 4096) {
-            memset(wpak.shau, 0, sizeof(wpak.shau));
-            initshaw(ssid, 0,2, 0);
-        } else {
-            // done
-            memcpy(res, wpak.res, 32);
-            return 0;
-        }
-    }
-    // return 1 to ask for more loops
-    return 1;
-}
-
-#endif
-
-#ifndef MICROCHIP_API
-/*
- * MD5 implementation below is mostly from Sergey Lyubka, author of SHTTPD.
- * Any other implementation would do as well, but we like this one.
- * This code has been published by Sergey under his "THE BEER-WARE LICENSE" (Revision 42):
- *
- *   Sergey Lyubka wrote this software. As long as you retain this notice you
- *   can do whatever you want with this stuff. If we meet some day, and you think
- *   this stuff is worth it, you can buy me a beer in return.
- */
-
-#ifndef CPU_BIG_ENDIAN
-#define byteReverse(buf, len) // Do nothing
-#else
-static void byteReverse(unsigned char *buf, unsigned longs) {
-    u32 t;
-    do {
-        t = (u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
-        ((unsigned) buf[1] << 8 | buf[0]);
-        *(u32 *) buf = t;
-        buf += 4;
-    } while (--longs);
-}
-#endif
-
-#define F1(x, y, z) (z ^ (x & (y ^ z)))
-#define F2(x, y, z) F1(z, x, y)
-#define F3(x, y, z) (x ^ y ^ z)
-#define F4(x, y, z) (y ^ (x | ~z))
-
-#define MD5STEP(f, w, x, y, z, data, s) \
-( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
-// initialization constants.
-void MD5Initialize(HASH_SUM *ctx)
-{
-    ctx->buf[0] = 0x67452301;
-    ctx->buf[1] = 0xefcdab89;
-    ctx->buf[2] = 0x98badcfe;
-    ctx->buf[3] = 0x10325476;
-
-    ctx->bits[0] = 0;
-    ctx->bits[1] = 0;
-}
-
-static void MD5Transform(u32 buf[4], u32 const in[16])
-{
-    register u32 a, b, c, d;
-
-    a = buf[0];
-    b = buf[1];
-    c = buf[2];
-    d = buf[3];
-
-    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
-    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
-    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
-    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
-    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
-    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
-    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
-    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
-    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
-    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
-    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
-    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
-    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
-    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
-    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
-    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
-
-    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
-    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
-    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
-    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
-    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
-    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
-    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
-    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
-    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
-    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
-    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
-    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
-    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
-    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
-    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
-    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
-
-    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
-    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
-    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
-    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
-    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
-    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
-    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
-    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
-    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
-    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
-    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
-    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
-    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
-    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
-    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
-    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
-
-    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
-    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
-    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
-    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
-    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
-    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
-    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
-    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
-    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
-    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
-    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
-    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
-    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
-    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
-    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
-    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
-
-    buf[0] += a;
-    buf[1] += b;
-    buf[2] += c;
-    buf[3] += d;
-}
-
-void MD5AddData(HASH_SUM *ctx,  const u8 *buf, u32 len)
-{
-    u32 t;
-
-    t = ctx->bits[0];
-    if ((ctx->bits[0] = t + ((u32) len << 3)) < t)
-        ctx->bits[1]++;
-    ctx->bits[1] += len >> 29;
-
-    t = (t >> 3) & 0x3f;
-
-    if (t) {
-        unsigned char *p = (unsigned char *) ctx->in + t;
-
-        t = 64 - t;
-        if (len < t) {
-            memcpy(p, buf, len);
-            return;
-        }
-        memcpy(p, buf, t);
-        byteReverse(ctx->in, 16);
-        MD5Transform(ctx->buf, (u32 *) ctx->in);
-        buf += t;
-        len -= t;
-    }
-
-    while (len >= 64) {
-        memcpy(ctx->in, buf, 64);
-        byteReverse(ctx->in, 16);
-        MD5Transform(ctx->buf, (u32 *) ctx->in);
-        buf += 64;
-        len -= 64;
-    }
-
-    memcpy(ctx->in, buf, len);
-}
-
-void MD5Calculate(HASH_SUM *ctx, u8 digest[16])
-{
-    unsigned count;
-    unsigned char *p;
-
-    count = (ctx->bits[0] >> 3) & 0x3F;
-
-    p = ctx->in + count;
-    *p++ = 0x80;
-    count = 64 - 1 - count;
-    if (count < 8) {
-        memset(p, 0, count);
-        byteReverse(ctx->in, 16);
-        MD5Transform(ctx->buf, (u32 *) ctx->in);
-        memset(ctx->in, 0, 56);
-    } else {
-        memset(p, 0, count - 8);
-    }
-    byteReverse(ctx->in, 14);
-
-    ctx->in32[14] = ctx->bits[0];
-    ctx->in32[15] = ctx->bits[1];
-
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-    byteReverse((unsigned char *) ctx->buf, 4);
-    memcpy(digest, ctx->buf, 16);
-    memset((char *) ctx, 0, sizeof(*ctx));
-}
-#endif
-
--- a/Sources/cpplib/yapi/ykey.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*********************************************************************
- *
- * $Id: ykey.h 23001 2016-02-01 16:36:18Z seb $
- *
- * Declaration of standard key computations
- *
- * - - - - - - - - - License information: - - - - - - - - - 
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing 
- *  with Yoctopuce products. 
- *
- *  You may reproduce and distribute copies of this file in 
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain 
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and 
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YKEY_H
-#define YKEY_H
-#include "ydef.h"
-
-void bin2str(char *to, const u8 *p, u16 len,u8 addnull);
-
-// HTTP digest authentication support
-
-#define HTTP_AUTH_MD5_SIZE      16
-#define HTTP_AUTH_MD5_STRLEN    (HTTP_AUTH_MD5_SIZE*2)
-
-void ComputeAuthHA1(u8 *buf, const char *user, const char *pass, const char *realm);
-void ComputeAuthHA2(u8 *buf, const char *method, const char *url) ;
-void ComputeAuthResponse(char *buf,  const u8 * ha1,  const char *nonce, const char *nc,  const char *cnonce,  const u8 *ha2);
-int  CheckWSAuth(u32 nonce, const u8 *ha1, const u8 *to_verify, u8 *out);
-
-// Parse a request header, return 0 if a valid WWW-Authenticate header and set args to corresponding fields
-// - Request is patched in place to null-terminate each field.
-// - If return value is 0, at least method,realm and qop are set to non-NULL value
-// - qop is set to an empty string if not specified in thq authenticate header
-int yParseWWWAuthenticate(char *replybuf, int replysize, char **method, char **realm, char **qop, char **nonce, char **opaque);
-
-// Fill in buf with a proper digest authorization header
-void yDigestAuthorization(char *buf, int bufsize, const char *user, const char *realm, const u8 *ha1, 
-                          const char *nonce, const char *opaque, u32 *nc, const char *method, const char *uri);
-
-// Note: This API is designed for cooperative multitasking
-//       It is not multithread-safe
-void yInitPsk(const char *pass, const char *ssid);
-int  yIterPsk(u8 *res, const char *ssid);
-u8   *ySHA1(const char *text);
-
-// MD5 hash structures
-#ifndef MICROCHIP_API
-typedef struct {
-    u32 buf[4];
-    u32 bits[2];
-    union {
-        u8   in[64];
-        u32  in32[16];
-    };
-} HASH_SUM;
-
-void MD5Initialize(HASH_SUM *theSum);
-void MD5AddData(HASH_SUM *theSum, const u8* data, u32 len);
-void MD5Calculate(HASH_SUM *theSum, u8* result);
-#endif
-
-#endif
--- a/Sources/cpplib/yapi/ymemory.c
+++ /dev/null
@@ -1,392 +0,0 @@
-/*********************************************************************
- *
- * $Id: ymemory.c 33698 2018-12-14 07:50:14Z seb $
- *
- * Basic memory check function to prevent memory leak
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "ymemory"
- // do not use microsoft secure string
-#define _CRT_SECURE_NO_DEPRECATE
-#define YMEMORY_ALLOW_MALLOC
-#include "yproto.h"
-
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#ifdef WINDOWS_API
-#include <time.h>
-#else
-#include <sys/time.h>
-#endif
-
-
-#ifdef YSAFE_MEMORY
-typedef  enum{
-    YMEM_NOT_USED=0,
-    YMEM_MALLOCED,
-    YMEM_FREED
-} YMEM_STATE;
-
-typedef struct{
-    YMEM_STATE  state;
-    const char *malloc_file;
-    u32         malloc_line;
-    u32         malloc_size;
-    const char *free_file;
-    u32         free_line;
-    void        *ptr;
-} YMEM_ENTRY;
-
-YMEM_ENTRY          *yMap    = NULL;
-u32                 yMapSize = 0;
-u32                 yMapUsed = 0;
-yCRITICAL_SECTION   yMapCS;
-
-
-
-static void ymemdumpentry(YMEM_ENTRY *entry,const char* prefix)
-{
-    dbglog("%s %lX: alloc %s:%d of %db, free %s:%d\n",prefix,entry->ptr,entry->malloc_file,entry->malloc_line,entry->malloc_size,entry->free_file,entry->free_line);
-}
-
-
-static void  ymemdump(void)
-{
-    u32 i;
-    YMEM_ENTRY *entry;
-    u32 total,count;
-
-    dbglog("ySafeMemoryDump: %d/%d entry\n\n", yMapUsed, yMapSize);
-    dbglog("Malloc:\n");
-    total=count=0;
-    for(i=0, entry=yMap; i< yMapUsed ; i++,entry++){
-        if(entry->state == YMEM_MALLOCED){
-            ymemdumpentry(entry,"");
-            dbglog("%s : %d of %db (0x%x)\n", entry->malloc_file, entry->malloc_line, entry->malloc_size, entry->ptr);
-            total+= entry->malloc_size;
-            count++;
-        }
-    }
-    dbglog("total: %db (%d Kb) on %d entry\n\n",total,(int)(total/1024),count);
-#if 0
-    dbglog("Free:\n");
-    for(i=0, entry=yMap; i< yMapUsed ; i++,entry++){
-        if(entry->state == YMEM_FREED){
-            dbglog("alloc %s:%d of %db, free %s:%d\n",entry->malloc_file,entry->malloc_line,entry->malloc_size,entry->free_file,entry->free_line);
-        }
-    }
-#endif
-}
-
-
-
-void ySafeMemoryInit(u32 nbentry)
-{
-    YASSERT(yMap==NULL);
-    YASSERT(yMapSize==0);
-    yInitializeCriticalSection(&yMapCS);
-    yEnterCriticalSection(&yMapCS);
-    yMap = malloc(nbentry *sizeof(YMEM_ENTRY));
-    if(yMap){
-        yMapSize = nbentry;
-        memset(yMap,0,nbentry *sizeof(YMEM_ENTRY));
-        yMapUsed=0;
-    }
-    yLeaveCriticalSection(&yMapCS);
-}
-
-void *ySafeMalloc(const char *file,u32 line,u32 size)
-{
-    u32 i;
-    YMEM_ENTRY *entry;
-    void *ptr;
-
-    yEnterCriticalSection(&yMapCS);
-    if(yMapUsed < yMapSize){
-        //use a new one
-        entry=yMap+yMapUsed;
-    }else{
-        // find a freed entry
-        for(i=0; i< yMapSize;i++){
-            if(yMap[i].state == YMEM_FREED)
-                break;
-        }
-        if(i==yMapSize){
-            dbglog("No more entry available for ySafeMalloc\n\n");
-            ymemdump();
-            yLeaveCriticalSection(&yMapCS);
-            return NULL;
-        }
-        entry = yMap+i;
-    }
-
-    ptr=malloc(size);
-    if(!ptr){
-        dbglog("No more memory available (unable to allocate %d bytes)\n\n",size);
-        ymemdump();
-        yLeaveCriticalSection(&yMapCS);
-        return NULL;
-    }
-
-    memset(entry,0,sizeof(YMEM_ENTRY));
-    entry->state = YMEM_MALLOCED;
-    entry->malloc_file = file;
-    entry->malloc_line = line;
-    entry->ptr  = ptr;
-    entry->malloc_size = size;
-    if(yMapUsed < yMapSize)
-        yMapUsed++;
-    yLeaveCriticalSection(&yMapCS);
-
-    return ptr;
-}
-
-void  ySafeFree(const char *file,u32 line,void *ptr)
-{
-    u32 i;
-    YMEM_ENTRY *entry;
-
-    yEnterCriticalSection(&yMapCS);
-    for(i=0, entry=yMap; i< yMapUsed ; i++,entry++){
-        YASSERT(entry->state != YMEM_NOT_USED);
-        if(entry->ptr == ptr)
-            break;
-    }
-    if(i == yMapUsed){
-        dbglog("Free of unallocated pointer 0x%x at %s:%d\n\n",ptr,file,line);
-        ymemdump();
-        YASSERT(0);
-    }
-    if(entry->state == YMEM_FREED){
-        dbglog("Free of already freed pointer (0x%x) at %s:%d\n",ptr,file,line);
-        dbglog("was allocated at %s:%d size =%d freed at %s:%d\n\n",
-            entry->malloc_file, entry->malloc_line, entry->malloc_size, entry->free_file,entry->free_line);
-        ymemdump();
-        YASSERT(0);
-    }
-    free(entry->ptr);
-    entry->free_file = file;
-    entry->free_line = line;
-    entry->state = YMEM_FREED;
-    entry->ptr=NULL;
-
-    yLeaveCriticalSection(&yMapCS);
-}
-
-void  ySafeTrace(const char *file,u32 line,void *ptr)
-{
-    u32 i;
-    YMEM_ENTRY *entry;
-
-    yEnterCriticalSection(&yMapCS);
-    for(i=0, entry=yMap; i< yMapUsed ; i++,entry++){
-        YASSERT(entry->state != YMEM_NOT_USED);
-        if(entry->ptr == ptr)
-            break;
-    }
-    if(i == yMapUsed){
-        dbglog("Update trace of unallocated pointer 0x%x at %s:%d\n\n",ptr,file,line);
-        ymemdump();
-        YASSERT(0);
-    }
-    if(entry->state == YMEM_FREED){
-        dbglog("Update trace of already freed pointer (0x%x) at %s:%d\n",ptr,file,line);
-        dbglog("was allocated at %s:%d size =%d freed at %s:%d\n\n",
-               entry->malloc_file, entry->malloc_line, entry->malloc_size, entry->free_file,entry->free_line);
-        ymemdump();
-        YASSERT(0);
-    }
-    ymemdumpentry(entry,"trace");
-    entry->malloc_file = file;
-    entry->malloc_line = line;
-    yLeaveCriticalSection(&yMapCS);
-}
-
-void  ySafeMemoryDump(void *discard)
-{
-    u32 i;
-    YMEM_ENTRY *entry;
-
-    yEnterCriticalSection(&yMapCS);
-    for(i=0, entry=yMap; i< yMapUsed ; i++,entry++){
-        if(entry->state == YMEM_MALLOCED && entry->ptr!=discard){
-            break;
-        }
-    }
-    if(i< yMapUsed){
-        ymemdump();
-    } else {
-        dbglog("No memory leak detected\n");
-    }
-    yLeaveCriticalSection(&yMapCS);
-}
-
-
-void  ySafeMemoryStop(void)
-{
-    yDeleteCriticalSection(&yMapCS);
-    free(yMap);
-    yMap=NULL;
-    yMapSize = yMapUsed = 0;
-}
-
-#endif
-
-
-// return the min of strlen and maxlen
-static unsigned ystrnlen(const char *src,unsigned maxlen)
-{
-    unsigned len;
-    for (len=0 ; *src && len < maxlen ;len++,src++);
-    return len;
-}
-
-YRETCODE ystrcpy_s(char *dst, unsigned dstsize,const char *src)
-{
-
-    return ystrncpy_s(dst,dstsize,src,dstsize);
-}
-
-
-char* ystrdup_s(const char *src)
-{
-    int len = YSTRLEN(src);
-    char *tmp = yMalloc(len+1);
-    memcpy(tmp, src, len + 1);
-    return tmp;
-}
-
-
-YRETCODE ystrcat_s(char *dst, unsigned dstsize,const char *src)
-{
-    return ystrncat_s(dst, dstsize, src, dstsize);
-}
-
-int ysprintf_s(char *dst, unsigned dstsize,const char *fmt ,...)
-{
-    int len;
-    va_list args;
-    va_start( args, fmt );
-    len = yvsprintf_s(dst,dstsize,fmt,args);
-    va_end(args);
-    return len;
-}
-
-YRETCODE ystrncpy_s(char *dst,unsigned dstsize,const char *src,unsigned arglen)
-{
-    unsigned len;
-
-    if (dst==NULL){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (src==NULL){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if(dstsize ==0){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    len = ystrnlen(src,arglen);
-    if(len+1 > dstsize){
-        YPANIC;
-        dst[0]=0;
-        return YAPI_INVALID_ARGUMENT;
-    }else{
-        memcpy(dst,src,len);
-        dst[len]=0;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-YRETCODE ystrncat_s(char *dst, unsigned dstsize,const char *src,unsigned len)
-{
-    unsigned dstlen;
-    if (dst==NULL){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (src==NULL){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    dstlen = ystrnlen(dst, dstsize);
-    if(dstlen+1 > dstsize){
-        YPANIC;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return ystrncpy_s(dst+dstlen, dstsize-dstlen, src, len);
-}
-
-
-int yvsprintf_s (char *dst, unsigned dstsize, const char * fmt, va_list arg )
-{
-    int len;
-#if defined(_MSC_VER) && (_MSC_VER <= MSC_VS2003)
-    len = _vsnprintf(dst,dstsize,fmt,arg);
-#else
-    len = vsnprintf(dst,dstsize,fmt,arg);
-#endif
-    if(len <0 || len >=(long)dstsize){
-        YPANIC;
-        dst[dstsize-1]=0;
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return len;
-}
-
-int ymemfind(const u8 *haystack, u32 haystack_len, const u8 *needle, u32 needle_len)
-{
-    u32 abspos = 0;
-    u32 needle_pos = 0;
-
-    do {
-        while (needle_pos < needle_len && (abspos + needle_pos)<haystack_len && needle[needle_pos] == haystack[abspos + needle_pos]) {
-            needle_pos++;
-        }
-        if (needle_pos == needle_len) {
-            return abspos;
-        } else {
-            abspos++;
-            needle_pos = 0;
-        }
-    } while (abspos + needle_len < haystack_len);
-    return -1;
-}
-
-
--- a/Sources/cpplib/yapi/ymemory.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*********************************************************************
- *
- * $Id: ymemory.h 19326 2015-02-17 17:29:00Z seb $
- *
- * Basic memory check function to prevent memory leak
- *
- * - - - - - - - - - License information: - - - - - - - - - 
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing 
- *  with Yoctopuce products. 
- *
- *  You may reproduce and distribute copies of this file in 
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain 
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and 
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YMEMORY_H
-#define YMEMORY_H
-#include "ydef.h"
-
-#ifdef YSAFE_MEMORY
-void  ySafeMemoryInit(u32 nbentry);
-void* ySafeMalloc(const char *file,u32 line,u32 size);
-void  ySafeFree(const char *file,u32 line,void *ptr);
-void  ySafeTrace(const char *file,u32 line,void *ptr);
-void  ySafeMemoryDump(void *discard);
-void  ySafeMemoryStop(void);
-#else
-#define ySafeMemoryInit(nbentry) {}
-#define ySafeMemoryDump(discard) {}
-#define ySafeMemoryStop() {}
-#endif
-
-#endif
--- a/Sources/cpplib/yapi/ypkt_lin.c
+++ /dev/null
@@ -1,759 +0,0 @@
-/*********************************************************************
- *
- * $Id: ypkt_lin.c 33735 2018-12-14 16:06:53Z seb $
- *
- * OS-specific USB packet layer, Linux version
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "ypkt_lin"
-#include "yapi.h"
-#ifdef LINUX_API
-#include "yproto.h"
-#include <pthread.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-#define yLinSetErr(intro, err,errmsg)  yLinSetErrEx(__LINE__,intro, err,errmsg)
-
-static int yLinSetErrEx(u32 line,char *intro, int err,char *errmsg)
-{
-    const char *msg;
-    if(errmsg==NULL)
-        return YAPI_IO_ERROR;
-     switch(err){
-        case LIBUSB_SUCCESS:            msg="Success (no error)";break;
-        case LIBUSB_ERROR_IO:           msg="Input/output error"; break;
-        case LIBUSB_ERROR_INVALID_PARAM:msg="Invalid parameter"; break;
-        case LIBUSB_ERROR_ACCESS:       msg="Access denied (insufficient permissions)"; break;
-        case LIBUSB_ERROR_NO_DEVICE:    msg="No such device (it may have been disconnected)"; break;
-        case LIBUSB_ERROR_NOT_FOUND:    msg="Entity not found"; break;
-        case LIBUSB_ERROR_BUSY:         msg="Resource busy"; break;
-        case LIBUSB_ERROR_TIMEOUT:      msg="Operation timed out"; break;
-        case LIBUSB_ERROR_OVERFLOW:     msg="Overflow"; break;
-        case LIBUSB_ERROR_PIPE:         msg="Pipe error"; break;
-        case LIBUSB_ERROR_INTERRUPTED:  msg="System call interrupted (perhaps due to signal)"; break;
-        case LIBUSB_ERROR_NO_MEM:       msg="Insufficient memory"; break;
-        case LIBUSB_ERROR_NOT_SUPPORTED:msg="Operation not supported or unimplemented on this platform"; break;
-        default:
-        case LIBUSB_ERROR_OTHER:        msg="Other error"; break;
-    }
-    if (intro){
-        YSPRINTF(errmsg,YOCTO_ERRMSG_LEN,"%s:%s",intro,msg);
-    } else{
-        YSPRINTF(errmsg,YOCTO_ERRMSG_LEN,"LIN(%d):%s",line,msg);
-    }
-    HALLOG("LIN(%d):%s\n",line,msg);
-    return YAPI_IO_ERROR;
-};
-
-
- /*****************************************************************
- * USB ENUMERATION
-*****************************************************************/
-
-
-#define YOCTO_LOCK_PIPE "/tmp/.yoctolock"
-
-int pid_lock_fd = -1;
-
-
-// return 1 if we can reserve access to the device 0 if the device
-// is already reserved
-static int yReserveGlobalAccess(yContextSt *ctx, char *errmsg)
-{
-    int fd;
-    int chk_val, mypid, usedpid = 0;
-    size_t res;
-    mode_t mode = 0666;
-    mode_t oldmode = umask(0000);
-    char msg[YOCTO_ERRMSG_LEN];
-
-    HALLOG("old mode (%#o)\n",oldmode);
-    HALLOG("create fifo with (%#o)\n",mode);
-    if(mkfifo(YOCTO_LOCK_PIPE,mode)<0) {
-        HALLOG("unable to create lock fifo (%d:%s)\n",errno,strerror(errno));
-    }
-    umask(oldmode);
-    fd = open(YOCTO_LOCK_PIPE,O_RDWR|O_NONBLOCK);
-    if(fd<0){
-        HALLOG("unable to open lock fifo (%d)\n",errno);
-        if(errno==EACCES) {
-            return YERRMSG(YAPI_DOUBLE_ACCES, "we do not have access to lock fifo");
-        }else{
-            // we cannot open lock file so we cannot really
-            // check double instance so we assume that we are
-            // alone
-            return YAPI_SUCCESS;
-        }
-    }
-    chk_val = 0;
-    mypid = (int) getpid();
-    res = read(fd, &chk_val, sizeof(chk_val));
-    if (res == sizeof(chk_val)) {
-        //there is already someone
-        usedpid = chk_val;
-    } else{
-        // nobody there -> store my PID
-        chk_val = mypid;
-    }
-    res = write(fd, &chk_val, sizeof(chk_val));
-    if(res != sizeof(chk_val)) {
-        YSPRINTF(msg, YOCTO_ERRMSG_LEN, "Write to lock fifo failed (%d)", res);
-        close(fd);
-        return YERRMSG(YAPI_DOUBLE_ACCES, msg);
-    }
-    if (usedpid != 0) {
-        if (usedpid == 1) {
-            close(fd);
-            // locked by api that not store the pid
-            return YERRMSG(YAPI_DOUBLE_ACCES, "Another process is already using yAPI");
-        } else {
-            YSPRINTF(msg, YOCTO_ERRMSG_LEN, "Another process (pid %d) is already using yAPI", (u32) usedpid);
-            close(fd);
-            return YERRMSG(YAPI_DOUBLE_ACCES, msg);
-        }
-    }
-    pid_lock_fd = fd;
-    return YAPI_SUCCESS;
-}
-
-
-size_t dropwarning;
-
-static void yReleaseGlobalAccess(yContextSt *ctx)
-{
-    int chk_val;
-    if(pid_lock_fd >=0){
-        dropwarning = read(pid_lock_fd,&chk_val,sizeof(chk_val));
-        close(pid_lock_fd);
-        pid_lock_fd = -1;
-      }
-}
-
-typedef struct {
-    libusb_device *dev;
-    int desc_index;
-    int len;
-    char *string;
-    u64 expiration;
-} stringCacheSt;
-
-#define STRING_CACHE_SIZE 16
-#define STRING_CACHE_EXPIRATION 60000 //1 minutes
-static stringCacheSt stringCache[STRING_CACHE_SIZE];
-
-
-// on success data point to a null terminated string of max length-1 characters
-static int getUsbStringASCII(yContextSt *ctx, libusb_device_handle *hdl, libusb_device *dev, u8 desc_index, char *data, u32 length)
-{
-    u8  buffer[512];
-    u32 l,len;
-    int res,i;
-    stringCacheSt *c = stringCache;
-    stringCacheSt *f = NULL;
-    u64 now = yapiGetTickCount();
-
-    yEnterCriticalSection(&ctx->string_cache_cs);
-
-    for (i = 0; i < STRING_CACHE_SIZE; i++, c++) {
-        if (c->expiration > now) {
-            if(c->dev == dev && c->desc_index == desc_index) {
-                if (c->len > 0 && c->string) {
-                    len = c->len;
-                    if (c->len >= length)
-                        len = length-1;
-                    memcpy(data, c->string,  len);
-                    data[len] = 0;
-                    HALENUMLOG("return string from cache (%p:%d->%s)\n",dev,desc_index,c->string);
-                    yLeaveCriticalSection(&ctx->string_cache_cs);
-                    return c->len;
-                } else {
-                    f = c;
-                    break;
-                }
-            }
-        } else {
-            if (c->string) {
-                yFree(c->string);
-                c->string =NULL;
-            }
-            if (f == NULL) {
-                f = c;
-            }
-        }
-    }
-
-    res=libusb_control_transfer(hdl, LIBUSB_ENDPOINT_IN,
-        LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING << 8) | desc_index,
-        0, buffer, 512, 10000);
-    if(res<0) {
-        yLeaveCriticalSection(&ctx->string_cache_cs);
-        return res;
-    }
-
-    len=(buffer[0]-2)/2;
-    if (len >= length) {
-        len = length - 1;
-    }
-
-    for (l = 0; l < len; l++){
-        data[l] = (char) buffer[2+(l*2)];
-    }
-    data[len] = 0;
-
-    if (f != NULL) {
-        f->dev = dev;
-        f->desc_index = desc_index;
-        f->string = yMalloc(len+1);
-        memcpy(f->string, data, len+1);
-        f->len  = len;
-        f->expiration = yapiGetTickCount() + STRING_CACHE_EXPIRATION;
-        HALENUMLOG("add string to cache (%p:%d->%s)\n",dev,desc_index,f->string);
-    }
-    yLeaveCriticalSection(&ctx->string_cache_cs);
-
-    return len;
-}
-
-
-int process_libusb_events(yContextSt *ctx, int ms, char * errmsg)
-{
-    int res;
-    struct timeval tv;
-    memset(&tv, 0, sizeof(tv));
-    tv.tv_sec = ms / 1000;
-    tv.tv_usec = (ms % 1000) * 1000;
-    res = libusb_handle_events_timeout(ctx->libusb, &tv);
-    if (res < 0) {
-        yLinSetErr("libusb_handle_events_timeout", res, errmsg);
-    }
-    return res;
-}
-
-
-static void *event_thread(void *param)
-{
-    yContextSt *ctx = (yContextSt*)param;
-    char            errmsg[YOCTO_ERRMSG_LEN];
-    ctx->usb_thread_state = USB_THREAD_RUNNING;
-    /* Non-blocking. See if the OS has any reports to give. */
-    HALLOG("Start event_thread run loop\n");
-    while (ctx->usb_thread_state != USB_THREAD_MUST_STOP) {
-        int res = process_libusb_events(ctx, 1000, errmsg);
-        if (res < 0) {
-            yLinSetErr("libusb_handle_events_timeout", res,errmsg);
-            break;
-        }
-    }
-    HALLOG("event_thread run loop stopped\n");
-    ctx->usb_thread_state = USB_THREAD_STOPED;
-    return NULL;
-}
-
-
-int yyyUSB_init(yContextSt *ctx,char *errmsg)
-{
-    int res;
-
-    YPROPERR(yReserveGlobalAccess(ctx, errmsg));
-    memset(stringCache, 0, sizeof(stringCache));
-    yInitializeCriticalSection(&ctx->string_cache_cs);
-    res = libusb_init(&ctx->libusb);
-    if(res !=0){
-        return yLinSetErr("Unable to start lib USB", res,errmsg);
-    }
-#if 0
-    {
-        const struct libusb_version *libusb_v;
-        libusb_v = libusb_get_version();
-        dbglog("Use libUSB v%d.%d.%d.%d\n", libusb_v->major, libusb_v->minor, libusb_v->micro, libusb_v->nano);
-    }
-#endif
-    ctx->usb_thread_state = USB_THREAD_NOT_STARTED;
-    pthread_create(&ctx->usb_thread, NULL, event_thread, ctx);
-    //wait thread start
-    while(ctx->usb_thread_state != USB_THREAD_RUNNING){
-        usleep(50000);
-    }
-
-    return YAPI_SUCCESS;
-}
-
-
-int yyyUSB_stop(yContextSt *ctx,char *errmsg)
-{
-    int i;
-    stringCacheSt *c = stringCache;
-
-    if(ctx->usb_thread_state == USB_THREAD_RUNNING){
-        ctx->usb_thread_state = USB_THREAD_MUST_STOP;
-        pthread_join(ctx->usb_thread,NULL);
-    }
-    YASSERT(ctx->usb_thread_state == USB_THREAD_STOPED);
-
-    libusb_exit(ctx->libusb);
-    yReleaseGlobalAccess(ctx);
-    for (i = 0; i < STRING_CACHE_SIZE; i++, c++) {
-        if(c->string) {
-            yFree(c->string);
-        }
-    }
-    yDeleteCriticalSection(&ctx->string_cache_cs);
-
-    return YAPI_SUCCESS;
-}
-
-
-
-static int getDevConfig(libusb_device *dev, struct libusb_config_descriptor **config)
-{
-
-   int res = libusb_get_active_config_descriptor(dev,  config);
-    if(res==LIBUSB_ERROR_NOT_FOUND){
-        HALLOG("not yet configured\n");
-        if(libusb_get_config_descriptor(dev, 0, config)!=0){
-            return -1;
-        }
-    }else if(res!=0){
-        HALLOG("unable to get active configuration %d\n",res);
-        return -1;
-    }
-    return 0;
-
-}
-
-
-int yyyUSBGetInterfaces(yInterfaceSt **ifaces,int *nbifaceDetect,char *errmsg)
-{
-    libusb_device   **list;
-    ssize_t         nbdev;
-    int             returnval=YAPI_SUCCESS;
-    int             i;
-    int             alloc_size;
-    yInterfaceSt    *iface;
-
-    nbdev = libusb_get_device_list(yContext->libusb,&list);
-    if (nbdev < 0)
-        return yLinSetErr("Unable to get device list", nbdev, errmsg);
-    HALENUMLOG("%d devices found\n",nbdev);
-
-     // allocate buffer for detected interfaces
-    *nbifaceDetect = 0;
-    alloc_size = (nbdev + 1) * sizeof(yInterfaceSt);
-    *ifaces = (yInterfaceSt*) yMalloc(alloc_size);
-    memset(*ifaces, 0, alloc_size);
-
-    for (i = 0; i < nbdev; i++) {
-        int  res;
-        struct libusb_device_descriptor desc;
-        struct libusb_config_descriptor *config;
-        libusb_device_handle *hdl;
-
-        libusb_device  *dev = list[i];
-        if ((res = libusb_get_device_descriptor(dev,&desc)) != 0){
-            returnval = yLinSetErr("Unable to get device descriptor",res,errmsg);
-            goto exit;
-        }
-        if (desc.idVendor != YOCTO_VENDORID) {
-            continue;
-        }
-        HALENUMLOG("open device %x:%x\n", desc.idVendor, desc.idProduct);
-
-        if(getDevConfig(dev, &config) < 0) {
-            continue;
-        }
-        iface = (*ifaces) + (*nbifaceDetect);
-        iface->vendorid = (u16)desc.idVendor;
-        iface->deviceid = (u16)desc.idProduct;
-        iface->ifaceno  = 0;
-        iface->devref   = libusb_ref_device(dev);
-        res = libusb_open(dev, &hdl);
-        if (res == LIBUSB_ERROR_ACCESS) {
-            returnval = YERRMSG(YAPI_IO_ERROR, "the user has insufficient permissions to access USB devices");
-            goto exit;
-        }
-        if (res != 0){
-            HALENUMLOG("unable to access device %x:%x\n", desc.idVendor, desc.idProduct);
-            continue;
-        }
-        HALENUMLOG("try to get serial for %x:%x:%x (%p)\n", desc.idVendor, desc.idProduct, desc.iSerialNumber, dev);
-        res = getUsbStringASCII(yContext, hdl, dev, desc.iSerialNumber, iface->serial, YOCTO_SERIAL_LEN);
-        if (res < 0) {
-            HALENUMLOG("unable to get serial for device %x:%x\n", desc.idVendor, desc.idProduct);
-        }
-        libusb_close(hdl);
-        (*nbifaceDetect)++;
-        HALENUMLOG("----Running Dev %x:%x:%d:%s ---\n", iface->vendorid, iface->deviceid, iface->ifaceno, iface->serial);
-        libusb_free_config_descriptor(config);
-    }
-
-exit:
-    libusb_free_device_list(list,1);
-    return returnval;
-
-}
-
-
-
-// return 1 if OS hdl are identical
-//        0 if any of the interface has changed
-int yyyOShdlCompare( yPrivDeviceSt *dev, yInterfaceSt *newiface)
-{
-    if(dev->infos.nbinbterfaces != 1){
-        HALLOG("bad number of interface for %s (%d)\n",dev->infos.serial,dev->infos.nbinbterfaces);
-        return 0;
-    }
-    if(dev->iface.devref != newiface->devref){
-        HALLOG("devref has changed for %s (%X)\n",dev->infos.serial,dev->iface.devref);
-        return 0;
-    }
-
-    return 1;
-}
-
-static void rd_callback(struct libusb_transfer *transfer);
-static void wr_callback(struct libusb_transfer *transfer);
-
-
-static int sendNextPkt(yInterfaceSt *iface, char *errmsg)
-{
-    pktItem *pktitem;
-    yPktQueuePeekH2D(iface, &pktitem);
-    if (pktitem != NULL) {
-        int res;
-        memcpy(&iface->wrTr->tmppkt, &pktitem->pkt, sizeof(USB_Packet));
-        libusb_fill_interrupt_transfer( iface->wrTr->tr,
-                                iface->hdl,
-                                iface->wrendp,
-                                (u8*)&iface->wrTr->tmppkt,
-                                sizeof(USB_Packet),
-                                wr_callback,
-                                iface->wrTr,
-                                2000);
-        res = libusb_submit_transfer(iface->wrTr->tr);
-        if (res < 0) {
-            return yLinSetErr("libusb_submit_transfer(WR) failed", res, errmsg);
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int submitReadPkt(yInterfaceSt *iface, char *errmsg)
-{
-    int res;
-    libusb_fill_interrupt_transfer( iface->rdTr->tr,
-                                    iface->hdl,
-                                    iface->rdendp,
-                                    (u8*)&iface->rdTr->tmppkt,
-                                    sizeof(USB_Packet),
-                                    rd_callback,
-                                    iface->rdTr,
-                                    0);
-    res = libusb_submit_transfer(iface->rdTr->tr);
-    if (res < 0) {
-        return yLinSetErr("libusb_submit_transfer(RD) failed", res, errmsg);
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static void rd_callback(struct libusb_transfer *transfer)
-{
-    int res;
-    linRdTr      *lintr = (linRdTr*)transfer->user_data;
-    yInterfaceSt *iface = lintr->iface;
-    char          errmsg[YOCTO_ERRMSG_LEN];
-
-    if (lintr == NULL){
-        HALLOG("CBrd:drop invalid ypkt rd_callback (lintr is null)\n");
-        return;
-    }
-    if (iface == NULL){
-        HALLOG("CBrd:drop invalid ypkt rd_callback (iface is null)\n");
-        return;
-    }
-
-    switch(transfer->status){
-    case LIBUSB_TRANSFER_COMPLETED:
-        //HALLOG("%s:%d pkt_arrived (len=%d)\n",iface->serial,iface->ifaceno,transfer->actual_length);
-        yPktQueuePushD2H(iface,&lintr->tmppkt,NULL);
-        break;
-    case LIBUSB_TRANSFER_ERROR:
-        iface->ioError++;
-        HALLOG("CBrd:%s pkt error (len=%d nbError:%d)\n",iface->serial, transfer->actual_length,  iface->ioError);
-        break;
-    case LIBUSB_TRANSFER_TIMED_OUT :
-        HALLOG("CBrd:%s pkt timeout\n",iface->serial);
-        break;
-    case LIBUSB_TRANSFER_CANCELLED:
-        HALLOG("CBrd:%s pkt_cancelled (len=%d) \n",iface->serial, transfer->actual_length);
-        if (iface->flags.yyySetupDone && transfer->actual_length == 64) {
-            yPktQueuePushD2H(iface, &lintr->tmppkt, NULL);
-        }
-        return;
-    case LIBUSB_TRANSFER_STALL:
-        HALLOG("CBrd:%s pkt stall\n",iface->serial );
-        res = libusb_cancel_transfer(lintr->tr);
-        HALLOG("CBrd:%s libusb_cancel_transfer returned %d\n",iface->serial, res);
-        res = libusb_clear_halt(iface->hdl, iface->rdendp);
-        HALLOG("CBrd:%s libusb_clear_hal returned %d\n",iface->serial, res);
-        break;
-    case LIBUSB_TRANSFER_NO_DEVICE:
-        HALLOG("CBrd:%s no_device (len=%d)\n",iface->serial, transfer->actual_length);
-        return;
-    case LIBUSB_TRANSFER_OVERFLOW:
-        HALLOG("CBrd:%s pkt_overflow (len=%d)\n",iface->serial, transfer->actual_length);
-        return;
-    default:
-        HALLOG("CBrd:%s unknown state %X\n",iface->serial, transfer->status);
-        return;
-    }
-
-    if (iface->flags.yyySetupDone) {
-        res = submitReadPkt(iface, errmsg);
-        if (res < 0) {
-            HALLOG("CBrd:%s libusb_submit_transfer error %X\n", iface->serial, res);
-        }
-    }
-
-}
-
-static void wr_callback(struct libusb_transfer *transfer)
-{
-    linRdTr      *lintr = (linRdTr*)transfer->user_data;
-    yInterfaceSt *iface = lintr->iface;
-    char          errmsg[YOCTO_ERRMSG_LEN];
-    pktItem *pktitem;
-    int res;
-
-    if (lintr == NULL) {
-        HALLOG("CBwr:drop invalid ypkt wr_callback (lintr is null)\n");
-        return;
-    }
-
-    if (iface == NULL){
-        HALLOG("CBwr:drop invalid ypkt wr_callback (iface is null)\n");
-        return;
-    }
-    YASSERT(transfer == lintr->tr);
-
-    switch(transfer->status) {
-    case LIBUSB_TRANSFER_COMPLETED:
-        //HALLOG("CBwr:%s pkt_sent (len=%d)\n",iface->serial, transfer->actual_length);
-        // remove sent packet
-        yPktQueuePopH2D(iface, &pktitem);
-        yFree(pktitem);
-#if 0
-        // following code make no sense and failed on very slow computer
-        // (the main thread queue a new packet durring the yFree(pktitem);
-        res = sendNextPkt(iface, errmsg);
-        if (res < 0) {
-            HALLOG("send of next pkt item failed:%d:%s\n", res, errmsg);
-        }
-#endif
-        return;
-    case LIBUSB_TRANSFER_ERROR:
-        iface->ioError++;
-        HALLOG("CBwr:%s pkt error (len=%d nbError:%d)\n",iface->serial, transfer->actual_length,  iface->ioError);
-        break;
-    case LIBUSB_TRANSFER_TIMED_OUT :
-        HALLOG("CBwr:%s pkt timeout\n",iface->serial);
-        res = sendNextPkt(iface, errmsg);
-        if (res < 0) {
-            HALLOG("retry of next pkt item failed:%d:%s\n", res, errmsg);
-        }
-        break;
-    case LIBUSB_TRANSFER_CANCELLED:
-        HALLOG("CBwr:%s pkt_cancelled (len=%d) \n",iface->serial, transfer->actual_length);
-        break;
-    case LIBUSB_TRANSFER_STALL:
-        HALLOG("CBwr:%s pkt stall\n",iface->serial );
-        break;
-    case LIBUSB_TRANSFER_NO_DEVICE:
-        HALLOG("CBwr:%s pkt_cancelled (len=%d)\n",iface->serial, transfer->actual_length);
-        return;
-    case LIBUSB_TRANSFER_OVERFLOW:
-        HALLOG("CBwr:%s pkt_overflow (len=%d)\n",iface->serial, transfer->actual_length);
-        break;
-    default:
-        HALLOG("CBwr:%s unknown state %X\n",iface->serial, transfer->status);
-        break;
-    }
-}
-
-
-int yyySetup(yInterfaceSt *iface,char *errmsg)
-{
-    int res,j;
-    int error;
-    struct libusb_config_descriptor *config;
-    const struct libusb_interface_descriptor* ifd;
-
-
-
-    HALLOG("%s yyySetup %X:%X\n",iface->serial,iface->vendorid,iface->deviceid);
-    if(iface->devref==NULL){
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    // we need to do this as it is possible that the device was not closed properly in a previous session
-    // if we don't do this and the device wasn't closed properly odd behavior results.
-    // thanks to Rob Krakora who find this solution
-    if((res=libusb_open(iface->devref,&iface->hdl))!=0){
-        return yLinSetErr("libusb_open", res,errmsg);
-    } else {
-        libusb_reset_device(iface->hdl);
-        libusb_close(iface->hdl);
-        usleep(200);
-    }
-
-    if((res=libusb_open(iface->devref,&iface->hdl))!=0){
-        return yLinSetErr("libusb_open", res,errmsg);
-    }
-
-    if((res=libusb_kernel_driver_active(iface->hdl,iface->ifaceno))<0){
-        error= yLinSetErr("libusb_kernel_driver_active",res,errmsg);
-        goto error;
-    }
-    if (res) {
-        HALLOG("%s need to detach kernel driver\n",iface->serial);
-        if((res = libusb_detach_kernel_driver(iface->hdl,iface->ifaceno))<0){
-            error= yLinSetErr("libusb_detach_kernel_driver",res,errmsg);
-            goto error;
-        }
-    }
-
-    HALLOG("%s Claim interface\n",iface->serial);
-    if((res = libusb_claim_interface(iface->hdl,iface->ifaceno))<0){
-        error= yLinSetErr("libusb_claim_interface", res,errmsg);
-        goto error;
-    }
-
-
-    res=getDevConfig(iface->devref,&config);
-    if(res<0){
-        error=YERRMSG(YAPI_IO_ERROR,"unable to get configuration descriptor");
-        goto error;
-    }
-
-
-    ifd = &config->interface[iface->ifaceno].altsetting[0];
-    for (j = 0; j < ifd->bNumEndpoints; j++) {
-        //HALLOG("endpoint %X size=%d \n",ifd->endpoint[j].bEndpointAddress,ifd->endpoint[j].wMaxPacketSize);
-        if((ifd->endpoint[j].bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK) == LIBUSB_ENDPOINT_IN){
-            iface->rdendp = ifd->endpoint[j].bEndpointAddress;
-        }else{
-            iface->wrendp = ifd->endpoint[j].bEndpointAddress;
-        }
-    }
-    HALLOG("endpoints are rd=%d wr=%d\n", iface->rdendp,iface->wrendp);
-
-    yPktQueueInit(&iface->rxQueue);
-    yPktQueueInit(&iface->txQueue);
-    iface->rdTr = yMalloc(sizeof(linRdTr));
-    iface->wrTr = yMalloc(sizeof(linRdTr));
-    HALLOG("allocate linRdTr=%p linWrTr\n", iface->rdTr, iface->wrTr);
-    iface->wrTr->iface = iface;
-    iface->wrTr->tr = libusb_alloc_transfer(0);
-    iface->rdTr->iface = iface;
-    iface->rdTr->tr = libusb_alloc_transfer(0);
-    iface->flags.yyySetupDone = 1;
-    HALLOG("%s both libusbTR allocated (%p /%p)\n",iface->serial, iface->rdTr->tr, iface->wrTr->tr);
-    res = submitReadPkt(iface, errmsg);
-    if (res < 0) {
-        return res;
-    }
-    HALLOG("%s yyySetup done\n",iface->serial);
-
-    return YAPI_SUCCESS;
-error:
-    libusb_close(iface->hdl);
-    return error;
-}
-
-
-
-
-int yyySignalOutPkt(yInterfaceSt *iface, char *errmsg)
-{
-    return sendNextPkt(iface, errmsg);
-}
-
-
-
-void yyyPacketShutdown(yInterfaceSt  *iface)
-{
-    if (iface && iface->hdl) {
-        int res;
-        iface->flags.yyySetupDone = 0;
-        HALLOG("%s:%d cancel all transfer\n",iface->serial,iface->ifaceno);
-        if (iface->rdTr->tr) {
-            int count = 10;
-            int res =libusb_cancel_transfer(iface->rdTr->tr);
-            if(res == 0){
-                while(count && iface->rdTr->tr->status != LIBUSB_TRANSFER_CANCELLED){
-                        usleep(1000);
-                    count--;
-                }
-            }
-        }
-        HALLOG("%s:%d libusb release iface\n",iface->serial,iface->ifaceno);
-        res = libusb_release_interface(iface->hdl,iface->ifaceno);
-        if(res != 0 && res!=LIBUSB_ERROR_NOT_FOUND && res!=LIBUSB_ERROR_NO_DEVICE){
-            HALLOG("%s:%dlibusb_release_interface error\n",iface->serial,iface->ifaceno);
-        }
-
-        res = libusb_attach_kernel_driver(iface->hdl,iface->ifaceno);
-        if(res<0 && res!=LIBUSB_ERROR_NO_DEVICE){
-            HALLOG("%s:%d libusb_attach_kernel_driver error\n",iface->serial,iface->ifaceno);
-        }
-        libusb_close(iface->hdl);
-        iface->hdl = NULL;
-
-        if (iface->rdTr->tr) {
-            HALLOG("%s:%d libusb_TR free\n", iface->serial, iface->ifaceno);
-            libusb_free_transfer(iface->rdTr->tr);
-            iface->rdTr->tr = NULL;
-        }
-        yFree(iface->rdTr);
-        yPktQueueFree(&iface->rxQueue);
-        yPktQueueFree(&iface->txQueue);
-    }
-}
-
-#endif
--- a/Sources/cpplib/yapi/ypkt_osx.c
+++ /dev/null
@@ -1,575 +0,0 @@
-/*********************************************************************
- *
- * $Id: ypkt_osx.c 33735 2018-12-14 16:06:53Z seb $
- *
- * OS-specific USB packet layer, Mac OS X version
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__ "ypkt_osx"
-#include "yapi.h"
-#ifdef OSX_API
-#include "yproto.h"
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/sysctl.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-/*****************************************************************
- * USB ENUMERATION
- *****************************************************************/
-
-
-#define YOCTO_LOCK_PIPE "/tmp/.yoctolock"
-
-// return YAPI_SUCCESS if we can reserve access to the device return
-// an error if the device is already reserved
-static int yReserveGlobalAccess(yContextSt *ctx, char *errmsg)
-{
-    int fd;
-    int chk_val, mypid, usedpid = 0;
-    size_t res;
-
-    mkfifo(YOCTO_LOCK_PIPE, 0600);
-    fd = open(YOCTO_LOCK_PIPE, O_RDWR|O_NONBLOCK);
-    if (fd < 0) {
-        // we cannot open lock file so we cannot really
-        // check double instance so we assume that we are
-        // alone
-        return YAPI_SUCCESS;
-    }
-    chk_val = 0;
-    mypid = (int) getpid();
-    res = read(fd, &chk_val, sizeof(chk_val));
-    if (res == sizeof(chk_val)) {
-        //there is already someone
-        usedpid = chk_val;
-    } else{
-        // nobody there -> store my PID
-        chk_val = mypid;
-    }
-    write(fd, &chk_val, sizeof(chk_val));
-    if (usedpid != 0) {
-        if (usedpid == 1) {
-            // locked by api that not store the pid
-            return YERRMSG(YAPI_DOUBLE_ACCES, "Another process is already using yAPI");
-        } else {
-            char msg[YOCTO_ERRMSG_LEN];
-            YSPRINTF(msg, YOCTO_ERRMSG_LEN, "Another process (pid %d) is already using yAPI", (u32) usedpid);
-            return YERRMSG(YAPI_DOUBLE_ACCES, msg);
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-
-static void yReleaseGlobalAccess(yContextSt *ctx)
-{
-    int chk_val;
-    int fd = open(YOCTO_LOCK_PIPE,O_RDWR|O_NONBLOCK);
-    if(fd>=0){
-        read(fd,&chk_val,sizeof(chk_val));
-    }
-}
-
-static void *event_thread(void *param)
-{
-    yContextSt  *ctx=param;
-
-    ctx->usb_run_loop     = CFRunLoopGetCurrent();
-    ctx->usb_thread_state = USB_THREAD_RUNNING;
-    /* Non-blocking. See if the OS has any reports to give. */
-    HALLOG("Start event_thread run loop\n");
-    while (ctx->usb_thread_state != USB_THREAD_MUST_STOP) {
-        CFRunLoopRunInMode( kCFRunLoopDefaultMode, 10, FALSE);
-    }
-
-    HALLOG("event_thread run loop stopped\n");
-    ctx->usb_thread_state = USB_THREAD_STOPED;
-    return NULL;
-}
-
-
-static int setupHIDManager(yContextSt *ctx, OSX_HID_REF *hid, char *errmsg)
-{
-    int             c_vendorid = YOCTO_VENDORID;
-    CFMutableDictionaryRef dictionary;
-    CFNumberRef     Vendorid;
-    IOReturn        tIOReturn;
-
-    yInitializeCriticalSection(&hid->hidMCS);
-    // Initialize HID Manager
-    hid->manager = IOHIDManagerCreate(kCFAllocatorDefault, kIOHIDOptionsTypeNone);
-    // create dictionary to match Yocto devices
-    dictionary = CFDictionaryCreateMutable(kCFAllocatorDefault,1,&kCFTypeDictionaryKeyCallBacks,&kCFTypeDictionaryValueCallBacks);
-    Vendorid = CFNumberCreate( kCFAllocatorDefault, kCFNumberIntType, &c_vendorid );
-    CFDictionarySetValue( dictionary, CFSTR( kIOHIDVendorIDKey ), Vendorid );
-    CFRelease(Vendorid);
-    // register the dictionary
-    IOHIDManagerSetDeviceMatching(hid->manager, dictionary );
-    // now we can release the dictionary
-    CFRelease(dictionary);
-    // schedule the HID Manager with our global run loop
-    IOHIDManagerScheduleWithRunLoop(hid->manager, ctx->usb_run_loop, kCFRunLoopDefaultMode);
-
-    // Now open the IO HID Manager reference
-    tIOReturn = IOHIDManagerOpen(hid->manager, kIOHIDOptionsTypeNone );
-    if(kIOReturnSuccess != tIOReturn ||CFGetTypeID(hid->manager) != IOHIDManagerGetTypeID()){
-        HALLOG("Unable to Open HID Manager");
-        return YERRMSG(YAPI_NOT_SUPPORTED,"Unable to Open HID Manager");
-    }
-    return YAPI_SUCCESS;
-
-}
-
-
-
-static void stopHIDManager(OSX_HID_REF *hid)
-{
-    if (hid->manager) {
-        IOHIDManagerClose(hid->manager, kIOHIDOptionsTypeNone );
-        CFRelease( hid->manager);
-        hid->manager=NULL;
-        yDeleteCriticalSection(&hid->hidMCS);
-    }
-}
-
-
-int yyyUSB_init(yContextSt *ctx,char *errmsg)
-{
-    char str[256];
-    size_t size = sizeof(str);
-    YPROPERR(yReserveGlobalAccess(ctx, errmsg));
-
-    if (sysctlbyname("kern.osrelease", str, &size, NULL, 0) ==0){
-        int numver;
-        //15.x.x  OS X 10.11.x El Capitan
-        //14.x.x  OS X 10.10.x Yosemite
-        //13.x.x  OS X 10.9.x Mavericks
-        //12.x.x  OS X 10.8.x Mountain Lion
-        //11.x.x  OS X 10.7.x Lion
-        //10.x.x  OS X 10.6.x Snow Leopard
-        str[2]=0;
-        numver = atoi(str);
-        if (numver >= 13 && numver < 15){
-            ctx->osx_flags |= YCTX_OSX_MULTIPLES_HID;
-        }
-    }
-
-    ctx->usb_thread_state = USB_THREAD_NOT_STARTED;
-    pthread_create(&ctx->usb_thread, NULL, event_thread, ctx);
-    while(ctx->usb_thread_state != USB_THREAD_RUNNING){
-        usleep(50000);
-    }
-
-    if (YISERR(setupHIDManager(ctx, &ctx->hid,errmsg))) {
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-int yyyUSB_stop(yContextSt *ctx,char *errmsg)
-{
-    stopHIDManager(&ctx->hid);
-
-    if(ctx->usb_thread_state == USB_THREAD_RUNNING){
-        ctx->usb_thread_state = USB_THREAD_MUST_STOP;
-        CFRunLoopStop(ctx->usb_run_loop);
-    }
-    pthread_join(ctx->usb_thread,NULL);
-    YASSERT(ctx->usb_thread_state == USB_THREAD_STOPED);
-
-    yReleaseGlobalAccess(ctx);
-
-    return 0;
-}
-
-
-
-
-static u32 get_int_property(IOHIDDeviceRef device, CFStringRef key)
-{
-    CFTypeRef ref;
-    u32 value;
-
-    ref = IOHIDDeviceGetProperty(device, key);
-    if (ref) {
-        if (CFGetTypeID(ref) == CFNumberGetTypeID() && CFNumberGetValue((CFNumberRef) ref, kCFNumberSInt32Type, &value)) {
-            return value;
-        }
-    }
-    return 0;
-}
-
-
-static void get_txt_property(IOHIDDeviceRef device,char *buffer,u32 maxlen, CFStringRef key)
-{
-    CFTypeRef ref;
-    size_t  len;
-
-    ref = IOHIDDeviceGetProperty(device, key);
-    if (ref) {
-        if (CFGetTypeID(ref) == CFStringGetTypeID()) {
-            const char *str;
-            CFStringEncoding encodingMethod;
-            encodingMethod = CFStringGetSystemEncoding();
-            // 1st try for English system
-            str = CFStringGetCStringPtr(ref, encodingMethod);
-            //str = NULL;
-            if ( str == NULL ) {
-                // 2nd try
-                encodingMethod = kCFStringEncodingUTF8;
-                str = CFStringGetCStringPtr(ref, encodingMethod);
-            }
-            if( str == NULL ) {
-                //3rd try
-                CFIndex cflength = CFStringGetLength(ref)*2+2;
-                char *tmp_str = yMalloc( (u32)cflength);
-                if (!CFStringGetCString(ref, tmp_str, cflength, kCFStringEncodingUTF8 )) {
-                    yFree( tmp_str );
-                    *buffer=0;
-                    return;
-                }
-                if(cflength>maxlen-1){
-                    cflength=maxlen-1;
-                }
-                memcpy(buffer,tmp_str,cflength);
-                buffer[cflength]=0;
-                yFree( tmp_str );
-                return;
-            }
-            len=strlen(str);
-            if(len>maxlen-1){
-                len=maxlen-1;
-            }
-            memcpy(buffer,str,len);
-            buffer[len]=0;
-            return;
-        }
-    }
-    *buffer=0;
-}
-
-
-
-
-
-static IOHIDDeviceRef* getDevRef(OSX_HID_REF *hid, CFIndex *deviceCount)
-{
-
-    CFSetRef        deviceCFSetRef;
-    IOHIDDeviceRef  *dev_refs=NULL;
-
-    *deviceCount = 0;
-
-    yEnterCriticalSection(&hid->hidMCS);
-    deviceCFSetRef = IOHIDManagerCopyDevices(hid->manager);
-    yLeaveCriticalSection(&hid->hidMCS);
-    if (deviceCFSetRef!= NULL) {
-        // how many devices in the set?
-        *deviceCount = CFSetGetCount( deviceCFSetRef );
-        dev_refs = yMalloc( sizeof(IOHIDDeviceRef) * (u32)*deviceCount );
-        // now extract the device ref's from the set
-        CFSetGetValues( deviceCFSetRef, (const void **) dev_refs );
-    }
-    return dev_refs;
-}
-
-
-int yyyUSBGetInterfaces(yInterfaceSt **ifaces,int *nbifaceDetect,char *errmsg)
-{
-    int             nbifaceAlloc;
-    int             deviceIndex;
-    CFIndex         deviceCount;
-    IOHIDDeviceRef  *dev_refs;
-
-    // get all device detected by the OSX
-    dev_refs = getDevRef(&yContext->hid, &deviceCount);
-    if(dev_refs == NULL) {
-        return 0;
-    }
-
-    // allocate buffer for detected interfaces
-    *nbifaceDetect = 0;
-    nbifaceAlloc  = 8;
-    *ifaces =yMalloc(nbifaceAlloc * sizeof(yInterfaceSt));
-    memset(*ifaces, 0 ,nbifaceAlloc * sizeof(yInterfaceSt));
-    for(deviceIndex=0 ; deviceIndex < deviceCount ;deviceIndex++){
-        u16 vendorid;
-        u16 deviceid;
-        IOHIDDeviceRef dev = dev_refs[deviceIndex];
-        yInterfaceSt    *iface;
-        vendorid = get_int_property(dev,CFSTR(kIOHIDVendorIDKey));
-        deviceid = get_int_property(dev,CFSTR(kIOHIDProductIDKey));
-        //ensure the buffer of detected interface is big enought
-        if(*nbifaceDetect == nbifaceAlloc){
-            yInterfaceSt    *tmp;
-            tmp = (yInterfaceSt*) yMalloc(nbifaceAlloc*2 * sizeof(yInterfaceSt));
-            memset(tmp,0,nbifaceAlloc*2 * sizeof(yInterfaceSt));
-            yMemcpy(tmp,*ifaces, nbifaceAlloc * sizeof(yInterfaceSt) );
-            yFree(*ifaces);
-            *ifaces = tmp;
-            nbifaceAlloc    *=2;
-        }
-        iface = *ifaces + *nbifaceDetect;
-        //iface->devref   = dev;
-        iface->vendorid = vendorid;
-        iface->deviceid = deviceid;
-        get_txt_property(dev,iface->serial,YOCTO_SERIAL_LEN*2, CFSTR(kIOHIDSerialNumberKey));
-        HALENUMLOG("work on interface %d (%x:%x:%s)\n",deviceIndex,vendorid,deviceid,iface->serial);
-        (*nbifaceDetect)++;
-    }
-    yFree(dev_refs);
-    return YAPI_SUCCESS;
-}
-
-
-/*****************************************************************
- * OSX implementation of yyypacket functions
- *****************************************************************/
-
-
-
-
-// return 1 if OS hdl are identical
-//        0 if any of the interface has changed
-int yyyOShdlCompare( yPrivDeviceSt *dev, yInterfaceSt *newdev)
-{
-    if(dev->infos.nbinbterfaces != 1){
-        HALLOG("bad number of inteface for %s (%d)\n",dev->infos.serial,dev->infos.nbinbterfaces);
-        return 0;
-    }
-    return 1;
-}
-
-
-
-
-static void Handle_IOHIDDeviceIOHIDReportCallback(
-                                                  void *          inContext,          // context from IOHIDDeviceRegisterInputReportCallback
-                                                  IOReturn        inResult,           // completion result for the input report operation
-                                                  void *          inSender,           // IOHIDDeviceRef of the device this report is from
-                                                  IOHIDReportType inType,             // the report type
-                                                  uint32_t        inReportID,         // the report ID
-                                                  uint8_t *       inReport,           // pointer to the report data
-                                                  CFIndex         InReportLength)     // the actual size of the input report
-{
-    yInterfaceSt *iface= (yInterfaceSt*) inContext;
-    yPktQueuePushD2H(iface,&iface->tmprxpkt,NULL);
-    memset(&iface->tmprxpkt,0xff,sizeof(USB_Packet));
-}
-
-
-int yyySetup(yInterfaceSt *iface,char *errmsg)
-{
-    char str[32];
-    int i;
-    CFIndex deviceCount;
-    IOHIDDeviceRef *dev_refs;
-
-
-    if (yContext->osx_flags & YCTX_OSX_MULTIPLES_HID) {
-        if (YISERR(setupHIDManager(yContext, &iface->hid,errmsg))) {
-            return YAPI_IO_ERROR;
-        }
-        // get all device detected by the OSX
-        dev_refs = getDevRef(&iface->hid, &deviceCount);
-    } else {
-        dev_refs = getDevRef(&yContext->hid, &deviceCount);
-    }
-    if(dev_refs == NULL) {
-        return YERRMSG(YAPI_IO_ERROR,"Device disappear before yyySetup");
-    }
-
-
-    for(i=0 ; i < deviceCount ;i++){
-        u16 vendorid;
-        u16 deviceid;
-        IOHIDDeviceRef dev = dev_refs[i];
-        vendorid = get_int_property(dev,CFSTR(kIOHIDVendorIDKey));
-        deviceid = get_int_property(dev,CFSTR(kIOHIDProductIDKey));
-        if (iface->vendorid == vendorid && iface->deviceid == deviceid){
-            char serial[YOCTO_SERIAL_LEN * 2];
-            memset(serial, 0, YOCTO_SERIAL_LEN * 2);
-            get_txt_property(dev,serial,YOCTO_SERIAL_LEN * 2, CFSTR(kIOHIDSerialNumberKey));
-            if (YSTRCMP(serial, iface->serial) == 0){
-                HALLOG("right Interface detected (%x:%x:%s)\n",vendorid,deviceid,iface->serial);
-                iface->devref = dev;
-                break;
-            }
-        }
-    }
-    yFree(dev_refs);
-    if (i == deviceCount) {
-        return YERRMSG(YAPI_IO_ERROR,"Unable to match device detected");
-    }
-
-    IOReturn ret = IOHIDDeviceOpen(iface->devref, kIOHIDOptionsTypeNone);
-    if (ret != kIOReturnSuccess) {
-        YSPRINTF(str,32,"Unable to open device (0x%x)",ret);
-        return YERRMSG(YAPI_IO_ERROR,str);
-    }
-
-    yPktQueueInit(&iface->rxQueue);
-	yPktQueueInit(&iface->txQueue);
-
-
-    /* Create the Run Loop Mode for this device. printing the reference seems to work. */
-    sprintf(str, "yocto_%p", iface->devref);
-    iface->run_loop_mode = CFStringCreateWithCString(NULL, str, kCFStringEncodingASCII);
-    /* Attach the device to a Run Loop */
-    IOHIDDeviceScheduleWithRunLoop(iface->devref, yContext->usb_run_loop, iface->run_loop_mode);
-    IOHIDDeviceRegisterInputReportCallback( iface->devref,              // IOHIDDeviceRef for the HID device
-                                           (u8*) &iface->tmprxpkt,     // pointer to the report data
-                                           USB_PKT_SIZE,               // number of bytes in the report (CFIndex)
-                                           &Handle_IOHIDDeviceIOHIDReportCallback,   // the callback routine
-                                           iface);                     // context passed to callback
-
-    // save setup ed iface pointer in context in order
-    // to retrieve it during unplugcallback
-    for (i=0; i< SETUPED_IFACE_CACHE_SIZE ; i++) {
-        if(yContext->setupedIfaceCache[i]==NULL){
-            yContext->setupedIfaceCache[i] = iface;
-            break;
-        }
-    }
-    if (i==SETUPED_IFACE_CACHE_SIZE) {
-        return YERRMSG(YAPI_IO_ERROR,"Too many setup USB interfaces");
-    }
-    iface->flags.yyySetupDone = 1;
-    return 0;
-}
-
-
-
-int yyySignalOutPkt(yInterfaceSt *iface, char *errmsg)
-{
-    int res =YAPI_SUCCESS;
-    pktItem *pktitem;
-
-    yPktQueuePopH2D(iface, &pktitem);
-    while (pktitem!=NULL){
-        if(iface->devref==NULL){
-            yFree(pktitem);
-            return YERR(YAPI_IO_ERROR);
-        }
-        res = IOHIDDeviceSetReport(iface->devref,
-                                   kIOHIDReportTypeOutput,
-                                   0, /* Report ID*/
-                                   (u8*)&pktitem->pkt, sizeof(USB_Packet));
-        yFree(pktitem);
-        if (res != kIOReturnSuccess) {
-            dbglog("IOHIDDeviceSetReport failed with 0x%x\n", res);
-            return YERRMSG(YAPI_IO_ERROR,"IOHIDDeviceSetReport failed");;
-        }
-        yPktQueuePopH2D(iface, &pktitem);
-    }
-	return YAPI_SUCCESS;
-}
-
-
-
-void yyyPacketShutdown(yInterfaceSt  *iface)
-{
-    int i;
-
-    // remove iface from setup ifaces
-    for (i=0; i< SETUPED_IFACE_CACHE_SIZE ; i++) {
-        if(yContext->setupedIfaceCache[i]==iface){
-            yContext->setupedIfaceCache[i] = NULL;
-            break;
-        }
-    }
-    YASSERT(i<SETUPED_IFACE_CACHE_SIZE);
-    if(iface->devref!=NULL){
-        IOHIDDeviceRegisterInputReportCallback(iface->devref,              // IOHIDDeviceRef for the HID device
-                                               (u8*) &iface->tmprxpkt,   // pointer to the report data (uint8_t's)
-                                               USB_PKT_SIZE,              // number of bytes in the report (CFIndex)
-                                               NULL,   // the callback routine
-                                               iface);                      // context passed to callback
-        IOHIDDeviceClose(iface->devref, kIOHIDOptionsTypeNone);
-        iface->devref=NULL;
-    }
-    yPktQueueFree(&iface->rxQueue);
-	yPktQueueFree(&iface->txQueue);
-    iface->flags.yyySetupDone = 0;
-    CFRelease(iface->run_loop_mode);
-    if (yContext->osx_flags & YCTX_OSX_MULTIPLES_HID) {
-        stopHIDManager(&iface->hid);
-    }
-}
-
-#endif
-
-#ifdef IOS_API
-#include "yproto.h"
-
-int yyyUSB_init(yContextSt *ctx,char *errmsg)
-{
-    return YAPI_SUCCESS;
-}
-
-int yyyUSB_stop(yContextSt *ctx,char *errmsg)
-{
-    return 0;
-}
-
-int yyyUSBGetInterfaces(yInterfaceSt **ifaces,int *nbifaceDetect,char *errmsg)
-{
-    *nbifaceDetect = 0;
-    return 0;
-}
-
-int yyyOShdlCompare( yPrivDeviceSt *dev, yInterfaceSt *newdev)
-{
-    return 1;
-}
-
-int yyySetup(yInterfaceSt *iface,char *errmsg)
-{
-    return YERR(YAPI_NOT_SUPPORTED);
-}
-
-int yyySignalOutPkt(yInterfaceSt *iface, char *errmsg)
-{
-    return -1;
-}
-
-void yyyPacketShutdown(yInterfaceSt  *iface)
-{}
-
-#endif
--- a/Sources/cpplib/yapi/ypkt_win.c
+++ /dev/null
@@ -1,1010 +0,0 @@
-/*********************************************************************
- *
- * $Id: ypkt_win.c 33735 2018-12-14 16:06:53Z seb $
- *
- * OS-specific USB packet layer, Windows version
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "ypkt_win"
-#include "yapi.h"
-#if defined(WINDOWS_API) && !defined(WINCE)
-#include "yproto.h"
-#include <TlHelp32.h>
-#ifdef LOG_DEVICE_PATH
-#define DP(PATH) (PATH)
-#else
-#define DP(PATH) "..."
-#endif
-
-#ifndef _MSC_VER
-#define SPDRP_INSTALL_STATE (0x00000022)
-#define _TRUNCATE ((size_t)-1)
-#endif
-
-#define yWinSetErr(iface,errmsg)  yWinSetErrEx(__LINE__,iface,GetLastError(),"",errmsg)
-
-static int yWinSetErrEx(u32 line, yInterfaceSt *iface, DWORD err, const char *msg, char *errmsg)
-{
-    int len;
-    if (errmsg == NULL)
-        return YAPI_IO_ERROR;
-    if (iface) {
-        YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "%s:%d(%s:%d): %s(%d)", iface->serial, iface->ifaceno, __FILE_ID__, line, msg, (u32)err);
-    } else {
-        YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "%s:%d: %s(%d)", __FILE_ID__, line, msg, (u32)err);
-    }
-    len = YSTRLEN(errmsg);
-    FormatMessageA(
-        FORMAT_MESSAGE_FROM_SYSTEM |
-        FORMAT_MESSAGE_IGNORE_INSERTS,
-        NULL,
-        err,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-        (LPSTR)(errmsg + len),
-        YOCTO_ERRMSG_LEN - len, NULL);
-
-    return YAPI_IO_ERROR;
-}
-
-
-#if 0
-static void yWinPushEx(u32 line, yInterfaceSt *iface, pktQueue  *q, DWORD err)
-{
-    int len;
-    char errmsg[YOCTO_ERRMSG_LEN];
-
-    YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "%s:%d(%s:%d): (%d)", iface->serial, iface->ifaceno, __FILE_ID__, line, (u32)err);
-    len = YSTRLEN(errmsg);
-    FormatMessageA(
-        FORMAT_MESSAGE_FROM_SYSTEM |
-        FORMAT_MESSAGE_IGNORE_INSERTS,
-        NULL,
-        err,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-        (LPSTR)(errmsg + len),
-        YOCTO_ERRMSG_LEN - len, NULL);
-    yPktQueueSetError(q, YAPI_IO_ERROR, errmsg);
-}
-
-#endif
-
-
-static u32 decodeHex(const char *p, int nbdigit)
-{
-    u32 ret = 0;
-    int i;
-    for (i = nbdigit - 1; i >= 0; i--, p++) {
-        u32 digit;
-        if (*p >= 'a' && *p <= 'f') {
-            digit = 10 + *p - 'a';
-        } else if (*p >= 'A' && *p <= 'F') {
-            digit = 10 + *p - 'A';
-        } else if (*p >= '0' && *p <= '9') {
-            digit = *p - '0';
-        } else {
-            return 0;
-        }
-        ret += digit << (4 * i);
-    }
-    return ret;
-}
-
-
-
-#define FIRST_OF        1
-#define FIRST_NOT_OF    2
-
-static char* findDelim(char *str, const char *delimiters, const int nbdelim, const int mode)
-{
-    int d;
-
-    while (*str) {
-        for (d = 0; d < nbdelim; d++) {
-            if (*str == delimiters[d]) {
-                break;
-            }
-        }
-        if (mode == FIRST_OF) {
-            if (d < nbdelim) {
-                return str;
-            }
-        } else {
-            if (d == nbdelim) {
-                return str;
-            }
-        }
-        str++;
-    }
-    return str;
-}
-
-
-void DecodeHardwareid(char *str, u32 *vendorid, u32 *deviceid, u32 *release, u32 *iface)
-{
-    const char *delim = "\\&?";
-    char *token_start, *token_stop;
-    token_start = findDelim(str, delim, 4, FIRST_NOT_OF);
-    token_stop = findDelim(token_start, delim, 4, FIRST_OF);
-    *vendorid = *deviceid = *release = *iface = 0;
-    while (token_start != token_stop) {
-        if (YSTRNICMP(token_start, "VID_", 4) == 0) {
-            *vendorid = decodeHex(token_start + 4, 4);
-        } else if (YSTRNICMP(token_start, "PID_", 4) == 0) {
-            *deviceid = decodeHex(token_start + 4, 4);
-        } else if (YSTRNICMP(token_start, "REV_", 4) == 0) {
-            *release = decodeHex(token_start + 4, 4);
-        } else if (YSTRNICMP(token_start, "MI_", 3) == 0) {
-            *iface = decodeHex(token_start + 3, 2);
-        }
-        token_start = findDelim(token_stop, delim, 2, FIRST_NOT_OF);
-        token_stop = findDelim(token_start, delim, 2, FIRST_OF);
-    }
-}
-
-
-
-static int getProcName(char *buffer, int buffer_size)
-{
-    HANDLE hProcessSnap;
-    PROCESSENTRY32 pe32;
-    DWORD pid = GetCurrentProcessId();
-    *buffer = 0;
-
-    // Take a snapshot of all processes in the system.
-    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
-    if (hProcessSnap == INVALID_HANDLE_VALUE) {
-        dbglog("CreateToolhelp32Snapshot (of processes)\n");
-        return pid;
-    }
-
-    // Set the size of the structure before using it.
-    pe32.dwSize = sizeof(PROCESSENTRY32);
-
-    // Retrieve information about the first process,
-    // and exit if unsuccessful
-    if (!Process32First(hProcessSnap, &pe32)) {
-        dbglog("Process32First error\n"); // show cause of failure
-        CloseHandle(hProcessSnap);          // clean the snapshot object
-        return pid;
-    }
-
-    // Now walk the snapshot of processes, and
-    // display information about each process in turn
-    do {
-        if (pid == pe32.th32ProcessID) {
-#ifndef  UNICODE
-            YSTRCPY(buffer, buffer_size, pe32.szExeFile);
-#else
-#if defined(_MSC_VER) && (_MSC_VER > MSC_VS2003)
-            {
-                size_t          len;
-                wcstombs_s(&len, buffer, buffer_size, (wchar_t*)pe32.szExeFile, _TRUNCATE);
-            }
-#else
-            wcstombs(buffer, (wchar_t*)pe32.szExeFile, buffer_size);
-#endif
-#endif
-
-            break;
-        }
-    } while (Process32Next(hProcessSnap, &pe32));
-    buffer[buffer_size - 1] = 0;
-    CloseHandle(hProcessSnap);
-    return pid;
-}
-
-
-
-#define LEGACY_YOCTOPUCE_KEY "Software\\Yoctopuce\\"
-#define USB_LOCK_KEY "Software\\Yoctopuce\\usb_lock\\"
-#ifndef KEY_WOW64_32KEY
-// dirty hack to work with mingw32
-#define KEY_WOW64_32KEY 0
-#endif
-
-static int yConvertUSBLockKey(yContextSt *ctx, int deletekey)
-{
-    HKEY key;
-    LONG res;
-    res = ctx->registry.yRegOpenKeyEx(HKEY_LOCAL_MACHINE, LEGACY_YOCTOPUCE_KEY, 0, KEY_WRITE | KEY_READ | KEY_WOW64_32KEY, &key);
-    if (res == ERROR_SUCCESS) {
-        //save information
-        char process_name[512];
-        char buffer[32];
-        DWORD value_length = 32;
-        res = ctx->registry.yRegQueryValueEx(key, "process_id", NULL, NULL, (LPBYTE)buffer, &value_length);
-        if (res != ERROR_SUCCESS) {
-            return -1;
-        }
-        value_length = 512;
-        res = ctx->registry.yRegQueryValueEx(key, "process_name", NULL, NULL, (LPBYTE)process_name, &value_length);
-        if (res != ERROR_SUCCESS) {
-            return -1;
-        }
-        if (deletekey) {
-            // delete key
-            ctx->registry.yRegCloseKey(key);
-            res = ctx->registry.yRegDeleteKeyEx(HKEY_LOCAL_MACHINE, LEGACY_YOCTOPUCE_KEY, KEY_WOW64_32KEY, 0);
-        } else {
-            ctx->registry.yRegDeleteValue(key, "process_id");
-            ctx->registry.yRegDeleteValue(key, "process_name");
-            ctx->registry.yRegCloseKey(key);
-        }
-        // create new one
-        res = ctx->registry.yRegCreateKeyEx(HKEY_LOCAL_MACHINE, USB_LOCK_KEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ | KEY_WOW64_32KEY, NULL, &key, NULL);
-        // save value in new key
-        if (ctx->registry.yRegSetValueEx(key, "process_id", 0, REG_SZ, (BYTE*)buffer, YSTRLEN(buffer)) != ERROR_SUCCESS) {
-            dbglog("Unable to set registry value yapi_process");
-        }
-        if (ctx->registry.yRegSetValueEx(key, "process_name", 0, REG_SZ, (BYTE*)process_name, YSTRLEN(process_name)) != ERROR_SUCCESS) {
-            dbglog("Unable to set registry value yapi_process");
-        }
-        ctx->registry.yRegCloseKey(key);
-        return 1;
-    } else {
-        return -1;
-    }
-}
-
-// return 1 if we can reserve access to the device 0 if the device
-// is already reserved
-static int yReserveGlobalAccess(yContextSt *ctx, char * errmsg)
-{
-    int has_reg_key = 1;
-    char process_name[512];
-    char buffer[32];
-    DWORD value_length = 512;
-    int retval;
-    s64 pid;
-    HKEY key = NULL;
-    LONG res;
-
-    if (ctx->registry.hREG != NULL) {
-        res = ctx->registry.yRegCreateKeyEx(HKEY_LOCAL_MACHINE, USB_LOCK_KEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ | KEY_WOW64_32KEY, NULL, &key, NULL);
-        if (res == ERROR_CHILD_MUST_BE_VOLATILE) {
-            yConvertUSBLockKey(ctx, 1);
-            res = ctx->registry.yRegCreateKeyEx(HKEY_LOCAL_MACHINE, USB_LOCK_KEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ | KEY_WOW64_32KEY, NULL, &key, NULL);
-            if (res != ERROR_SUCCESS) {
-                has_reg_key = 0;
-            }
-        } else if (res == ERROR_SUCCESS) {
-            yConvertUSBLockKey(ctx, 0);
-        } else {
-            has_reg_key = 0;
-        }
-    } else {
-        has_reg_key = 0;
-    }
-
-    ctx->apiLock = CreateMailslotA("\\\\.\\mailslot\\yoctopuce_yapi", 8, 0, NULL);
-    ctx->nameLock = CreateMailslotA("\\\\.\\mailslot\\yoctopuce_yapi_name", 8, 0, NULL);
-    if (ctx->apiLock == INVALID_HANDLE_VALUE) {
-        // unable to create lock -> another instance is already using the device
-        retval = YAPI_DOUBLE_ACCES;
-        YERRMSG(YAPI_DOUBLE_ACCES, "Another process is already using yAPI");
-        if (has_reg_key && ctx->nameLock == INVALID_HANDLE_VALUE) {
-            pid = -1;
-            res = ctx->registry.yRegQueryValueEx(key, "process_id", NULL, NULL, (LPBYTE)buffer, &value_length);
-            if (res == ERROR_SUCCESS) {
-                pid = atoi(buffer);
-            }
-            value_length = 512;
-            res = ctx->registry.yRegQueryValueEx(key, "process_name", NULL, NULL, (LPBYTE)process_name, &value_length);
-            if (res == ERROR_SUCCESS && pid >= 0) {
-                char current_name[512];
-                getProcName(current_name, 512);
-                if (YSTRCMP(process_name, current_name)) {
-                    YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Another process named %s (pid %"FMTs64") is already using yAPI", process_name, pid);
-                } else {
-                    YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Another %s (pid %"FMTs64") is already using yAPI", process_name, pid);
-                }
-            }
-        }
-    } else {
-        retval = YAPI_SUCCESS;
-        if (has_reg_key) {
-            int pid = getProcName(process_name, 512);
-            YSPRINTF(buffer, 32, "%d", pid);
-            if (ctx->registry.yRegSetValueEx(key, "process_id", 0, REG_SZ, (BYTE*)buffer, YSTRLEN(buffer)) != ERROR_SUCCESS) {
-                dbglog("Unable to set registry value yapi_process");
-            }
-            if (ctx->registry.yRegSetValueEx(key, "process_name", 0, REG_SZ, (BYTE*)process_name, YSTRLEN(process_name)) != ERROR_SUCCESS) {
-                dbglog("Unable to set registry value yapi_process");
-            }
-        }
-    }
-    if (has_reg_key) {
-        ctx->registry.yRegCloseKey(key);
-    }
-
-    return retval;
-}
-
-static void yReleaseGlobalAccess(yContextSt *ctx)
-{
-    CloseHandle(ctx->apiLock);
-    ctx->apiLock = INVALID_HANDLE_VALUE;
-    CloseHandle(ctx->nameLock);
-    ctx->nameLock = INVALID_HANDLE_VALUE;
-}
-
-
-
-int yyyUSB_init(yContextSt *ctx, char *errmsg)
-{
-    ctx->registry.hREG = LoadLibraryA("Advapi32.dll");
-    if (ctx->registry.hREG != NULL) {
-        //Update the pointers:
-        ctx->registry.yRegCreateKeyEx = (PYRegCreateKeyEx)GetProcAddress(ctx->registry.hREG, "RegCreateKeyExA");
-        ctx->registry.yRegOpenKeyEx = (PYRegOpenKeyEx)GetProcAddress(ctx->registry.hREG, "RegOpenKeyExA");
-        ctx->registry.yRegSetValueEx = (PYRegSetValueEx)GetProcAddress(ctx->registry.hREG, "RegSetValueExA");
-        ctx->registry.yRegQueryValueEx = (PYRegQueryValueEx)GetProcAddress(ctx->registry.hREG, "RegQueryValueExA");
-        ctx->registry.yRegDeleteValue = (PYRegDeleteValue)GetProcAddress(ctx->registry.hREG, "RegDeleteValueA");
-        ctx->registry.yRegCloseKey = (PYRegCloseKey)GetProcAddress(ctx->registry.hREG, "RegCloseKey");
-        ctx->registry.yRegDeleteKeyEx = (PYRegDeleteKeyEx)GetProcAddress(ctx->registry.hREG, "RegDeleteKeyExA");
-    }
-
-
-    YPROPERR(yReserveGlobalAccess(ctx, errmsg));
-    ctx->hid.hHID = LoadLibraryA("HID.DLL");
-    if (ctx->hid.hHID == NULL) {
-        return yWinSetErr(NULL, errmsg);
-    }
-    //Update the pointers:
-    ctx->hid.GetHidGuid = (PHidD_GetHidGuid)GetProcAddress(ctx->hid.hHID, "HidD_GetHidGuid");
-    ctx->hid.GetAttributes = (PHidD_GetAttributes)GetProcAddress(ctx->hid.hHID, "HidD_GetAttributes");
-    ctx->hid.GetManufacturerString = (PHidD_GetManufacturerString)GetProcAddress(ctx->hid.hHID, "HidD_GetManufacturerString");
-    ctx->hid.GetProductString = (PHidD_GetProductString)GetProcAddress(ctx->hid.hHID, "HidD_GetProductString");
-    ctx->hid.GetSerialNumberString = (PHidD_GetSerialNumberString)GetProcAddress(ctx->hid.hHID, "HidD_GetSerialNumberString");
-    ctx->hid.SetNumInputBuffers = (PHidD_SetNumInputBuffers)GetProcAddress(ctx->hid.hHID, "HidD_SetNumInputBuffers");
-    yInitializeCriticalSection(&ctx->prevEnum_cs);
-
-    return YAPI_SUCCESS;
-}
-
-
-int yyyUSB_stop(yContextSt *ctx, char *errmsg)
-{
-    yDeleteCriticalSection(&ctx->prevEnum_cs);
-    if (ctx->prevEnum) {
-        yFree(ctx->prevEnum);
-        ctx->prevEnum = NULL;
-    }
-    ctx->prevEnumCnt = 0;
-    yReleaseGlobalAccess(ctx);
-    return YAPI_SUCCESS;
-}
-/*****************************************************************
-* yPacket API without cycling logic
-*****************************************************************/
-
-
-// no check on reentrant or initializations since we are only called
-// by the yUpdateDeviceList witch take care of all this stuff
-// the caller is responsible of freeing the ifaces buffer (if not set to NULL)
-int yyyUSBGetInterfaces(yInterfaceSt **ifaces, int *nbifaceDetect, char *errmsg)
-{
-    PSP_DEVICE_INTERFACE_DETAIL_DATA_A    pDetailedInterfaceData;
-    int         index = 0;
-    GUID        InterfaceClassGuid;
-    DWORD       needsize;
-    HDEVINFO    DeviceInfoTable = INVALID_HANDLE_VALUE;
-    int         nbifaceAlloc;
-    char        buffer[WIN_DEVICE_PATH_LEN];//buffer for DetailedInterfaceData
-
-    *ifaces = NULL;
-    //setup some windows stuff
-    yContext->hid.GetHidGuid(&InterfaceClassGuid);
-    DeviceInfoTable = SetupDiGetClassDevs(&InterfaceClassGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
-    if (DeviceInfoTable == INVALID_HANDLE_VALUE) {
-        return yWinSetErr(NULL, errmsg);
-    }
-    yEnterCriticalSection(&yContext->prevEnum_cs);
-    pDetailedInterfaceData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)buffer;
-    // allocate buffer for detected interfaces
-    *nbifaceDetect = 0;
-    nbifaceAlloc = yContext->prevEnumCnt + 8;
-    *ifaces = (yInterfaceSt*)yMalloc(nbifaceAlloc * sizeof(yInterfaceSt));
-    memset(*ifaces, 0, nbifaceAlloc * sizeof(yInterfaceSt));
-
-    //Now look through the list we just populated.  We are trying to see if any of them match our device.
-    for (;; index++) {
-        u32             vendorid, deviceid, release, ifaceno, inst_state;
-        SP_DEVINFO_DATA DevInfoData;
-
-        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
-        if (!SetupDiEnumDeviceInfo(DeviceInfoTable, index, &DevInfoData)) {
-            //no more device
-            break;
-        }
-        // get device hardwareid string
-        SetupDiGetDeviceRegistryPropertyA(DeviceInfoTable, &DevInfoData, SPDRP_HARDWAREID, NULL, (PBYTE)buffer, 512, NULL);
-        // skip 4 first char ("HID/")
-        DecodeHardwareid(buffer + 4, &vendorid, &deviceid, &release, &ifaceno);
-        // get installation status see:http://msdn.microsoft.com/en-us/library/ff543130
-        SetupDiGetDeviceRegistryProperty(DeviceInfoTable, &DevInfoData, SPDRP_INSTALL_STATE, NULL, (PBYTE)&inst_state, sizeof(inst_state), &needsize);
-        if (vendorid == YOCTO_VENDORID && inst_state == 0) {
-            SP_DEVICE_INTERFACE_DATA    InterfaceData;
-            yInterfaceSt    *iface;
-            int             find, retry = 16;
-
-            //ensure the buffer of detected interface is big enough
-            if (*nbifaceDetect == nbifaceAlloc) {
-                yInterfaceSt    *tmp;
-                u32 newsize = nbifaceAlloc * 2 * sizeof(yInterfaceSt);
-                tmp = (yInterfaceSt*)yMalloc(newsize);
-                memset(tmp, 0, newsize);
-                yMemcpy(tmp, *ifaces, nbifaceAlloc * sizeof(yInterfaceSt));
-                yFree(*ifaces);
-                *ifaces = tmp;
-                nbifaceAlloc *= 2;
-            }
-            iface = *ifaces + *nbifaceDetect;
-            iface->vendorid = (u16)vendorid;
-            iface->deviceid = (u16)deviceid;
-            iface->ifaceno = (u16)ifaceno;
-
-            InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
-            if (!SetupDiEnumDeviceInterfaces(DeviceInfoTable, &DevInfoData, &InterfaceClassGuid, 0, &InterfaceData)) {
-                dbglog("Fail to retrieve DeviceInterfaces");
-                continue;
-            }
-            SetupDiGetDeviceInterfaceDetailA(DeviceInfoTable, &InterfaceData, NULL, 0, &needsize, NULL);
-            if (WIN_DEVICE_PATH_LEN < needsize) {
-                dbglog("buffer too small");
-                continue;
-            }
-            pDetailedInterfaceData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
-            SetupDiGetDeviceInterfaceDetailA(DeviceInfoTable, &InterfaceData, pDetailedInterfaceData, needsize, NULL, NULL);
-            YSTRNCPY(iface->devicePath, WIN_DEVICE_PATH_LEN, pDetailedInterfaceData->DevicePath, WIN_DEVICE_PATH_LEN);
-            for (find = 0; find < yContext->prevEnumCnt; find++) {
-                if (YSTRCMP(iface->devicePath, yContext->prevEnum[find].devicePath) == 0) break;
-            }
-            if (find < yContext->prevEnumCnt) {
-                yMemcpy(iface->serial, yContext->prevEnum[find].serial, YOCTO_SERIAL_LEN * 2);
-            } else {
-                HANDLE          control;
-                HALLOG("Get serial for %s\n", pDetailedInterfaceData->DevicePath);
-                control = CreateFileA(pDetailedInterfaceData->DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
-                if (control == INVALID_HANDLE_VALUE) {
-                    dbglog("Unable to open device %s to get serial\n", pDetailedInterfaceData->DevicePath);
-                    continue;
-                }
-                while (!yContext->hid.GetSerialNumberString(control, buffer, WIN_DEVICE_PATH_LEN) && --retry >= 0) {
-                    dbglog("Unable to get serial for %s (%d), retrying (%d)\n", pDetailedInterfaceData->DevicePath, GetLastError(), retry);
-                    Sleep(17);
-                }
-                if (retry < 0) {
-                    dbglog("Unable to get serial for %s (%d), giving up\n", pDetailedInterfaceData->DevicePath, GetLastError());
-                    CloseHandle(control);
-                    continue;
-                }
-#if defined(_MSC_VER) && (_MSC_VER > MSC_VS2003)
-                {
-                    size_t          len;
-                    wcstombs_s(&len, iface->serial, YOCTO_SERIAL_LEN * 2, (wchar_t*)buffer, _TRUNCATE);
-                }
-#else
-                wcstombs(iface->serial, (wchar_t*)buffer, YOCTO_SERIAL_LEN * 2);
-#endif
-                CloseHandle(control);
-            }
-            (*nbifaceDetect)++;
-            if (deviceid > YOCTO_DEVID_BOOTLOADER) {
-                HALENUMLOG("----Running Dev %x:%x:%d:%s ---\n", vendorid, deviceid, ifaceno, iface->serial);
-#ifdef LOG_DEVICE_PATH
-                HALENUMLOG("----DevicePath %s ---\n", iface->devicePath);
-#endif
-            } else {
-                HALENUMLOG("----Running Firm %x:%x:%d:%s ---\n", vendorid, deviceid, ifaceno, iface->serial);
-            }
-        } else {
-            //HALLOG("Drop device vendorid=%x inst_state=%x\n", vendorid, inst_state);
-        }
-    }
-    // unallocate Device infos
-    if (!SetupDiDestroyDeviceInfoList(DeviceInfoTable)) {
-        HALLOG("Unable to unallocated Device Info Table  (%d)", GetLastError());
-    }
-    // save enumeration result to prevent later USB packets to redetect serial
-    if (yContext->prevEnum) yFree(yContext->prevEnum);
-    yContext->prevEnumCnt = *nbifaceDetect;
-    if (*nbifaceDetect > 0) {
-        yContext->prevEnum = (yInterfaceSt*)yMalloc(*nbifaceDetect * sizeof(yInterfaceSt));
-        yMemcpy(yContext->prevEnum, *ifaces, *nbifaceDetect * sizeof(yInterfaceSt));
-    } else {
-        yContext->prevEnum = NULL;
-    }
-    yLeaveCriticalSection(&yContext->prevEnum_cs);
-
-    return YAPI_SUCCESS;
-}
-
-
-// return 1 if OS hdl are identicals
-//        0 if any of the interface has changed
-int yyyOShdlCompare(yPrivDeviceSt *dev, yInterfaceSt *newiface)
-{
-    if (dev->infos.nbinbterfaces != 1) {
-        HALLOG("bad number of inteface for %s (%d)\n", dev->infos.serial, dev->infos.nbinbterfaces);
-        return 0;
-    }
-    if (YSTRCMP(dev->iface.devicePath, newiface->devicePath) != 0) {
-        HALLOG("devref has changed for %s (%s)\n", dev->infos.serial, DP(dev->iface.devicePath));
-        return 0;
-    }
-    return 1;
-}
-
-
-
-/*****************************************************************
-* Window implementation of yyypacket functions
-*****************************************************************/
-
-
-
-
-
-static int OpenWriteHandles(yInterfaceSt    *iface)
-{
-    int res;
-    iface->wrHDL = INVALID_HANDLE_VALUE;
-    //open blocking write handle
-    iface->wrHDL = CreateFileA(iface->devicePath, GENERIC_WRITE | GENERIC_READ,
-        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
-    if (iface->wrHDL == INVALID_HANDLE_VALUE) {
-        char  errmsg[YOCTO_ERRMSG_LEN];
-        res = yWinSetErr(iface, errmsg);
-        HALLOG("OpenWriteHandles error of %s:%d (%s)\n", iface->serial, iface->ifaceno, errmsg);
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static void CloseWriteHandles(yInterfaceSt    *iface)
-{
-    if (iface->wrHDL != INVALID_HANDLE_VALUE) {
-        CloseHandle(iface->wrHDL);
-        iface->wrHDL = INVALID_HANDLE_VALUE;
-    }
-}
-
-
-
-static int OpenReadHandles(yInterfaceSt    *iface)
-{
-    char  errmsg[YOCTO_ERRMSG_LEN];
-    int res;
-    BOOLEAN setbuffres;
-    //open non blocking read handle
-    iface->rdHDL = CreateFileA(iface->devicePath, GENERIC_WRITE | GENERIC_READ,
-        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
-    if (iface->rdHDL == INVALID_HANDLE_VALUE) {
-        res = yWinSetErr(iface, errmsg);
-        HALLOG("OpenReadHandles of %s error %d of %s:%d (%s)\n", DP(iface->devicePath), res, iface->serial, iface->ifaceno, errmsg);
-        return res;
-    }
-    // since Win XP HID buffer size is 32 by default and can be up to 512
-    setbuffres = yContext->hid.SetNumInputBuffers(iface->rdHDL, 256);
-    if (!setbuffres) {
-        res = yWinSetErr(iface, errmsg);
-        dbglog("SetNumInputBuffers of %s error %d of %s:%d (%s)\n", DP(iface->devicePath), res, iface->serial, iface->ifaceno, errmsg);
-    }
-    // create Event for non blocking read
-    iface->EV[YWIN_EVENT_READ] = CreateEvent(NULL, TRUE, TRUE, NULL);
-    if (iface->EV[YWIN_EVENT_READ] == NULL) {
-        res = yWinSetErr(iface, errmsg);
-        HALLOG("OpenReadHandles error %d of %s:%d (%s)\n", res, iface->serial, iface->ifaceno, errmsg);
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static void CloseReadHandles(yInterfaceSt    *iface)
-{
-    DWORD readed;
-
-    if (iface->rdpending && iface->rdHDL != INVALID_HANDLE_VALUE) {
-        if (CancelIo(iface->rdHDL) == 0) {
-            HALLOG("CancelIo failed with %d\n", GetLastError());
-        } else {
-            if (GetOverlappedResult(iface->rdHDL, &iface->rdOL, &readed, TRUE)) {
-                //finished
-                if (readed != sizeof(OS_USB_Packet)) {
-                    HALLOG("invalid packet size read %d  %d\n", iface->ifaceno, readed);
-                } else {
-                    yPktQueuePushD2H(iface, &iface->tmpd2hpkt.pkt, NULL);
-                }
-                ySetEvent(&yContext->exitSleepEvent);
-            } else {
-                u32 error = GetLastError();
-                if (error != ERROR_OPERATION_ABORTED) {
-                    HALLOG("Error when stopping read IO on %s:%d\n", iface->serial, iface->ifaceno);
-                }
-            }
-        }
-    }
-    if (iface->EV[YWIN_EVENT_READ] != NULL) {
-        CloseHandle(iface->EV[YWIN_EVENT_READ]);
-        iface->EV[YWIN_EVENT_READ] = NULL;
-    }
-    if (iface->rdHDL != INVALID_HANDLE_VALUE) {
-        CloseHandle(iface->rdHDL);
-        iface->rdHDL = INVALID_HANDLE_VALUE;
-    }
-    iface->rdpending = 0;
-}
-
-
-static int StartReadIO(yInterfaceSt *iface, char *errmsg)
-{
-    DWORD readed;
-    u32   retrycount = 0;
-retry:
-    YASSERT(iface->rdpending == 0);
-    memset(&iface->rdOL, 0, sizeof(iface->rdOL));
-    //check if we need that : if(!SetEvent(iface->rdEV)) return yWinSetErr(errmsg);
-    iface->rdOL.hEvent = iface->EV[YWIN_EVENT_READ];
-    if (!ReadFile(iface->rdHDL, &iface->tmpd2hpkt, sizeof(OS_USB_Packet), &readed, &iface->rdOL)) {
-        u32 error = GetLastError();
-        if (error != ERROR_IO_PENDING) {
-            return yWinSetErrEx(__LINE__, iface, error, "", errmsg);
-        }
-        iface->rdpending = 1;
-    } else {
-        yPktQueuePushD2H(iface, &iface->tmpd2hpkt.pkt, NULL);
-        ySetEvent(&yContext->exitSleepEvent);
-        // TODO: add some kind of timeout to be able to send reset packet
-        // if device become crazy
-        retrycount++;
-        goto retry;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-
-
-
-//Look if we have new packet arrived
-static int yyyyRead(yInterfaceSt *iface, char *errmsg)
-{
-    DWORD           readed;
-    int             res;
-    int             retrycount = 1;
-retry:
-    if (iface->rdpending == 0) {
-        // no IO started -> start a new one
-        res = StartReadIO(iface, errmsg);
-        if (YISERR(res)) {
-            if (retrycount--) {
-                CloseReadHandles(iface);
-                if (YISERR(OpenReadHandles(iface))) {
-                    HALLOG("Open read handles failed %s:%d\n", iface->serial, iface->ifaceno);
-                    return res;
-                }
-                //seep a bit to let the OS restart thing correctly
-                yApproximateSleep(1);
-                goto retry;
-            }
-            HALLOG("Read IO error %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-            return res;
-        }
-    }
-    if (GetOverlappedResult(iface->rdHDL, &iface->rdOL, &readed, 0)) {
-        iface->rdpending = 0;
-        if (readed != sizeof(OS_USB_Packet)) {
-            HALLOG("drop invalid packet on %s:%d (invalid size %d)\n", iface->serial, iface->ifaceno, readed);
-        } else {
-            yPktQueuePushD2H(iface, &iface->tmpd2hpkt.pkt, NULL);
-            ySetEvent(&yContext->exitSleepEvent);
-        }
-        res = StartReadIO(iface, errmsg);
-        if (YISERR(res)) {
-            if (retrycount--) {
-                CloseReadHandles(iface);
-                if (YISERR(OpenReadHandles(iface))) {
-                    HALLOG("Open read handles failed %s:%d\n", iface->serial, iface->ifaceno);
-                    return res;
-                }
-                //seep a bit to let the OS restart thing correctly
-                yApproximateSleep(1);
-                goto retry;
-            }
-            HALLOG("Read IO error %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-            return res;
-        }
-    } else {
-        u32 error = GetLastError();
-        if (error != ERROR_IO_INCOMPLETE) {
-            iface->rdpending = 0;
-            res = yWinSetErrEx(__LINE__, iface, error, "", errmsg);
-            if (retrycount--) {
-                CloseReadHandles(iface);
-                if (YISERR(OpenReadHandles(iface))) {
-                    HALLOG("Open read handles failed %s:%d\n", iface->serial, iface->ifaceno);
-                    return res;
-                }
-                //seep a bit to let the OS restart thing correctly
-                yApproximateSleep(1);
-                goto retry;
-            }
-            HALLOG("Read IO error %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-            return res;
-        }
-    }
-    if (retrycount == 0) {
-        HALLOG("Read IO needed 1 retry %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int yyyyWrite(yInterfaceSt *iface, pktItem *pktItem)
-{
-    char            errmsg[YOCTO_ERRMSG_LEN];
-    DWORD           written;
-    OS_USB_Packet   winpkt;
-    int             retrycount = 1;
-
-    winpkt.dummy = 0;
-    memcpy(&winpkt.pkt, &pktItem->pkt, sizeof(USB_Packet));
-retry:
-    if (!WriteFile(iface->wrHDL, &winpkt, sizeof(OS_USB_Packet), &written, NULL)) {
-        YRETCODE code = yWinSetErr(iface, errmsg);
-        if (retrycount--) {
-            // reset handles
-            CloseWriteHandles(iface);
-            if (YISERR(OpenWriteHandles(iface))) {
-                HALLOG("Open write handles failed %s:%d\n", iface->serial, iface->ifaceno);
-                return code;
-            }
-            //seep a bit to let the OS restart thing correctly
-            yApproximateSleep(1);
-            goto retry;
-        }
-        HALLOG("Write IO error %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-        return code;
-    }
-    if (retrycount == 0) {
-        HALLOG("Write IO needed 1 retry %s:%d (%s/%s)\n", iface->serial, iface->ifaceno, errmsg, DP(iface->devicePath));
-    }
-    return YAPI_SUCCESS;
-}
-
-
-
-static void* yyyUsbIoThread(void* thread_void)
-{
-    u32             i;
-    char            errmsg[YOCTO_ERRMSG_LEN];
-    DWORD           dwEvent;
-    yThread         *thread = (yThread*)thread_void;
-    yInterfaceSt    *iface = (yInterfaceSt*)thread->ctx;
-
-
-    iface->wrHDL = INVALID_HANDLE_VALUE;
-    iface->rdHDL = INVALID_HANDLE_VALUE;
-    for (i = 0; i < 2; i++) {
-        iface->EV[i] = NULL;
-    }
-
-    //open blocking write handle
-    if (YISERR(OpenWriteHandles(iface))) {
-        yThreadSignalStart(thread);
-        goto exitThread;
-    }
-    //open blocking write handle
-    if (YISERR(OpenReadHandles(iface))) {
-        yThreadSignalStart(thread);
-        goto exitThread;
-    }
-    // create Event for breaking wait
-    iface->EV[YWIN_EVENT_INTERRUPT] = CreateEvent(NULL, FALSE, FALSE, NULL);
-    if (iface->EV[YWIN_EVENT_INTERRUPT] == NULL) {
-        yWinSetErr(iface, errmsg);
-        HALLOG("IO error %s:%d (%s)\n", iface->serial, iface->ifaceno, errmsg);
-        yThreadSignalStart(thread);
-        goto exitThread;
-    }
-
-
-    HALLOG("yyyReady I%x wr=%x rd=%x se=%s\n", iface->ifaceno, iface->wrHDL, iface->rdHDL, iface->serial);
-    yThreadSignalStart(thread);
-    //CloseHandle(iface->EV[YWIN_EVENT_INTERRUPT]);
-
-
-    if (yyyyRead(iface, errmsg) != YAPI_SUCCESS) {
-        HALLOG("Read error  %s:%d (%s)\n", iface->serial, iface->ifaceno, errmsg);
-        goto exitThread;
-    }
-
-
-    HALLOG("----IoThread start of %s:%d (%s)  ---\n", iface->serial, iface->ifaceno, DP(iface->devicePath));
-
-    while (!yThreadMustEnd(thread)) {
-        pktItem *pktItem;
-        yPktQueuePeekH2D(iface, &pktItem);
-        //first write pending out packet
-        while (pktItem) {
-#ifdef DEBUG_PKT_TIMING
-            u64     timeBeforeWrite, timeAfterWrite, stop;
-            YASSERT(pktItem->time);
-            timeBeforeWrite = yapiGetTickCount() - pktItem->time;
-            YASSERT(timeBeforeWrite >= 0 && timeBeforeWrite < 50);
-#endif
-            if (YISERR(yyyyWrite(iface, pktItem))) {
-                goto exitThread;
-            }
-            yPktQueuePopH2D(iface, &pktItem);
-#ifdef DEBUG_PKT_TIMING
-            stop = yapiGetTickCount();
-            timeAfterWrite = stop - pktItem->time;
-            if (pktItem->next) {
-                u64 tmp = yapiGetTickCount() - pktItem->time;
-                printf("outpkt no %llu %llu -> %llu (%llu=>%llu) (next=no %llu %llu)\n", pktItem->ospktno, timeBeforeWrite, timeAfterWrite, pktItem->time, stop, pktItem->next->ospktno, tmp);
-            } else {
-                printf("outpkt no %llu %llu -> %llu (%llu=>%llu) (no next)\n",
-                    pktItem->ospktno, timeBeforeWrite, timeAfterWrite, pktItem->time, stop);
-            }
-            YASSERT(timeAfterWrite >= 0 && timeAfterWrite < 50);
-#endif
-            yFree(pktItem);
-            yPktQueuePeekH2D(iface, &pktItem);
-        }
-
-        // Wait for the thread to signal one of the event objects
-        dwEvent = WaitForMultipleObjects(
-            2,          // number of objects in array
-            iface->EV,  // array of objects
-            FALSE,      // wait for any object
-            50);        // wait for max 50 ms
-        if (dwEvent == WAIT_FAILED) {
-            YRETCODE code = yWinSetErr(iface, errmsg);
-            HALLOG("Wait error %s:%d (%s)\n", iface->serial, iface->ifaceno, errmsg);
-            yPktQueueSetError(&iface->txQueue, code, errmsg);
-            yPktQueueSetError(&iface->rxQueue, code, errmsg);
-            yApproximateSleep(2);
-            continue;
-        }
-        if (dwEvent != WAIT_TIMEOUT) {
-            if (yyyyRead(iface, errmsg) != YAPI_SUCCESS) {
-                HALLOG("Read error %s:%d (%s)\n", iface->serial, iface->ifaceno, errmsg);
-                yPktQueueSetError(&iface->rxQueue, YAPI_IO_ERROR, errmsg);
-                break;
-            }
-        }
-            }
-
-exitThread:
-    HALLOG("----IoThread end of  %s:%d (%s)  ---\n", iface->serial, iface->ifaceno, DP(iface->devicePath));
-    if (iface->EV[YWIN_EVENT_INTERRUPT] != NULL) {
-        CloseHandle(iface->EV[YWIN_EVENT_INTERRUPT]);
-        iface->EV[YWIN_EVENT_INTERRUPT] = NULL;
-    }
-    CloseWriteHandles(iface);
-    CloseReadHandles(iface);
-    yThreadSignalEnd(thread);
-    return NULL;
-        }
-
-
-int yyySetup(yInterfaceSt *iface, char *errmsg)
-{
-    HALLOG("yyySetup %p\n", iface);
-    yPktQueueInit(&iface->rxQueue);
-    yPktQueueInit(&iface->txQueue);
-    memset(&iface->io_thread, 0, sizeof(yThread));
-    if (yThreadCreate(&iface->io_thread, yyyUsbIoThread, (void*)iface) < 0) {
-        return YERRMSG(YAPI_IO_ERROR, "Unable to start USB IO thread");
-    }
-    return YAPI_SUCCESS;
-}
-
-int yyySignalOutPkt(yInterfaceSt *iface, char *errmsg)
-{
-    ySetEvent(&iface->EV[YWIN_EVENT_INTERRUPT]);
-    return YAPI_SUCCESS;
-}
-
-void yyyPacketShutdown(yInterfaceSt *iface)
-{
-    HALLOG("yyyPacketShutdown %p\n", iface);
-    if (yThreadIsRunning(&iface->io_thread)) {
-        u64 timeout;
-        yThreadRequestEnd(&iface->io_thread);
-        timeout = yapiGetTickCount() + YIO_DEFAULT_USB_TIMEOUT;
-        while (yThreadIsRunning(&iface->io_thread) && timeout >= yapiGetTickCount()) {
-            yApproximateSleep(10);
-        }
-        yThreadKill(&iface->io_thread);
-    }
-    yPktQueueFree(&iface->rxQueue);
-    yPktQueueFree(&iface->txQueue);
-}
-
-#endif
-
-
-#ifdef WINCE
-#include "yproto.h"
-
-
-int yUSB_init(yContextSt *ctx, char *errmsg)
-{
-    return YAPI_SUCCESS;
-}
-
-
-int yUSB_stop(yContextSt *ctx, char *errmsg)
-{
-    return 0;
-}
-
-
-
-int yUSBGetInterfaces(yInterfaceSt **ifaces, int *nbifaceDetect, char *errmsg)
-{
-    *nbifaceDetect = 0;
-    return 0;
-}
-
-
-
-int yyyTestOShdl(yPrivDeviceSt *dev, DevEnum *newdev)
-{
-    return 1;
-}
-
-
-
-
-int yyySetup(yInterfaceSt *iface, char *errmsg)
-{
-    return YERR(YAPI_NOT_SUPPORTED);
-}
-
-int yyySignalOutPkt(yInterfaceSt *iface)
-{
-    return YAPI_SUCCESS;
-}
-
-void yyyPacketShutdown(yInterfaceSt  *iface)
-{}
-
-#endif
--- a/Sources/cpplib/yapi/yprog.c
+++ /dev/null
@@ -1,2391 +0,0 @@
-/*********************************************************************
- *
- * $Id: yprog.c 33735 2018-12-14 16:06:53Z seb $
- *
- * Implementation of firmware upgrade functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__ "yprog"
-#include "ydef.h"
-#ifdef YAPI_IN_YDEVICE
-#include "Yocto/yocto.h"
-#endif
-#ifdef MICROCHIP_API
-#include <Yocto/yapi_ext.h>
-#else
-#include "yproto.h"
-#ifndef WINDOWS_API
-#include <dirent.h>
-#include <sys/stat.h>
-#endif
-#endif
-#include "yhash.h"
-#include "yjson.h"
-#include "yprog.h"
-#include <stdio.h>
-//#define DEBUG_FIRMWARE
-
-#ifndef YAPI_IN_YDEVICE
-// Public implementation of uProgXXX function (used only in public API).
-// Init and Free are automatically called from yapiInit and yapiFree
-
-FIRMWARE_CONTEXT fctx;
-// these two variable have been extracted from FIRMWARE_CONTEXT
-// to prevent some compiler to misalign them (GCC on raspberry PI)
-BootloaderSt            firm_dev;
-USB_Packet              firm_pkt;
-
-#ifdef __BORLANDC__
-#pragma warn - 8066
-#pragma warn - 8008
-#pragma warn - 8065
-#endif
-
-void yProgInit(void)
-{
-    // BYN header must have an even number of bytes
-    YASSERT((sizeof(byn_head_multi)& 1) == 0);
-
-    memset(&fctx, 0, sizeof(fctx));
-    fctx.stepA = FLASH_DONE;
-    memset(&firm_dev, 0, sizeof(firm_dev));
-    yContext->fuCtx.global_progress = 100;
-    yInitializeCriticalSection(&fctx.cs);
-}
-
-void  yProgFree(void)
-{
-    int fuPending;
-    do {
-
-        yEnterCriticalSection(&fctx.cs);
-        if (yContext->fuCtx.global_progress <0 || yContext->fuCtx.global_progress >= 100) {
-            fuPending = 0;
-        } else{
-            fuPending = 1;
-        }
-        yLeaveCriticalSection(&fctx.cs);
-        if (fuPending){
-            yApproximateSleep(1);
-        }
-    } while (fuPending);
-
-    if (yContext->fuCtx.serial)
-        yFree(yContext->fuCtx.serial);
-    if (yContext->fuCtx.firmwarePath)
-        yFree(yContext->fuCtx.firmwarePath);
-    if (yContext->fuCtx.settings)
-        yFree(yContext->fuCtx.settings);
-    yDeleteCriticalSection(&fctx.cs);
-    memset(&fctx, 0, sizeof(fctx));
-}
-
-#endif
-
-#ifdef MICROCHIP_API
-static
-#endif
-const char* prog_GetCPUName(BootloaderSt *dev)
-{
-	const char * res="";
-	switch(dev->devid_family){
-	case FAMILY_PIC24FJ256DA210:
-        switch(dev->devid_model){
-#ifndef MICROCHIP_API
-            case PIC24FJ128DA206 :
-                return "PIC24FJ128DA206";
-            case PIC24FJ128DA106 :
-                return "PIC24FJ128DA106";
-            case PIC24FJ128DA210 :
-                return "PIC24FJ128DA210";
-            case PIC24FJ128DA110 :
-                return "PIC24FJ128DA110";
-            case PIC24FJ256DA206 :
-                return "PIC24FJ256DA206";
-            case PIC24FJ256DA106 :
-                return "PIC24FJ256DA106";
-            case PIC24FJ256DA210 :
-                return "PIC24FJ256DA210";
-            case PIC24FJ256DA110 :
-                return "PIC24FJ256DA110";
-			default:
-			   res = "Unknown CPU model(family PIC24FJ256DA210)";
-			   break;
-#else
-            case PIC24FJ256DA206 :
-                return "PIC24FJ256DA206";
-            default: ;
-#endif
-		}
-        break;
-    case FAMILY_PIC24FJ64GB004:
-        switch(dev->devid_model){
-#ifndef MICROCHIP_API
-            case PIC24FJ32GB002 :
-                return "PIC24FJ32GB002";
-            case PIC24FJ64GB002 :
-                return "PIC24FJ64GB002";
-            case PIC24FJ32GB004 :
-                return "PIC24FJ32GB004";
-            case PIC24FJ64GB004 :
-                return "PIC24FJ64GB004";
-            default:
-				res= "Unknown CPU model(family PIC24FJ64GB004)";
-				break;
-#else
-            case PIC24FJ64GB002 :
-                return "PIC24FJ64GB002";
-			default:
-				break;
-#endif
-        }
-        break;
-    }
-	return res;
-}
-
-
-//used by yprogrammer
-static int  checkHardwareCompat(BootloaderSt *dev,const char *pictype)
-{
-    const char *cpuname=prog_GetCPUName(dev);
-    if(YSTRICMP(cpuname,pictype)!=0){
-        return 0;
-    }
-    return 1;
-}
-
-
-
-#ifdef MICROCHIP_API
-
-int IsValidBynHead(const byn_head_multi *head, u32 size, u16 flags, char *errmsg)
-{
-    if(head->h.sign != BYN_SIGN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Not a firmware file");
-    }
-    if(YSTRLEN(head->h.serial) >= YOCTO_SERIAL_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Bad serial");
-    }
-    if(YSTRLEN(head->h.product) >= YOCTO_PRODUCTNAME_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Bad product name");
-    }
-    if(YSTRLEN(head->h.firmware) >= YOCTO_FIRMWARE_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Bad firmware revision");
-    }
-    switch(head->h.rev) {
-        case BYN_REV_V4:
-            if( head->v4.nbzones > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many zones");
-            }
-            if(head->v4.datasize != size -(sizeof(byn_head_sign)+sizeof(byn_head_v4))){
-                return YERRMSG(YAPI_INVALID_ARGUMENT, "Incorrect file size");
-            }
-            return YAPI_SUCCESS;
-        case BYN_REV_V5:
-            //we do not check prog_version on YoctoHubs on purpose
-            if( head->v5.nbzones > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many zones");
-            }
-            if(head->v5.datasize != size -(sizeof(byn_head_sign)+sizeof(byn_head_v5))){
-                return YERRMSG(YAPI_INVALID_ARGUMENT, "Incorrect file size");
-            }
-            return YAPI_SUCCESS;
-        case BYN_REV_V6:
-            //we do not check prog_version on YoctoHubs on purpose
-            if( head->v6.ROM_nb_zone > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many ROM zones");
-            }
-            if( head->v6.FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many FLASH zones");
-            }
-            return YAPI_SUCCESS;
-        default:
-            break;
-    }
-    return YERRMSG(YAPI_INVALID_ARGUMENT, "Please upgrade the hub device first");
-}
-
-#else
-
-int IsValidBynHead(const byn_head_multi *head, u32 size, u16 flags, char *errmsg)
-{
-    if(head->h.sign != BYN_SIGN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Not a valid .byn file");
-    }
-    if(YSTRLEN(head->h.serial) >= YOCTO_SERIAL_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid serial");
-    }
-    if(YSTRLEN(head->h.product) >= YOCTO_PRODUCTNAME_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid product name");
-    }
-    if(YSTRLEN(head->h.firmware) >= YOCTO_FIRMWARE_LEN){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid firmware revision");
-    }
-
-    switch(head->h.rev) {
-        case BYN_REV_V4:
-            if( head->v4.nbzones > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many zones in .byn file");
-            }
-            if(head->v4.datasize != size -(sizeof(byn_head_sign)+sizeof(byn_head_v4))){
-               return YERRMSG(YAPI_INVALID_ARGUMENT, "Incorrect file size or corrupt file");
-            }
-            return YAPI_SUCCESS;
-        case BYN_REV_V5:
-            if(YSTRLEN(head->v5.prog_version) >= YOCTO_SERIAL_LEN){
-                return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid programming tools revision or corrupt file");
-            }
-#ifndef YBUILD_PATCH_WITH_BUILD
-            if((flags & YPROG_FORCE_FW_UPDATE) == 0 && head->v5.prog_version[0]){
-                 int byn = atoi(head->v5.prog_version);
-                 int tools=atoi(YOCTO_API_BUILD_NO);
-                 if(byn>tools){
-                     return YERRMSG(YAPI_VERSION_MISMATCH, "This firmware is too recent, please upgrade your VirtualHub or Yoctopuce library");
-                 }
-            }
-#endif
-            if( head->v5.nbzones > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many zones in .byn file");
-            }
-            if(head->v5.datasize != size -(sizeof(byn_head_sign)+sizeof(byn_head_v5))){
-               return YERRMSG(YAPI_INVALID_ARGUMENT, "Incorrect file size or corrupt file");
-            }
-            return YAPI_SUCCESS;
-        case BYN_REV_V6:
-            if(YSTRLEN(head->v6.prog_version) >= YOCTO_SERIAL_LEN){
-                return YERRMSG(YAPI_INVALID_ARGUMENT, "Invalid programming tools revision or corrupt file");
-            }
-#ifndef YBUILD_PATCH_WITH_BUILD
-            if ((flags & YPROG_FORCE_FW_UPDATE) == 0 && head->v6.prog_version[0]){
-                int byn = atoi(head->v6.prog_version);
-                int tools=atoi(YOCTO_API_BUILD_NO);
-                if(byn>tools){
-                    return YERRMSG(YAPI_VERSION_MISMATCH, "This firmware is too recent, please upgrade your VirtualHub or Yoctopuce library");
-                }
-            }
-#endif
-            if( head->v6.ROM_nb_zone > MAX_ROM_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many ROM zones in .byn file");
-            }
-            if( head->v6.FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES){
-                return YERRMSG(YAPI_INVALID_ARGUMENT,"Too many FLASH zones in .byn file");
-            }
-            return YAPI_SUCCESS;
-        default:
-            break;
-    }
-    return YERRMSG(YAPI_INVALID_ARGUMENT, "Unsupported file format, please upgrade your VirtualHub or Yoctopuce library");
-}
-#endif
-
-int ValidateBynCompat(const byn_head_multi *head, u32 size, const char *serial, u16 flags, BootloaderSt *dev, char *errmsg)
-{
-    YPROPERR(IsValidBynHead(head, size, flags, errmsg));
-    if(serial && YSTRNCMP(head->h.serial,serial,YOCTO_BASE_SERIAL_LEN)!=0){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "This BYN file is not designed for your device");
-    }
-    if(dev && !checkHardwareCompat(dev,head->h.pictype)){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "This BYN file is not designed for your device");
-    }
-    return 0;
-}
-
-#ifndef MICROCHIP_API
-// user by yprogrammer
-int  IsValidBynFile(const byn_head_multi *head, u32 size, const char *serial, u16 flags, char *errmsg)
-{
-    HASH_SUM ctx;
-    u8       md5res[16];
-    int      res;
-
-    res = ValidateBynCompat(head, size, serial, flags, NULL, errmsg);
-    if(res == YAPI_SUCCESS && head->h.rev == BYN_REV_V6) {
-        // compute MD5
-        MD5Initialize(&ctx);
-        MD5AddData(&ctx, ((u8*)head)+BYN_MD5_OFS_V6, size-BYN_MD5_OFS_V6);
-        MD5Calculate(&ctx, md5res);
-        if(memcmp(md5res, head->v6.md5chk, 16)) {
-            return YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid checksum");
-        }
-    }
-    return res;
-}
-#endif
-
-#ifdef CPU_BIG_ENDIAN
-
-#define BSWAP_U16(NUM)  (((NUM )>> 8) | ((NUM) << 8))
-#define BSWAP_U32(NUM) ((((NUM) >> 24) & 0xff) | (((NUM) << 8) & 0xff0000) | (((NUM) >> 8) & 0xff00) | (((NUM) << 24) & 0xff000000 ))
-
-void decode_byn_head_multi(byn_head_multi *head)
-{
-    head->h.sign = BSWAP_U32(head->h.sign);
-    head->h.rev = BSWAP_U16(head->h.rev);
-    switch (head->h.rev) {
-    case BYN_REV_V4:
-        head->v4.nbzones = BSWAP_U32(head->v4.nbzones);
-        head->v4.datasize = BSWAP_U32(head->v4.datasize);
-        break;
-    case BYN_REV_V5:
-        head->v5.pad = BSWAP_U16(head->v5.pad);
-        head->v5.nbzones = BSWAP_U32(head->v5.nbzones);
-        head->v5.datasize = BSWAP_U32(head->v5.datasize);
-        break;
-    case BYN_REV_V6:
-        head->v6.ROM_total_size = BSWAP_U32(head->v6.ROM_total_size);
-        head->v6.FLA_total_size = BSWAP_U32(head->v6.FLA_total_size);
-        break;
-    default:
-        break;
-    }
-}
-
-void decode_byn_zone(byn_zone *zone)
-{
-    zone->addr_page = BSWAP_U32(zone->addr_page);
-    zone->len = BSWAP_U32(zone->len);
-}
-
-#endif
-
-
-#if !defined(MICROCHIP_API)
-// Return 1 if the communication channel to the device is busy
-// Return 0 if there is no ongoing transaction with the device
-int ypIsSendBootloaderBusy(BootloaderSt *dev)
-{
-    return 0;
-}
-
-
-// Return 0 if there command was successfully queued for sending
-// Return -1 if the output channel is busy and the command could not be sent
-int ypSendBootloaderCmd(BootloaderSt *dev, const USB_Packet *pkt,char *errmsg)
-{
-	return yyySendPacket(&dev->iface,pkt,errmsg);
-}
-
-// Return 0 if a reply packet was available and returned
-// Return -1 if there was no reply available or on error
-int ypGetBootloaderReply(BootloaderSt *dev, USB_Packet *pkt,char *errmsg)
-{
-	pktItem *ptr;
-    // clear the dest buffer to avoid any misinterpretation
-    memset(pkt->prog.raw, 0, sizeof(USB_Packet));
-	YPROPERR(yPktQueueWaitAndPopD2H(&dev->iface,&ptr,10,errmsg));
-    if(ptr){
-        yTracePtr(ptr);
-        memcpy(pkt,&ptr->pkt,sizeof(USB_Packet));
-        yFree(ptr);
-        return 0;
-    }
-	return YAPI_TIMEOUT; // not a fatal error, handled by caller
-}
-#endif
-
-
-
-#if !defined(MICROCHIP_API)
-//pool a packet form usb for a specific device
-int BlockingRead(BootloaderSt *dev,USB_Packet *pkt, int maxwait, char *errmsg)
-{
-	pktItem *ptr;
-	YPROPERR(yPktQueueWaitAndPopD2H(&dev->iface,&ptr,maxwait,errmsg));
-    if (ptr) {
-	    yTracePtr(ptr);
-		memcpy(pkt,&ptr->pkt,sizeof(USB_Packet));
-		yFree(ptr);
-        return YAPI_SUCCESS;
-	}
-	return YERR(YAPI_TIMEOUT);
-}
-
-int SendDataPacket( BootloaderSt *dev,int program, u32 address, u8 *data,int nbinstr,char *errmsg)
-{
-
-    USB_Packet  pkt;
-    //USB_Prog_Packet *pkt = &dev->iface.txqueue->pkt.prog;
-    memset(&pkt.prog,0,sizeof(USB_Prog_Packet));
-    if(program){
-        pkt.prog.pkt.type = PROG_PROG;
-    }else{
-        pkt.prog.pkt.type = PROG_VERIF;
-    }
-    pkt.prog.pkt.adress_low = address &0xffff;
-    pkt.prog.pkt.addres_high = (address>>16)&0xff;
-    if(nbinstr > MAX_INSTR_IN_PACKET){
-        nbinstr = MAX_INSTR_IN_PACKET;
-    }
-    if(nbinstr){
-        memcpy(pkt.prog.pkt.data,data,nbinstr*3);
-        pkt.prog.pkt.size= nbinstr;
-    }
-
-    YPROPERR(ypSendBootloaderCmd(dev,&pkt,errmsg));
-    return nbinstr;
-}
-
-
-
-int yUSBGetBooloader(const char *serial, const char * name,  yInterfaceSt *iface,char *errmsg)
-{
-
-    int             nbifaces=0;
-    yInterfaceSt    *curif;
-    yInterfaceSt    *runifaces=NULL;
-    int             i;
-
-    YPROPERR(yyyUSBGetInterfaces(&runifaces,&nbifaces,errmsg));
-    //inspect all interfaces
-    for(i=0, curif = runifaces ; i < nbifaces ; i++, curif++){
-        // skip real devices
-        if(curif->deviceid >YOCTO_DEVID_BOOTLOADER)
-            continue;
-#ifdef WINDOWS_API
-        if(name !=NULL && YSTRICMP(curif->devicePath,name)==0){
-            if (iface)
-                memcpy(iface,curif,sizeof(yInterfaceSt));
-            yFree(runifaces);
-            return YAPI_SUCCESS;
-        }else
-#endif
-        if(serial!=NULL && YSTRCMP(curif->serial,serial)==0){
-            if (iface)
-                memcpy(iface,curif,sizeof(yInterfaceSt));
-            yFree(runifaces);
-            return YAPI_SUCCESS;
-        }
-    }
-    // free all tmp ifaces
-    if(runifaces){
-        yFree(runifaces);
-    }
-    return YERR(YAPI_DEVICE_NOT_FOUND);
-}
-
-#endif
-
-#ifndef YAPI_IN_YDEVICE
-static int yLoadFirmwareFile(const char * filename, u8 **buffer, char *errmsg)
-{
-    FILE *f = NULL;
-    int  size;
-    int  readed;
-    u8   *ptr;
-
-    *buffer = NULL;
-    if (YFOPEN(&f, filename, "rb") != 0) {
-        return YERRMSG(YAPI_IO_ERROR, "unable to access file");
-    }
-    fseek(f, 0, SEEK_END);
-    size = (int)ftell(f);
-    if (size > 0x100000 || size <= 0){
-        fclose(f);
-        return YERR(YAPI_IO_ERROR);
-    }
-    ptr = yMalloc(size);
-    if (ptr == NULL) {
-        fclose(f);
-        return YERR(YAPI_IO_ERROR);
-    }
-    fseek(f, 0, SEEK_SET);
-    readed = (int)fread(ptr, 1, size, f);
-    fclose(f);
-    if (readed != size) {
-        yFree(ptr);
-        return YERRMSG(YAPI_IO_ERROR, "short read");
-    }
-    *buffer = ptr;
-    return size;
-}
-
-
-static void yGetFirmware(u32 ofs, u8 *dst, u16 size)
-{
-    YASSERT(fctx.firmware);
-    YASSERT(ofs + size <= fctx.len);
-    memcpy(dst, fctx.firmware + ofs, size);
-}
-
-
-#endif
-
-
-
-#ifdef YAPI_IN_YDEVICE
-    #define ulog ylog
-    #define ulogU16 ylogU16
-    #define ulogChar ylogChar
-    #define uLogProgress(msg) yProgLogProgress(msg)
-
-
-    // report progress for devices and vhub
-    static void yProgLogProgress(const char *msg)
-    {
-        yEnterCriticalSection(&fctx.cs);
-        YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN, msg);
-        hProgLog(msg);
-        yLeaveCriticalSection(&fctx.cs);
-    }
-#else
-    #define ytime() ((u32) yapiGetTickCount())
-    #define Flash_ready()  1
-    #define ulog(str) dbglog("%s",str)
-    #define ulogU16(val) dbglog("%x",val)
-    #define ulogChar(val) dbglog("%c",val)
-
-    // report progress for Yoctolib
-    #define setOsGlobalProgress(prog, msg) osProgLogProgressEx(__FILE_ID__,__LINE__, prog, msg)
-    #define uLogProgress(msg) yProgLogProgress(msg)
-
-
-    // report progress for devices and vhub
-    static void yProgLogProgress(const char *msg)
-    {
-        yEnterCriticalSection(&fctx.cs);
-        YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN, msg);
-        yLeaveCriticalSection(&fctx.cs);
-    }
-
-
-    static void osProgLogProgressEx(const char *fileid, int line, int prog, const char *msg)
-    {
-        yEnterCriticalSection(&fctx.cs);
-        if (prog != 0){
-           yContext->fuCtx.global_progress = prog;
-        }
-        if (msg != NULL && *msg != 0){
-#ifdef DEBUG_FIRMWARE
-            dbglog("%s:%d:(%d%%) %s\n", fileid, line, prog, msg);
-            YSPRINTF(yContext->fuCtx.global_message, YOCTO_ERRMSG_LEN, "%s:%d:%s", fileid, line, msg);
-#else
-            YSTRCPY(yContext->fuCtx.global_message, YOCTO_ERRMSG_LEN, msg);
-#endif
-        }
-        yLeaveCriticalSection(&fctx.cs);
-    }
-
-#endif
-
-#ifdef MICROCHIP_API
-#define uGetBootloader(serial,ifaceptr)   yGetBootloaderPort(serial,ifaceptr)
-#else
-#define uGetBootloader(serial,ifaceptr)   yUSBGetBooloader(serial, NULL, ifaceptr,NULL)
-#endif
-
-
-
-
-//-1 = error 0= retry 1= ok (the global fctx.stepA is already updated)
-static int uGetDeviceInfo(void)
-{
-    switch(fctx.stepB){
-    case 0:
-        fctx.stepB++;
-        fctx.timeout = ytime() + PROG_GET_INFO_TIMEOUT;
-        // no break on purpose;
-    case 1:
-        memset(&firm_pkt,0,sizeof(USB_Prog_Packet));
-        firm_pkt.prog.pkt.type = PROG_INFO;
-        if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-            if((s32)(fctx.timeout - ytime()) < 0) {
-#ifdef DEBUG_FIRMWARE
-                ulog("Cannot send GetInfo pkt\n");
-#endif
-                YSTRCPY(fctx.errmsg, FLASH_ERRMSG_LEN, "Cannot send GetInfo");
-                return -1;
-            }
-            return 0;
-        }
-        fctx.stepB++;
-        fctx.timeout = ytime() + PROG_GET_INFO_TIMEOUT;
-        // no break on purpose;
-    case 2:
-        if(ypGetBootloaderReply(&firm_dev, &firm_pkt,NULL)<0){
-            if((s32)(fctx.timeout - ytime()) < 0) {
-#ifdef DEBUG_FIRMWARE
-                ulog("Bootloader did not respond to GetInfo pkt\n");
-#endif
-                YSTRCPY(fctx.errmsg, FLASH_ERRMSG_LEN, "Cannot recv GetInfo");
-                return -1;
-            }
-            return 0;
-        }
-        fctx.stepB++;
-        // no break on purpose;
-    case 3:
-        if(firm_pkt.prog.pkt.type == PROG_INFO) {
-#ifdef DEBUG_FIRMWARE
-            ulog("PROG_INFO received\n");
-#endif
-            firm_dev.er_blk_size   = DECODE_U16(firm_pkt.prog.pktinfo.er_blk_size);
-            firm_dev.pr_blk_size   = DECODE_U16(firm_pkt.prog.pktinfo.pr_blk_size);
-            firm_dev.last_addr     = DECODE_U32(firm_pkt.prog.pktinfo.last_addr);
-            firm_dev.settings_addr = DECODE_U32(firm_pkt.prog.pktinfo.settings_addr);
-            firm_dev.devid_family  = DECODE_U16(firm_pkt.prog.pktinfo.devidl)>>8;
-            firm_dev.devid_model   = DECODE_U16(firm_pkt.prog.pktinfo.devidl) & 0xff;
-            firm_dev.devid_rev     = DECODE_U16(firm_pkt.prog.pktinfo.devidh);
-            firm_dev.startconfig   = DECODE_U32(firm_pkt.prog.pktinfo.config_start);
-            firm_dev.endofconfig   = DECODE_U32(firm_pkt.prog.pktinfo.config_stop);
-#ifndef MICROCHIP_API
-            firm_dev.ext_jedec_id    = 0xffff;
-            firm_dev.ext_page_size   = 0xffff;
-            firm_dev.ext_total_pages = 0;
-            firm_dev.first_code_page = 0xffff;
-            firm_dev.first_yfs3_page = 0xffff;
-#endif
-            uLogProgress("Device info retrieved");
-            fctx.stepB = 0;
-            fctx.stepA = FLASH_VALIDATE_BYN;
-#ifndef MICROCHIP_API
-        } else if(firm_pkt.prog.pkt.type == PROG_INFO_EXT) {
-#ifdef DEBUG_FIRMWARE
-            ulog("PROG_INFO_EXT received\n");
-#endif
-            firm_dev.er_blk_size   = DECODE_U16(firm_pkt.prog.pktinfo_ext.er_blk_size);
-            firm_dev.pr_blk_size   = DECODE_U16(firm_pkt.prog.pktinfo_ext.pr_blk_size);
-            firm_dev.last_addr     = DECODE_U32(firm_pkt.prog.pktinfo_ext.last_addr);
-            firm_dev.settings_addr = DECODE_U32(firm_pkt.prog.pktinfo_ext.settings_addr);
-            firm_dev.devid_family  = DECODE_U16(firm_pkt.prog.pktinfo_ext.devidl) >> 8;
-            firm_dev.devid_model   = DECODE_U16(firm_pkt.prog.pktinfo_ext.devidl) & 0xff;
-            firm_dev.devid_rev     = DECODE_U16(firm_pkt.prog.pktinfo_ext.devidh);
-            firm_dev.startconfig   = DECODE_U32(firm_pkt.prog.pktinfo_ext.config_start);
-            firm_dev.endofconfig   = DECODE_U32(firm_pkt.prog.pktinfo_ext.config_stop);
-            firm_dev.ext_jedec_id    = DECODE_U16(firm_pkt.prog.pktinfo_ext.ext_jedec_id);
-            firm_dev.ext_page_size   = DECODE_U16(firm_pkt.prog.pktinfo_ext.ext_page_size);
-            firm_dev.ext_total_pages = DECODE_U16(firm_pkt.prog.pktinfo_ext.ext_total_pages);
-            firm_dev.first_code_page = DECODE_U16(firm_pkt.prog.pktinfo_ext.first_code_page);
-            firm_dev.first_yfs3_page = DECODE_U16(firm_pkt.prog.pktinfo_ext.first_yfs3_page);
-            uLogProgress("Device info retrieved");
-            fctx.stepB = 0;
-            fctx.stepA = FLASH_VALIDATE_BYN;
-#endif
-        } else {
-#ifdef DEBUG_FIRMWARE
-            ulog("Not a PROG_INFO pkt\n");
-#endif
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Invalid prog pkt");
-            return -1;
-        }
-        return 1;
-#ifdef DEBUG_FIRMWARE
-    default:
-        ulog("invalid step in uGetDeviceInfo\n");
-        break;
-#endif
-    }
-    return 0;
-}
-
-
-
-
-static int uSendCmd(u8 cmd,FLASH_DEVICE_STATE nextState)
-{
-    if(ypIsSendBootloaderBusy(&firm_dev)) {
-        return 0;
-    }
-    memset(&firm_pkt,0,sizeof(USB_Packet));
-    firm_pkt.prog.pkt.type = cmd;
-    if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-        return -1;
-    }
-    fctx.stepA = nextState;
-    return 1;
-}
-
-static int uFlashZone()
-{
-    u16         datasize;
-    char msg[FLASH_ERRMSG_LEN];
-
-    switch(fctx.zst){
-        case FLASH_ZONE_START:
-            if(fctx.currzone == fctx.bynHead.v6.ROM_nb_zone + fctx.bynHead.v6.FLA_nb_zone){
-                fctx.stepA = FLASH_GET_INFO_BFOR_REBOOT;
-                fctx.stepB = 0;
-                fctx.zOfs = FLASH_NB_REBOOT_RETRY;
-                return 0;
-            }
-            uGetFirmwareBynZone(fctx.zOfs, &fctx.bz);
-            YSTRCPY(msg, FLASH_ERRMSG_LEN, "Flash zone");
-#if defined(DEBUG_FIRMWARE)
-#ifdef MICROCHIP_API
-            {
-                char *p = msg + 10;
-                *p++ = ' ';
-                u16toa(fctx.currzone, p);
-                p += ystrlen(p);
-                *p++ = ':';
-                u32toa(fctx.zOfs, p);
-                p += ystrlen(p);
-            }
-#else
-            YSPRINTF(msg, FLASH_ERRMSG_LEN, "Flash zone %d:%d : %x(%x)", fctx.currzone, fctx.zOfs, fctx.bz.addr_page, fctx.bz.len);
-            dbglog("Flash zone %d:%x : %x(%x)\n",fctx.currzone,fctx.zOfs,fctx.bz.addr_page,fctx.bz.len);
-#endif
-#endif
-            uLogProgress(msg);
-        if((fctx.bz.addr_page % (firm_dev.pr_blk_size*2)) !=0 ) {
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"ProgAlign");
-                return -1;
-            }
-            fctx.zOfs += sizeof(byn_zone);
-            fctx.zNbInstr = fctx.bz.len/3;
-            fctx.stepB    = 0;
-            if(fctx.zNbInstr < (u32)firm_dev.pr_blk_size){
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"ProgSmall");
-                return -1;
-            }
-            fctx.zst = FLASH_ZONE_PROG;
-            //no break on purpose
-        case FLASH_ZONE_PROG:
-            if(ypIsSendBootloaderBusy(&firm_dev)) {
-                return 0;
-            }
-            memset(&firm_pkt,0,sizeof(USB_Packet));
-            firm_pkt.prog.pkt.type = PROG_PROG;
-            firm_pkt.prog.pkt.adress_low = DECODE_U16(fctx.bz.addr_page & 0xffff);
-            firm_pkt.prog.pkt.addres_high = (fctx.bz.addr_page>>16) & 0xff;
-            firm_pkt.prog.pkt.size = (u8) (fctx.zNbInstr < MAX_INSTR_IN_PACKET? fctx.zNbInstr : MAX_INSTR_IN_PACKET) ;
-
-            datasize = firm_pkt.prog.pkt.size*3;
-            uGetFirmware(fctx.zOfs, firm_pkt.prog.pkt.data, datasize);
-            //dbglog("Flash zone %d:0x%x  0x%x(%d /%d)\n", fctx.currzone, fctx.zOfs, fctx.bz.addr_page, fctx.stepB, firm_dev.pr_blk_size);
-            if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"ProgPkt");
-                return -1;
-            }
-
-            fctx.zOfs     += datasize;
-            fctx.zNbInstr -= firm_pkt.prog.pkt.size;
-            fctx.stepB    += firm_pkt.prog.pkt.size;
-            fctx.progress = (u16)(4 + 92*fctx.zOfs / fctx.len);
-
-            if( fctx.stepB >= firm_dev.pr_blk_size){
-                //look for confirmation
-                fctx.timeout =ytime()+ BLOCK_FLASH_TIMEOUT;
-                fctx.zst =  FLASH_ZONE_RECV_OK;
-            }
-            break;
-        case FLASH_ZONE_RECV_OK:
-            if(ypGetBootloaderReply(&firm_dev, &firm_pkt,NULL)<0){
-                if((s32)(fctx.timeout - ytime()) < 0) {
-#if defined(DEBUG_FIRMWARE) && !defined(MICROCHIP_API)
-                    dbglog("Bootlaoder did not send confirmation for Zone %x Block %x\n",fctx.currzone,fctx.bz.addr_page);
-#endif
-                    YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"ProgDead");
-                    return -1;
-                }
-                return 0;
-            }
-            if(firm_pkt.prog.pkt.type != PROG_PROG){
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"ProgReply");
-                return -1;
-            }else{
-                u32 newblock = ((u32)firm_pkt.prog.pkt.addres_high <<16) | DECODE_U16(firm_pkt.prog.pkt.adress_low);
-                //uLogProgress("Block %x to %x is done",fctx.zStartAddr,newblock);
-                fctx.bz.addr_page = newblock;
-            }
-            fctx.stepB = fctx.stepB - firm_dev.pr_blk_size;
-            if(fctx.zNbInstr==0){
-                fctx.zst =  FLASH_ZONE_START;
-                fctx.currzone++;
-            }else{
-                fctx.zst =  FLASH_ZONE_PROG;
-            }
-            break;
-        default:
-            YASSERT(0);
-    }
-
-    return 0;
-}
-
-
-
-#ifndef MICROCHIP_API
-
-static void uSendReboot(u16 signature, FLASH_DEVICE_STATE nextState)
-{
-    if(ypIsSendBootloaderBusy(&firm_dev))
-        return;
-    memset(&firm_pkt,0,sizeof(USB_Packet));
-    firm_pkt.prog.pkt_ext.type = PROG_REBOOT;
-    firm_pkt.prog.pkt_ext.opt.btsign = DECODE_U16(signature);
-    // do not check reboot packet on purpose (most of the time
-    // the os generate an error because the device rebooted too quickly)
-    ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL);
-    fctx.stepA =  nextState;
-    return;
-}
-
-static int uSendErase(u16 firstPage, u16 nPages, FLASH_DEVICE_STATE nextState)
-{
-    if(ypIsSendBootloaderBusy(&firm_dev))
-        return 0;
-    memset(&firm_pkt,0,sizeof(USB_Packet));
-    firm_pkt.prog.pkt_ext.type = PROG_ERASE;
-    SET_PROG_POS_PAGENO(firm_pkt.prog.pkt_ext, firstPage, 0);
-    firm_pkt.prog.pkt_ext.opt.npages = DECODE_U16(nPages);
-    if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-        return -1;
-    }
-    fctx.stepA =  nextState;
-    return 0;
-}
-
-static int uFlashFlash()
-{
-    u32 addr, datasize;
-    u8  buff[MAX_BYTE_IN_PACKET];
-    char msg[FLASH_ERRMSG_LEN];
-    u32 pos, pageno;
-
-    switch(fctx.zst){
-    case FLASH_ZONE_START:
-        if(fctx.currzone == fctx.bynHead.v6.ROM_nb_zone + fctx.bynHead.v6.FLA_nb_zone){
-            fctx.stepA = FLASH_AUTOFLASH;
-            return 0;
-        }
-        uGetFirmwareBynZone(fctx.zOfs, &fctx.bz);
-        if(fctx.currzone < fctx.bynHead.v6.ROM_nb_zone) {
-            fctx.bz.addr_page = (u32)firm_dev.first_code_page * firm_dev.ext_page_size + 3*fctx.bz.addr_page/2;
-        } else {
-            fctx.bz.addr_page = (u32)firm_dev.first_yfs3_page * firm_dev.ext_page_size + fctx.bz.addr_page;
-        }
-#ifdef DEBUG_FIRMWARE
-        dbglog("Flash zone %d:%x : %x(%x)\n",fctx.currzone,fctx.zOfs,fctx.bz.addr_page,fctx.bz.len);
-#endif
-        YSPRINTF(msg, FLASH_ERRMSG_LEN, "Flash zone %d:%x : %x(%x)",fctx.currzone,fctx.zOfs,fctx.bz.addr_page,fctx.bz.len);
-        uLogProgress(msg);
-
-        if((fctx.bz.addr_page & 1) != 0 || (fctx.bz.len & 1) != 0) {
-            dbglog("Prog block not on a word boundary (%d+%d)\n", fctx.bz.addr_page, fctx.bz.len);
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Prog block not on a word boundary");
-            return -1;
-        }
-        fctx.zOfs += sizeof(byn_zone);
-        fctx.stepB = 0;
-        fctx.zst = FLASH_ZONE_PROG;
-        //no break on purpose
-    case FLASH_ZONE_PROG:
-        if(fctx.bz.len > 0 && fctx.currzone < fctx.bynHead.v6.ROM_nb_zone &&
-           fctx.bz.addr_page >= (u32)firm_dev.first_yfs3_page * firm_dev.ext_page_size) {
-            // skip end of ROM image past reserved flash zone
-#ifdef DEBUG_FIRMWARE
-            dbglog("Drop ROM data past firmware boundary (zone %d at offset %x)\n", fctx.currzone, fctx.zOfs);
-#endif
-            fctx.zOfs += fctx.bz.len;
-            fctx.bz.len = 0;
-            fctx.zst = FLASH_ZONE_START;
-            fctx.currzone++;
-            return 0;
-        }
-        addr = fctx.bz.addr_page + fctx.stepB;
-        memset(&firm_pkt,0,sizeof(USB_Packet));
-
-        SET_PROG_POS_PAGENO(firm_pkt.prog.pkt_ext, addr / firm_dev.ext_page_size,  addr >> 2);
-        datasize = firm_dev.ext_page_size - (addr & (firm_dev.ext_page_size-1));
-        if(datasize > MAX_BYTE_IN_PACKET) {
-            datasize = MAX_BYTE_IN_PACKET;
-        }
-        if(fctx.stepB + datasize > fctx.bz.len) {
-            datasize = fctx.bz.len - fctx.stepB;
-        }
-        YASSERT((datasize & 1) == 0);
-        firm_pkt.prog.pkt_ext.size = (u8)(datasize / 2);
-        firm_pkt.prog.pkt_ext.type = PROG_PROG;
-#ifdef DEBUG_FIRMWARE
-        {
-            u32 page, pos;
-            GET_PROG_POS_PAGENO(firm_pkt.prog.pkt_ext, page,  pos);
-            pos *=4;
-            dbglog("Flash at 0x%x:0x%x (0x%x bytes) found at 0x%x (0x%x more in zone)\n",page, pos,
-              2*firm_pkt.prog.pkt_ext.size, fctx.zOfs, fctx.bz.len);
-         }
-#endif
-        uGetFirmware(fctx.zOfs, firm_pkt.prog.pkt_ext.opt.data, 2*firm_pkt.prog.pkt_ext.size);
-        if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-            dbglog("Unable to send prog pkt\n");
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Unable to send prog pkt");
-            return -1;
-        }
-        fctx.zOfs  += datasize;
-        fctx.stepB += datasize;
-
-        // verify each time we finish a page or a zone
-        if ((u16)((addr & (firm_dev.ext_page_size-1)) + datasize) >= firm_dev.ext_page_size || fctx.stepB >= fctx.bz.len) {
-            fctx.zOfs -= fctx.stepB; // rewind to check
-            fctx.zst = FLASH_ZONE_READ;
-        }
-        break;
-    case FLASH_ZONE_READ:
-        // pageno is already set properly
-        addr = fctx.bz.addr_page;
-        SET_PROG_POS_PAGENO(firm_pkt.prog.pkt_ext, addr / firm_dev.ext_page_size,  addr >> 2);
-        firm_pkt.prog.pkt.type = PROG_VERIF;
-        if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-            dbglog("Unable to send verif pkt\n");
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Unable to send verif pkt");
-            return -1;
-        }
-        fctx.zst =  FLASH_ZONE_RECV_OK;
-        fctx.timeout =ytime()+ ZONE_VERIF_TIMEOUT;
-        //no break on purpose
-    case FLASH_ZONE_RECV_OK:
-        if(ypGetBootloaderReply(&firm_dev, &firm_pkt,NULL)<0){
-            if((s32)(fctx.timeout - ytime()) < 0) {
-#ifdef DEBUG_FIRMWARE
-                dbglog("Bootloader did not send confirmation for Zone %x Block %x\n",fctx.currzone,fctx.bz.addr_page);
-#endif
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Device did not respond to verif pkt");
-                return -1;
-            }
-            return 0;
-        }
-        if(firm_pkt.prog.pkt.type != PROG_VERIF) {
-            dbglog("Invalid verif pkt\n");
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Invalid verif pkt");
-            return -1;
-        }
-        GET_PROG_POS_PAGENO(firm_pkt.prog.pkt_ext, pageno, pos);
-#ifdef DEBUG_FIRMWARE
-            dbglog("Verif at 0x%x:0x%x (up to 0x%x bytes)\n",pageno,
-                  pos <<2,
-                  2*firm_pkt.prog.pkt_ext.size);
-#endif
-        addr = pageno * firm_dev.ext_page_size + (pos << 2) ;
-        YASSERT(addr >= fctx.bz.addr_page);
-        if(addr < fctx.bz.addr_page + fctx.stepB) {
-            // packet is in verification range
-            datasize = 2 * firm_pkt.prog.pkt_ext.size;
-            if(addr + datasize >= fctx.bz.addr_page + fctx.stepB) {
-                datasize = fctx.bz.addr_page + fctx.stepB - addr;
-            }
-            uGetFirmware(fctx.zOfs + (addr-fctx.bz.addr_page), buff, (u16)datasize);
-            if(memcmp(buff, firm_pkt.prog.pkt_ext.opt.data, datasize) != 0) {
-                dbglog("Flash verification failed at %x (%x:%x)\n", addr, pageno, addr);
-                YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Flash verification failed");
-                return -1;
-            }
-#ifdef DEBUG_FIRMWARE
-        } else {
-            dbglog("Skip verification for block at addr 0x%x (block ends at %x)\n", addr, fctx.bz.addr_page + fctx.stepB);
-#endif
-        }
-        if((addr & (firm_dev.ext_page_size-1)) + 2 * (u32)firm_pkt.prog.pkt_ext.size < (u32)firm_dev.ext_page_size) {
-            // more packets expected (device will dump a whole flash page)
-            return 0;
-        }
-        fctx.zOfs += fctx.stepB;
-        fctx.progress = (u16)(20 + 76*fctx.zOfs / (BYN_HEAD_SIZE_V6 + fctx.bynHead.v6.ROM_total_size + fctx.bynHead.v6.FLA_total_size));
-        fctx.bz.addr_page += fctx.stepB;
-        fctx.bz.len -= fctx.stepB;
-        if(fctx.bz.len > 0 && fctx.currzone < fctx.bynHead.v6.ROM_nb_zone &&
-           fctx.bz.addr_page >= (u32)firm_dev.first_yfs3_page * firm_dev.ext_page_size) {
-            // skip end of ROM image past reserved flash zone
-#ifdef DEBUG_FIRMWARE
-            dbglog("Drop ROM data past firmware boundary (zone %d at offset %x)\n", fctx.currzone, fctx.zOfs);
-#endif
-            fctx.zOfs += fctx.bz.len;
-            fctx.bz.len = 0;
-        }
-        if(fctx.bz.len == 0){
-            fctx.zst = FLASH_ZONE_START;
-            fctx.currzone++;
-#ifdef DEBUG_FIRMWARE
-            dbglog("Switch to next zone (zone %d at offset %x)\n", fctx.currzone, fctx.zOfs);
-#endif
-        } else {
-            fctx.zst = FLASH_ZONE_PROG;
-            fctx.stepB = 0;
-#ifdef DEBUG_FIRMWARE
-            dbglog("Continue zone %d at offset %x for %x more bytes\n", fctx.currzone, fctx.zOfs, fctx.bz.len);
-#endif
-        }
-    }
-
-    return 0;
-}
-#endif
-
-
-YPROG_RESULT uFlashDevice(void)
-{
-    byn_head_multi  head;
-    int             res;
-
-    if(fctx.stepA != FLASH_FIND_DEV && fctx.stepA != FLASH_DONE) {
-        if(ypIsSendBootloaderBusy(&firm_dev)) {
-            return YPROG_WAITING;
-        }
-        // ReSharper disable once CppUnreachableCode
-        if(!Flash_ready()) {
-            return YPROG_WAITING;
-        }
-    }
-
-    switch(fctx.stepA){
-    case FLASH_FIND_DEV:
-        uLogProgress("Wait for device");
-        if (uGetBootloader(fctx.bynHead.h.serial, &firm_dev.iface)<0){
-#ifndef MICROCHIP_API
-            if((s32)(fctx.timeout - ytime()) >= 0) {
-                return YPROG_WAITING;
-            }
- #endif
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"device not present");
-#ifdef DEBUG_FIRMWARE
-            ulog("device not present\n");
-#endif
-            return YPROG_DONE;
-        }
-        fctx.progress = 2;
-        uLogProgress("Device detected");
-
-#if defined(DEBUG_FIRMWARE) && defined(MICROCHIP_API)
-        ulog("Bootloader ");
-        ulog(fctx.bynHead.h.serial);
-        ulog(" on port ");
-#ifdef MICROCHIP_API
-        ulogU16(firm_dev.iface);
-#else
-        ulogU16(firm_dev.iface.deviceid);
-#endif
-        ulog("\n");
-#endif
-#ifndef MICROCHIP_API
-        fctx.stepA = FLASH_CONNECT;
-        // no break on purpose
-    case FLASH_CONNECT:
-        if(YISERR(yyySetup(&firm_dev.iface,NULL))){
-            YSTRCPY(fctx.errmsg,FLASH_ERRMSG_LEN,"Unable to open connection to the device");
-            return YPROG_DONE;
-        }
-        uLogProgress("Device connected");
-#endif
-        fctx.stepA = FLASH_GET_INFO;
-        fctx.stepB = 0;
-        break;
-    case FLASH_GET_INFO:
-        if(uGetDeviceInfo()<0){
-#ifdef DEBUG_FIRMWARE
-            ulog("uGetDeviceInfo failed\n");
-#endif
-            fctx.stepA = FLASH_DISCONNECT;
-        }
-        fctx.progress = 2;
-        break;
-    case FLASH_VALIDATE_BYN:
-#ifdef DEBUG_FIRMWARE
-        ulog("PICDev ");
-        ulogU16(firm_dev.devid_model);
-        ulog(" detected\n");
-#endif
-        uGetFirmwareBynHead(&head);
-        if (ValidateBynCompat(&head, fctx.len, fctx.bynHead.h.serial, fctx.flags, &firm_dev, fctx.errmsg) < 0) {
-#ifdef DEBUG_FIRMWARE
-            ulog("ValidateBynCompat failed:");
-            ulog(fctx.errmsg);
-            ulog("\n");
-#endif
-            fctx.stepA = FLASH_DISCONNECT;
-            break;
-        }
-
-        switch(head.h.rev) {
-            case BYN_REV_V4:
-                fctx.bynHead.v6.ROM_nb_zone = (u8)head.v4.nbzones;
-                fctx.bynHead.v6.FLA_nb_zone = 0;
-                fctx.currzone = 0;
-                fctx.zOfs = BYN_HEAD_SIZE_V4;
-                break;
-            case BYN_REV_V5:
-                fctx.bynHead.v6.ROM_nb_zone = (u8)head.v5.nbzones;
-                fctx.bynHead.v6.FLA_nb_zone = 0;
-                fctx.currzone = 0;
-                fctx.zOfs = BYN_HEAD_SIZE_V5;
-                break;
-            case BYN_REV_V6:
-                fctx.bynHead.v6.ROM_nb_zone = (u8)head.v6.ROM_nb_zone;
-                fctx.bynHead.v6.FLA_nb_zone = (u8)head.v6.FLA_nb_zone;
-                fctx.currzone = 0;
-                fctx.zOfs = BYN_HEAD_SIZE_V6;
-                break;
-            default:
-#ifdef DEBUG_FIRMWARE
-                ulog("Unsupported file format (upgrade our VirtualHub)\n");
-#endif
-                fctx.stepA  = FLASH_DISCONNECT;
-                break;
-            }
-        fctx.progress = 3;
-        fctx.stepA = FLASH_ERASE;
-#ifndef MICROCHIP_API
-        if(firm_dev.ext_total_pages) {
-            fctx.flashPage = firm_dev.first_code_page;
-        }
-#endif
-#ifdef DEBUG_FIRMWARE
-        ulogU16(fctx.bynHead.v6.ROM_nb_zone);
-        ulog(" ROM zones to flash\n");
-#endif
-        break;
-    case FLASH_ERASE:
-        fctx.zst = FLASH_ZONE_START;
-        fctx.stepB = 0;
-#ifdef MICROCHIP_API
-        res = uSendCmd(PROG_ERASE,FLASH_WAIT_ERASE);
-#else
-        if(firm_dev.ext_total_pages) {
-            int npages = firm_dev.ext_total_pages - fctx.flashPage;
-            int maxpages = (firm_dev.ext_jedec_id == JEDEC_SPANSION_4MB || firm_dev.ext_jedec_id == JEDEC_SPANSION_8MB ? 16 : 128);
-#ifdef DEBUG_FIRMWARE
-            ulogU16(npages);
-            ulog(" pages still to flash\n");
-#endif
-            if(npages > maxpages) npages = maxpages;
-            res = uSendErase(fctx.flashPage, npages, FLASH_WAIT_ERASE);
-            fctx.flashPage += npages;
-        } else {
-            res = uSendCmd(PROG_ERASE,FLASH_WAIT_ERASE);
-        }
-#endif
-        if(res<0){
-#ifdef DEBUG_FIRMWARE
-            ulog("FlashErase failed\n");
-#endif
-            YSTRCPY(fctx.errmsg,sizeof(fctx.errmsg),"Unable to blank flash");
-            fctx.stepA = FLASH_DISCONNECT;
-        }
-        break;
-    case FLASH_WAIT_ERASE:
-        if(fctx.stepB == 0) {
-#ifndef MICROCHIP_API
-            if(firm_dev.ext_total_pages) {
-                if(ypIsSendBootloaderBusy(&firm_dev)) {
-                    return YPROG_WAITING;
-                }
-                memset(&firm_pkt,0,sizeof(USB_Prog_Packet));
-                firm_pkt.prog.pkt.type = PROG_INFO;
-                if(ypSendBootloaderCmd(&firm_dev,&firm_pkt,NULL)<0){
-                    return YPROG_WAITING;
-                }
-            }
-#endif
-            fctx.stepB = ytime();
-        } else {
-#ifndef MICROCHIP_API
-            if(firm_dev.ext_total_pages) {
-                if(ypGetBootloaderReply(&firm_dev, &firm_pkt,NULL)<0) {
-                    if((u32)(ytime() - fctx.stepB) < 2000u) {
-                        return YPROG_WAITING;
-                    }
-#ifdef DEBUG_FIRMWARE
-                    ulog("FlashErase failed\n");
-#endif
-                    YSTRCPY(fctx.errmsg,sizeof(fctx.errmsg),"Timeout blanking flash");
-                    fctx.stepA = FLASH_DISCONNECT;
-                } else {
-#ifdef DEBUG_FIRMWARE
-                    ulog("clear time: ");
-                    ulogU16((u16)(ytime() - fctx.stepB));
-                    ulog("\n");
-#endif
-                    fctx.progress = 3+(18*fctx.flashPage/firm_dev.ext_total_pages);
-                    uLogProgress("Erasing flash");
-                    if(fctx.flashPage < firm_dev.ext_total_pages) {
-                        fctx.stepA = FLASH_ERASE;
-                        break;
-                    }
-                }
-            } else
-#endif
-            {
-                u32 delay = 1000 + (firm_dev.last_addr>>5);
-                if((u32)(ytime() - fctx.stepB) < delay) {
-                    return YPROG_WAITING;
-                }
-            }
-            fctx.stepA = FLASH_DOFLASH;
-            fctx.stepB = 0;
-        }
-        break;
-    case FLASH_DOFLASH:
-#ifdef MICROCHIP_API
-        res = uFlashZone();
-#else
-        if(firm_dev.ext_total_pages) {
-            res = uFlashFlash();
-        } else {
-            res = uFlashZone();
-        }
-#endif
-        if(res<0){
-#ifdef DEBUG_FIRMWARE
-            ulog("Flash failed\n");
-            ulog("errmsg=");
-            ulog(fctx.errmsg);
-            ulogChar('\n');
-#endif
-            fctx.stepA = FLASH_DISCONNECT;
-        }
-        break;
-
-    case FLASH_GET_INFO_BFOR_REBOOT:
-        res =uGetDeviceInfo();
-        if(res <0){
-#ifdef DEBUG_FIRMWARE
-            ulog("uGetDeviceInfo failed\n");
-#endif
-            YSTRCPY(fctx.errmsg, FLASH_ERRMSG_LEN, "Last communication before reboot failed");
-            fctx.stepA = FLASH_DISCONNECT;
-        } else if(res == 1) {
-            fctx.stepA = FLASH_REBOOT;
-        }
-        break;
-
-    case FLASH_REBOOT:
-        fctx.progress = 95;
-#ifdef DEBUG_FIRMWARE
-        ulog("Send reboot\n");
-#endif
-
-#ifdef MICROCHIP_API
-        res = ypBootloaderShutdown(&firm_dev);
-        if (res < 0) {
-#ifdef DEBUG_FIRMWARE
-            ulog("reboot failed\n");
-#endif
-            YSTRCPY(fctx.errmsg,sizeof(fctx.errmsg),"Unable to reboot bootloader");
-            fctx.stepA = FLASH_DISCONNECT;
-        }
-#else
-        uSendCmd(PROG_REBOOT, FLASH_REBOOT_VALIDATE);
-        // do not check reboot packet on purpose (most of the time
-        // the os generate an error because the device rebooted too quickly)
-#endif
-        fctx.stepA  = FLASH_REBOOT_VALIDATE;
-        fctx.timeout = ytime() + YPROG_BOOTLOADER_TIMEOUT;
-        break;
-    case FLASH_REBOOT_VALIDATE:
-        if(uGetBootloader(fctx.bynHead.h.serial,NULL)<0){
-            fctx.progress = 98;
-#ifdef DEBUG_FIRMWARE
-            ulog("device not present\n");
-#endif
-            fctx.stepA  = FLASH_SUCCEEDED;
-            break;
-        } else {
-            if((s32)(fctx.timeout - ytime()) >= 0) {
-                return YPROG_WAITING;
-            }
-#if defined(DEBUG_FIRMWARE) && defined(MICROCHIP_API)
-            ulog("Bootloader ");
-            ulog(fctx.bynHead.h.serial);
-            ulog(" on port ");
-#ifdef MICROCHIP_API
-            ulogU16(firm_dev.iface);
-#else
-            ulogU16(firm_dev.iface.deviceid);
-#endif
-            ulog("\n");
-#endif
-            if (fctx.zOfs == 0){
-                uLogProgress("reboot failed try again...");
-                fctx.stepA = FLASH_GET_INFO_BFOR_REBOOT;
-                break;
-            }
-            uLogProgress("Device still in bootloader");
-            fctx.zOfs--;
-            uLogProgress("Device still in bootloader");
-            // FIXME: could try to add a retry
-            fctx.stepA = FLASH_DISCONNECT;
-        }
-        break;
-#ifndef MICROCHIP_API
-    case FLASH_AUTOFLASH:
-        fctx.progress = 98;
-        uSendReboot(START_AUTOFLASHER_SIGN, FLASH_SUCCEEDED);
-        fctx.stepA  = FLASH_SUCCEEDED;
-        break;
-#endif
-    case FLASH_SUCCEEDED:
-#ifdef DEBUG_FIRMWARE
-        ulog("Flash succeeded\n");
-#endif
-        YSTRCPY(fctx.errmsg,sizeof(fctx.errmsg),"Flash succeeded");
-        fctx.progress = 100;
-        fctx.stepA   = FLASH_DISCONNECT;
-        // intentionally no break
-    case FLASH_DISCONNECT:
-#ifdef DEBUG_FIRMWARE
-        ulog("Flash disconnect\n");
-#endif
-#ifndef MICROCHIP_API
-        yyyPacketShutdown(&firm_dev.iface);
-#endif
-        fctx.stepA   = FLASH_DONE;
-        // intentionally no break
-    case FLASH_DONE:
-        return YPROG_DONE;
-    }
-    return YPROG_WAITING;
-}
-
-
-#ifndef MICROCHIP_API
-
-typedef int(*yprogTcpReqCb)(void *ctx, const char* buffer, u32 len, char *errmsg);
-
-static int getTCPBootloaders(void *ctx, const char* buffer, u32 len, char *errmsg)
-{
-    int res = 0;
-    yJsonStateMachine j;
-    char *p = ctx;
-    memset(p, 0, YOCTO_SERIAL_LEN * 4);
-
-    // Parse HTTP header
-    j.src = buffer;
-    j.end = j.src + len;
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        return YERRMSG(YAPI_IO_ERROR,"Failed to parse HTTP header");
-    }
-    if (YSTRCMP(j.token, "200")) {
-        return YERRMSG(YAPI_IO_ERROR,"Unexpected HTTP return code");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "list")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_ARRAY) {
-                return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-            }
-
-            while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st != YJSON_PARSE_ARRAY) {
-                if (res < 4) {
-                    YSTRCPY(p + res * YOCTO_SERIAL_LEN, YOCTO_SERIAL_LEN, j.token);
-                }
-                res++;
-            }
-        }
-        yJsonSkip(&j, 1);
-    }
-    return res;
-}
-
-
-// return the list of bootloaders in a specific hub
-// buffer must be an pointer to a buffer of min 4 * YOCTO_SERIAL_LEN
-// return the number of bootloader copied to buffer
-int yNetHubGetBootloaders(const char *hubserial, char *buffer, char *errmsg)
-{
-    const char * req = "GET /flash.json?a=list \r\n\r\n";
-    YIOHDL  iohdl;
-    YRETCODE res, subres;
-    int replysize;
-    char *reply;
-
-    res = yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, hubserial, req, YSTRLEN(req), &reply, &replysize, NULL, NULL, errmsg);
-    if (YISERR(res)) {
-        return res;
-    }
-    res = getTCPBootloaders(buffer, reply, replysize, errmsg);
-    subres = yapiHTTPRequestSyncDone_internal(&iohdl, NULL);
-    YASSERT(!YISERR(subres));
-    return res;
-}
-
-
-#endif
-
-
-#ifndef YAPI_IN_YDEVICE
-
-static int  getBootloaderInfos(const char *devserial, char *out_hubserial, char *errmsg)
-{
-    int             i, res;
-
-
-    if (yContext->detecttype & Y_DETECT_USB) {
-        int             nbifaces = 0;
-        yInterfaceSt    *iface;
-        yInterfaceSt    *runifaces = NULL;
-
-        if (YISERR(res = (YRETCODE)yyyUSBGetInterfaces(&runifaces, &nbifaces, errmsg))){
-            return res;
-        }
-
-        for (i = 0, iface = runifaces; i < nbifaces; i++, iface++){
-            if (iface->deviceid == YOCTO_DEVID_BOOTLOADER && YSTRCMP(devserial, iface->serial) == 0) {
-                YSTRCPY(out_hubserial, YOCTO_SERIAL_LEN, "usb");
-                return 1;
-            }
-        }
-    }
-
-
-    for (i = 0; i < NBMAX_NET_HUB; i++){
-        if (yContext->nethub[i]){
-            char bootloaders[4 * YOCTO_SERIAL_LEN];
-            char hubserial[YOCTO_SERIAL_LEN];
-            int j;
-            char *serial;
-            yHashGetStr(yContext->nethub[i]->serial, hubserial, YOCTO_SERIAL_LEN);
-            res = yNetHubGetBootloaders(hubserial, bootloaders, errmsg);
-            if (YISERR(res)) {
-                return res;
-            }
-            for (j = 0, serial = bootloaders; j < res; j++, serial += YOCTO_SERIAL_LEN){
-                if (YSTRCMP(devserial,serial) == 0) {
-                    YSTRCPY(out_hubserial, YOCTO_SERIAL_LEN, hubserial);
-                    return 1;
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-typedef enum
-{
-    FLASH_HUB_AVAIL = 0u,
-    FLASH_HUB_STATE,
-    FLASH_HUB_FLASH,
-    FLASH_HUB_NOT_BUSY, // CHECK there is on pending fwupdate (cmd=state-> !uploading && !flashing)
-    FLASH_HUB_NONE
-} FLASH_HUB_CMD;
-
-
-typedef struct {
-    FLASH_HUB_CMD cmd;
-    const char *devserial;
-}ckReqHeadCtx;
-
-static int checkRequestHeader(void *ctx_ptr, const char* buffer, u32 len, char *errmsg) {
-    ckReqHeadCtx *ctx = ctx_ptr;
-    yJsonStateMachine j;
-    char lastmsg[YOCTO_ERRMSG_LEN] = "invalid";
-    int count = 0, return_code = 0;;
-
-    // Parse HTTP header
-    j.src = buffer;
-    j.end = j.src + len;
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        return YERRMSG(YAPI_IO_ERROR,"Failed to parse HTTP header");
-    }
-    if (YSTRCMP(j.token, "200")) {
-        return YERRMSG(YAPI_IO_ERROR,"Unexpected HTTP return code");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        switch (ctx->cmd){
-        case FLASH_HUB_STATE:
-            if (!strcmp(j.token, "state")) {
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                if (YSTRCMP(j.token, "valid")) {
-                    YSTRCPY(lastmsg, YOCTO_ERRMSG_LEN, "Invalid firmware");
-                    return_code = YAPI_IO_ERROR;
-                } else {
-                    count++;
-                }
-            } else  if (!strcmp(j.token, "firmware")) {
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                if (YSTRNCMP(j.token, ctx->devserial,YOCTO_BASE_SERIAL_LEN)) {
-                    YSTRCPY(lastmsg, YOCTO_ERRMSG_LEN, "Firmware not designed for this module");
-                    return_code = YAPI_IO_ERROR;
-                } else {
-                    count++;
-                }
-            } else  if (!strcmp(j.token, "message")) {
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                YSTRCPY(lastmsg, YOCTO_ERRMSG_LEN, j.token);
-            } else {
-                yJsonSkip(&j, 1);
-            }
-            break;
-        case FLASH_HUB_NOT_BUSY:
-            if (!strcmp(j.token, "state")) {
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                if (YSTRCMP(j.token, "uploading") == 0 || YSTRCMP(j.token, "flashing")==0) {
-                    YSTRCPY(lastmsg, YOCTO_ERRMSG_LEN, "Cannot start firmware update: busy (");
-                    YSTRCAT(lastmsg, YOCTO_ERRMSG_LEN, j.token);
-                    YSTRCAT(lastmsg, YOCTO_ERRMSG_LEN, ")");
-                    return_code = YAPI_IO_ERROR;
-                } else {
-                    count++;
-                }
-            } else {
-                yJsonSkip(&j, 1);
-            }
-            break;
-        case FLASH_HUB_AVAIL:
-            yJsonSkip(&j, 1);
-            break;
-        case FLASH_HUB_FLASH:
-            if (!strcmp(j.token, "logs")) {
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_ARRAY) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st != YJSON_PARSE_ARRAY) {
-                    setOsGlobalProgress(0, j.token);
-                    YSTRCPY(lastmsg, YOCTO_ERRMSG_LEN, j.token);
-                }
-            } else  if (!strcmp(j.token, "progress")) {
-                int progress;
-                if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                    return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                }
-                progress = atoi(j.token);
-                if (progress < 100) {
-                    return_code = YAPI_IO_ERROR;
-                }
-            } else {
-                yJsonSkip(&j, 1);
-            }
-            break;
-        default:
-            yJsonSkip(&j, 1);
-            break;
-        }
-    }
-
-    if (return_code < 0) {
-        YSTRCPY(errmsg,YOCTO_ERRMSG_LEN, lastmsg);
-        return return_code;
-    }
-    return count;
-}
-
-static int checkHTTPHeader(void *ctx, const char* buffer, u32 len, char *errmsg) {
-    yJsonStateMachine j;
-    // Parse HTTP header
-    j.src = buffer;
-    j.end = j.src + len;
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        return YERRMSG(YAPI_IO_ERROR, "Failed to parse HTTP header");
-    }
-    if (YSTRCMP(j.token, "200")) {
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected HTTP return code");
-    }
-
-    return 0;
-}
-
-
-// Method used to upload a file to the device
-static int upload(const char *hubserial, const char *subpath, const char *filename, u8 *data, u32 data_len, char *errmsg)
-{
-
-    char       *p;
-    int         buffer_size = 1024 + data_len;
-    char        *buffer = yMalloc(buffer_size);
-    char        boundary[32];
-    int         res;
-    YIOHDL      iohdl;
-    char    *reply = NULL;
-    int     replysize = 0;
-
-    do {
-        YSPRINTF(boundary, 32, "Zz%06xzZ", rand() & 0xffffff);
-    } while (ymemfind(data, data_len, (u8*)boundary, YSTRLEN(boundary)) >= 0);
-
-    YSTRCPY(buffer, buffer_size, "POST ");
-    YSTRCAT(buffer, buffer_size, subpath);
-    YSTRCAT(buffer, buffer_size, "upload.html HTTP/1.1\r\nContent-Type: multipart/form-data; boundary=");
-    YSTRCAT(buffer, buffer_size, boundary);
-    YSTRCAT(buffer, buffer_size,
-        "\r\n\r\n"
-        "--");
-    YSTRCAT(buffer, buffer_size, boundary);
-    YSTRCAT(buffer, buffer_size, "\r\nContent-Disposition: form-data; name=\"");
-    YSTRCAT(buffer, buffer_size, filename);
-    YSTRCAT(buffer, buffer_size, "\"; filename=\"api\"\r\n"
-        "Content-Type: application/octet-stream\r\n"
-        "Content-Transfer-Encoding: binary\r\n\r\n");
-    p = buffer + YSTRLEN(buffer);
-    memcpy(p, data, data_len);
-    p += data_len;
-    YASSERT(p - buffer < buffer_size);
-    buffer_size -= (int)(p - buffer);
-    YSTRCPY(p, buffer_size, "\r\n--");
-    YSTRCAT(p, buffer_size, boundary);
-    YSTRCAT(p, buffer_size, "--\r\n");
-    buffer_size = (int)(p - buffer) + YSTRLEN(p);
-    //todo: chose wisely callback and tpchan
-    res = yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, hubserial, buffer, buffer_size, &reply, &replysize, NULL, NULL,errmsg);
-    if (res >= 0) {
-        res = checkHTTPHeader(NULL, reply, replysize, errmsg);
-        yapiHTTPRequestSyncDone_internal(&iohdl, errmsg);
-    }
-    yFree(buffer);
-    return res;
-}
-
-
-typedef enum
-{
-    FLASH_USB = 0u,
-    FLASH_NET_SELF,
-    FLASH_NET_SUBDEV,
-} FLASH_TYPE;
-
-
-static int sendHubFlashCmd(const char *hubserial, const char *subpath, const char *devserial, FLASH_HUB_CMD cmd, const char *args, char *errmsg)
-{
-    char buffer[512];
-    const char *cmd_str;
-    ckReqHeadCtx ctx;
-    int res;
-    YIOHDL  iohdl;
-    YRETCODE subres;
-    int replysize;
-    char *reply;
-
-    switch (cmd){
-    case FLASH_HUB_AVAIL:
-    case FLASH_HUB_STATE:
-    case FLASH_HUB_NOT_BUSY:
-        cmd_str = "state";
-        break;
-    case FLASH_HUB_FLASH:
-        cmd_str = "flash";
-        break;
-    default:
-        return YERR(YAPI_INVALID_ARGUMENT);
-    }
-    YSPRINTF(buffer, 512, "GET %sflash.json?a=%s%s \r\n\r\n", subpath, cmd_str, args);
-    ctx.cmd = cmd;
-    ctx.devserial = devserial;
-    res = yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, hubserial, buffer, YSTRLEN(buffer), &reply, &replysize, NULL, NULL, errmsg);
-    if (YISERR(res)) {
-        return res;
-    }
-    res = checkRequestHeader(&ctx, reply, replysize, errmsg);
-    subres = yapiHTTPRequestSyncDone_internal(&iohdl, NULL);
-    YASSERT(!YISERR(subres));
-    return res;
-}
-
-static int isWebPath(const char *path)
-{
-    if (YSTRNCMP(path, "http://", 7) == 0){
-        return 7;
-    } else if (YSTRNCMP(path, "www.yoctopuce.com",17) == 0){
-        return 0;
-    }
-    return -1;
-}
-
-static int yDownloadFirmware(const char * url, u8 **out_buffer, char *errmsg)
-{
-    char host[256];
-    u8 *buffer;
-    int res, len, ofs, i;
-    const char * http_ok = "HTTP/1.1 200 OK";
-
-
-    for (i = 0; i < 255 && i < YSTRLEN(url) && url[i] != '/'; i++){
-        host[i] = url[i];
-    }
-
-    if (url[i] != '/'){
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "invalid url");
-    }
-    host[i] = 0;
-
-    //yFifoInit(&(hub->fifo), hub->buffer,sizeof(hub->buffer));
-    res = yTcpDownload(host, url+i, &buffer, 10000, errmsg);
-    if (res < 0){
-        return res;
-    }
-    if (YSTRNCMP((char*)buffer, http_ok, YSTRLEN(http_ok))) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected HTTP return code");
-    }
-
-    ofs = ymemfind(buffer, res, (u8*)"\r\n\r\n", 4);
-    if (ofs <0) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR, "Invalid HTTP header");
-
-    }
-    ofs += 4;
-    len = res - ofs;
-    *out_buffer = yMalloc(len);
-    memcpy(*out_buffer, buffer + ofs, len);
-    yFree(buffer);
-    return len;
-
-}
-
-
-static void* yFirmwareUpdate_thread(void* ctx)
-{
-    yThread     *thread = (yThread*)ctx;
-    YAPI_DEVICE dev;
-    int         res;
-    char        errmsg[YOCTO_ERRMSG_LEN];
-    char        buffer[256];
-    char        subpath[256];
-    char        bootloaders[YOCTO_SERIAL_LEN * 4];
-    char        *p;
-    char        replybuf[512];
-    const char* reboot_req = "GET %sapi/module/rebootCountdown?rebootCountdown=-3 \r\n\r\n";
-    const char* reboot_hub = "GET %sapi/module/rebootCountdown?rebootCountdown=-1003 \r\n\r\n";
-    const char* get_api_fmt = "GET %sapi.json \r\n\r\n";
-    char        hubserial[YOCTO_SERIAL_LEN];
-    char        *reply = NULL;
-    int         replysize = 0;
-    int         ofs,i;
-    u64         timeout;
-    FLASH_TYPE  type = FLASH_USB;
-    int         online, found;
-    YPROG_RESULT u_flash_res;
-
-
-    yThreadSignalStart(thread);
-
-    //1% -> 5%
-    setOsGlobalProgress(1, "Loading firmware");
-    ofs = isWebPath(yContext->fuCtx.firmwarePath);
-    if (ofs < 0){
-        res = yLoadFirmwareFile(yContext->fuCtx.firmwarePath, &fctx.firmware, errmsg);
-    } else {
-        res = yDownloadFirmware(yContext->fuCtx.firmwarePath + ofs, &fctx.firmware, errmsg);
-    }
-    if (YISERR(res)) {
-        setOsGlobalProgress(res, errmsg);
-        goto exitthread;
-    }
-    fctx.len = res;
-    //copy firmware header into context variable (to have same behavior as a device)
-    memcpy(&fctx.bynHead, fctx.firmware, sizeof(fctx.bynHead));
-    YSTRCPY(fctx.bynHead.h.serial, YOCTO_SERIAL_LEN, yContext->fuCtx.serial);
-
-
-    res = IsValidBynFile((const byn_head_multi *)fctx.firmware, fctx.len, yContext->fuCtx.serial, fctx.flags, errmsg);
-    if (YISERR(res)) {
-        setOsGlobalProgress(res, errmsg);
-        goto exit_and_free;
-    }
-
-    //5% -> 10%
-    setOsGlobalProgress(5, "Enter firmware update mode");
-    dev = wpSearch(yContext->fuCtx.serial);
-    if (dev != -1) {
-        yUrlRef url;
-        int urlres = wpGetDeviceUrl(dev, hubserial, subpath, 256, NULL);
-        if (urlres < 0) {
-            setOsGlobalProgress(YAPI_IO_ERROR, NULL);
-            goto exit_and_free;
-        }
-        url = wpGetDeviceUrlRef(dev);
-        if (yHashGetUrlPort(url, NULL, NULL, NULL, NULL, NULL, NULL) == USB_URL) {
-            // USB connected device -> reboot it in bootloader
-            type = FLASH_USB;
-            YSPRINTF(buffer, sizeof(buffer), reboot_req, subpath);
-            res = yapiHTTPRequest(hubserial, buffer, replybuf, sizeof(replybuf), NULL, errmsg);
-            if (res < 0) {
-                setOsGlobalProgress(res, errmsg);
-                goto exit_and_free;
-            }
-        } else {
-            res = sendHubFlashCmd(hubserial, subpath, yContext->fuCtx.serial, FLASH_HUB_AVAIL, "", NULL);
-            if (res < 0 || YSTRNCMP(hubserial, "VIRTHUB", 7) == 0) {
-                int is_shield = YSTRNCMP(yContext->fuCtx.serial, "YHUBSHL1", YOCTO_BASE_SERIAL_LEN)==0;
-                res = yNetHubGetBootloaders(hubserial, bootloaders, errmsg);
-                if (res < 0) {
-                    setOsGlobalProgress(res, errmsg);
-                    goto exit_and_free;
-                }
-                for (i = 0; i < res; i++) {
-                    p = bootloaders + YOCTO_SERIAL_LEN * i;
-                    if (YSTRCMP(yContext->fuCtx.serial, p) == 0) {
-                        break;
-                    }
-                }
-                if (i == res) {
-                    // not in bootloader list...
-                    //...check if list is already full..
-                    if (res == 4) {
-                        setOsGlobalProgress(YAPI_IO_ERROR, "Too many devices in update mode");
-                        goto exit_and_free;
-                    }
-                    if (is_shield) {
-                        //...and that we do not already have a shield in bootloader..
-                        for (i = 0; i < res; i++) {
-                            p = bootloaders + YOCTO_SERIAL_LEN * i;
-                            if (YSTRNCMP(p, "YHUBSHL1", YOCTO_BASE_SERIAL_LEN)==0) {
-                                setOsGlobalProgress(YAPI_IO_ERROR, "Only one YoctoHub-Shield is allowed in update mode");
-                                goto exit_and_free;
-                            }
-                        }
-                    }
-
-                    // ...must reboot in programing
-                    setOsGlobalProgress(8, "Reboot to firmware update mode");
-                    YSPRINTF(buffer, sizeof(buffer), reboot_req, subpath);
-                    res = yapiHTTPRequest(hubserial, buffer, replybuf, sizeof(replybuf), NULL, errmsg);
-                    if (res < 0) {
-                        setOsGlobalProgress(res, errmsg);
-                        goto exit_and_free;
-                    }
-                    if (replybuf[0] != 'O' || replybuf[1] != 'K') {
-                        dbglog("Reboot to firmware update mode:\n%s\n", replybuf);
-                    }
-                }
-                type = FLASH_NET_SUBDEV;
-            } else  {
-                type = FLASH_NET_SELF;
-            }
-        }
-    } else {
-        //no known device -> check if device is in bootloader
-        res = getBootloaderInfos(yContext->fuCtx.serial, hubserial, errmsg);
-        if (res < 0) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        if (res == 0) {
-            setOsGlobalProgress(YAPI_DEVICE_NOT_FOUND, "Bootloader not found");
-            goto exit_and_free;
-        }
-        if (YSTRCMP(hubserial, "usb") == 0) {
-            type = FLASH_USB;
-        } else {
-            type = FLASH_NET_SUBDEV;
-        }
-    }
-
-    //10% -> 40%
-    setOsGlobalProgress(10, "Send new firmware");
-    if (type != FLASH_USB){
-        // ensure flash engine is not busy
-        res = sendHubFlashCmd(hubserial, type == FLASH_NET_SELF ? subpath : "/", yContext->fuCtx.serial, FLASH_HUB_NOT_BUSY, "", errmsg);
-        if (res < 1) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        // start firmware upload
-        // IP connected device -> upload the firmware to the Hub
-        res = upload(hubserial, type == FLASH_NET_SELF ? subpath : "/", "firmware", fctx.firmware, fctx.len, errmsg);
-        if (res < 0) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        // verify that firmware is correctly uploaded
-        res = sendHubFlashCmd(hubserial, type == FLASH_NET_SELF ? subpath : "/", yContext->fuCtx.serial, FLASH_HUB_STATE, "", errmsg);
-        if (res < 2) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-
-        if (type == FLASH_NET_SELF) {
-            const char *settingsOnly, *services;
-            u8 *startupconf_data;
-            int settings_len = yapiJsonGetPath_internal("api", (char*)yContext->fuCtx.settings, yContext->fuCtx.settings_len, 0, &settingsOnly, errmsg);
-            int service_len = yapiJsonGetPath_internal("services", settingsOnly, settings_len, 0, &services, errmsg);
-            int startupconf_data_len;
-            if (service_len > 0) {
-                int first_len = (services - settingsOnly) & 0xffffffff;
-                int sec_len = ((settingsOnly + settings_len) - (services + service_len)) & 0xffffffff;
-                startupconf_data = yMalloc(settings_len - service_len + 2);
-                memcpy(startupconf_data, settingsOnly, first_len);
-                startupconf_data[first_len] = '{';
-                startupconf_data[first_len + 1] = '}';
-                memcpy(startupconf_data + first_len + 2, services + service_len, sec_len);
-                startupconf_data_len = first_len + sec_len;
-            } else {
-                startupconf_data_len = settings_len;
-                startupconf_data = yMalloc(settings_len);
-                memcpy(startupconf_data, settingsOnly, settings_len);
-            }
-            setOsGlobalProgress(20,"Save startupConf.json");
-            // save settings
-            res = upload(hubserial, subpath, "startupConf.json", startupconf_data, startupconf_data_len, errmsg);
-            if (res < 0) {
-                yFree(startupconf_data);
-                setOsGlobalProgress(res, errmsg);
-                goto exit_and_free;
-            }
-            setOsGlobalProgress(30,"Save firmwareConf");
-            res = upload(hubserial, subpath, "firmwareConf", startupconf_data, startupconf_data_len, errmsg);
-            yFree(startupconf_data);
-            if (res < 0) {
-                setOsGlobalProgress(res, errmsg);
-                goto exit_and_free;
-            }
-        }
-    }
-
-    //40%-> 80%
-    fctx.progress = 0 ;
-    switch (type){
-    case FLASH_USB:
-        setOsGlobalProgress(40, "Flash firmware");
-        fctx.timeout = ytime() + YPROG_BOOTLOADER_TIMEOUT;
-        do {
-            u_flash_res = uFlashDevice();
-            if (u_flash_res != YPROG_DONE){
-                setOsGlobalProgress(40 + fctx.progress/2, fctx.errmsg);
-                yApproximateSleep(1);
-            }
-        } while (u_flash_res != YPROG_DONE);
-        if (fctx.progress < 100) {
-            setOsGlobalProgress(YAPI_IO_ERROR, fctx.errmsg);
-            goto exit_and_free;
-        }
-        break;
-    case FLASH_NET_SELF:
-        setOsGlobalProgress(40, "Flash firmware");
-        // the hub itself -> reboot in autoflash mode
-        YSPRINTF(buffer, sizeof(buffer), reboot_hub, subpath);
-        res = yapiHTTPRequest(hubserial, buffer, replybuf, sizeof(replybuf), NULL, errmsg);
-        if (res < 0) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        for (i = 0; i < 8; i++){
-            setOsGlobalProgress(50 + i*5, "Flash firmware");
-            yApproximateSleep(1000);
-        }
-        break;
-    case FLASH_NET_SUBDEV:
-        // verify that the device is in bootloader
-        setOsGlobalProgress(40, "Verify that the device is in update mode");
-        timeout = yapiGetTickCount() + YPROG_BOOTLOADER_TIMEOUT;
-        found = 0;
-        while (!found && yapiGetTickCount()< timeout) {
-            res = yNetHubGetBootloaders(hubserial, bootloaders, errmsg);
-            if (res < 0) {
-                setOsGlobalProgress(res, errmsg);
-                goto exit_and_free;
-            } else if (res > 0) {
-                for (i = 0; i < res; i++) {
-                    p = bootloaders + YOCTO_SERIAL_LEN * i;
-                    if (YSTRCMP(yContext->fuCtx.serial, p) == 0) {
-                        found = 1;
-                        break;
-                    }
-                }
-            }
-            // device still rebooting
-            yApproximateSleep(100);
-        }
-        if (!found) {
-            setOsGlobalProgress(YAPI_IO_ERROR, "Hub did not detect bootloader");
-            goto exit_and_free;
-        }
-        //start flash
-        setOsGlobalProgress(50, "Flash firmware");
-        YSPRINTF(buffer, sizeof(buffer), "&s=%s", yContext->fuCtx.serial);
-        res = sendHubFlashCmd(hubserial, "/", yContext->fuCtx.serial,  FLASH_HUB_FLASH, buffer, errmsg);
-        if (res < 0) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        break;
-    }
-
-    //90%-> 98%
-    setOsGlobalProgress(90, "Wait for the device to restart");
-    online = 0;
-    timeout = yapiGetTickCount() + 60000;
-    do {
-        YIOHDL  iohdl;
-        char tmp_errmsg[YOCTO_ERRMSG_LEN];
-        res = yapiUpdateDeviceList(1, errmsg);
-        if (res < 0 && type != FLASH_NET_SELF) {
-            setOsGlobalProgress(res, errmsg);
-            goto exit_and_free;
-        }
-        dev = wpSearch(yContext->fuCtx.serial);
-        if (dev != -1) {
-            wpGetDeviceUrl(dev, hubserial, subpath, 256, NULL);
-            YSPRINTF(buffer, sizeof(buffer), get_api_fmt, subpath);
-            res = yapiHTTPRequestSyncStartEx_internal(&iohdl, 0, hubserial, buffer, YSTRLEN(buffer), &reply, &replysize, NULL, NULL, tmp_errmsg);
-            if (res >= 0) {
-                if (checkHTTPHeader(NULL, reply, replysize, tmp_errmsg) >= 0) {
-                    const char * real_fw;
-                    int fw_len;
-                    fw_len = yapiJsonGetPath_internal("module|firmwareRelease", (char*)reply, replysize, 1, &real_fw, errmsg);
-                    online = 1;
-                    if (fw_len > 2) {
-                        const char *p = ((const byn_head_multi *)fctx.firmware)->h.firmware;
-                        //remove quote
-                        real_fw++;
-                        fw_len -= 2;
-                        if (YSTRNCMP(real_fw,p, fw_len)==0) {
-                            online = 2;
-                        }
-                    }
-                    yapiHTTPRequestSyncDone_internal(&iohdl, tmp_errmsg);
-                    break;
-                }
-                yapiHTTPRequestSyncDone_internal(&iohdl, tmp_errmsg);
-            }
-        }
-        // idle a bit
-        yApproximateSleep(100);
-    } while (!online && yapiGetTickCount()< timeout);
-
-    if (online){
-        if (online == 2) {
-            setOsGlobalProgress(100, "Firmware updated");
-        }else {
-            setOsGlobalProgress(YAPI_VERSION_MISMATCH, "Unable to update firmware");
-        }
-    } else {
-        setOsGlobalProgress(YAPI_DEVICE_NOT_FOUND, "Device did not reboot correctly");
-    }
-
-exit_and_free:
-
-    if (fctx.firmware) {
-        yFree(fctx.firmware);
-        fctx.firmware = NULL;
-    }
-
-exitthread:
-    yThreadSignalEnd(thread);
-    return NULL;
-}
-
-
-static int yStartFirmwareUpdate(const char *serial, const char *firmwarePath, const char *settings, u16 flags, char *msg)
-{
-
-    if (yContext->fuCtx.serial)
-        yFree(yContext->fuCtx.serial);
-    yContext->fuCtx.serial = YSTRDUP(serial);
-    if (yContext->fuCtx.firmwarePath)
-        yFree(yContext->fuCtx.firmwarePath);
-    if (yContext->fuCtx.settings)
-        yFree(yContext->fuCtx.settings);
-    yContext->fuCtx.firmwarePath = YSTRDUP(firmwarePath);
-    yContext->fuCtx.settings = (u8*) YSTRDUP(settings);
-    yContext->fuCtx.settings_len = YSTRLEN(settings);
-    fctx.firmware = NULL;
-    fctx.len = 0;
-    fctx.flags = flags;
-    fctx.stepA = FLASH_FIND_DEV;
-    YSTRNCPY(fctx.bynHead.h.serial, YOCTO_SERIAL_LEN, serial, YOCTO_SERIAL_LEN - 1);
-    yContext->fuCtx.global_progress = 0;
-    YSTRCPY(msg, FLASH_ERRMSG_LEN, "Firmware update started");
-    memset(&yContext->fuCtx.thread, 0, sizeof(yThread));
-    //yThreadCreate will not create a new thread if there is already one running
-    if (yThreadCreate(&yContext->fuCtx.thread, yFirmwareUpdate_thread, NULL)<0){
-        yContext->fuCtx.serial = NULL;
-        YSTRCPY(msg, FLASH_ERRMSG_LEN, "Unable to start helper thread");
-        return YAPI_IO_ERROR;
-    }
-    return 0;
-
-}
-
-
-
-static YRETCODE yapiCheckFirmwareFile(const char *serial, int current_rev, u16 flags, const char *path, char *buffer, int buffersize, int *fullsize, char *errmsg)
-{
-    byn_head_multi *head;
-    int size, res, file_rev;
-    u8  *p;
-
-    size = yLoadFirmwareFile(path, &p, errmsg);
-    if (YISERR(size) || p == NULL){
-        return YAPI_IO_ERROR;
-    }
-    head = (byn_head_multi*) p;
-    res = IsValidBynFile(head, size, serial, flags, errmsg);
-    if (YISERR(res)) {
-        yFree(p);
-        return res;
-    }
-
-
-    file_rev = atoi(head->h.firmware);
-    if (file_rev > current_rev) {
-        int pathsize = YSTRLEN(path) + 1;
-        if (fullsize)
-            *fullsize = YSTRLEN(path);
-        if (pathsize <= buffersize) {
-            YSTRCPY(buffer, buffersize, path);
-        }
-    } else{
-        file_rev = 0;
-    }
-    yFree(p);
-    return file_rev;
-}
-
-
-/***************************************************************************
- * new firmware upgrade API
- **************************************************************************/
-
-static YRETCODE yapiCheckFirmware_r(const char *serial, int current_rev, u16 flags, const char *path, char *buffer, int buffersize, int *fullsize, char *errmsg)
-{
-    int best_rev = current_rev;
-    int pathlen = YSTRLEN(path);
-    char abspath[1024];
-#ifdef WINDOWS_API
-    WIN32_FIND_DATAA ffd;
-    HANDLE hFind;
-#else
-    struct dirent *pDirent;
-    DIR *pDir;
-#endif
-
-#ifdef WINDOWS_API
-#else
-
-    pDir = opendir(path);
-    if (pDir == NULL) {
-        return yapiCheckFirmwareFile(serial, current_rev, flags, path, buffer, buffersize, fullsize, errmsg);
-    }
-#endif
-
-    if (pathlen == 0 || pathlen >= 1024 - 32) {
-        return YERRMSG(YAPI_INVALID_ARGUMENT, "path too long");
-    }
-
-    YSTRCPY(abspath, 1024, path);
-    if (abspath[pathlen - 1] != '/' && abspath[pathlen - 1] != '\\') {
-#ifdef WINDOWS_API
-        abspath[pathlen] = '\\';
-#else
-        abspath[pathlen] = '/';
-#endif
-        abspath[++pathlen] = 0;
-    }
-
-
-#ifdef WINDOWS_API
-    // Find the first file in the directory.
-    YSTRCAT(abspath, 1024, "*");
-    hFind = FindFirstFileA(abspath, &ffd);
-    if (INVALID_HANDLE_VALUE == hFind) {
-        return yapiCheckFirmwareFile(serial, current_rev, flags, path, buffer, buffersize, fullsize, errmsg);
-    }
-    do {
-        char *name = ffd.cFileName;
-#else
-    while ((pDirent = readdir(pDir)) != NULL) {
-        char *name = pDirent->d_name;
-        struct stat buf;
-#endif
-        int isdir;
-        int frev = 0;
-
-        if (*name == '.')
-            continue;
-        abspath[pathlen] = 0;
-        YSTRCAT(abspath, 1024, name);
-#ifdef WINDOWS_API
-        isdir = ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
-#else
-        stat(abspath, &buf);
-        isdir = S_ISDIR(buf.st_mode);
-#endif
-        if (isdir)
-        {
-            frev = yapiCheckFirmware_r(serial, best_rev, flags, abspath, buffer, buffersize, fullsize, errmsg);
-        } else {
-            int len = YSTRLEN(name);
-            if (len < 32 && 'b' == name[len - 3] && 'y' == name[len - 2] && 'n' == name[len - 1]) {
-                frev = yapiCheckFirmwareFile(serial, best_rev, flags, abspath, buffer, buffersize, fullsize, errmsg);
-            }
-        }
-        if (frev > 0){
-            best_rev = frev;
-        }
-
-#ifdef WINDOWS_API
-    } while (FindNextFileA(hFind, &ffd) != 0);
-#else
-    }
-    closedir(pDir);
-#endif
-    return best_rev;
-}
-
-
-static int checkFirmwareFromWeb(const char * serial, char * out_url, int url_max_len, int *fullsize,  char * errmsg)
-{
-    char request[256];
-    u8 *buffer;
-    int res, len;
-    yJsonStateMachine j;
-
-    YSPRINTF(request, 256,"/FR/common/getLastFirmwareLink.php?serial=%s" , serial);
-    res = yTcpDownload("www.yoctopuce.com", request, &buffer, 10000, errmsg);
-    if (res<0){
-        return res;
-    }
-    // Parse HTTP header
-    j.src = (char*)buffer;
-    j.end = j.src + res;
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR,"Unexpected HTTP return code");
-    }
-    if (YSTRCMP(j.token, "200")) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR,"Unexpected HTTP return code");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        yFree(buffer);
-        return YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-    }
-    res = 0;
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "link")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                res = YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                break;
-            }
-            len = YSTRLEN(j.token);
-            if (fullsize){
-                *fullsize = len;
-            }
-            if (url_max_len < len + 1){
-                res = YERRMSG(YAPI_INVALID_ARGUMENT, "buffer too small");
-                break;
-            }
-            if (out_url) {
-                YSTRCPY(out_url,url_max_len,j.token);
-            }
-        } else  if (!strcmp(j.token, "version")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                res = YERRMSG(YAPI_IO_ERROR, "Unexpected JSON reply format");
-                break;
-            }
-            res = atoi(j.token);
-        } else {
-            yJsonSkip(&j, 1);
-        }
-    }
-
-    yFree(buffer);
-    return res;
-}
-
-YRETCODE yapiCheckFirmware_internal(const char *serial, const char *rev, u32 flags, const char *path, char *buffer, int buffersize, int *fullsize, char *errmsg)
-{
-    int current_rev = 0;
-    int best_rev;
-
-    *buffer = 0;
-    if (fullsize)
-        *fullsize = 0;
-    if (*rev!=0)
-        current_rev = atoi(rev);
-
-    if (isWebPath(path)>=0) {
-        best_rev = checkFirmwareFromWeb(serial, buffer, buffersize, fullsize, errmsg);
-    } else{
-        best_rev = yapiCheckFirmware_r(serial, current_rev, (u16)flags, path, buffer, buffersize, fullsize, errmsg);
-    }
-    if (best_rev < 0){
-        return best_rev;
-    }
-    if (best_rev <= current_rev) {
-        buffer[0] = 0;
-        if (fullsize){
-            *fullsize = 0;
-        }
-        return 0;
-    }
-    return best_rev;
-}
-
-YRETCODE yapiUpdateFirmware_internal(const char *serial, const char *firmwarePath, const char *settings, int force, int startUpdate, char *msg)
-{
-    YRETCODE res;
-    yEnterCriticalSection(&fctx.cs);
-    if (startUpdate) {
-        if (yContext->fuCtx.serial == NULL || yContext->fuCtx.firmwarePath == NULL) {
-            res = yStartFirmwareUpdate(serial, firmwarePath, settings, force ? YPROG_FORCE_FW_UPDATE : 0, msg);
-        }else if (yContext->fuCtx.global_progress < 0 || yContext->fuCtx.global_progress >= 100) {
-            res = yStartFirmwareUpdate(serial, firmwarePath, settings, force ? YPROG_FORCE_FW_UPDATE : 0, msg);
-        } else {
-            YSTRCPY(msg, FLASH_ERRMSG_LEN, "Last firmware update is not finished");
-            res = 0;
-        }
-    } else {
-        if (yContext->fuCtx.serial == NULL || yContext->fuCtx.firmwarePath == NULL) {
-            YSTRCPY(msg, FLASH_ERRMSG_LEN, "No firmware update pending");
-            res = YAPI_INVALID_ARGUMENT;
-        } else if (YSTRCMP(serial, yContext->fuCtx.serial) || YSTRCMP(firmwarePath, yContext->fuCtx.firmwarePath)){
-            YSTRCPY(msg, FLASH_ERRMSG_LEN, "Last firmware update is not finished");
-            res = YAPI_INVALID_ARGUMENT;
-        } else {
-            YSTRCPY(msg, FLASH_ERRMSG_LEN, yContext->fuCtx.global_message);
-            res = yContext->fuCtx.global_progress;
-        }
-    }
-    yLeaveCriticalSection(&fctx.cs);
-    return res;
-}
-
-#endif
--- a/Sources/cpplib/yapi/yprog.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*********************************************************************
- *
- * $Id: yprog.h 25611 2016-10-19 12:37:56Z seb $
- *
- * Declaration of firmware upgrade functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YPROG_H
-#define YPROG_H
-#include "ydef.h"
-
-#ifdef MICROCHIP_API
-typedef int ProgIface;
-#else
-#include "yproto.h"
-typedef yInterfaceSt ProgIface;
-#endif
-
-#if !defined(MICROCHIP_API) || (defined(YHUB) && defined(FLASH_FIRMW_FIRSTPAGE))
-#define PROG_SUBDEV
-#endif
-
-#define MAX_ROM_ZONES_PER_FILES     16
-#define MAX_FLASH_ZONES_PER_FILES   4
-
-#define  BYN_SIGN  ((u32) ('B'| ((u16)'Y'<<8) | ((u32)'N'<<16) ))
-#define  BYN_REV_V4 4
-#define  BYN_REV_V5 5
-#define  BYN_REV_V6 6
-
-#ifndef C30
-#pragma pack(push,1)
-#endif
-
-
-#define USE_V6_BYN_FILE
-
-
-typedef struct{
-    union {
-        u32 sign;
-        struct {
-            char a;
-            char b;
-            char c;
-            char d;
-        } signchars;
-    };
-    u16 rev;
-    char serial[YOCTO_SERIAL_LEN];
-    char pictype[20];
-    char product[YOCTO_PRODUCTNAME_LEN];
-    char firmware[YOCTO_FIRMWARE_LEN];
-}byn_head_sign;
-
-typedef struct{
-    u32 nbzones;
-    u32 datasize;
-}byn_head_v4;
-
-typedef struct{
-    char prog_version[YOCTO_FIRMWARE_LEN];
-    u16 pad;
-    u32 nbzones;
-    u32 datasize;
-}byn_head_v5;
-
-typedef struct{
-    u8  md5chk[16];
-    char prog_version[YOCTO_FIRMWARE_LEN]; // 22 bytes
-    u8  ROM_nb_zone;
-    u8  FLA_nb_zone;
-    u32 ROM_total_size;
-    u32 FLA_total_size;
-}byn_head_v6;
-
-typedef struct{
-    byn_head_sign h;
-    union {
-        byn_head_v6 v6;
-        byn_head_v5 v5;
-        byn_head_v4 v4;
-     };
-}byn_head_multi;
-
-
-
-#define BYN_HEAD_SIZE_V4    (sizeof(byn_head_sign)+sizeof(byn_head_v4))
-#define BYN_HEAD_SIZE_V5    (sizeof(byn_head_sign)+sizeof(byn_head_v5))
-#define BYN_HEAD_SIZE_V6    (sizeof(byn_head_sign)+sizeof(byn_head_v6))
-#define BYN_MD5_OFS_V6      (sizeof(byn_head_sign)+16)
-
-typedef struct{
-    u32 addr_page;
-    u32 len;
-}byn_zone;
-
-#ifdef CPU_BIG_ENDIAN
-void decode_byn_head_multi(byn_head_multi *byn_head);
-void decode_byn_zone(byn_zone *zone);
-#define DECODE_U16(NUM) ((((NUM) & 0xff00) >> 8) | (((NUM)&0xff) << 8))
-#define DECODE_U32(NUM) ((((NUM) >> 24) & 0xff) | (((NUM) << 8) & 0xff0000) | (((NUM) >> 8) & 0xff00) | (((NUM) << 24) & 0xff000000 ))
-#else
-#define decode_byn_head_multi(dummy) {}
-#define decode_byn_zone(dummy) {}
-#define DECODE_U16(NUM)  (NUM)
-#define DECODE_U32(NUM) (NUM)
-#endif
-
-typedef struct{
-    u32 addr;
-    u32 nbinstr;
-    u32 nbblock;
-    u8  *ptr;
-    u32 len;
-}romzone;
-
-typedef struct{
-    u32 page;
-    u8  *ptr;
-    u32 len;
-}flashzone;
-
-typedef struct {
-    u32         nbrom;
-    u32         nbflash;
-    romzone     rom[MAX_ROM_ZONES_PER_FILES];
-    flashzone   flash[MAX_FLASH_ZONES_PER_FILES];
-}newmemzones;
-
-typedef struct{
-    ProgIface   iface;
-    u32         pr_blk_size;
-    u32         er_blk_size;
-    u32         last_addr;
-    u32         settings_addr;
-    u8          devid_family;
-    u8          devid_model;
-    u16         devid_rev;
-    u32         startconfig;
-    u32         endofconfig;
-#ifndef MICROCHIP_API
-    u16         ext_jedec_id;
-    u16         ext_page_size;
-    u16         ext_total_pages;
-    u16         first_code_page;
-    u16         first_yfs3_page;
-#endif
-}BootloaderSt;
-
-// from yfirmupd.c
-extern BootloaderSt firm_dev;
-extern USB_Packet   firm_pkt;
-
-#ifndef C30
-#pragma pack(pop)
-#endif
-YRETCODE yapiGetBootloadersDevs(char *serials, unsigned int maxNbSerial, unsigned int *totalBootladers, char *errmsg);
-
-// Return 1 if the communication channel to the device is busy
-// Return 0 if there is no ongoing transaction with the device
-int ypIsSendBootloaderBusy(BootloaderSt *dev);
-
-// Return 0 if there command was successfully queued for sending
-// Return -1 if the output channel is busy and the command could not be sent
-int ypSendBootloaderCmd(BootloaderSt *dev, const USB_Packet *pkt,char *errmsg);
-// Return 0 if a reply packet was available and returned
-// Return -1 if there was no reply available
-int ypGetBootloaderReply(BootloaderSt *dev, USB_Packet *pkt,char *errmsg);
-// Power cycle the device
-int ypBootloaderShutdown(BootloaderSt *dev);
-int IsValidBynHead(const byn_head_multi *head, u32 size, u16 flags, char *errmsg);
-
-#ifndef MICROCHIP_API
-const char* prog_GetCPUName(BootloaderSt *dev);
-int ValidateBynCompat(const byn_head_multi *head, u32 size, const char *serial, u16 flags, BootloaderSt *dev, char *errmsg);
-int IsValidBynFile(const byn_head_multi *head, u32 size, const char *serial, u16 flags, char *errmsg);
-int BlockingRead(BootloaderSt *dev, USB_Packet *pkt, int maxwait, char *errmsg);
-int SendDataPacket(BootloaderSt *dev, int program, u32 address, u8 *data, int nbinstr, char *errmsg);
-#endif
-
-//#define DEBUG_FIRMWARE
-typedef enum
-{
-    YPROG_DONE = 0u,    // Finished with procedure
-    YPROG_WAITING       // Waiting for asynchronous process to complete, call again later
-} YPROG_RESULT;
-
-
-#define MAX_FIRMWARE_LEN  0x100000ul
-#define INVALID_FIRMWARE  0xfffffffful
-#define FLASH_NB_REBOOT_RETRY  1
-
-typedef enum{
-    FLASH_FIND_DEV = 0,
-#ifndef MICROCHIP_API
-    FLASH_CONNECT,
-#endif
-    FLASH_GET_INFO,
-    FLASH_VALIDATE_BYN,
-    FLASH_ERASE,
-    FLASH_WAIT_ERASE,
-    FLASH_DOFLASH,
-    FLASH_GET_INFO_BFOR_REBOOT,
-    FLASH_REBOOT,
-    FLASH_REBOOT_VALIDATE,
-#ifndef MICROCHIP_API
-    FLASH_AUTOFLASH,
-#endif
-    FLASH_SUCCEEDED,
-    FLASH_DISCONNECT,
-    FLASH_DONE
-}FLASH_DEVICE_STATE;
-
-typedef enum {
-    FLASH_ZONE_START,
-    FLASH_ZONE_PROG,
-    FLASH_ZONE_READ,
-    FLASH_ZONE_RECV_OK
-} FLASH_ZONE_STATE;
-
-
-#define BLOCK_FLASH_TIMEOUT       4000u
-#define PROG_GET_INFO_TIMEOUT    10000u
-#define ZONE_VERIF_TIMEOUT        4000u
-#define FLASH_SUBDEV_TIMEOUT     59000u
-#define YPROG_BOOTLOADER_TIMEOUT 20000u
-#define YPROG_FORCE_FW_UPDATE    1u
-
-#ifdef MICROCHIP_API
-#define FLASH_ERRMSG_LEN        56
-#else
-#define FLASH_ERRMSG_LEN        YOCTO_ERRMSG_LEN
-#endif
-
-
-#define PROG_IN_ERROR 0x8000
-typedef struct {
-#ifndef MICROCHIP_API
-    u8                  *firmware;
-    yCRITICAL_SECTION   cs;
-#endif
-    u32                 len;
-    union {
-        byn_head_multi  bynHead;
-        u8              bynBuff[sizeof(byn_head_multi)];
-    };
-    u16                 flags;
-    u16                 currzone;
-    s16                 progress;
-    FLASH_DEVICE_STATE  stepA;
-    FLASH_ZONE_STATE    zst;
-    union {
-        byn_zone        bz;
-        u8              bzBuff[sizeof(byn_zone)];
-    };
-    yTime               timeout;
-    u32                 zOfs;
-    u32                 zNbInstr;
-    u32                 stepB;
-    u16                 flashErase;
-    u16                 flashPage;
-    u16                 flashAddr;
-    char                errmsg[FLASH_ERRMSG_LEN];
-} FIRMWARE_CONTEXT;
-
-extern FIRMWARE_CONTEXT fctx;
-
-
-// memo: u=universal y=yapi h=hub
-
-#ifdef YAPI_IN_YDEVICE
-#define uGetFirmware(ofs, dst, size) hProgGetFirmware(ofs, dst, size)
-void hProgInit(void);
-void hProgFree(void);
-#else
-#define uGetFirmware(ofs, dst, size) yGetFirmware(ofs, dst, size)
-void yProgInit(void);
-void yProgFree(void);
-YRETCODE yapiCheckFirmware_internal(const char *serial, const char *rev, u32 flags, const char *path, char *buffer, int buffersize, int *fullsize, char *errmsg);
-YRETCODE yapiUpdateFirmware_internal(const char *serial, const char *firmwarePath, const char *settings, int force, int startUpdate, char *msg);
-#endif
-
-
-
-#define uGetFirmwareBynHead(head_ptr) {uGetFirmware(0, (u8*)(head_ptr), sizeof(byn_head_multi));decode_byn_head_multi(head_ptr);}
-#define uGetFirmwareBynZone(offset,zone_ptr) {uGetFirmware(offset,(u8*)(zone_ptr),sizeof(byn_zone)); decode_byn_zone(zone_ptr);}
-
-YPROG_RESULT uFlashDevice(void);
-int yNetHubGetBootloaders(const char *hubserial, char *buffer, char *errmsg);
-#endif
--- a/Sources/cpplib/yapi/yproto.h
+++ /dev/null
@@ -1,1094 +0,0 @@
-/*********************************************************************
- *
- * $Id: yproto.h 33735 2018-12-14 16:06:53Z seb $
- *
- * Definitions and prototype common to all supported OS
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef  YPROTO_H
-#define  YPROTO_H
-
-#include "ydef.h"
-#ifdef WINDOWS_API
-#ifndef _WIN32_WINNT
-#define _WIN32_WINNT 0x400
-#endif
-#endif
-#include "yapi.h"
-#include "ytcp.h"
-#ifdef WINDOWS_API
-/**************************************************************
-* WINDOWS SPECIFIC HEADER
-***************************************************************/
-#if defined(__BORLANDC__)
-#pragma warn -8019
-#include <windows.h>
-#pragma warn +8019
-#else
-#include <windows.h>
-#endif
-#ifndef WINAPI_PARTITION_DESKTOP
-#define WINDOWS_WIN32_API
-#else
-#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
-#define WINDOWS_WIN32_API
-#else
-#define WINDOWS_UWP_API
-#endif
-#endif
-
-#ifdef WINDOWS_WIN32_API
-#include <dbt.h>
-
-#include <SetupAPI.h>
-#ifdef _MSC_VER
-#pragma comment(lib, "SetupApi.lib")
-#pragma comment(lib, "OleAut32.lib")
-
-#endif
-/**************************************************************
-* WINDOWS HID ACCES FOR WINODWS
-***************************************************************/
-
-typedef struct _HIDD_ATTRIBUTES {
-    ULONG Size;
-    USHORT VendorID;
-    USHORT ProductID;
-    USHORT VersionNumber;
-} HIDD_ATTRIBUTES, *PHIDD_ATTRIBUTES;
-
-//Pointers to a HID function  used
-typedef VOID    (__stdcall *PHidD_GetHidGuid)(LPGUID);
-typedef BOOLEAN (__stdcall *PHidD_GetAttributes)(HANDLE, PHIDD_ATTRIBUTES);
-typedef BOOLEAN (__stdcall *PHidD_GetManufacturerString) (HANDLE,PVOID,ULONG);
-typedef BOOLEAN (__stdcall *PHidD_GetProductString) (HANDLE,PVOID,ULONG);
-typedef BOOLEAN (__stdcall *PHidD_GetSerialNumberString) (HANDLE,PVOID,ULONG);
-typedef BOOLEAN (__stdcall *PHidD_SetNumInputBuffers) (HANDLE, ULONG);
-
-typedef struct{
-    HINSTANCE                   hHID;
-    PHidD_GetHidGuid            GetHidGuid;
-    PHidD_GetAttributes         GetAttributes;
-    PHidD_GetManufacturerString GetManufacturerString;
-    PHidD_GetProductString      GetProductString;
-    PHidD_GetSerialNumberString GetSerialNumberString;
-    PHidD_SetNumInputBuffers    SetNumInputBuffers;
-}win_hid_api;
-#endif
-
-#ifdef  WINDOWS_WIN32_API
-
-//Pointers to a registry function  used
-
-typedef LONG (__stdcall *PYRegCreateKeyEx)( HKEY hKey,
-                                            const char *                lpSubKey,
-                                            DWORD                 Reserved,
-                                            LPTSTR                lpClass,
-                                            DWORD                 dwOptions,
-                                            REGSAM                samDesired,
-                                            LPSECURITY_ATTRIBUTES lpSecurityAttributes,
-                                            PHKEY                 phkResult,
-                                            LPDWORD               lpdwDisposition);
-typedef LONG (_stdcall *PYRegOpenKeyEx) (HKEY hKey, const char * lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
-typedef LONG (__stdcall *PYRegSetValueEx)(  HKEY    hKey,
-                                            char *  lpValueName,
-                                            DWORD   Reserved,
-                                            DWORD   dwType,
-                                            const BYTE    *lpData,
-                                            DWORD   cbData);
-
-typedef LONG (__stdcall *PYRegQueryValueEx)(    HKEY    hKey,
-                                                char *  lpValueName,
-                                                LPDWORD lpReserved,
-                                                LPDWORD lpType,
-                                                LPBYTE  lpData,
-                                                LPDWORD lpcbData);
-typedef LONG(__stdcall *PYRegDeleteValue)(HKEY hKey, char * lpValueName);
-typedef LONG (__stdcall *PYRegCloseKey)(HKEY hKey);
-typedef LONG (__stdcall *PYRegDeleteKeyEx)(HKEY hKey, char * lpSubKey, REGSAM samDesired, DWORD Reserved);
-
-typedef struct{
-    HINSTANCE                  hREG;
-    PYRegCreateKeyEx           yRegCreateKeyEx;
-    PYRegOpenKeyEx             yRegOpenKeyEx;
-    PYRegSetValueEx            yRegSetValueEx;
-    PYRegQueryValueEx          yRegQueryValueEx;
-    PYRegDeleteValue           yRegDeleteValue;
-    PYRegCloseKey              yRegCloseKey;
-    PYRegDeleteKeyEx           yRegDeleteKeyEx;
-}win_reg_api;
-
-#endif
-
-#elif defined(OSX_API)
-/*****************************************************************************
-  OSX SPECIFIC HEADER
- ****************************************************************************/
-#include <IOKit/hid/IOHIDLib.h>
-
-
-#elif defined(LINUX_API)
-/*****************************************************************************
-  LINUX SPECIFIC HEADER
- ****************************************************************************/
-#include <libusb-1.0/libusb.h>
-#endif
-
-/*****************************************************************************
-  MISC GLOBAL INCLUDES:
- ****************************************************************************/
-
-#include "yfifo.h"
-#include "yhash.h"
-#include "ykey.h"
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <ctype.h>
-
-/*****************************************************************************
-  MEMORY MANAGEMENT FUNCTION:
- ****************************************************************************/
-//#define YSAFE_MEMORY
-
-#include "ymemory.h"
-#ifdef YSAFE_MEMORY
-#define yMalloc(size)                   ySafeMalloc(__FILE_ID__,__LINE__,size)
-#define yFree(ptr)                      {ySafeFree(__FILE_ID__,__LINE__,ptr);ptr=NULL;}
-#define yTracePtr(ptr)                  ySafeTrace(__FILE_ID__,__LINE__,ptr)
-#ifndef YMEMORY_ALLOW_MALLOC
-#undef malloc
-#undef free
-#define malloc(size)                    yForbiden_malloc(size)
-#define free(ptr)                       yForbiden_free(ptr)
-#endif
-#else
-#define yMalloc(size)                   malloc(size)
-#define yFree(ptr)                      free(ptr)
-#define yTracePtr(ptr)
-#endif
-
-#define yMemset(dst,val,size)           memset(dst,val,size)
-#define yMemcpy(dst,src,size)           memcpy(dst,src,size)
-#define yMemmove(dst,src,size)          memmove(dst,src,size)
-
-#if defined(WINDOWS_API) && defined(_MSC_VER) && !defined(WINCE)
-    #define YSTRCMP(A,B)                        strcmp(A,B)
-    #define YSTRNCMP(A,B,len)                   strncmp(A,B,len)
-    #define YSTRICMP(A,B)                       _stricmp(A,B)
-    #define YSTRNICMP(A,B,len)                  _strnicmp(A,B,len)
-    #define YSTRLEN(str)                        ((int)strlen(str))
-#elif defined(WINDOWS_API) && defined(__BORLANDC__)
-    #define YSTRCMP(A,B)                        strcmp(A,B)
-    #define YSTRNCMP(A,B,len)                   strncmp(A,B,len)
-    #define YSTRICMP(A,B)                       strcmpi(A,B)
-    #define YSTRNICMP(A,B,len)                  strncmpi(A,B,len)
-    #define YSTRLEN(str)                        ((int)strlen(str))
-#elif defined(WINCE)
-    #define YSTRCMP(A,B)                        strcmp(A,B)
-    #define YSTRNCMP(A,B,len)                   strncmp(A,B,len)
-    #define YSTRICMP(A,B)                       _stricmp(A,B)
-    #define YSTRNICMP(A,B,len)                  _strnicmp(A,B,len)
-    #define YSTRLEN(str)                        ((int)strlen(str))
-#else
-    #define YSTRCMP(A,B)                        strcmp(A,B)
-    #define YSTRNCMP(A,B,len)                   strncmp(A,B,len)
-    #define YSTRICMP(A,B)                       strcasecmp(A,B)
-    #define YSTRNICMP(A,B,len)                  strncasecmp(A,B,len)
-    #define YSTRLEN(str)                        ((int)strlen(str))
-#endif
-
-#define YSTRDUP(src)                        ystrdup_s(src)
-#define YSTRCPY(dst,dstsize,src)            ystrcpy_s(dst,dstsize,src)
-#define YSTRCAT(dst,dstsize,src)            ystrcat_s(dst,dstsize,src)
-#define YSTRNCAT(dst,dstsize,src,len)       ystrncat_s(dst,dstsize,src,len)
-#define YSTRNCPY(dst,dstsize,src,len)       ystrncpy_s(dst,dstsize,src,len)
-#define YSPRINTF                            ysprintf_s
-#define YVSPRINTF                           yvsprintf_s
-char *ystrdup_s(const char *src);
-YRETCODE ystrcpy_s(char *dst, unsigned dstsize, const char *src);
-YRETCODE ystrncpy_s(char *dst,unsigned dstsize,const char *src,unsigned len);
-YRETCODE ystrcat_s(char *dst, unsigned dstsize,const char *src);
-YRETCODE ystrncat_s(char *dst, unsigned dstsize,const char *src,unsigned len);
-int ysprintf_s(char *dst, unsigned dstsize,const char *fmt ,...);
-int yvsprintf_s (char *dst, unsigned dstsize, const char * fmt, va_list arg );
-int ymemfind(const u8 *haystack, u32 haystack_len, const u8 *needle, u32 needle_len);
-
-
-//#define DEBUG_YAPI_REQ
-//#define DEBUG_HAL
-//#define DEBUG_HAL_ENUM
-//#define DEBUG_DEV_ENUM
-//#define DEBUG_DEV_ENUM_VERBOSE
-//#define DEBUG_NET_ENUM
-//#define DEBUG_NOTIFICATION
-//#define DEBUG_NET_NOTIFICATION
-//#define DEBUG_DUMP_PKT
-//#define DEBUG_USB_TRAFIC
-//#define TRACE_NET_HUB
-//#define DEBUG_TRACE_FILE "c:\\tmp\\tracefile.txt"
-//#define DEBUG_TCP
-//#define DEBUG_WEBSOCKET
-//#define TRACE_REQUESTS
-//#define DEBUG_MISSING_PACKET
-
-#define MSC_VS2003 1310
-
-#ifdef DEBUG_YAPI_REQ
-#define YREQLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define YREQLOG(fmt,...)
-#else
-__forceinline void __YREQLOG(fmt,...){}
-#define YREQLOG __YREQLOG
-#endif
-#else
-#define YREQLOG(fmt,args...)
-#endif
-#endif
-
-#ifdef DEBUG_HAL
-#define HALLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define HALLOG(fmt,...)
-#else
-__forceinline void __HALLOG(fmt,...){}
-#define HALLOG __HALLOG
-#endif
-#else
-#define HALLOG(fmt,args...)
-#endif
-#endif
-
-#ifdef DEBUG_HAL_ENUM
-#define HALENUMLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define HALENUMLOG(fmt,...)
-#else
-__forceinline void HALENUMLOG(fmt,...){}
-#define HALENUMLOG __HALLOG
-#endif
-#else
-#define HALENUMLOG(fmt,args...)
-#endif
-#endif
-
-#ifdef DEBUG_TCP
-#define TCPLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define TCPLOG(fmt,...)
-#else
-__forceinline void __TCPLOG(fmt,...){}
-#define TCPLOG __TCPLOG
-#endif
-#else
-#define TCPLOG(fmt,args...)
-#endif
-#endif
-
-#ifdef TRACE_REQUESTS
-#define REQLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define REQLOG(fmt,...)
-#else
-__forceinline void __REQLOG(fmt, ...) {}
-#define REQLOG __REQLOG
-#endif
-#else
-#define REQLOG(fmt,args...)
-#endif
-#endif
-
-
-#ifdef DEBUG_DEV_ENUM
-#define ENUMLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define ENUMLOG(fmt,...)
-#else
-__forceinline void __ENUMLOG(fmt,...){}
-#define ENUMLOG __ENUMLOG
-#endif
-#else
-#define ENUMLOG(fmt,args...)
-#endif
-#endif
-
-#ifdef DEBUG_NET_ENUM
-#define NETENUMLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define NETENUMLOG(fmt,...)
-#else
-__forceinline void __NETENUMLOG(fmt,...){}
-#define NETENUMLOG __NETENUMLOG
-#endif
-#else
-#define NETENUMLOG(fmt,args...)
-#endif
-#endif
-
-
-
-#ifdef DEBUG_WEBSOCKET
-#define WSLOG  dbglog
-#else
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define WSLOG(fmt,...)
-#else
-__forceinline void __WSLOG(fmt, ...) {}
-#define WSLOG __WSLOG
-#endif
-#else
-#define WSLOG(fmt,args...)
-#endif
-#endif
-
-
-
-
-int vdbglogf(const char *fileid,int line,const char *fmt,va_list args);
-int dbglogf(const char *fileid,int line,const char *fmt,...);
-#if defined(_MSC_VER)
-#if (_MSC_VER > MSC_VS2003)
-#define dbglog(...)      dbglogf(__FILE_ID__,__LINE__, __VA_ARGS__)
-#else
-__forceinline int __dbglog(const char* fmt,...) {
-    int len;
-    va_list args;
-
-    va_start( args, fmt );
-    len = vdbglogf("vs2003",__LINE__,fmt,args);
-    va_end(args);
-    return len;
-}
-#define dbglog __dbglog
-#endif
-#else
-#define dbglog(args...)  dbglogf(__FILE_ID__,__LINE__, ## args)
-#endif
-
-
-#ifdef DEBUG_DUMP_PKT
-void dumpAnyPacket(char *prefix,int ifaceno,USB_Packet *pkt);
-#endif
-
-
-#define STRINGIFY(x) #x
-#define TOSTRING(x) STRINGIFY(x)
-
-/*****************************************************************************
- MISC DEFINITION
- ****************************************************************************/
-#ifdef WINDOWS_API
-#define yApproximateSleep(ms)  Sleep(ms)
-#else
-#include <unistd.h>
-#include <stdio.h>
-#define yApproximateSleep(ms)          usleep(ms*1000)
-#endif
-//secure fopen
-#if defined(_MSC_VER) &&  (_MSC_VER > MSC_VS2003)
-#define YFOPEN(f,filename,mode) fopen_s(f,filename,mode)
-#else
-#include <stdio.h>
-int YFOPEN(FILE** f, const char *filename, const char *mode);
-#endif
-
-#if 0
-#if defined(WINDOWS_API) && (_MSC_VER)
-#define YDEBUG_BREAK { __debugbreak();}
-#else
-#define YDEBUG_BREAK  {__asm__("int3");}
-#endif
-#else
-#define YDEBUG_BREAK {}
-#endif
-
-#define YPANIC                  {dbglog("YPANIC:%s:%d\n",__FILE_ID__ , __LINE__);YDEBUG_BREAK}
-#define YASSERT(x)              if(!(x)){dbglog("ASSERT FAILED:%s:%d\n",__FILE_ID__ , __LINE__);YDEBUG_BREAK}
-#define YPROPERR(call)          {int tmpres=(call); if(YISERR(tmpres)) {return (YRETCODE)tmpres;}}
-#define YERR(code)              ySetErr(code,errmsg,NULL,__FILE_ID__,__LINE__)
-#define YERRTO(code,buffer)     ySetErr(code,buffer,NULL,__FILE_ID__,__LINE__)
-#define YERRMSG(code,message)   ySetErr(code,errmsg,message,__FILE_ID__,__LINE__)
-#define YERRMSGSILENT(code,message)   ySetErr(code, errmsg, message, NULL, 0)
-#define YERRMSGTO(code,message,buffer)   ySetErr(code,buffer,message,__FILE_ID__,__LINE__)
-int ySetErr(int code, char *outmsg, const char *erreur, const char *file, u32 line);
-int FusionErrmsg(int code,char *errmsg, const char *generr, const char *detailerr);
-
-
-/*****************************************************************************
- OLD version fo protocol that are supported
-****************************************************************************/
-
-#define YPKT_VERSION_ORIGINAL_RELEASE    0x0202
-
-/*****************************************************************************
- PERFORMANCE TEST DEFINITIONS (very old)
-****************************************************************************/
-typedef struct
-{
-    u64 totaltime;
-    u64 count;
-    u64 leave;
-    u64 tmp;
-} yPerfMon;
-
-void  dumpYPerfEntry(yPerfMon *entry,const char *name);
-
-
-/*****************************************************************************
- INTERNAL STRUCTURES and DEFINITIONS
-****************************************************************************/
-
-// MISC packet definitions
-#pragma pack(push,1)
-typedef struct{
-    u8         dummy;
-    USB_Packet pkt;
-} OS_USB_Packet;
-#pragma pack(pop)
-
-
-#if defined(LINUX_API)
-typedef struct {
-    struct _yInterfaceSt    *iface;
-    struct libusb_transfer  *tr;
-    USB_Packet              tmppkt;
-} linRdTr;
-#endif
-
-// packet queue stuff
-typedef struct _pktItem{
-    USB_Packet          pkt;
-#ifdef DEBUG_PKT_TIMING
-    u64                 time;
-    u64                 ospktno;
-#endif
-    struct _pktItem     *next;
-} pktItem;
-
-
-typedef struct {
-    pktItem             *first;
-    pktItem             *last;
-    int                 count;
-    u64                 totalPush;
-    u64                 totalPop;
-    YRETCODE            status;
-    char                errmsg[YOCTO_ERRMSG_LEN];
-    yCRITICAL_SECTION   cs;
-    yEvent              notEmptyEvent;
-    yEvent              emptyEvent;
-} pktQueue;
-
-//pktQueue Helpers
-void yPktQueueInit(pktQueue  *q);
-void yPktQueueFree(pktQueue  *q);
-void yPktQueueSetError(pktQueue  *q,YRETCODE code, const char * msg);
-
-#ifdef OSX_API
-
-typedef struct {
-    IOHIDManagerRef     manager;
-    yCRITICAL_SECTION   hidMCS;
-} OSX_HID_REF;
-
-#endif
-
-#ifdef WINDOWS_UWP_API
-typedef struct _uwp_enum_item {
-    u16 vendorid;
-    u16 devicid;
-    //String ^serial;
-    //String ^id;
-} uwp_enum_item;
-#endif
-
-#define NBMAX_NET_HUB               32
-#define NBMAX_USB_DEVICE_CONNECTED  256
-#define WIN_DEVICE_PATH_LEN         512
-#define HTTP_RAW_BUFF_SIZE          (8*1024)
-#define NB_LINUX_USB_TR             1
-
-#define YWIN_EVENT_READ     0
-#define YWIN_EVENT_INTERRUPT 1
-
-typedef struct _yInterfaceSt {
-    u16             vendorid;
-    u16             deviceid;
-    u16             ifaceno;
-    u16             pkt_version;
-    char            serial[YOCTO_SERIAL_LEN*2];
-    struct {
-        u32         yyySetupDone:1;
-    } flags;
-    pktQueue        rxQueue;
-    pktQueue        txQueue;
-#if defined(WINDOWS_API)
-    char            devicePath[WIN_DEVICE_PATH_LEN];
-    yThread         io_thread;
-    HANDLE          wrHDL;
-    OVERLAPPED      rdOL;
-    HANDLE          rdHDL;
-    HANDLE          EV[2];
-    u32             rdpending;
-    OS_USB_Packet   tmpd2hpkt;
-    OS_USB_Packet   tmph2dpkt;
-#elif defined(OSX_API)
-    OSX_HID_REF         hid;
-    CFStringRef         run_loop_mode;
-    IOHIDDeviceRef      devref;
-    USB_Packet          tmprxpkt;
-#elif defined(LINUX_API)
-    libusb_device           *devref;
-    libusb_device_handle    *hdl;
-    u8                      rdendp;
-    u8                      wrendp;
-    linRdTr                 *rdTr;
-    linRdTr                 *wrTr;
-    int                     ioError;
-#endif
-} yInterfaceSt;
-
-YRETCODE    yPktQueuePushD2H(yInterfaceSt *iface,const USB_Packet *pkt, char * errmsg);
-YRETCODE    yPktQueueWaitAndPopD2H(yInterfaceSt *iface,pktItem **pkt,int ms,char * errmsg);
-YRETCODE    yPktQueuePushH2D(yInterfaceSt *iface,const USB_Packet *pkt, char * errmsg);
-YRETCODE    yPktQueuePeekH2D(yInterfaceSt *iface,pktItem **pkt);
-YRETCODE    yPktQueuePopH2D(yInterfaceSt *iface,pktItem **pkt);
-
-#define NBMAX_INTERFACE_PER_DEV     1
-typedef enum
-{
-    YDEV_UNPLUGGED=0,           // device has been plugged by the past but is no more
-                                // -> YDEV_WORKING  or YDEV_NOTRESPONDING
-    YDEV_WORKING,               // device is plugged and running
-                                // -> YDEV_UNPLUGGED
-    YDEV_NOTRESPONDING          // device has not answered to StartDevice and we will never try to speak with it
-                                // -> none
-} YDEV_STATUS;
-
-
-typedef enum
-{
-    YENU_NONE,
-    YENU_START,
-    YENU_STOP,
-    YENU_RESTART
-} YENU_ACTION;
-
-typedef enum
-{
-    YRUN_STOPED,
-    YRUN_AVAIL,                 // device is available for a request
-    YRUN_REQUEST,               // device has be reserved for a request
-    YRUN_BUSY,                  // device is doing IO for the request
-    YRUN_IDLE,                  // device is doing IO for the idle thread
-    YRUN_ERROR,                 // device has been stopped because an IO error
-} YRUN_STATUS;
-
-typedef enum
-{
-    YHTTP_CLOSED,
-    YHTTP_OPENED,
-    YHTTP_INREQUEST,
-    YHTTP_CLOSE_BY_DEV,
-    YHTTP_CLOSE_BY_API
-} YHTTP_STATUS;
-
-
-// structure that contain generic device information (usb and network)
-#define DEVGEN_LOG_ACTIVATED     1u
-#define DEVGEN_LOG_PENDING       2u
-#define DEVGEN_LOG_PULLING       4u
-typedef struct  _yGenericDeviceSt {
-    yStrRef             serial; // set only once at init -> no need to use the mutex
-    u32                 flags;
-    u32                 deviceLogPos;
-    yFifoBuf            logFifo;
-    u8*                 logBuffer;
-    u64                 lastTimeRef;
-    u64                 lastFreq;
-} yGenericDeviceSt;
-
-void initDevYdxInfos(int devYdxy, yStrRef serial);
-void freeDevYdxInfos(int devYdx);
-
-
-#define YIO_REMOTE_CLOSE 1u
-
-typedef struct{
-    u8      flags;
-    u64     timeout;
-    YUSBIO  hdl;
-    yapiRequestAsyncCallback callback;
-    void *context;
-} USB_HDL;
-
-#define NB_MAX_STARTUP_RETRY   5u
-
-#define NEXT_YPKT_NO(current) ((current+1)& YPKTNOMSK)
-#define NEXT_IFACE_NO(current,total) (current+1<total?current+1:0)
-
-// structure that contain all information about a device
-typedef struct  _yPrivDeviceSt{
-    yCRITICAL_SECTION   acces_state;
-    YUSBDEV             yhdl;       // unique YHANDLE to identify device during execution
-    YDEV_STATUS         dStatus;    // detection status
-    YENU_ACTION         enumAction; // action to trigger at end of enumeration
-    YRUN_STATUS         rstatus;    // running status of the device (valid only on working dev)
-    char                errmsg[YOCTO_ERRMSG_LEN];
-    unsigned int        nb_startup_retry;
-    u64                 next_startup_attempt;
-    USB_HDL             pendingIO;
-    YHTTP_STATUS        httpstate;
-    yDeviceSt           infos;      // device infos
-    u32                 lastUtcUpdate;
-    pktItem             *currxpkt;
-    u8                  curxofs;
-    pktItem             *curtxpkt;
-    u8                  curtxofs;
-    pktItem             tmptxpkt;
-    u8                  lastpktno;
-    int                 pktAckDelay;
-    yInterfaceSt        iface;
-    char                *replybuf;      // Used to buffer request result
-    int                 replybufsize;   // allocated size of replybuf
-    yFifoBuf            http_fifo;
-    u8                  *http_raw_buf;
-    u8                  *devYdxMap;
-    struct              _yPrivDeviceSt   *next;
-} yPrivDeviceSt;
-
-
-typedef void (*yDevInfoCallback)(const yDeviceSt *infos);
-typedef void (*yNotificCallback)(const char *serial, const char *funcid, const char *funcname, const char *funcval);
-
-typedef enum {
-    USB_THREAD_NOT_STARTED,
-    USB_THREAD_RUNNING,
-    USB_THREAD_MUST_STOP,
-    USB_THREAD_STOPED
-} USB_THREAD_STATE;
-
-typedef enum {
-    NET_HUB_DISCONNECTED=0,
-    NET_HUB_TRYING,
-    NET_HUB_ESTABLISHED,
-    NET_HUB_TOCLOSE,
-    NET_HUB_CLOSED
-} NET_HUB_STATE;
-
-// If made bigger than 255, change plenty of u8 into u16 and pray
-#define MAX_YDX_PER_HUB 255
-#define ALLOC_YDX_PER_HUB 256
-// NetHubSt flags
-//#define NETH_F_MANDATORY                1
-//#define NETH_F_SEND_PING_NOTIFICATION   2
-
-#define NET_HUB_NOT_CONNECTION_TIMEOUT   (6*1024)
-
-typedef struct _HTTPNetHubSt {
-    // the following fields are for the notification helper thread only
-    struct _RequestSt    *notReq;
-                                        // the following fields are used by hub net enum and notification helper thread
-    u64                 lastTraffic;    // time of the last data received on the notification socket (in ms)
-                                        // the following fields are used for authentication to the hub, and require mutex access
-    char                *s_user;
-    char                *s_realm;
-    char                *s_pwd;
-    char                *s_nonce;
-    char                *s_opaque;
-    u8                  s_ha1[16];        // computed when realm is received if pwd is not NULL
-    u32                 nc;             // reset each time a new nonce is received
-} HTTPNetHub;
-
-
-
-enum WS_BASE_STATE
-{
-    WS_BASE_OFFLINE = 0,
-    WS_BASE_HEADER_SENT,
-    WS_BASE_SOCKET_UPGRADED,
-    WS_BASE_AUTHENTICATING,
-    WS_BASE_CONNECTED,
-};
-
-typedef struct _WSChanSt {
-    u32 lastUploadAckBytes;
-    u64 lastUploadAckTime;
-    u32 lastUploadRateBytes;
-    u64 lastUploadRateTime;
-    yCRITICAL_SECTION access;
-    struct _RequestSt* requests;
-}WSChanSt;
-
-typedef struct _WSNetHubSt {
-    enum WS_BASE_STATE base_state;
-    enum WS_BASE_STATE strym_state;
-    char serial[YOCTO_SERIAL_LEN];
-    char websocket_key[32];
-    int websocket_key_len;
-    int remoteVersion;
-    u32 remoteNounce;
-    u32 nounce;
-    yStrRef user;
-    yStrRef pass;
-    int s_next_async_id;
-    YSOCKET skt;
-    yFifoBuf mainfifo;
-    u64 bws_open_tm;
-    u64 bws_timeout_tm;
-    u64 bws_read_tm;
-    u64 next_transmit_tm;
-    u64 connectionTime;
-    u32 tcpRoundTripTime;
-    u32 tcpMaxWindowSize;
-    u32 uploadRate;
-    WSChanSt chan[MAX_ASYNC_TCPCHAN];
-    u8* fifo_buffer;
-    struct _RequestSt *openRequests;
-} WSNetHub;
-
-
-#define INCOMPATIBLE_JZON_ENCODING 1
-
-typedef struct _HubSt {
-    yUrlRef url;            // hub base URL, or INVALID_HASH_IDX if unused
-    // misc flag that are mapped to int for efficiency and thread safety
-    int rw_access;
-    int send_ping;
-    int mandatory;
-    int writeProtected; // admin password detected
-    yStrRef serial;
-    WakeUpSocket wuce;
-    yThread net_thread;
-    char *name;
-    yAsbUrlProto proto;
-    NET_HUB_STATE state;
-    yFifoBuf not_fifo; // notification fifo
-    u8 not_buffer[1024]; // buffer for the fifo
-    int retryCount;
-    u32 notifAbsPos;
-    u64 lastAttempt;    // time of the last connection attempt (in ms)
-    u64 attemptDelay;   // delay until next attempts (in ms)
-    u64 devListExpires;
-    u8 devYdxMap[ALLOC_YDX_PER_HUB];   // maps hub's internal devYdx to our WP devYdx
-    int errcode;  // in case an error occurred
-    char errmsg[YOCTO_ERRMSG_LEN];
-    yCRITICAL_SECTION access; // CS for field that need to be protected again concurrency (these filed start with cs_)
-    u32 flags;
-    u32 typical_apireq_size;
-    char fw_release[YOCTO_FIRMWARE_LEN];
-    u8 *ref_api;
-    u32  ref_api_size;
-    // implementations specific struct
-    HTTPNetHub http;
-    WSNetHub ws;
-} HubSt;
-
-
-#define TCPREQ_KEEPALIVE       1
-#define TCPREQ_IN_USE          2
-
-
-typedef struct _HTTPReqSt {
-    YSOCKET             skt;            // socket used to talk to the device
-    YSOCKET             reuseskt;       // socket to reuse for next query, when keep alive is true
-} HTTPReqSt;
-
-typedef struct _WSReqSt
-{
-    int channel;
-    int asyncId;
-    u32 iohdl;
-    struct _RequestSt *next;
-    u8* requestbuf; // Used to store the request to send
-    int requestsize; // the size of the request
-    int requestpos; // the pos of the request that need to be sent
-    u64 first_write_tm;
-    u64 last_write_tm;
-} WSReqSt;
-
-typedef enum
-{
-    REQ_CLOSED = 0, REQ_OPEN, REQ_CLOSED_BY_HUB, REQ_CLOSED_BY_API, REQ_ERROR
-} RequestState;
-
-typedef void(*RequestProgress)(void *context, u32 acked, u32 totalbytes);
-
-
-typedef struct _RequestSt {
-    HubSt               *hub;           // pointer to the NetHubSt handling the device
-    yCRITICAL_SECTION   access;
-    yEvent              finished;       // event seted when this request can be reused
-    RequestState        state;          // state of the request (fixme: currenty only use by WS)
-    char                *headerbuf;     // Used to store all lines of the HTTP header (with the double \r\n)
-    int                 headerbufsize;  // allocated size of requestbuf
-    char                *bodybuf;       // Used to store the body of the POST request
-    int                 bodybufsize;    // allocated size of the body of the POST request
-    int                 bodysize;       // effective size of the body of the POST request
-    u8                  *replybuf;      // Used to buffer request result
-    int                 replybufsize;   // allocated size of replybuf
-    int                 replysize;      // write pointer within replybuf
-    int                 replypos;       // read pointer within replybuf; -1 when not ready to start reading
-    int                 retryCount;     // number of authorization attempts
-    int                 errcode;        // in case an error occurred
-    char                errmsg[YOCTO_ERRMSG_LEN];
-    u64                 open_tm;        // timestamp of the start of a connection used to detect timeout of the device
-                                        // (must be reset if we reuse the socket)
-    u64                 write_tm;       // timestamp of the last successfully write of the request
-    u64                 read_tm;        // timestamp of the last received packet (must be reset if we reuse the socket)
-    u64                 timeout_tm;     // the maximum time to live of this connection
-    u32                 flags;          // flags for keep alive and no expiration
-    yAsbUrlProto        proto;          // the type of protocol used for this request (same information as the one contained in the hub url)
-    yapiRequestAsyncCallback callback;
-    void                *context;
-    RequestProgress     progressCb;
-    void                *progressCtx;
-    HTTPReqSt           http;
-    WSReqSt             ws;
-} RequestSt;
-
-#define SETUPED_IFACE_CACHE_SIZE 128
-
-
-typedef struct {
-    char        *serial;
-    char        *firmwarePath;
-    u8          *settings;
-    int         settings_len;
-    yThread     thread;
-    int         global_progress; //-1:error 0-99:working 100:success
-    char        global_message[YOCTO_ERRMSG_LEN]; // the last message or the error
-    const char* fileid;
-    int         line;
-} FUpdateContext;
-
-
-typedef struct _YIOHDL_internal {
-    struct _YIOHDL_internal *next;
-    u64     ioid;
-    u8      type;
-    u8      pad8;
-    u16     pad16;
-    union {
-        u32     tcpreqidx;
-        YUSBIO  hdl;
-        RequestSt *ws;
-    };
-} YIOHDL_internal;
-
-
-#define YCTX_OSX_MULTIPLES_HID 1
-// structure that contain information about the API
-typedef struct{
-    //yapi CS
-    yCRITICAL_SECTION   updateDev_cs;
-    yCRITICAL_SECTION   handleEv_cs;
-    yEvent              exitSleepEvent;
-    // global information on all devices
-    yCRITICAL_SECTION   generic_cs;
-    yGenericDeviceSt    generic_infos[ALLOC_YDX_PER_HUB];
-    // usb stuff
-    yCRITICAL_SECTION   enum_cs;
-    int                 detecttype;
-    YUSBDEV             devhdlcount;
-    yPrivDeviceSt       *devs;
-    int                 nbdevs;
-    int                 devs_capacity;
-    yCRITICAL_SECTION   io_cs;
-    YIOHDL_internal     *yiohdl_first;
-    u32                 io_counter;
-    u64                 deviceListValidityMs;
-    // network discovery info
-    HubSt*              nethub[NBMAX_NET_HUB];
-    RequestSt*          tcpreq[ALLOC_YDX_PER_HUB];  // indexed by our own DevYdx
-    yRawNotificationCb  rawNotificationCb;
-    yRawReportCb        rawReportCb;
-    yRawReportV2Cb      rawReportV2Cb;
-    yCRITICAL_SECTION   deviceCallbackCS;
-    yCRITICAL_SECTION   functionCallbackCS;
-    // SSDP stuff
-    SSDPInfos           SSDP;            // socket used to talk to the device
-    // Public callbacks
-    yapiLogFunction             log;
-    yapiDeviceLogCallback       logDeviceCallback;
-    yapiDeviceUpdateCallback    arrivalCallback;
-    yapiDeviceUpdateCallback    changeCallback;
-    yapiBeaconCallback          beaconCallback;
-    yapiDeviceUpdateCallback    confChangeCallback;
-    yapiDeviceUpdateCallback    removalCallback;
-    yapiFunctionUpdateCallback  functionCallback;
-    yapiTimedReportCallback     timedReportCallback;
-    yapiHubDiscoveryCallback    hubDiscoveryCallback;
-    // Programing api
-    FUpdateContext      fuCtx;
-    // OS specifics variables
-    yInterfaceSt*       setupedIfaceCache[SETUPED_IFACE_CACHE_SIZE];
-#if defined(WINDOWS_API)
-    HANDLE              apiLock;
-    HANDLE              nameLock;
-    yCRITICAL_SECTION   prevEnum_cs;
-    int                 prevEnumCnt;
-    yInterfaceSt        *prevEnum;
-#ifdef WINDOWS_WIN32_API
-    win_hid_api         hid;
-    win_reg_api         registry;
-#endif
-#elif defined(OSX_API)
-    u32                 osx_flags;
-    OSX_HID_REF         hid;
-    CFRunLoopRef        usb_run_loop;
-    pthread_t           usb_thread;
-    USB_THREAD_STATE    usb_thread_state;
-#elif defined(LINUX_API)
-    yCRITICAL_SECTION   string_cache_cs;
-    libusb_context      *libusb;
-    pthread_t           usb_thread;
-    USB_THREAD_STATE    usb_thread_state;
-#endif
- } yContextSt;
-
-#define TRACEFILE_NAMELEN  512
-
-extern char  ytracefile[];
-extern yContextSt  *yContext;
-
-YRETCODE yapiPullDeviceLogEx(int devydx);
-YRETCODE yapiPullDeviceLog(const char *serial);
-YRETCODE yapiRequestOpen(YIOHDL_internal *iohdl, int tpchan, const char *device, const char *request, int reqlen, yapiRequestAsyncCallback callback, void *context, yapiRequestProgressCallback progress_cb, void *progress_ctx, char *errmsg);
-
-/*****************************************************************
- * PLATFORM SPECIFIC USB code
-*****************************************************************/
-
-
-// for devices detection
-int  yyyUSB_init(yContextSt *ctx, char *errmsg);
-int  yyyUSB_stop(yContextSt *ctx, char *errmsg);
-int  yyyUSBGetInterfaces(yInterfaceSt **ifaces,int *nbifaceDetect,char *errmsg);
-int  yyyOShdlCompare(yPrivDeviceSt *dev, yInterfaceSt *newiface);
-int  yyySetup(yInterfaceSt *iface,char *errmsg);
-YRETCODE  yyySendPacket( yInterfaceSt *iface,const USB_Packet *pkt,char *errmsg);
-int  yyySignalOutPkt(yInterfaceSt *iface, char *errmsg);
-// close all stuff of setup
-void yyyPacketShutdown(yInterfaceSt *iface);
-
-
-/*****************************************************************************
-  ENUMERATION RELATED FUNCTION
-******************************************************************************/
-
-//some early declarations
-void wpSafeRegister(HubSt *hub, u8 devYdx, yStrRef serialref,yStrRef lnameref, yStrRef productref, u16 deviceid, yUrlRef devUrl,s8 beacon);
-void wpSafeUpdate(HubSt *hub, u8 devYdx, yStrRef serialref,yStrRef lnameref, yUrlRef devUrl, s8 beacon);
-void wpSafeUnregister(yStrRef serialref);
-
-void ypUpdateUSB(const char *serial, const char *funcid, const char *funcname, int funclass, int funydx, const char *funcval);
-void ypUpdateYdx(int devydx, Notification_funydx funInfo, const char *funcval);
-void ypUpdateHybrid(const char *serial, Notification_funydx funInfo, const char *funcval);
-
-/*****************************************************************
- * yStream API with cycling logic and yyPacket API
-*****************************************************************/
-
-/**********************************************************************
-  GENERIC DEVICE LIST FUNCTION
- **********************************************************************/
-
-// return the yDeviceSt *from a matching string (serial or name)
-#define FIND_FROM_SERIAL 1
-#define FIND_FROM_NAME   2
-#define FIND_FROM_ANY    (FIND_FROM_SERIAL|FIND_FROM_NAME)
-yPrivDeviceSt *findDev(const char *str,u32 flags);
-
-
-// return the YHANDLE from a matching string (serial or name)
-YUSBDEV findDevHdlFromStr(const char *str);
-yPrivDeviceSt *findDevFromIOHdl(YIOHDL_internal *hdl);
-void devHdlInfo(YUSBDEV hdl,yDeviceSt *infos);
-
-YRETCODE yUSBUpdateDeviceList(char *errmsg);
-void     yUSBReleaseAllDevices(void);
-
-/*****************************************************************************
-  USB REQUEST FUNCTIONS
-  ***************************************************************************/
-
-int  yUsbInit(yContextSt *ctx,char *errmsg);
-int  yUsbFree(yContextSt *ctx,char *errmsg);
-int  yUsbIdle(void);
-int  yUsbTrafficPending(void);
-yGenericDeviceSt* yUSBGetGenericInfo(yStrRef devdescr);
-
-int  yUsbOpenDevDescr(YIOHDL_internal *ioghdl, yStrRef devdescr, char *errmsg);
-int  yUsbOpen(YIOHDL_internal *ioghdl, const char *device, char *errmsg);
-int  yUsbSetIOAsync(YIOHDL_internal *ioghdl, yapiRequestAsyncCallback callback, void *context, char *errmsg);
-int  yUsbWrite(YIOHDL_internal *ioghdl, const char *buffer, int writelen,char *errmsg);
-int  yUsbReadNonBlock(YIOHDL_internal *ioghdl, char *buffer, int len,char *errmsg);
-int  yUsbReadBlock(YIOHDL_internal *ioghdl, char *buffer, int len,u64 blockUntil,char *errmsg);
-int  yUsbEOF(YIOHDL_internal *ioghdl,char *errmsg);
-int  yUsbClose(YIOHDL_internal *ioghdl,char *errmsg);
-
-#if 0
-// Implemented but never tested
-int  yUsbSendMeta(const char *str, USB_Meta_Pkt *pkt, int len, char *errmsg);
-#endif
-int  yUSBGetBooloader(const char *serial, const char * name,  yInterfaceSt *iface,char *errmsg);
-
-// Misc helper
-int handleNetNotification(HubSt *hub);
-u32 yapiGetCNonce(u32 nc);
-YRETCODE  yapiHTTPRequestSyncStartEx_internal(YIOHDL *iohdl, int tcpchan, const char *device, const char *request, int requestsize, char **reply, int *replysize, yapiRequestProgressCallback progress_cb, void *progress_ctx, char *errmsg);
-YRETCODE  yapiHTTPRequestSyncDone_internal(YIOHDL *iohdl, char *errmsg);
-void yFunctionUpdate(YAPI_FUNCTION fundescr, const char *value);
-void yFunctionTimedUpdate(YAPI_FUNCTION fundescr, u64 deviceTime, u64 freq, const u8 *report, u32 len);
-int yapiJsonGetPath_internal(const char *path, const char *json_data, int json_size, int withHTTPheader, const char **output, char *errmsg);
-void request_pending_logs(HubSt* hub);
-#endif
--- a/Sources/cpplib/yapi/ystream.c
+++ /dev/null
@@ -1,2958 +0,0 @@
-/*********************************************************************
- *
- * $Id: ystream.c 33735 2018-12-14 16:06:53Z seb $
- *
- * USB stream implementation
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "ystream"
-#include "yproto.h"
-#include "yhash.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <string.h>
-#include <stdarg.h>
-#ifdef WINDOWS_API
-#include <time.h>
-#else
-#include <sys/time.h>
-#endif
-
-/*****************************************************************************
-  Global variables
- ***************************************************************************/
-
-yContextSt *yContext=NULL;
-
-#ifdef DEBUG_TRACE_FILE
-char  ytracefile[512]=DEBUG_TRACE_FILE;
-#else
-char  ytracefile[512]="";
-#endif
-
-/*****************************************************************************
-  Error and logs functions
- ***************************************************************************/
-
-
-int ySetErr(int code, char *outmsg, const char *erreur,const char *file,u32 line)
-{
-    const char *msg;
-    if(outmsg==NULL){
-        // no output buffer only return code
-        return code;
-    }
-    if(erreur==NULL){
-        switch(code){
-            case YAPI_SUCCESS:          msg="Success";break;
-            case YAPI_NOT_INITIALIZED:  msg="API not initialized";break;
-            case YAPI_INVALID_ARGUMENT: msg="Invalid argument";break;
-            case YAPI_NOT_SUPPORTED:    msg="Not supported";break;
-            case YAPI_DEVICE_NOT_FOUND: msg="Device not found";break;
-            case YAPI_VERSION_MISMATCH: msg="Version mismatch"; break;
-            case YAPI_DEVICE_BUSY:      msg="Device busy";break;
-            case YAPI_TIMEOUT:          msg="Timeout";break;
-            case YAPI_IO_ERROR:         msg="I/O error";break;
-            case YAPI_NO_MORE_DATA:     msg="No more data";break;
-            case YAPI_EXHAUSTED:        msg="Resource exhausted";break;
-            case YAPI_DOUBLE_ACCES:     msg="double access to the same device";break;
-            case YAPI_UNAUTHORIZED:     msg="unauthorized access";break;
-            case YAPI_RTC_NOT_READY:    msg="real-time clock has not been initialized";break;
-            case YAPI_FILE_NOT_FOUND:   msg="file is not found";break;
-            default:                    msg="Unknown error";
-            break;
-        }
-    }else{
-        msg=erreur;
-    }
-    if (file) {
-        YSPRINTF(outmsg, YOCTO_ERRMSG_LEN, "%s (%s:%d)", msg, file, line);
-    } else {
-        YSTRCPY(outmsg, YOCTO_ERRMSG_LEN, msg);
-    }
-    return code;
-}
-
-
-
-int FusionErrmsg(int code,char *errmsg, const char *generr, const char *detailerr)
-{
-    int len;
-    if(YISERR(code) && errmsg){
-        YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,generr);
-        YSTRCAT(errmsg,YOCTO_ERRMSG_LEN,":");
-        len=YSTRLEN(errmsg);
-        YSTRNCAT(errmsg,YOCTO_ERRMSG_LEN,detailerr,YOCTO_ERRMSG_LEN-len);
-    }
-    return code;
-}
-
-
-
-
-
-#if !defined(_MSC_VER) ||  (_MSC_VER <= MSC_VS2003)
-
-int YFOPEN(FILE** f, const char *filename, const char *mode)
-{
-    *f=fopen(filename,mode);
-    if(*f==NULL){
-        return -1;
-    }
-    return 0;
-}
-
-#endif
-
-
-
-#define DBGLOGOUT(str) yContext->log(str,YSTRLEN(str))
-
-static int dayofs[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
-
-static void WriteTsamp(FILE *f)
-{
-    u32  year, month, day, h, m, s;
-
-#ifdef WINCE
-    SYSTEMTIME time;
-    GetLocalTime( &time);
-    year  = time.wYear;
-    month = time.wMonth;
-    day   = time.wDay;
-    h     = time.wHour;
-    m     = time.wMinute;
-    s     = time.wSecond;
-#else
-
-    u32 secs, days,y;
-    time_t ltime;
-
-    time(&ltime);
-    secs = (u32)(ltime % 86400);
-    days = (u32)(ltime / 86400);
-    h = secs / 3600;
-    m = (secs % 3600) / 60;
-    s = secs % 60;
-    y = days / 365; /* relative to 1970 */
-    if (((y + 1) >> 2) + 365 * (u32)y > days) y--;
-    days -= ((y + 1) >> 2) + 365 * (u32)y;
-    if ((y & 3) == 2 && days == 59) {
-        month = 2;
-    } else {
-        if((y & 3) == 2 && days >= 59)
-        days--;
-        for (month = 1; month < 12; (month)++)
-            if (dayofs[month] > (u16)days) break;
-    }
-    year = y + 1970;
-    day = days - dayofs[month - 1] + 1;
-#endif
-    fprintf(f,"[%04d-%02d-%02d/%02d:%02d:%02d]:",year,month,day,h,m,s);
-}
-
-
-int vdbglogf(const char *fileid,int line,const char *fmt,va_list args)
-{
-    char buffer[2048];
-    int len;
-    int  threadIdx;
-    threadIdx = yThreadIndex();
-    len=YSPRINTF(buffer,2048,"[%d]%s:% 4d: ",threadIdx,fileid,line);
-    if(len<0 || len>=2028 || (len = YVSPRINTF(buffer+len,2048-len,fmt,args))<0){
-        YSTRCPY(buffer,2048,"dbglogf failed\n");
-        return -1;
-    }
-    len =YSTRLEN(buffer);
-
-    if(yContext && yContext->log)
-        yContext->log(buffer,len);
-
-#if 0
-    buffer[len] = 0;
-    printf("%s", buffer);
-#endif
-
-    if(ytracefile[0]){
-        FILE *f;
-        if(YFOPEN(&f,ytracefile,"a+")!=0){
-            return -1;
-        }
-        WriteTsamp(f);
-        fwrite(buffer,1,len,f);
-        fclose(f);
-    }
-    return len;
-}
-
-int dbglogf(const char *fileid,int line,const char *fmt,...)
-{
-    int len;
-    va_list args;
-
-    va_start( args, fmt );
-    len =vdbglogf(fileid,line,fmt,args);
-    va_end(args);
-    return len;
-}
-
-
-#ifdef __BORLANDC__
-#pragma argsused
-int sprintf_s(char *buffer,size_t sizeOfBuffer,const char *format,...)
-{
-    va_list args;
-    va_start( args, format);
-    return vsprintf(buffer,format,args);
-}
-#pragma argsused
-int wcstombs_s(size_t *pReturnValue, char *mbstr, size_t sizeInBytes, const wchar_t *wcstr, size_t count)
-{
-    *pReturnValue = wcstombs(mbstr, wcstr, count);
-    return 0;
-}
-#endif
-
-
-/*****************************************************************************
- Whitepage and Yellowpage wrapper for USB devices
- ****************************************************************************/
-
-void ypUpdateUSB(const char *serial, const char *funcid, const char *funcname, int funclass, int funydx, const char *funcval)
-{
-    char    funcid_cstr[YOCTO_FUNCTION_LEN];
-    char    categ[YOCTO_FUNCTION_LEN];
-    yStrRef serialref, funcidref, funcnameref = INVALID_HASH_IDX;
-    u16     i;
-
-    funcid_cstr[0] = funcid[0];
-    categ[0] = (funcid[0] & ~0x20); // aka to_upper()
-    for(i = 1; i < YOCTO_FUNCTION_LEN-1; i++) {
-        char c = funcid[i];
-        if(!c || (c <= '9' && c >= '0')) break;
-        funcid_cstr[i] = c;
-        categ[i] = c;
-    }
-    categ[i] = 0;
-    for(; i < YOCTO_FUNCTION_LEN-1; i++) {
-        char c = funcid[i];
-        if(!c) break;
-        funcid_cstr[i] = c;
-    }
-    funcid_cstr[i] = 0;
-    serialref = yHashPutStr(serial);
-    funcidref = yHashPutStr(funcid_cstr);
-    if(funcname) funcnameref = yHashPutStr(funcname);
-    if(ypRegister(yHashPutStr(categ), serialref, funcidref, funcnameref, funclass, funydx, funcval)){
-        // Forward high-level notification to API user
-        yFunctionUpdate(((s32)funcidref << 16) | serialref, funcval);
-    }
-}
-
-void ypUpdateYdx(int devydx, Notification_funydx funInfo, const char *funcval)
-{
-    YAPI_FUNCTION fundesc;
-
-    if(ypRegisterByYdx(devydx, funInfo, funcval, &fundesc)){
-        // Forward high-level notification to API user
-        if (funcval) {
-            char buffer[YOCTO_PUBVAL_LEN];
-            decodePubVal(funInfo, funcval, buffer);
-            yFunctionUpdate(fundesc,buffer);
-        }
-    }
-}
-
-void ypUpdateHybrid(const char *serial, Notification_funydx funInfo, const char *funcval)
-{
-    int     devydx;
-    yStrRef serialref;
-
-    serialref = yHashPutStr(serial);
-    devydx = wpGetDevYdx(serialref);
-    if(devydx >= 0) {
-        ypUpdateYdx(devydx, funInfo, funcval);
-    }
-}
-
-/*****************************************************************************
-  THEAD / CONCURENCY RELATED FUNCTIONS
- ***************************************************************************/
-//#define DEBUG_DEVICE_LOCK
-#ifdef DEBUG_DEVICE_LOCK
-#define LOCATION int line,
-#define PUSH_LOCATION __LINE__,
-#define PUSH_LOCATION __LINE__,
-#else
-#define LOCATION
-#define PUSH_LOCATION
-#endif
-
- static void devInitAccces(LOCATION yPrivDeviceSt *dev)
- {
-    yInitializeCriticalSection(&dev->acces_state);
-  }
-
- static void devDeleteAccces(LOCATION yPrivDeviceSt *dev)
- {
-     yDeleteCriticalSection(&dev->acces_state);
- }
-
-static int devStartIdle(LOCATION yPrivDeviceSt *dev,char *errmsg)
-{
-    int res =YAPI_DEVICE_BUSY;
-    //get access
-    if (yTryEnterCriticalSection(&dev->acces_state)==0) {
-        return YERR(YAPI_DEVICE_BUSY);
-    }
-
-    if (dev->dStatus!=YDEV_WORKING){
-        yLeaveCriticalSection(&dev->acces_state);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    switch(dev->rstatus){
-        case YRUN_STOPED:
-        case YRUN_ERROR:
-            res= YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-            break;
-        case YRUN_REQUEST:
-        case YRUN_BUSY:
-            res = YERR(YAPI_DEVICE_BUSY);
-            break;
-        case YRUN_AVAIL:
-            dev->rstatus = YRUN_IDLE;
-            // do not release the mutex on purpose!
-#ifdef DEBUG_DEVICE_LOCK
-            dbglog("start Idle on %s (line %d)\n",dev->infos.serial,line);
-#endif
-            return YAPI_SUCCESS;
-        case YRUN_IDLE:
-#ifdef DEBUG_DEVICE_LOCK
-            dbglog("double Idle on %s (line %d)\n",dev->infos.serial,line);
-#endif
-            res = YERR(YAPI_DEVICE_BUSY);
-            break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-}
-
-
-static void devStopIdle(LOCATION yPrivDeviceSt *dev)
-{
-
-    switch(dev->rstatus){
-    case YRUN_STOPED:
-        break;
-    case YRUN_ERROR:
-    case YRUN_REQUEST:
-    case YRUN_BUSY:
-    case YRUN_AVAIL:
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        break;
-    case YRUN_IDLE:
-        dev->rstatus = YRUN_AVAIL;
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("stop Idle on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-}
-
-
-
-static void devStartEnum(LOCATION yPrivDeviceSt *dev)
-{
-    u64  timeref;
-    //get access
-    yEnterCriticalSection(&dev->acces_state);
-
-    timeref = yapiGetTickCount();
-    while((dev->rstatus == YRUN_IDLE || dev->rstatus == YRUN_BUSY ) && (u64)(yapiGetTickCount() - timeref) < 2000){
-        // if someone is doing IO release the mutex and give him 2 second to quit
-        yLeaveCriticalSection(&dev->acces_state);
-        yPktQueueSetError(&dev->iface.rxQueue, YAPI_DEVICE_NOT_FOUND, "Device need to be stopped");
-        yApproximateSleep(100);
-        yEnterCriticalSection(&dev->acces_state);
-    }
-    dev->rstatus = YRUN_STOPED;
-    // keep the Mutex on purpose
-}
-
-
-static void devStopEnum(LOCATION yPrivDeviceSt *dev)
-{
-    yLeaveCriticalSection(&dev->acces_state);
-}
-
-
-
-
-static void devReportErrorFromIdle(LOCATION yPrivDeviceSt *dev, char *error_to_set)
-{
-    //get access
-    dbglog("Error from idle %s(%d) : %s\n",dev->infos.serial,dev->rstatus,error_to_set);
-    switch(dev->rstatus){
-    case YRUN_STOPED:
-        break;
-    case YRUN_ERROR:
-    case YRUN_REQUEST:
-    case YRUN_BUSY:
-    case YRUN_AVAIL:
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        break;
-    case YRUN_IDLE:
-        dev->rstatus = YRUN_ERROR;
-        YSTRCPY(dev->errmsg,YOCTO_ERRMSG_LEN,error_to_set);
-        break;
-    }
-    yLeaveCriticalSection(&dev->acces_state);
-}
-
-
-
-
-static int devStartIO(LOCATION yPrivDeviceSt *dev, char *errmsg)
-{
-    int res =YAPI_DEVICE_BUSY;
-    //get access
-    yEnterCriticalSection(&dev->acces_state);
-
-    if (dev->dStatus!=YDEV_WORKING){
-        yLeaveCriticalSection(&dev->acces_state);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    switch(dev->rstatus){
-    case YRUN_ERROR:
-        res = YERRMSG(YAPI_IO_ERROR,dev->errmsg);
-        break;
-    case YRUN_STOPED:
-        res = YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-        break;
-    case YRUN_REQUEST:
-    case YRUN_BUSY:
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    case YRUN_AVAIL:
-        dev->rstatus = YRUN_BUSY;
-        res = YAPI_SUCCESS;
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("start IO on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    }
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-}
-
-
-static int devPauseIO(LOCATION yPrivDeviceSt *dev,char *errmsg)
-{
-    int res = YAPI_SUCCESS;
-
-    yEnterCriticalSection(&dev->acces_state);
-    switch(dev->rstatus){
-    case YRUN_ERROR:
-        res = YERRMSG(YAPI_IO_ERROR,dev->errmsg);
-        break;
-    case YRUN_STOPED:
-        res = YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-        break;
-    case YRUN_REQUEST:
-        //should never occur
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    case YRUN_BUSY:
-        dev->rstatus = YRUN_REQUEST;
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("pause IO on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        break;
-    case YRUN_AVAIL:
-        res = YERRMSG(YAPI_INVALID_ARGUMENT,"No IO started");
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-}
-
-
-
-static int devCheckIO(LOCATION yPrivDeviceSt *dev, YIOHDL_internal *iohdl,char *errmsg)
-{
-    int res = YAPI_SUCCESS;
-
-    yEnterCriticalSection(&dev->acces_state);
-
-    if (dev->dStatus!=YDEV_WORKING){
-        yLeaveCriticalSection(&dev->acces_state);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    switch(dev->rstatus){
-    case YRUN_ERROR:
-        res = YERRMSG(YAPI_IO_ERROR,dev->errmsg);
-        break;
-    case YRUN_STOPED:
-        res = YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-        break;
-    case YRUN_REQUEST:
-        if(YIO_USB != iohdl->type || dev->pendingIO.hdl != iohdl->hdl){
-            res=YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid  IO Handle");
-        }else{
-            dev->rstatus = YRUN_BUSY;
-#ifdef DEBUG_DEVICE_LOCK
-            dbglog("restart IO on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        }
-        break;
-   case YRUN_BUSY:
-        res=YERRMSG(YAPI_INVALID_ARGUMENT,"Access violation");
-        break;
-    case YRUN_AVAIL:
-        res = YERRMSG(YAPI_INVALID_ARGUMENT,"No IO started");
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-}
-
-static int devCheckAsyncIO(LOCATION yPrivDeviceSt *dev, char *errmsg)
-{
-    int res = YAPI_SUCCESS;
-
-    yEnterCriticalSection(&dev->acces_state);
-
-    if (dev->dStatus!=YDEV_WORKING){
-        yLeaveCriticalSection(&dev->acces_state);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    switch(dev->rstatus){
-    case YRUN_ERROR:
-        res = YERRMSG(YAPI_IO_ERROR,dev->errmsg);
-        break;
-    case YRUN_STOPED:
-        res = YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-        break;
-    case YRUN_REQUEST:
-        if (dev->pendingIO.callback == NULL) {
-            res=YERRMSG(YAPI_INVALID_ARGUMENT,"Invalid IO Handle");
-        } else {
-            dev->rstatus = YRUN_BUSY;
-#ifdef DEBUG_DEVICE_LOCK
-            dbglog("Async IO bg process on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        }
-        break;
-   case YRUN_BUSY:
-        res=YERRMSG(YAPI_INVALID_ARGUMENT,"Access violation");
-        break;
-    case YRUN_AVAIL:
-        res = YERRMSG(YAPI_INVALID_ARGUMENT,"No IO started");
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-}
-
-
-static int devStopIO(LOCATION yPrivDeviceSt *dev, char *errmsg)
-{
-    int res = YAPI_SUCCESS;
-
-    yEnterCriticalSection(&dev->acces_state);
-    switch(dev->rstatus){
-    case YRUN_ERROR:
-        res = YERRMSG(YAPI_IO_ERROR,dev->errmsg);
-        break;
-    case YRUN_STOPED:
-        res = YERRMSG(YAPI_DEVICE_NOT_FOUND,"This device is not available");
-        break;
-    case YRUN_REQUEST:
-        res=YERRMSG(YAPI_INVALID_ARGUMENT,"Access violation");
-        break;
-   case YRUN_BUSY:
-        dev->rstatus = YRUN_AVAIL;
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("Stop IO on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        break;
-    case YRUN_AVAIL:
-        res = YERRMSG(YAPI_INVALID_ARGUMENT,"No IO started");
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        res = YERR(YAPI_DEVICE_BUSY);
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-    return res;
-
-}
-
-static void devReportError(LOCATION yPrivDeviceSt *dev, const char *error_to_set)
-{
-    //get access
-    yEnterCriticalSection(&dev->acces_state);
-    switch(dev->rstatus){
-    case YRUN_STOPED:
-    case YRUN_ERROR:
-    case YRUN_REQUEST:
-    case YRUN_BUSY:
-    case YRUN_AVAIL:
-        dbglog("Error %s(%d) : %s\n",dev->infos.serial,dev->rstatus,error_to_set);
-        dev->rstatus = YRUN_ERROR;
-        YSTRCPY(dev->errmsg,YOCTO_ERRMSG_LEN,error_to_set);
-        break;
-    case YRUN_IDLE:
-        //should never occur since we keep the mutex during idle
-#ifdef DEBUG_DEVICE_LOCK
-        dbglog("panic on %s (line %d)\n",dev->infos.serial,line);
-#endif
-        YPANIC;
-        break;
-    }
-
-    yLeaveCriticalSection(&dev->acces_state);
-}
-
-
-
-/*****************************************************************************
-  Dump functions
- ***************************************************************************/
-
-
-
-#ifdef DEBUG_DUMP_PKT
-
-static void dumpAnyStream(char *prefix,int iface,u8 pkt,u8 stream,u8 size,u8 *data,u8 pktno)
-{
-
-    USB_Notify_Pkt *notif= (USB_Notify_Pkt*) data;
-    int pos, j;
-    char buff[17];
-    buff[16] = 0;
-    dbglog("%s:%d: head: type=%d stream/cmd=%d size=%d (pktno=%d)\n",
-           prefix,iface ,pkt ,stream,size,pktno);
-
-    if(pkt== YPKT_CONF){
-        switch(stream){
-            case USB_CONF_RESET:
-                dbglog("%s: USB_CONF_RESET\n",prefix);
-                break;
-            case USB_CONF_START:
-                dbglog("%s: USB_CONF_START\n",prefix);
-                break;
-            default:
-                dbglog("%s: CONF PKT INVALID!\n",prefix);
-                break;
-        }
-    }else if(pkt == YPKT_STREAM){
-        switch(stream){
-            case YSTREAM_EMPTY:
-                dbglog("%s: Stream Empty\n",prefix);
-                break;
-            case YSTREAM_NOTICE:
-            case YSTREAM_NOTICE_V2:
-                if(notif->firstByte <= NOTIFY_1STBYTE_MAXTINY) {
-                    dbglog("%s: TINY FUNCTION VALUE\n",prefix);
-                } else if(notif->firstByte >= NOTIFY_1STBYTE_MINSMALL) {
-                    dbglog("%s: SMALL FUNCTION VALUE\n",prefix);
-                } else switch(notif->head.type){
-                    case NOTIFY_PKT_NAME:
-                        dbglog("%s: NOTIFY LOGICAL NAME\n",prefix);
-                        break;
-                    case NOTIFY_PKT_PRODNAME:
-                        dbglog("%s: NOTIFY PRODNAME\n",prefix);
-                        break;
-                    case NOTIFY_PKT_CHILD:
-                        dbglog("%s: NOTIFY CHILD\n",prefix);
-                        break;
-                    case NOTIFY_PKT_FIRMWARE:
-                        dbglog("%s: NOTIFY FIRMWARE\n",prefix);
-                        break;
-                    case NOTIFY_PKT_FUNCNAME:
-                        dbglog("%s: NOTIFY FUNCTION NAME\n",prefix);
-                        break;
-                    case NOTIFY_PKT_FUNCVAL:
-                        dbglog("%s: NOTIFY FUNCTION VALUE\n",prefix);
-                        break;
-                    case NOTIFY_PKT_STREAMREADY:
-                        dbglog("%s: NOTIFY DEVICE READY\n",prefix);
-                        break;
-                    case NOTIFY_PKT_LOG:
-                        dbglog("%s: NOTIFY DEVICE LOG\n",prefix);
-                        break;
-                    case NOTIFY_PKT_CONFCHANGE:
-                        dbglog("%s: NOTIFY DEVICE CONF CHANGE\n",prefix);
-                        break;
-                    default:
-                        dbglog("%s: Unknown NOTIFY\n",prefix);
-                        break;
-                }
-                break;
-            case YSTREAM_TCP:
-                dbglog("%s: Stream tcp\n",prefix);
-                for(pos = 0; pos < size; pos += 16) {
-                    memset(buff, '.', 16);
-                    for(j = 0; j < 16; j++)
-                        if(data[pos+j] >= ' ')
-                            buff[j] = data[pos+j];
-                    dbglog("   %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x   %s\n",
-                           data[pos+0], data[pos+1], data[pos+2], data[pos+3],
-                           data[pos+4], data[pos+5], data[pos+6], data[pos+7],
-                           data[pos+8], data[pos+9], data[pos+10], data[pos+11],
-                           data[pos+12], data[pos+13], data[pos+14], data[pos+15],
-                           buff);
-                }
-                break;
-            case YSTREAM_TCP_CLOSE:
-                dbglog("%s: Stream tcp close\n",prefix);
-                for(pos = 0; pos < size; pos += 16) {
-                    memset(buff, '.', 16);
-                    for(j = 0; j < 16; j++)
-                        if(data[pos+j] >= ' ')
-                            buff[j] = data[pos+j];
-                    dbglog("   %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x %02x.%02x.%02x.%02x   %s\n",
-                           data[pos+0], data[pos+1], data[pos+2], data[pos+3],
-                           data[pos+4], data[pos+5], data[pos+6], data[pos+7],
-                           data[pos+8], data[pos+9], data[pos+10], data[pos+11],
-                           data[pos+12], data[pos+13], data[pos+14], data[pos+15],
-                           buff);
-                }
-                break;
-            default:
-                dbglog("%s: Stream invalid !\n",prefix);
-                break;
-        }
-
-    }
-}
-static u32 dumpAnyStreamHead(char *prefix,int iface,YSTREAM_Head *head,int dumpContent)
-{
-    u8 *data =((u8*)head)+sizeof(YSTREAM_Head);
-    dumpAnyStream(prefix,iface,head->pkt , head->stream, head->size, data, head->pktno);
-    return head->size;
-}
-
-void dumpAnyPacket(char *prefix, int iface,USB_Packet *pkt)
-{
-    u32 pos=0;
-    //dbglog("%s:%d: DUMP FULL PACKET!\n",prefix,iface);
-    while(pos < USB_PKT_SIZE-sizeof(YSTREAM_Head)){
-        YSTREAM_Head *head =(YSTREAM_Head*) (pkt->data+pos);
-        pos+=sizeof(YSTREAM_Head)+dumpAnyStreamHead(prefix,iface,head,1);
-    }
-
-}
-
-#endif
-
-
-
-/*****************************************************************************
-  PACKET QUEUING FUNCTIONS
-  ***************************************************************************/
-//#define DUMP_USB_PKT_SHORT
-#ifdef DUMP_USB_PKT_SHORT
-static void dumpPktSummary(char *prefix, int iface,int isInput,const USB_Packet *pkt)
-{
-    u32 pos=0;
-    char buffer[512];
-    u32 len;
-
-    len =YSPRINTF(buffer,512,"%s%s:%d",(isInput?"<-":"->"),prefix,iface);
-#if 0
-    while(pos < USB_PKT_SIZE-sizeof(YSTREAM_Head)){
-        YSTREAM_Head *head =(YSTREAM_Head*) (pkt->data+pos);
-        char ty,st;
-        switch(head->pkt){
-        case YPKT_STREAM :
-            ty='S';
-            switch(head->stream){
-            case YSTREAM_EMPTY:
-                st ='e';
-                break;
-            case YSTREAM_TCP:
-                st ='T';
-                break;
-            case YSTREAM_TCP_CLOSE:
-                st ='C';
-                break;
-            case YSTREAM_NOTICE:
-                st ='N';
-                break;
-            case YSTREAM_REPORT:
-                st ='X';
-                break;
-            case YSTREAM_META:
-                st ='M';
-                break;
-            case YSTREAM_REPORT_V2:
-                st ='V';
-                break;
-            case YSTREAM_NOTICE_V2:
-                st ='U';
-                break;
-            default:
-                st='?';
-                break;
-            }
-            break;
-        case YPKT_CONF:
-            ty='C';
-            switch(head->stream){
-            case USB_CONF_RESET:
-                st ='R';
-                break;
-            case USB_CONF_START:
-                st ='S';
-                break;
-            default:
-                st='?';
-                break;
-            }
-            break;
-        default:
-            ty='?';
-            st='!';
-            break;
-        }
-        len += YSPRINTF(buffer+len,512-len," /ty=%c st=%c sz=%d pno=%d",
-           ty ,st,head->size,head->pktno);
-        pos+=sizeof(YSTREAM_Head)+head->size;
-    }
-#endif
-    dbglog("%s\n",buffer);
-
-}
-#endif
-
-void yPktQueueInit(pktQueue *q)
-{
-    memset(q,0,sizeof(pktQueue));
-    q->status = YAPI_SUCCESS;
-    yInitializeCriticalSection(&q->cs);
-    yCreateManualEvent(&q->notEmptyEvent,0);
-    yCreateManualEvent(&q->emptyEvent,0);
-}
-
-void yPktQueueFree(pktQueue *q)
-{
-    pktItem *p,*t;
-
-    p=q->first;
-    while(p){
-        t=p;
-        p=p->next;
-        yFree(t);
-    }
-    yDeleteCriticalSection(&q->cs);
-    yCloseEvent(&q->notEmptyEvent);
-    yCloseEvent(&q->emptyEvent);
-    memset(q,0xca,sizeof(pktQueue));
-}
-
-static YRETCODE  yPktQueuePushEx(pktQueue *q,const USB_Packet *pkt, char * errmsg)
-{
-    pktItem *newpkt;
-    YRETCODE res;
-    yEnterCriticalSection(&q->cs);
-
-    if (q->status != YAPI_SUCCESS) {
-        res = q->status;
-        if(errmsg)
-            YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,q->errmsg);
-        //dbglog("%X:yPktQueuePush drop pkt\n",q);
-    } else {
-        res = YAPI_SUCCESS;
-         // allocate new buffer
-        newpkt= ( pktItem *) yMalloc(sizeof(pktItem));
-        memcpy(&newpkt->pkt,pkt,sizeof(USB_Packet));
-#ifdef DEBUG_PKT_TIMING
-        newpkt->time = yapiGetTickCount();
-        newpkt->ospktno = q->totalPush;
-#endif
-        newpkt->next = NULL;
-        //lock the queue acces
-        if (q->first == NULL) {
-            //empty queue
-            q->first = newpkt;
-            q->last = newpkt;
-            yResetEvent(&q->emptyEvent);
-            //dbglog("%X:yPktQueuePush First pkt\n",q);
-        } else {
-            q->last->next = newpkt;
-            q->last = newpkt;
-            //dbglog("%X:yPktQueuePush a pkt\n",q);
-        }
-        q->count++;
-        q->totalPush++;
-    }
-        ySetEvent(&q->notEmptyEvent);
-        yLeaveCriticalSection(&q->cs);
-    return res;
-}
-
-void  yPktQueueSetError(pktQueue *q, YRETCODE code, const char * msg)
-{
-    //lock the queue access
-    yEnterCriticalSection(&q->cs);
-    //dbglog("PKTSetErr %d:%s\n",code,msg);
-    YSTRCPY(q->errmsg,YOCTO_ERRMSG_LEN,msg);
-    q->status = code;
-    ySetEvent(&q->emptyEvent);
-    ySetEvent(&q->notEmptyEvent);
-    yLeaveCriticalSection(&q->cs);
-}
-
-
-static int yPktQueueIsEmpty(pktQueue *q, char * errmsg)
-{
-    int retval;
-
-    yEnterCriticalSection(&q->cs);
-    retval = q->status;
-    if(retval !=YAPI_SUCCESS){
-        //dbglog("%X:yPktQueuePop error %d:%s\n",q,q->status,q->errmsg);
-        if(errmsg)
-            YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,q->errmsg);
-    }else{
-        if(q->first==NULL)
-            retval=1;
-    }
-    yLeaveCriticalSection(&q->cs);
-    return retval;
-}
-
-static YRETCODE yPktQueuePeek(pktQueue *q, pktItem **pkt, char * errmsg)
-{
-    YRETCODE retval;
-
-    yEnterCriticalSection(&q->cs);
-    retval = q->status;
-    if(retval !=YAPI_SUCCESS){
-        //dbglog("%X:yPktQueuePop error %d:%s\n",q,q->status,q->errmsg);
-        *pkt = NULL;
-        if(errmsg)
-            YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,q->errmsg);
-    }else{
-        *pkt = q->first;
-    }
-    yLeaveCriticalSection(&q->cs);
-    return retval;
-}
-
-
-
-static YRETCODE yPktQueuePop(pktQueue *q, pktItem **pkt, char * errmsg)
-{
-    YRETCODE retval;
-
-    yEnterCriticalSection(&q->cs);
-    retval = q->status;
-    if(retval !=YAPI_SUCCESS){
-        //dbglog("%X:yPktQueuePop error %d:%s\n",q,q->status,q->errmsg);
-        *pkt = NULL;
-        if(errmsg)
-            YSTRCPY(errmsg,YOCTO_ERRMSG_LEN,q->errmsg);
-    }else{
-        *pkt = q->first;
-        if(q->first!=NULL){
-           if(q->first == q->last){
-                q->first=NULL;
-                q->last=NULL;
-                //dbglog("%X:yPktQueuePop last pkt\n",q);
-                yResetEvent(&q->notEmptyEvent);
-                ySetEvent(&q->emptyEvent);
-            }else{
-                //dbglog("%X:yPktQueuePop a pkt\n",q);
-                q->first = q->first->next;
-            }
-            q->count--;
-            q->totalPop++;
-        }
-    }
-    yLeaveCriticalSection(&q->cs);
-    return retval;
-}
-
-
-static void yPktQueueDup(pktQueue *q, int expected_pkt_no, const char *file, int line)
-{
-    int verifcount = 0;
-    pktItem *pkt;
-
-    yEnterCriticalSection(&q->cs);
-    dbglogf(file, line, "PKTs: %dpkts (%lld in / %lld out)\n", q->count, q->totalPush, q->totalPop);
-    dbglogf(file, line, "PKTs: start %x stop =%X\n", q->first, q->last);
-    if (q->status != YAPI_SUCCESS) {
-        dbglogf(file, line, "PKTs: state = %s\n", q->status, q->errmsg);
-    }
-    pkt = q->first;
-    while (pkt != NULL){
-        if (expected_pkt_no != pkt->pkt.first_stream.pktno) {
-            dbglogf(file, line, "PKTs: invalid pkt %d (no=%d should be %d\n", verifcount, pkt->pkt.first_stream.pktno, expected_pkt_no);
-        }
-
-        verifcount++;
-        expected_pkt_no = NEXT_YPKT_NO(expected_pkt_no);
-        pkt = pkt->next;
-    }
-    if (verifcount != q->count) {
-        dbglogf(file, line, "PKTs: invalid pkt count has %d report %d\n", verifcount, q->count);
-    }
-    yLeaveCriticalSection(&q->cs);
-}
-
-
-YRETCODE  yPktQueuePushD2H(yInterfaceSt *iface,const USB_Packet *pkt, char * errmsg)
-{
-#ifdef DUMP_USB_PKT_SHORT
-    dumpPktSummary(iface->serial, iface->ifaceno,1,pkt);
-#endif
-#ifdef DEBUG_MISSING_PACKET
-    {
-        int mustdump = 0;
-        yEnterCriticalSection(&iface->rxQueue.cs);
-        if (pkt->first_stream.pkt != YPKT_CONF) {
-            pktItem *p = iface->rxQueue.last;
-            if (p != NULL && p->pkt.first_stream.pkt == YPKT_CONF) {
-                int pktno = p->pkt.first_stream.pktno + 1;
-                if (pktno > 7)
-                    pktno = 0;
-                if (pkt->first_stream.pktno != pktno) {
-                    dbglog("missing packet on push (need %d received %d)\n", pktno, pkt->first_stream.pktno );
-                    mustdump++;
-                }
-            }
-        }
-        yLeaveCriticalSection(&iface->rxQueue.cs);
-        if (mustdump) {
-            yPktQueueDup(&iface->rxQueue, __FILE_ID__, __LINE__);
-        }
-    }
-#endif
-
-    return yPktQueuePushEx(&iface->rxQueue,pkt,errmsg);
-}
-
-YRETCODE yPktQueueWaitAndPopD2H(yInterfaceSt *iface,pktItem **pkt, int ms, char * errmsg)
-{
-
-    YRETCODE res;
-    *pkt = NULL;
-    res= yPktQueuePop(&iface->rxQueue,pkt,errmsg);
-    if(res != YAPI_SUCCESS || ms == 0){
-        return  res;
-    }
-    if (*pkt == NULL) {
-        yWaitForEvent(&iface->rxQueue.notEmptyEvent, ms);
-        return  yPktQueuePop(&iface->rxQueue,pkt, errmsg);
-    }
-    return res;
-}
-
-
-YRETCODE  yPktQueuePushH2D(yInterfaceSt *iface,const USB_Packet *pkt, char * errmsg)
-{
-    return yPktQueuePushEx(&iface->txQueue,pkt,errmsg);
-}
-
-// return 1 if empty, 0 if not empty, or an error code
-static int yPktQueueWaitEmptyH2D(yInterfaceSt *iface,int ms, char * errmsg)
-{
-    if (ms > 0) {
-        yWaitForEvent(&iface->txQueue.emptyEvent, ms);
-    }
-    return yPktQueueIsEmpty(&iface->txQueue,errmsg);
-}
-
-
-YRETCODE yPktQueuePeekH2D(yInterfaceSt *iface,pktItem **pkt)
-{
-
-#ifdef DUMP_USB_PKT_SHORT
-    pktItem *tmp;
-    YRETCODE res = yPktQueuePeek(&iface->txQueue,&tmp,NULL);
-    if(tmp!=NULL){
-        dumpPktSummary(iface->serial, iface->ifaceno, 0, &tmp->pkt);
-    }
-    *pkt=tmp;
-    return res;
-#else
-    return yPktQueuePeek(&iface->txQueue,pkt,NULL);
-#endif
-}
-
-YRETCODE yPktQueuePopH2D(yInterfaceSt *iface,pktItem **pkt)
-{
-
-#ifdef DUMP_USB_PKT_SHORT
-    pktItem *tmp;
-    YRETCODE res = yPktQueuePop(&iface->txQueue,&tmp,NULL);
-    if(tmp!=NULL){
-        dumpPktSummary(iface->serial, iface->ifaceno,0,&tmp->pkt);
-    }
-    *pkt=tmp;
-    return res;
-#else
-    return yPktQueuePop(&iface->txQueue,pkt,NULL);
-#endif
-}
-
-
-/*****************************************************************************
-  yyPACKET ioFUNCTIONS
-  ***************************************************************************/
-
-
-// this function copy the pkt into the interface out queue and send the packet
-YRETCODE yyySendPacket(yInterfaceSt *iface, const USB_Packet *pkt, char *errmsg)
-{
-    int res;
-    res = yPktQueuePushH2D(iface,pkt,errmsg);
-    if (YISERR(res)) {
-        return (YRETCODE) res;
-    }
-    res = yyySignalOutPkt(iface, errmsg);
-    if (YISERR(res)) {
-        return res;
-    }
-    res = yPktQueueWaitEmptyH2D(iface,5000,errmsg);
-    if (YISERR(res)) {
-        return (YRETCODE) res;
-    }else if(res > 0){
-        return YAPI_SUCCESS;
-    }
-    return YERRMSG(YAPI_TIMEOUT,"Unable to send packet to the device");
-}
-
-static YRETCODE yAckPkt(yInterfaceSt *iface, int pktno, char *errmsg)
-{
-    pktItem qpkt;
-
-    YSTREAM_Head  *yshead = (YSTREAM_Head*)(qpkt.pkt.data);
-    u8 *data = qpkt.pkt.data + sizeof(YSTREAM_Head);
-    yshead->pktno = 0;
-    yshead->pkt = YPKT_STREAM;
-    yshead->stream = YSTREAM_META;
-    yshead->size = 2;
-    data[0] = USB_META_ACK_D2H_PACKET;
-    data[1] = pktno & 0xff;
-    yshead = (YSTREAM_Head*)(qpkt.pkt.data + 2 + sizeof(YSTREAM_Head));
-    yshead->pkt = YPKT_STREAM;
-    yshead->stream = YSTREAM_EMPTY;
-    yshead->size = USB_PKT_SIZE - (2 * sizeof(YSTREAM_Head) + 2);
-    return yyySendPacket(iface, &qpkt.pkt, errmsg);
-}
-
-
-
-
-// wait for the next Configuration packet to come on a particular interface
-// ALL OTHER PACKET OF THIS INTERFACE ARE DROPED
-static int yyWaitOnlyConfPkt(yInterfaceSt *iface, u8 cmdtowait,pktItem **rpkt,u32 s_timeout,char *errmsg)
-{
-    u64 timeout = yapiGetTickCount() + s_timeout * 1000;
-    pktItem *tmp;
-    u32 dropcount = 0;
-    YRETCODE  error;
-
-    *rpkt = NULL;
-    do{
-        error = yPktQueueWaitAndPopD2H(iface, &tmp, 1000, errmsg);
-        if(error!=YAPI_SUCCESS){
-            return error;
-        }
-        if (tmp != NULL){
-            if(tmp->pkt.confpkt.head.pkt == YPKT_CONF && tmp->pkt.confpkt.head.stream == cmdtowait){
-                //conf packet has bee received
-                YASSERT(tmp->pkt.confpkt.head.size >= sizeof(USB_Conf_Pkt));
-                *rpkt=tmp;
-                if(dropcount)
-                    dbglog("drop %d pkt on iface %d\n",dropcount, iface->ifaceno);
-                return YAPI_SUCCESS;
-            }
-#ifdef DEBUG_DUMP_PKT
-            else{
-                dumpAnyPacket("Drop non-config pkt",(u8)iface->ifaceno, &tmp->pkt);
-            }
-#endif
-            dropcount++;
-            yFree(tmp);
-        }
-    } while(timeout> yapiGetTickCount());
-
-    return YERR(YAPI_TIMEOUT);
-}
-
-
-static void yyFormatConfPkt(pktItem *pkt, u8 conftype)
-{
-    pkt->pkt.confpkt.head.pkt    = YPKT_CONF;
-    pkt->pkt.confpkt.head.stream = conftype;
-    pkt->pkt.confpkt.head.size   = USB_PKT_SIZE - sizeof(pkt->pkt.confpkt.head);
-    pkt->pkt.confpkt.head.pktno  = 0;
-}
-
-
-// check protocol version compatibility
-// compatible without limitation -> return 1
-// compatible with limitations -> return 0;
-// incompatible -> return YAPI_IO_ERROR
-static int CheckVersionCompatibility(u16 version,const char *serial, char *errmsg)
-{
-    if ((version & 0xff00) != (YPKT_USB_VERSION_BCD & 0xff00)) {
-        // major version change
-        if ((version & 0xff00) > (YPKT_USB_VERSION_BCD & 0xff00)) {
-            dbglog("Yoctopuce library is too old (using 0x%x, need 0x%x) to handle device %s, please upgrade your Yoctopuce library\n",YPKT_USB_VERSION_BCD,version,serial);
-            return YERRMSG(YAPI_IO_ERROR,"Library is too old to handle this device");
-        } else {
-            // implement backward compatibility when implementing a new protocol
-            YPANIC;
-            return 1;
-        }
-    } else if (version != YPKT_USB_VERSION_BCD) {
-        if (version == YPKT_USB_VERSION_NO_RETRY_BCD && (yContext->detecttype & Y_RESEND_MISSING_PKT) == 0) {
-            // do prompt for firmware update since the Y_RESEND_MISSING_PKT feature is not used
-            return 1;
-        }
-        if (version == YPKT_USB_VERSION_NO_CONFCHG_BCD && YPKT_USB_VERSION_BCD == YPKT_USB_VERSION_NO_CONFCHG_BCD+1)  {
-            // do prompt for firmware update if the device simply has no config change notification
-            return 1;
-        }
-        if (version > YPKT_USB_VERSION_BCD) {
-            dbglog("Device %s is using a newer protocol, consider upgrading your Yoctopuce library\n",serial);
-        } else {
-            dbglog("Device %s is using an older protocol, consider upgrading the device firmware\n",serial);
-        }
-        return 0;
-    }
-    return 1;
-}
-
-
-static int ySendStart(yPrivDeviceSt *dev,char *errmsg)
-{
-    int nextiface;
-    pktItem  qpkt,*rpkt;
-
-    yyFormatConfPkt(&qpkt,USB_CONF_START);
-    if (yContext->detecttype & Y_RESEND_MISSING_PKT && dev->iface.pkt_version >= YPKT_USB_VERSION_BCD) {
-        dev->pktAckDelay = Y_DEFAULT_PKT_RESEND_DELAY;
-    } else{
-        dev->pktAckDelay = 0;
-    }
-    qpkt.pkt.confpkt.conf.start.nbifaces = 1;
-    qpkt.pkt.confpkt.conf.start.ack_delay = dev->pktAckDelay;
-    YPROPERR(yyySendPacket(&dev->iface, &qpkt.pkt, errmsg));
-    YPROPERR(yyWaitOnlyConfPkt(&dev->iface, USB_CONF_START, &rpkt, 5, errmsg));
-    nextiface = rpkt->pkt.confpkt.conf.start.nbifaces;
-    if (dev->pktAckDelay) {
-        // update ack delay with the one from the device (in case device does not implement pkt ack)
-        dev->pktAckDelay = rpkt->pkt.confpkt.conf.start.ack_delay;
-        dbglog("Activate USB pkt ack (%dms)\n", dev->pktAckDelay);
-    }
-    dev->lastpktno = rpkt->pkt.first_stream.pktno;
-    yFree(rpkt);
-    if(nextiface!=0 ){
-        return YERRMSG(YAPI_VERSION_MISMATCH,"Device has not been started correctly");
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int yPacketSetup(yPrivDeviceSt *dev,char *errmsg)
-{
-    pktItem qpkt, *rpkt = NULL;
-    int res;
-
-    YPROPERR(yyySetup(&dev->iface, errmsg));
-
-    //first try to send a connection reset
-    yyFormatConfPkt(&qpkt, USB_CONF_RESET);
-    qpkt.pkt.confpkt.conf.reset.ok = 1;
-    TO_SAFE_U16(qpkt.pkt.confpkt.conf.reset.api, YPKT_USB_VERSION_BCD);
-    YPROPERR(yyySendPacket(&dev->iface, &qpkt.pkt, errmsg));
-
-    if (YISERR(yyWaitOnlyConfPkt(&dev->iface, USB_CONF_RESET, &rpkt, 5, errmsg)) || rpkt == NULL) {
-        res = YERRMSG(YAPI_VERSION_MISMATCH, "Device does not respond to reset");
-        goto error;
-    }
-    FROM_SAFE_U16(rpkt->pkt.confpkt.conf.reset.api, dev->iface.pkt_version);
-    if (CheckVersionCompatibility(dev->iface.pkt_version, dev->iface.serial, errmsg)<0) {
-        res = YAPI_VERSION_MISMATCH;
-        goto error;
-    }
-    YASSERT(rpkt->pkt.confpkt.conf.reset.ifaceno < NBMAX_INTERFACE_PER_DEV);
-    if (rpkt->pkt.confpkt.conf.reset.nbifaces != 1) {
-        res = YERRMSG(YAPI_VERSION_MISMATCH, "Multiples USB interface are no more supported");
-        goto error;
-    }
-    dev->iface.ifaceno = 0;
-    yFree(rpkt);
-    rpkt = NULL;
-
-    if(!YISERR(res=ySendStart(dev,errmsg))){
-        return YAPI_SUCCESS;
-     }
-error:
-    if (rpkt) {
-        yFree(rpkt);
-    }
-    //shutdown all previously started interfaces;
-    dbglog("Closing partially opened device %s\n",dev->infos.serial);
-    yyyPacketShutdown(&dev->iface);
-    return res;
-}
-
-// Trigger a non blocking read
-static int yGetNextPktEx(yPrivDeviceSt *dev, pktItem **pkt_out, u64 blockUntilTime, char *errmsg)
-{
-    int             dropcount=0;
-    u8              nextpktno;
-    YRETCODE        res;
-    pktItem         *item;
-    u64             wait;
-    u64             now;
-     yInterfaceSt   *iface;
-
-    *pkt_out = NULL;
-    iface = &dev->iface;
-again:
-    now = yapiGetTickCount();
-    if (blockUntilTime > now)
-        wait = blockUntilTime - now;
-    else
-        wait = 0;
-
-
-
-    // ptr is set to null by yPktQueueWaitAndPop
-    res = yPktQueueWaitAndPopD2H(iface, &item, (int)wait, errmsg);
-    if (YISERR(res))
-        return res;
-    nextpktno = NEXT_YPKT_NO(dev->lastpktno);
-    if (item != NULL) {
-        if (dev->pktAckDelay > 0) {
-            res = yAckPkt(iface, item->pkt.first_stream.pktno, errmsg);
-            if (YISERR(res)){
-                yFree(item);
-                return res;
-            }
-        }
-        // verfiy the packet
-        if (item->pkt.first_stream.pkt == YPKT_CONF) {
-#ifdef DEBUG_DUMP_PKT
-            dumpAnyPacket("Drop Late config pkt",iface->ifaceno,&item->pkt);
-#endif
-            yFree(item);
-            dropcount++;
-            if(dropcount >10){
-                dbglog("Too many packets dropped, disable %s\n",dev->infos.serial);
-                return YERRMSG(YAPI_IO_ERROR,"Too many packets dropped");
-            }
-            goto again;
-        }
-        if (item->pkt.first_stream.pktno == dev->lastpktno) {
-            //late retry : drop it since we already have the packet.
-            yFree(item);
-            goto again;
-        }
-
-        if(item->pkt.first_stream.pktno == nextpktno){
-            *pkt_out = item;
-            dev->lastpktno = nextpktno;
-#ifdef DEBUG_DUMP_PKT
-            dumpAnyPacket("POP Pkt",iface->ifaceno,&item->pkt);
-#endif
-            return YAPI_SUCCESS;
-        } else {
-            yPktQueueDup(&iface->rxQueue, nextpktno, __FILE_ID__, __LINE__);
-            yFree(item);
-            return YERRMSG(YAPI_IO_ERROR, "Missing Packet");
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-/*****************************************************************
- * yStream API with cycling logic of the inside of the packet
-*****************************************************************/
-static int yStreamGetTxBuff(yPrivDeviceSt *dev, u8 **data, u8 *maxsize);
-static int yStreamTransmit(yPrivDeviceSt *dev, u8 proto, u8 size, char *errmsg);
-static int yStreamFlush(yPrivDeviceSt *dev, char *errmsg);
-
-static int yStreamSetup(yPrivDeviceSt *dev,char *errmsg)
-{
-    u32 currUtcTime;
-    YPROPERR(yPacketSetup(dev,errmsg));
-    // now we have all setup packet sent and received
-    dev->currxpkt=NULL;
-    dev->curxofs=0xff;
-    dev->curtxpkt = &dev->tmptxpkt;
-    dev->tmptxpkt.next=NULL;
-    dev->curtxofs=0;
-    dev->devYdxMap=NULL;
-    dev->lastUtcUpdate=0;
-    // send UTC time to the device
-    currUtcTime = (u32)time(NULL);
-    if (currUtcTime > (u32)0x51f151f1){ // timestamp appears to be valid
-        u8  *pktdata;
-        u8  maxpktlen;
-        // send updated UTC timestamp to keep datalogger on time
-        if (yStreamGetTxBuff(dev, &pktdata, &maxpktlen) && maxpktlen >= 5) {
-            dev->lastUtcUpdate = currUtcTime;
-            pktdata[0] = USB_META_UTCTIME;
-            pktdata[1] = currUtcTime & 0xff;
-            pktdata[2] = (currUtcTime >> 8) & 0xff;
-            pktdata[3] = (currUtcTime >> 16) & 0xff;
-            pktdata[4] = (currUtcTime >> 24) & 0xff;
-            YPROPERR(yStreamTransmit(dev, YSTREAM_META, 5, errmsg));
-            YPROPERR(yStreamFlush(dev, errmsg));
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static int yStreamReceived(yPrivDeviceSt *dev, u8 *stream, u8 **data, u8 *size, u64 blockUntilTime, char *errmsg)
-{
-    YSTREAM_Head  *yshead;
-    int res;
-
-    //check if we have processed the full usb packet
-    if (dev->curxofs >= USB_PKT_SIZE - sizeof(YSTREAM_Head)) {
-        // look if we have the next packet on a interface
-        if (dev->currxpkt) {
-            yFree(dev->currxpkt);
-            dev->currxpkt=NULL;
-        }
-        res = yGetNextPktEx(dev, &dev->currxpkt, blockUntilTime, errmsg);
-        YPROPERR(res);
-        if (dev->currxpkt != NULL) {
-            dev->curxofs=0;
-        } else {
-            // no pkt avail
-            return 0;
-        }
-    }
-
-    yshead= (YSTREAM_Head*) &dev->currxpkt->pkt.data[dev->curxofs];
-    YASSERT(dev->curxofs + sizeof(YSTREAM_Head) + yshead->size <= USB_PKT_SIZE);
-    *stream = yshead->stream;
-    *size = yshead->size;
-    *data = &dev->currxpkt->pkt.data[ dev->curxofs + sizeof(YSTREAM_Head) ];
-
-    return 1;
-}
-
-static int yStreamReceptionDone(yPrivDeviceSt *dev,char *errmsg)
-{
-    YSTREAM_Head * yshead= (YSTREAM_Head*) &dev->currxpkt->pkt.data[dev->curxofs];
-    dev->curxofs += sizeof(YSTREAM_Head) + yshead->size;
-    return YAPI_SUCCESS;
-}
-// return 0 when no more buff is available
-static int yStreamGetTxBuff(yPrivDeviceSt *dev, u8 **data, u8 *maxsize)
-{
-    u8  avail;
-    avail = USB_PKT_SIZE - dev->curtxofs;
-    if(avail <= sizeof(YSTREAM_Head)){
-        //we may want to allocate an new buffer
-        return 0;
-    }
-
-    *maxsize = avail - sizeof(YSTREAM_Head);
-    *data = &dev->curtxpkt->pkt.data[dev->curtxofs+sizeof(YSTREAM_Head)];
-    return 1;
-}
-
-static int yStreamFlush(yPrivDeviceSt *dev,char *errmsg)
-{
-    u8 avail;
-
-    if(dev->curtxofs==0){
-        return YAPI_SUCCESS;
-    }
-
-    avail = USB_PKT_SIZE - dev->curtxofs;
-
-    if(avail >=sizeof(YSTREAM_Head) ){
-        YSTREAM_Head  *yshead = (YSTREAM_Head*) (dev->curtxpkt->pkt.data + dev->curtxofs);
-        yshead->pkt    = YPKT_STREAM;
-        yshead->stream = YSTREAM_EMPTY;
-        yshead->size   = avail - sizeof(YSTREAM_Head);
-        dev->curtxofs  += sizeof(YSTREAM_Head)+yshead->size;
-    }
-    YPROPERR( yyySendPacket(&dev->iface,&dev->curtxpkt->pkt, errmsg));
-    dev->curtxofs =0;
-    return YAPI_SUCCESS;
-}
-
-
-static int yStreamTransmit(yPrivDeviceSt *dev, u8 proto,u8 size,char *errmsg)
-{
-    //dbglog("yPacketTransmit\n");
-
-    YSTREAM_Head  *yshead;
-    yshead = (YSTREAM_Head*) dev->curtxpkt->pkt.data + dev->curtxofs ;
-    yshead->pktno   =0;
-    yshead->pkt     = YPKT_STREAM;
-    yshead->stream  = proto;
-    yshead->size    = size;
-    if(!(dev->curtxofs  + sizeof(YSTREAM_Head) + size <=USB_PKT_SIZE)){
-        dbglog("Buffer overrun detected on (%s)\n",dev->infos.serial);
-        dbglog("unable to append data proto=%d (%d + %d + %d <= %d) (%s)\n",
-                proto,dev->curtxofs,sizeof(YSTREAM_Head),size,USB_PKT_SIZE);
-        //dumpAnyPacket("ystream buffer",0,&dev->curtxpkt->pkt);
-        return YERRMSG(YAPI_IO_ERROR,"buffer overrun");
-    }
-    dev->curtxofs += sizeof(YSTREAM_Head)+size;
-    if( dev->curtxofs >= USB_PKT_SIZE-sizeof(YSTREAM_Head))
-        return yStreamFlush(dev,errmsg);
-    return YAPI_SUCCESS;
-}
-
-
-static void yStreamShutdown(yPrivDeviceSt *dev)
-{
-    if(dev->devYdxMap) {
-        yFree(dev->devYdxMap);
-        dev->devYdxMap = NULL;
-    }
-    yyyPacketShutdown(&dev->iface);
-}
-
-
-// Notification packet dispatcher
-//
-static void yDispatchNotice(yPrivDeviceSt *dev, USB_Notify_Pkt *notify, int pktsize, int isV2)
-{
-    yPrivDeviceSt *notDev;
-    u16 vendorid,deviceid;
-
-    if(isV2 || notify->firstByte <= NOTIFY_1STBYTE_MAXTINY || notify->firstByte >= NOTIFY_1STBYTE_MINSMALL) {
-        // Tiny or small pubval notification:
-        // create a new null-terminated small notification that we can use and forward
-        char buff[sizeof(Notification_small)+YOCTO_PUBVAL_SIZE+2];
-        Notification_small *smallnot = (Notification_small *)buff;
-        memset(smallnot->pubval,0,YOCTO_PUBVAL_SIZE+2);
-
-        if (notify->smallpubvalnot.funInfo.v2.isSmall == 0) {
-            // convert tiny notification to samll notification
-            memcpy(smallnot->pubval, notify->tinypubvalnot.pubval,pktsize - sizeof(Notification_tiny));
-            smallnot->funInfo.v2.funydx = notify->tinypubvalnot.funInfo.v2.funydx;
-            smallnot->funInfo.v2.typeV2 = notify->tinypubvalnot.funInfo.v2.typeV2;
-            smallnot->funInfo.v2.isSmall = 1;
-            smallnot->devydx = wpGetDevYdx(yHashPutStr(dev->infos.serial));
-        } else {
-#ifndef __BORLANDC__
-            YASSERT(0);
-#endif
-            // Assert added on 2015-02-25, remove code below when confirmed dead code
-            memcpy(smallnot->pubval,notify->smallpubvalnot.pubval,pktsize - sizeof(Notification_small));
-            smallnot->funInfo.raw = notify->smallpubvalnot.funInfo.raw;
-            if(dev->devYdxMap) {
-                smallnot->devydx = dev->devYdxMap[notify->smallpubvalnot.devydx];
-            } else {
-                smallnot->devydx = 255;
-            }
-        }
-#ifdef DEBUG_NOTIFICATION
-        if(smallnot->funInfo.v2.typeV2 == NOTIFY_V2_LEGACY) {
-            dbglog("notifysmall %d %d %s\n",smallnot->devydx,smallnot->funInfo.v2.funydx,smallnot->pubval);
-        } else {
-            u8 *tmpbuff = (u8 *)smallnot->pubval;
-            dbglog("notifysmall %d %d %d:%02x.%02x.%02x.%02x.%02x.%02x\n",smallnot->devydx,smallnot->funInfo.v2.funydx,smallnot->funInfo.v2.typeV2,
-                   tmpbuff[0],tmpbuff[1],tmpbuff[2],tmpbuff[3],tmpbuff[4],tmpbuff[5]);
-        }
-#endif
-        if (smallnot->devydx < 255 && smallnot->funInfo.v2.typeV2 != NOTIFY_V2_FLUSHGROUP) {
-            ypUpdateYdx(smallnot->devydx, smallnot->funInfo, smallnot->pubval);
-            if(yContext->rawNotificationCb){
-                yContext->rawNotificationCb((USB_Notify_Pkt *)smallnot);
-            }
-        }
-        return;
-    }
-
-    notDev=findDev(notify->head.serial,FIND_FROM_SERIAL);
-    if(notDev==NULL){
-        dbglog("drop Notification %d for %s received (device missing)\n", notify->head.type,notify->head.serial);
-        return;
-    }
-
-#ifdef DEBUG_NOTIFICATION
-    dbglog("Notification %d received\n", notify->head.type);
-#endif
-    switch(notify->head.type){
-    case NOTIFY_PKT_NAME:
-        YSTRCPY(notDev->infos.logicalname,YOCTO_LOGICAL_LEN,notify->namenot.name);
-#ifdef DEBUG_NOTIFICATION
-        dbglog("new name is \"%s\"\n", notify->namenot.name);
-#endif
-        notDev->infos.beacon=notify->namenot.beacon;
-#ifdef DEBUG_NOTIFICATION
-        dbglog("new beacon %x\n",notify->namenot.beacon);
-#endif
-        {
-            yStrRef serialref = yHashPutStr(notify->head.serial);
-            yStrRef lnameref = yHashPutStr(notify->namenot.name);
-            wpSafeUpdate(NULL, MAX_YDX_PER_HUB,serialref,lnameref,yHashUrlUSB(serialref),notify->namenot.beacon);
-            if(yContext->rawNotificationCb){
-                yContext->rawNotificationCb(notify);
-            }
-        }
-        break;
-    case NOTIFY_PKT_PRODNAME:
-        YSTRCPY(notDev->infos.productname,YOCTO_PRODUCTNAME_LEN,notify->productname);
-#ifdef DEBUG_NOTIFICATION
-        dbglog("Product name update %s\n",notify->productname);
-#endif
-        break;
-    case NOTIFY_PKT_CHILD:
-#ifdef DEBUG_NOTIFICATION
-        dbglog("child update %s %d %u\n",notify->childserial.childserial,notify->childserial.onoff,notify->childserial.devydx);
-#endif
-        if(notDev == dev) {
-            // build devYdx mapping for immediate child hubs
-            if(dev->devYdxMap == NULL) {
-                dev->devYdxMap = (u8*) yMalloc(ALLOC_YDX_PER_HUB);
-                memset(dev->devYdxMap, 255, ALLOC_YDX_PER_HUB);
-            }
-            dev->devYdxMap[notify->childserial.devydx] = wpGetDevYdx(yHashPutStr(notify->childserial.childserial));
-        }
-        break;
-    case NOTIFY_PKT_FIRMWARE:
-#ifdef DEBUG_NOTIFICATION
-        dbglog("notify firmware %s\n",notify->firmwarenot.firmware);
-#endif
-        YSTRCPY(notDev->infos.firmware,YOCTO_FIRMWARE_LEN,notify->firmwarenot.firmware);
-        FROM_SAFE_U16(notify->firmwarenot.deviceid,deviceid);
-        FROM_SAFE_U16(notify->firmwarenot.vendorid,vendorid);
-        YASSERT(notDev->infos.deviceid == deviceid);
-        YASSERT(notDev->infos.vendorid == vendorid);
-        break;
-    case NOTIFY_PKT_FUNCNAME:
-        notify->funcnameydxnot.funydx = -1;
-        // common code below
-    case NOTIFY_PKT_FUNCNAMEYDX:
-        if(notify->funcnameydxnot.funclass >= YOCTO_N_BASECLASSES) {
-            // Unknown subclass, use YFunction instead
-            notify->funcnameydxnot.funclass = YOCTO_AKA_YFUNCTION;
-        }
-#ifdef DEBUG_NOTIFICATION
-        if(notify->funcnameydxnot.funydx >= 0) {
-            dbglog("notify functnameydx %s %s %d %d\n",notify->funcnamenot.funcid, notify->funcnamenot.funcname,
-                   notify->funcnameydxnot.funydx, notify->funcnameydxnot.funclass);
-        } else {
-            dbglog("notify functname %s %s\n",notify->funcnamenot.funcid, notify->funcnamenot.funcname);
-        }
-#endif
-        ypUpdateUSB(notDev->infos.serial, notify->funcnamenot.funcid, notify->funcnamenot.funcname, notify->funcnameydxnot.funclass, notify->funcnameydxnot.funydx, NULL);
-        if(yContext->rawNotificationCb){
-            yContext->rawNotificationCb(notify);
-        }
-        break;
-    case NOTIFY_PKT_FUNCVAL:
-        {
-            char buff[YOCTO_PUBVAL_SIZE+2];
-            memset(buff,0,YOCTO_PUBVAL_SIZE+2);
-            memcpy(buff,notify->pubvalnot.pubval,YOCTO_PUBVAL_SIZE);
-#ifdef DEBUG_NOTIFICATION
-            dbglog("notify funcval %s %s\n",notify->pubvalnot.funcid, buff);
-#endif
-            ypUpdateUSB(notDev->infos.serial,notify->pubvalnot.funcid,NULL,-1,-1,buff);
-            if(yContext->rawNotificationCb){
-                yContext->rawNotificationCb(notify);
-            }
-        }
-        break;
-    case NOTIFY_PKT_STREAMREADY:
-#ifdef DEBUG_NOTIFICATION
-        dbglog("notify steam ready (%x)\n",notify->raw);
-#endif
-        notDev->rstatus = YRUN_AVAIL;
-        break;
-    case NOTIFY_PKT_LOG:
-        {
-            if (!strncmp(notify->head.serial, dev->infos.serial, YOCTO_SERIAL_LEN)) {
-                yStrRef serialref = yHashPutStr(notify->head.serial);
-                int devydx = wpGetDevYdx(serialref);
-                if (devydx >=0 ) {
-                    yEnterCriticalSection(&yContext->generic_cs);
-                    if (yContext->generic_infos[devydx].flags & DEVGEN_LOG_ACTIVATED) {
-                        yContext->generic_infos[devydx].flags |= DEVGEN_LOG_PENDING;
-#ifdef DEBUG_NOTIFICATION
-                        dbglog("notify device log for %s\n",dev->infos.serial);
-#endif
-                    }
-#ifdef DEBUG_NOTIFICATION
-                    else {
-                        dbglog("notify device log for %s dropped\n",dev->infos.serial);
-                    }
-#endif
-                    yLeaveCriticalSection(&yContext->generic_cs);
-                }
-
-            }
-            if(yContext->rawNotificationCb){
-                yContext->rawNotificationCb(notify);
-            }
-        }
-        break;
-    case NOTIFY_PKT_CONFCHANGE:
-        {
-            if (!strncmp(notify->head.serial, dev->infos.serial, YOCTO_SERIAL_LEN)) {
-                yStrRef serialref = yHashPutStr(notify->head.serial);
-                // Forward high-level device config change notification to API user
-                if(yContext->confChangeCallback){
-                    yEnterCriticalSection(&yContext->deviceCallbackCS);
-#ifdef DEBUG_NOTIFICATION
-                    dbglog("notify conf change for %s\n",dev->infos.serial);
-#endif
-                    yContext->confChangeCallback(serialref);
-                    yLeaveCriticalSection(&yContext->deviceCallbackCS);
-                }
-            }
-            if(yContext->rawNotificationCb){
-                yContext->rawNotificationCb(notify);
-            }
-        }
-        break;
-    default:
-        break;
-    }
-}
-
-// Timed report packet dispatcher
-//
-static void yDispatchReportV1(yPrivDeviceSt *dev, u8 *data, int pktsize)
-{
-    yStrRef serialref = yHashPutStr(dev->infos.serial);
-#ifdef DEBUG_NOTIFICATION
-    {
-        USB_Report_Pkt_V1 *report = (USB_Report_Pkt_V1*)data;
-        dbglog("timed report (V1) for %d %d\n", wpGetDevYdx(serialref), report->funYdx);
-    }
-#endif
-    if(yContext->rawReportCb) {
-        yContext->rawReportCb(serialref, (USB_Report_Pkt_V1*) data, pktsize);
-    }
-    if (yContext->timedReportCallback) {
-        int  devydx = wpGetDevYdx(serialref);
-        if (devydx < 0)
-            return;
-        while (pktsize > 0) {
-            USB_Report_Pkt_V1 *report = (USB_Report_Pkt_V1*) data;
-            int  len = report->extraLen + 1;
-            if (report->funYdx == 0xf) {
-                u64 t = data[1] + 0x100u * data[2] + 0x10000u * data[3] + 0x1000000u * data[4];
-                yEnterCriticalSection(&yContext->generic_cs);
-                yContext->generic_infos[devydx].lastTimeRef = t * 1000 + data[5];
-                yLeaveCriticalSection(&yContext->generic_cs);
-            } else {
-                YAPI_FUNCTION fundesc;
-                u64 devtime;
-                Notification_funydx funInfo;
-                funInfo.raw = report->funYdx;
-                ypRegisterByYdx(devydx, funInfo, NULL, &fundesc);
-                data[0] = report->isAvg ? 1 : 0;
-                yEnterCriticalSection(&yContext->generic_cs);
-                devtime = yContext->generic_infos[devydx].lastTimeRef;
-                yLeaveCriticalSection(&yContext->generic_cs);
-                yFunctionTimedUpdate(fundesc, devtime, 0, data, len + 1);
-            }
-            pktsize -= 1 + len;
-            data += 1 + len;
-        }
-    }
-}
-
-// Timed report packet dispatcher
-//
-static void yDispatchReportV2(yPrivDeviceSt *dev, u8 *data, int pktsize)
-{
-    yStrRef serialref = yHashPutStr(dev->infos.serial);
-#ifdef DEBUG_NOTIFICATION
-    {
-        USB_Report_Pkt_V2 *report = (USB_Report_Pkt_V2*)data;
-        dbglog("timed report (V2) for %d %d\n", wpGetDevYdx(serialref), report->funYdx);
-    }
-#endif
-    if(yContext->rawReportV2Cb) {
-        yContext->rawReportV2Cb(serialref, (USB_Report_Pkt_V2*) data, pktsize);
-    }
-    if (yContext->timedReportCallback) {
-        int devydx = wpGetDevYdx(serialref);
-        if (devydx < 0)
-            return;
-        while (pktsize > 0) {
-            USB_Report_Pkt_V2 *report = (USB_Report_Pkt_V2*) data;
-            int  len = report->extraLen + 1;
-            if (report->funYdx == 0xf) {
-                u64 t = data[1] + 0x100u * data[2] + 0x10000u * data[3] + 0x1000000u * data[4];
-                u32 ms = data[5] << 2;
-                u64 freq = 0;
-                if (len >= 7) {
-                    ms += data[6] >>6;
-                    freq = data[7];
-                    freq += (data[6] & 0xf) * 0x100;
-                    if (data[6] & 0x10) {
-                        freq *= 1000;
-                    }
-                }
-                yEnterCriticalSection(&yContext->generic_cs);
-                yContext->generic_infos[devydx].lastTimeRef = t * 1000 + ms;
-                yContext->generic_infos[devydx].lastFreq = freq;
-                yLeaveCriticalSection(&yContext->generic_cs);
-            } else {
-                YAPI_FUNCTION fundesc;
-                u64 devtime;
-                u64 freq;
-                Notification_funydx funInfo;
-                funInfo.raw = report->funYdx;
-                ypRegisterByYdx(devydx, funInfo, NULL, &fundesc);
-                data[0] = 2;
-                yEnterCriticalSection(&yContext->generic_cs);
-                devtime = yContext->generic_infos[devydx].lastTimeRef;
-                freq = yContext->generic_infos[devydx].lastFreq;
-                yLeaveCriticalSection(&yContext->generic_cs);
-                yFunctionTimedUpdate(fundesc, devtime, freq, data, len + 1);
-            }
-            pktsize -= 1 + len;
-            data += 1 + len;
-        }
-    }
-}
-
-// blockUntilTime:
-//    0 -> only check pending (non blocking)
-//    >0 -> wait until yapiGetTickCount is >= blockUntilTime
-static int yDispatchReceive(yPrivDeviceSt *dev, u64 blockUntilTime, char *errmsg)
-{
-    u8 stream;
-    u8 size;
-    u8 *data;
-#ifdef DEBUG_USB_TRAFIC
-    char dump[64];
-#endif
-    int pktavail;
-
-    pktavail = yStreamReceived(dev, &stream, &data, &size, blockUntilTime,errmsg);
-    YPROPERR(pktavail);
-    while (pktavail && yFifoGetFree(&dev->http_fifo) > size) {
-        switch (stream) {
-            case YSTREAM_TCP_CLOSE:
-#ifdef DEBUG_USB_TRAFIC
-                dbglog("YSTREAM : TCP_CLOSE %d (%d:%d)\n",size,dev->pendingIO.hdl,dev->httpstate);
-                memcpy(dump,data,size);
-                dump[size]=0;
-                dbglog("---------------------------\n");
-                dbglog("%s\n",dump);
-                dbglog("---------------------------\n");
-#endif
-                if(dev->httpstate == YHTTP_OPENED || dev->httpstate == YHTTP_INREQUEST) {
-                    //handle new received packet
-                    if(size != yPushFifo(&dev->http_fifo, data, size)){
-                        return YERRMSG(YAPI_IO_ERROR,"FIFO overrun");
-                    }
-                    dev->httpstate = YHTTP_CLOSE_BY_DEV;
-                } else if(dev->httpstate == YHTTP_CLOSE_BY_API) {
-                    dev->httpstate = YHTTP_CLOSED;
-                }
-                break;
-            case YSTREAM_TCP:
-#ifdef DEBUG_USB_TRAFIC
-                dbglog("YSTREAM : TCP %d (%d:%d)\n",size,dev->pendingIO.hdl,dev->httpstate);
-                memcpy(dump,data,size);
-                dump[size]='\0';
-                dbglog("---------------------------\n");
-                dbglog("%s\n",dump);
-                dbglog("---------------------------\n");
-#endif
-                if (dev->httpstate == YHTTP_OPENED || dev->httpstate == YHTTP_INREQUEST) {
-                    //handle new received packet
-                    if(size!=yPushFifo(&dev->http_fifo, data, size)){
-                        return YERRMSG(YAPI_IO_ERROR,"FIFO overrun");
-                    }
-                }
-                break;
-            case YSTREAM_NOTICE:
-                yDispatchNotice(dev, (USB_Notify_Pkt*)data, size, 0);
-                break;
-            case YSTREAM_NOTICE_V2:
-                yDispatchNotice(dev, (USB_Notify_Pkt*)data, size, 1);
-                break;
-            case YSTREAM_REPORT:
-                yDispatchReportV1(dev, data, size);
-                break;
-            case YSTREAM_REPORT_V2:
-                yDispatchReportV2(dev, data, size);
-                break;
-            case YSTREAM_EMPTY:
-            default:
-                //packet droped
-                break;
-        }
-        //listen again
-        YPROPERR(yStreamReceptionDone(dev,errmsg));
-        // do not block on second attempt
-        pktavail=yStreamReceived(dev,&stream, &data, &size, 0, errmsg);
-        YPROPERR(pktavail);
-    }
-    return YAPI_SUCCESS;
-}
-
-
-
-
-
-/*****************************************************************************
-  ENUMERATION RELATED FUNCTION
-  ***************************************************************************/
-#ifdef DEBUG_DEV_ENUM
-const char *YDEV_STATUS_TXT[] =
-{
-    "YDEV_UNPLUGED",              // device has been plugged by the past but is no more
-                                  // -> YDEV_ARRIVAL
-    "YDEV_WORKING",               // device is plugged and running
-                                  // -> YDEV_UNPLUGED, YDEV_ALREADY_THERE
-    "YDEV_NOTRESPONDING"          // device has not answered to StartDevice and we will never try to speak with it
-                                  // -> none
-} ;
-#endif
-
-static void enuResetDStatus(void)
-{
-
-    yPrivDeviceSt *p=yContext->devs;
-
-    while(p){
-#ifdef DEBUG_DEV_ENUM_VERBOSE
-        dbglog("Initial State of %s is %s\n",p->infos.serial,YDEV_STATUS_TXT[p->dStatus]);
-#endif
-        if( p->dStatus== YDEV_WORKING){
-            p->enumAction=YENU_STOP;
-        }else{
-            p->enumAction=YENU_NONE;
-        }
-        p=p->next;
-    }
-}
-
-
-static yPrivDeviceSt* enuFindDevSlot(yInterfaceSt *iface)
-{
-    yPrivDeviceSt  *p;
-
-    for(p=yContext->devs ; p ; p=p->next ){
-        if(p->infos.vendorid == iface->vendorid && p->infos.deviceid == iface->deviceid
-            && strncmp(p->infos.serial,iface->serial,YOCTO_SERIAL_LEN)==0){
-            return p;
-        }
-    }
-    return NULL;
-}
-
-//allocate a  new device structure
-static yPrivDeviceSt* AllocateDevice(void)
-{
-    yPrivDeviceSt *dev;
-    dev  = (yPrivDeviceSt*) yMalloc(sizeof(yPrivDeviceSt));
-    yMemset(dev,0,sizeof(yPrivDeviceSt));
-    dev->http_raw_buf =  (u8*) yMalloc(HTTP_RAW_BUFF_SIZE);
-    yFifoInit(&dev->http_fifo, dev->http_raw_buf, HTTP_RAW_BUFF_SIZE);
-    devInitAccces(PUSH_LOCATION dev);
-    return dev;
-}
-
-static void FreeDevice(yPrivDeviceSt *dev)
-{
-    devDeleteAccces(PUSH_LOCATION dev);
-    yFree(dev->http_raw_buf);
-    yFifoCleanup(&dev->http_fifo);
-    yFree(dev);
-}
-
-
-
-// Start an interface
-static int StartDevice(yPrivDeviceSt *dev, char *errmsg)
-{
-    unsigned delay = 10;
-    int nb_try;
-    int res = YERRMSG(YAPI_IO_ERROR, "Negotiation failed");
-
-    for (nb_try = 0; nb_try < 4; nb_try++, delay *= 4, dbglog("retrying StartDevice (%s)\n", errmsg)) {
-        u64 timeout;
-        int res = yStreamSetup(dev, errmsg);
-        if (YISERR(res)) {
-            continue;
-        }
-        timeout = yapiGetTickCount() + 10000;
-        do {
-            res = yDispatchReceive(dev, timeout, errmsg);
-            if (dev->iface.pkt_version == YPKT_VERSION_ORIGINAL_RELEASE && !dev->infos.productname[0]) {
-                dev->rstatus = YRUN_AVAIL;
-            }
-            if (yapiGetTickCount() >= timeout) {
-                yStreamShutdown(dev);
-                return YERRMSG(YAPI_TIMEOUT, "Negotiation failed (device did not respond for 10 secs");
-            }
-        } while (res == YAPI_SUCCESS && dev->rstatus != YRUN_AVAIL);
-        if (res == YAPI_SUCCESS && dev->rstatus == YRUN_AVAIL) {
-            return YAPI_SUCCESS;
-        }
-        yStreamShutdown(dev);
-    }
-    return res;
-}
-
-
-static int StopDevice(yPrivDeviceSt *dev,char *errmsg)
-
-{
-    dev->rstatus=YRUN_STOPED;
-    yStreamShutdown(dev);
-    return YAPI_SUCCESS;
-}
-
-//thread safe because only modified only by yDetectDevices which is not reentrant
-static void enuUpdateDStatus(void)
-{
-    yPrivDeviceSt *p=yContext->devs;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    int res, updateWP;
-    yStrRef lnameref, prodref;
-    yUrlRef usb;
-    u8 beacon;
-    u16 deviceid;
-
-    while(p){
-        yStrRef serialref = yHashPutStr(p->infos.serial);
-        switch(p->enumAction){
-        case YENU_STOP:
-            devStartEnum(p);
-#ifdef DEBUG_DEV_ENUM
-            dbglog("ENU:stop %s(%d)->YDEV_UNPLUGED\n",p->infos.serial,p->infos.nbinbterfaces);
-#endif
-            p->dStatus = YDEV_UNPLUGGED;
-            if(YISERR(StopDevice(p,errmsg))){
-                dbglog("Unable to stop the device %s correctly:(%s)\n",p->infos.serial,errmsg);
-            }
-            dbglog("Device %s unplugged\n",p->infos.serial);
-            devStopEnum(p);
-            wpSafeUnregister(serialref);
-            break;
-
-        case YENU_RESTART:
-            devStartEnum(p);
-            if(YISERR(StopDevice(p,errmsg))){
-                dbglog("Unable to stop the device %s correctly:(%s)\n",p->infos.serial,errmsg);
-            }
-            p->dStatus = YDEV_WORKING; //we need to put the device in working to start device (safe because we already have the mutex)
-            res = StartDevice(p, errmsg);
-            if(YISERR(res)){
-                // we are unable to restart the device -> unplug it and follow the traditional process (white page update etc...)
-#ifdef DEBUG_DEV_ENUM
-                dbglog("ENU:Restart %s(%d)->YDEV_UNPLUGED (restart failed)\n",p->infos.serial,p->infos.nbinbterfaces);
-#endif
-
-                p->dStatus = YDEV_UNPLUGGED;
-            }else{
-#ifdef DEBUG_DEV_ENUM
-                dbglog("ENU:restart %s(%d)->YDEV_WORKING(restart)\n",p->infos.serial,p->infos.nbinbterfaces);
-#endif
-            }
-            devStopEnum(p);
-            if (YISERR(res)) {
-                wpSafeUnregister(serialref);
-            }
-            break;
-        case YENU_START:
-            if( p->next_startup_attempt <= yapiGetTickCount()) {
-                devStartEnum(p);
-                updateWP = 0;
-                p->dStatus = YDEV_WORKING; //we need to put the device in working to start device (safe because we already have the mutex)
-                res = StartDevice(p, errmsg);
-                if(YISERR(res)){
-                    if (res !=YAPI_TIMEOUT && p->nb_startup_retry < NB_MAX_STARTUP_RETRY) {
-                        dbglog("Unable to start the device %s correctly (%s). retry later (%d)\n", p->infos.serial, errmsg, p->nb_startup_retry);
-#ifdef DEBUG_DEV_ENUM
-                        dbglog("ENU:start %s(%d)->YDEV_UNPLUGED\n", p->infos.serial, p->infos.nbinbterfaces);
-#endif
-                        p->dStatus = YDEV_UNPLUGGED;
-                        p->next_startup_attempt = yapiGetTickCount() + 1000;
-                        p->nb_startup_retry++;
-                    } else {
-#ifdef DEBUG_DEV_ENUM
-                        dbglog("ENU:start %s(%d)->YDEV_NOTRESPONDING\n", p->infos.serial, p->infos.nbinbterfaces);
-#endif
-                        dbglog("Disable device %s (reason:%s)\n",p->infos.serial,errmsg);
-                        p->dStatus = YDEV_NOTRESPONDING;
-                        updateWP = 1;
-                    }
-                    devStopEnum(p);
-                    if (updateWP) {
-                        wpSafeUnregister(serialref);
-                    }
-                } else {
-#ifdef DEBUG_DEV_ENUM
-                    dbglog("ENU:start %s(%d)->YDEV_WORKING\n",p->infos.serial,p->infos.nbinbterfaces);
-#endif
-                    p->yhdl    = yContext->devhdlcount++;
-                    dbglog("Device %s plugged\n",p->infos.serial);
-                    lnameref = yHashPutStr(p->infos.logicalname);
-                    prodref = yHashPutStr(p->infos.productname);
-                    beacon = p->infos.beacon;
-                    deviceid = p->infos.deviceid;
-                    usb = yHashUrlUSB(serialref);
-                    devStopEnum(p);
-                    wpSafeRegister(NULL, MAX_YDX_PER_HUB, serialref, lnameref, prodref, deviceid, usb, beacon);
-                }
-            } else {
-#ifdef DEBUG_DEV_ENUM_VERBOSE
-                dbglog("enum : %s (%d ifaces) waiting for next attempt\n",p->infos.serial,p->infos.nbinbterfaces);
-#endif
-            }
-            break;
-        case YENU_NONE:
-            break;
-        }
-        p=p->next;
-    }
-}
-
-void yUSBReleaseAllDevices(void)
-{
-    yEnterCriticalSection(&yContext->enum_cs);
-    enuResetDStatus();
-    enuUpdateDStatus();
-    yLeaveCriticalSection(&yContext->enum_cs);
-
-}
-
-YRETCODE yUSBUpdateDeviceList(char *errmsg)
-{
-    int             nbifaces=0;
-    yInterfaceSt *iface;
-    int             j;
-    yInterfaceSt    *runifaces=NULL;
-
-    YPROPERR(yyyUSBGetInterfaces(&runifaces,&nbifaces,errmsg));
-
-    yEnterCriticalSection(&yContext->enum_cs);
-    enuResetDStatus();
-
-    for (j = 0, iface = runifaces; j < nbifaces; j++, iface++){
-        yPrivDeviceSt *dev;
-        if (iface->deviceid <= YOCTO_DEVID_BOOTLOADER)
-            continue;
-
-        dev =enuFindDevSlot(iface);
-        if(dev){
-            //device already allocated
-            if(dev->dStatus == YDEV_WORKING ){
-                if(!yyyOShdlCompare(dev, iface)){
-                    ENUMLOG("%s was already there but OS handles are no more valid\n",dev->infos.serial);
-                    dev->enumAction =  YENU_RESTART;
-                } else if (dev->rstatus==YRUN_ERROR){
-                    ENUMLOG("%s was already there but need to be reset due to runtime error\n",dev->infos.serial);
-                    dev->enumAction =  YENU_RESTART;
-                } else {
-                    // device is working correctly
-                    dev->enumAction = YENU_NONE;
-                }
-            }else if(dev->dStatus == YDEV_UNPLUGGED) {
-                ENUMLOG("%s replug of a previously detected device\n",dev->infos.serial);
-                dev->enumAction =  YENU_START;
-                // to be safe we update infos with fresh data form last enumeration
-                dev->infos.nbinbterfaces = 1;
-                memcpy(&dev->iface, iface, sizeof(yInterfaceSt));
-            } else if(dev->dStatus == YDEV_NOTRESPONDING && !yyyOShdlCompare(dev, iface) ){
-                ENUMLOG("%s replug of a previously detected device that was not responding\n",dev->infos.serial);
-                dev->enumAction =  YENU_START;
-                // to be safe we update infos with fresh data form last enumeration
-                dev->infos.nbinbterfaces = 1;
-                memcpy(&dev->iface, iface, sizeof(yInterfaceSt));
-            }
-        }else{
-            ENUMLOG("%s newly plugged device \n",iface->serial);
-            //ALLOCATE A  NEW DEVICE STUCTURE
-            dev = AllocateDevice();
-            dev->enumAction =  YENU_START;
-            //mark device a stopped
-            dev->rstatus = YRUN_STOPED;
-            dev->infos.vendorid = iface->vendorid;
-            dev->infos.deviceid = iface->deviceid;
-            YSTRNCPY(dev->infos.serial, YOCTO_SERIAL_LEN, iface->serial, YOCTO_SERIAL_LEN - 1);
-            dev->infos.nbinbterfaces = 1;
-            memcpy(&dev->iface, iface, sizeof(yInterfaceSt));
-            dev->next = yContext->devs;
-            yContext->devs=dev;
-        }
-    }
-    enuUpdateDStatus();
-    yLeaveCriticalSection(&yContext->enum_cs);
-
-    // free all tmp ifaces
-    if(runifaces){
-        yFree(runifaces);
-    }
-    return YAPI_SUCCESS;
-}
-
-
-
-
-/*****************************************************************************
-  GENERIC DEVICE LIST FUNCTION
-  ***************************************************************************/
-
-// return the YHANDLE from a matching string (serial or name)
-yPrivDeviceSt *findDev(const char *str,u32 flags)
-{
-    yPrivDeviceSt *p;
-
-    if(flags& FIND_FROM_SERIAL){
-        for( p=yContext->devs ; p ; p=p->next){
-            if(p->dStatus == YDEV_UNPLUGGED){
-                continue;
-            }
-            if(strncmp(str,p->infos.serial,YOCTO_SERIAL_LEN)==0){
-                return p;
-            }
-        }
-    }
-    if (flags & FIND_FROM_NAME) {
-        for( p=yContext->devs ; p ; p=p->next){
-            if(p->dStatus == YDEV_UNPLUGGED){
-                continue;
-            }
-            if(strncmp(str,p->infos.logicalname,YOCTO_LOGICAL_LEN)==0){
-                return p;
-            }
-        }
-    }
-
-    return NULL;
-}
-
-
-// return the YHANDLE from a matching string (serial or name)
-YUSBDEV findDevHdlFromStr(const char *str)
-{
-    yPrivDeviceSt *p = findDev(str,FIND_FROM_ANY);
-
-    if(p != NULL) {
-        return p->yhdl;
-    }
-    return INVALID_YHANDLE;
-}
-
-
-yPrivDeviceSt *findDevFromIOHdl(YIOHDL_internal *iohdl)
-{
-    yPrivDeviceSt *p;
-    if(iohdl->type!=YIO_USB)
-        return NULL;
-    for( p=yContext->devs ; p ; p=p->next){
-        if(p->pendingIO.hdl ==iohdl->hdl)
-            return p;
-    }
-    return NULL;
-}
-
-// find a device from his YHANDLE
-static yPrivDeviceSt *findDevFromDevHdl(YUSBDEV hdl)
-{
-    yPrivDeviceSt *p;
-
-    for( p=yContext->devs ; p ; p=p->next){
-        if(p->yhdl ==hdl)
-            return p;
-    }
-    return NULL;
-}
-
-void devHdlInfo(YUSBDEV hdl,yDeviceSt *infos)
-{
-    yPrivDeviceSt *p;
-
-    p=findDevFromDevHdl(hdl);
-    if(p!=NULL){
-        *infos = p->infos;
-    } else {
-        memset(infos, 0, sizeof(yDeviceSt));
-    }
-}
-
-
-
-/*****************************************************************************
-  USB REQUEST FUNCTIONS
-  ***************************************************************************/
-
-
-void  dumpYPerfEntry(yPerfMon *entry,const char *name)
-{
-    dbglog("%s count %lld(%lld) totaltime=%lld (avg =%lld)\n",name,entry->count,entry->leave,entry->totaltime,(entry->count>0?entry->totaltime/entry->count:0));
-}
-
-
-
-//#define PERF_YHUB_FUNCTIONS
-#ifdef PERF_YHUB_FUNCTIONS
-
-
-typedef struct {
-    yPerfMon  yUsbIdle;
-    yPerfMon  yUsbTrafficPending;
-    yPerfMon  yUsbOpen;
-    yPerfMon  yUsbSetIOAsync;
-    yPerfMon  yUsbWrite;
-    yPerfMon  yUsbReadNonBlock;
-    yPerfMon  yUsbReadBlock;
-    yPerfMon  yUsbEOF;
-    yPerfMon  yUsbClose;
-    yPerfMon  yUsbOpenDevDescr;
-} yUsbPerfMonSt;
-
-yUsbPerfMonSt yUsbPerf;
-
-
-#define YPERF_ENTER(NAME) {yUsbPerf.NAME.count++;yUsbPerf.NAME.tmp=yapiGetTickCount();}
-#define YPERF_LEAVE(NAME) {yUsbPerf.NAME.leave++;yUsbPerf.NAME.totaltime += yapiGetTickCount()- yUsbPerf.NAME.tmp;}
-
-
-
-void dumpYUSBPerf(void)
-{
-    dumpYPerfEntry(&yUsbPerf.yUsbIdle,"yUsbIdle");
-    dumpYPerfEntry(&yUsbPerf.yUsbTrafficPending,"yUsbTrafficPending");
-    dumpYPerfEntry(&yUsbPerf.yUsbOpen,"yUsbOpen");
-    dumpYPerfEntry(&yUsbPerf.yUsbSetIOAsync,"yUsbSetIOAsync");
-    dumpYPerfEntry(&yUsbPerf.yUsbWrite,"yUsbWrite");
-    dumpYPerfEntry(&yUsbPerf.yUsbReadNonBlock,"yUsbReadNonBlock");
-    dumpYPerfEntry(&yUsbPerf.yUsbReadBlock,"yUsbReadBlock");
-    dumpYPerfEntry(&yUsbPerf.yUsbEOF,"yUsbEOF");
-    dumpYPerfEntry(&yUsbPerf.yUsbClose,"yUsbClose");
-}
-#else
-#define YPERF_ENTER(NAME)
-#define YPERF_LEAVE(NAME)
-#endif
-
-int yUsbInit(yContextSt *ctx,char *errmsg)
-{
-#ifdef PERF_YHUB_FUNCTIONS
-    memset(&yUsbPerf,0,sizeof(yUsbPerfMonSt));
-#endif
-    return yyyUSB_init(ctx,errmsg);
-}
-
-
-int yUsbFree(yContextSt *ctx,char *errmsg)
-{
-
-    yPrivDeviceSt   *p,*next;
-
-#ifdef PERF_YHUB_FUNCTIONS
-    dumpYUSBPerf();
-#endif
-    p = ctx->devs;
-    ctx->devs = NULL;
-    while(p) {
-        if(p->dStatus == YDEV_WORKING){
-            int csTaken = yTryEnterCriticalSection(&p->acces_state);
-            yStrRef serialref = yHashTestStr(p->infos.serial);
-            p->dStatus = YDEV_UNPLUGGED;
-            StopDevice(p,NULL);
-            wpSafeUnregister(serialref);
-            if(csTaken)
-                yLeaveCriticalSection(&p->acces_state);
-        }
-        if(p->replybuf) {
-            yFree(p->replybuf);
-            p->replybuf = NULL;
-        }
-        next = p->next;
-        FreeDevice(p);
-        p = next;
-    }
-    return yyyUSB_stop(yContext,errmsg);
-}
-
-int yUsbIdle(void)
-{
-    yPrivDeviceSt   *p;
-    int             res;
-    char            errmsg[YOCTO_ERRMSG_LEN];
-
-    YPERF_ENTER(yUsbIdle);
-    for( p=yContext->devs ; p ; p=p->next){
-
-        if(p->dStatus != YDEV_WORKING){
-            continue;
-        }
-
-        res = devStartIdle(PUSH_LOCATION p,errmsg);
-        if (res == YAPI_SUCCESS) {
-            u32 currUtcTime;
-            if(YISERR(yDispatchReceive(p,0,errmsg))){
-                dbglog("yPacketDispatchReceive error:%s\n",errmsg);
-                devReportErrorFromIdle(PUSH_LOCATION p,errmsg);
-                continue;
-            }
-            currUtcTime = (u32)time(NULL);
-            if(currUtcTime > (u32)0x51f151f1 && // timestamp appears to be valid
-               (!p->lastUtcUpdate || currUtcTime < p->lastUtcUpdate || currUtcTime >= p->lastUtcUpdate+60u)) {
-                u8  *pktdata;
-                u8  maxpktlen;
-                // send updated UTC timestamp to keep datalogger on time
-                if(yStreamGetTxBuff(p,&pktdata, &maxpktlen) && maxpktlen >= 5){
-                    p->lastUtcUpdate = currUtcTime;
-                    pktdata[0] = USB_META_UTCTIME;
-                    pktdata[1] = currUtcTime & 0xff;
-                    pktdata[2] = (currUtcTime>>8) & 0xff;
-                    pktdata[3] = (currUtcTime>>16) & 0xff;
-                    pktdata[4] = (currUtcTime>>24) & 0xff;
-                    if(YISERR(yStreamTransmit(p,YSTREAM_META,5,errmsg))){
-                        dbglog("Unable to send UTC timestamp\n");
-                    } else if(YISERR(yStreamFlush(p,errmsg))) {
-                        dbglog("Unable to flush UTC timestamp\n");
-                    }
-                }
-            }
-            devStopIdle(PUSH_LOCATION p);
-            yapiPullDeviceLog(p->infos.serial);
-        } else if(res == YAPI_DEVICE_BUSY){
-            if (p->httpstate != YHTTP_CLOSED && p->pendingIO.callback) {
-                // if we have an async IO on this device
-                // simulate read from users
-                if (!YISERR(devCheckAsyncIO(PUSH_LOCATION p,errmsg))) {
-                    int sendClose=0;
-                    if(YISERR(yDispatchReceive(p,0,errmsg))){
-                        dbglog("yPacketDispatchReceive error:%s\n",errmsg);
-                        devReportError(PUSH_LOCATION p,errmsg);
-                        continue;
-                    }
-                    if(p->httpstate == YHTTP_CLOSE_BY_DEV) {
-                        sendClose=1;
-                    }else if(p->pendingIO.timeout<yapiGetTickCount()){
-                        dbglog("Last async request did not complete (%X:%d)\n",p->pendingIO.hdl,p->httpstate);
-                        sendClose=1;
-                    }
-                    if (sendClose) {
-                        u8  *pktdata;
-                        u8  maxpktlen;
-                        // send connection close
-                        if(yStreamGetTxBuff(p,&pktdata, &maxpktlen)){
-                            u8 * ptr;
-                            u16 len;
-                            if(YISERR(yStreamTransmit(p,YSTREAM_TCP_CLOSE,0,errmsg))){
-                                dbglog("Unable to send async connection close\n");
-                            } else if(YISERR(yStreamFlush(p,errmsg))) {
-                                dbglog("Unable to flush async connection close\n");
-                            }
-                            // since we empty the fifo at each request we can use yPeekContinuousFifo
-                            len = yPeekContinuousFifo(&p->http_fifo, &ptr, 0);
-                            p->pendingIO.callback(p->pendingIO.context, ptr, len, YAPI_SUCCESS, NULL);
-                            yFifoEmpty(&p->http_fifo);
-                            p->httpstate = YHTTP_CLOSED;
-                        }
-                    }
-                    if(p->httpstate == YHTTP_CLOSED) {
-                        if (YISERR(res =devStopIO(PUSH_LOCATION p,errmsg))) {
-                            dbglog("Idle : devStopIO err %s : %X:%s\n",p->infos.serial,res,errmsg);
-                        }
-                    } else {
-                        devPauseIO(PUSH_LOCATION p,NULL);
-                    }
-                }
-            }
-        }
-    }
-    YPERF_LEAVE(yUsbIdle);
-    return YAPI_SUCCESS;
-}
-
-int yUsbTrafficPending(void)
-{
-    yPrivDeviceSt   *p;
-    YPERF_ENTER(yUsbTrafficPending);
-    for( p=yContext->devs ; p ; p=p->next){
-        if(p->dStatus != YDEV_WORKING){
-            continue;
-        }
-        if(p->httpstate != YHTTP_CLOSED && p->pendingIO.callback) {
-            YPERF_LEAVE(yUsbTrafficPending);
-            return 1;
-        }
-    }
-    YPERF_LEAVE(yUsbTrafficPending);
-    return 0;
-}
-
-
-int yUsbOpenDevDescr(YIOHDL_internal *ioghdl, yStrRef devdescr, char *errmsg)
-{
-    char    serialBuf[YOCTO_SERIAL_LEN];
-    int     res;
-
-    YPERF_ENTER(yUsbOpenDevDescr);
-    yHashGetStr(devdescr, serialBuf, YOCTO_SERIAL_LEN);
-    res = yUsbOpen(ioghdl, serialBuf, errmsg);
-    YPERF_LEAVE(yUsbOpenDevDescr);
-
-    return res;
-}
-
-int yUsbOpen(YIOHDL_internal *ioghdl, const char *device, char *errmsg)
-{
-    int           res;
-    yPrivDeviceSt *p;
-
-    YPERF_ENTER(yUsbOpen);
-    p=findDev(device,FIND_FROM_ANY);
-    if(p==NULL){
-        YPERF_LEAVE(yUsbOpen);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    memset(ioghdl, 0, sizeof(YIOHDL_internal));
-    res = devStartIO(PUSH_LOCATION p,errmsg);
-    if(YISERR(res)){
-        YPERF_LEAVE(yUsbOpen);
-        return res;
-    }
-    //process some packet
-    if(YISERR(res=yDispatchReceive(p,0,errmsg))){
-        devReportError(PUSH_LOCATION p,errmsg);
-        YPERF_LEAVE(yUsbOpen);
-        return res;
-    }
-    p->httpstate = YHTTP_OPENED;
-    ioghdl->type = YIO_USB;
-    memset(&p->pendingIO,0,sizeof(USB_HDL));
-    yEnterCriticalSection(&yContext->io_cs);
-    p->pendingIO.hdl = ioghdl->hdl = ++(yContext->io_counter);
-    yLeaveCriticalSection(&yContext->io_cs);
-    p->pendingIO.timeout = YIO_DEFAULT_USB_TIMEOUT+yapiGetTickCount();
-    res = devPauseIO(PUSH_LOCATION p,errmsg);
-    YPERF_LEAVE(yUsbOpen);
-    return res;
-}
-
-int yUsbSetIOAsync(YIOHDL_internal *ioghdl, yapiRequestAsyncCallback callback, void *context, char *errmsg)
-{
-    int res;
-    yPrivDeviceSt *p;
-
-    YPERF_ENTER(yUsbSetIOAsync);
-    p = findDevFromIOHdl(ioghdl);
-    if(p == NULL){
-        YPERF_LEAVE(yUsbSetIOAsync);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    res = devCheckIO(PUSH_LOCATION p,ioghdl,errmsg);
-    if(YISERR(res)){
-        YPERF_LEAVE(yUsbSetIOAsync);
-        return res;
-    }
-    p->pendingIO.callback = callback;
-    p->pendingIO.context = context;
-    res = devPauseIO(PUSH_LOCATION p,errmsg);
-    YPERF_LEAVE(yUsbSetIOAsync);
-
-    return res;
-}
-
-
-
-int  yUsbWrite(YIOHDL_internal *ioghdl, const char *buffer, int writelen,char *errmsg)
-{
-    yPrivDeviceSt *p;
-    int totalsend=0;
-    u8  *pktdata;
-    u8  maxpktlen;
-    int res;
-
-    YPERF_ENTER(yUsbWrite);
-    p=findDevFromIOHdl(ioghdl);
-    if(p==NULL){
-        YPERF_LEAVE(yUsbWrite);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    YPROPERR(devCheckIO(PUSH_LOCATION p,ioghdl,errmsg));
-    if(YISERR(res=yDispatchReceive(p,0,errmsg))){
-        devReportError(PUSH_LOCATION p,errmsg);
-        YPERF_LEAVE(yUsbWrite);
-        return res;
-    }
-
-    if(p->httpstate != YHTTP_OPENED && p->httpstate != YHTTP_INREQUEST) {
-        devPauseIO(PUSH_LOCATION p,NULL);
-        YPERF_LEAVE(yUsbWrite);
-        return YERRMSG(YAPI_IO_ERROR,"Connection closed");
-    }
-    p->httpstate = YHTTP_INREQUEST;
-    while (writelen){
-        while(writelen && yStreamGetTxBuff(p,&pktdata, &maxpktlen)==1) {
-            u8 pktlen =(maxpktlen < writelen ? maxpktlen: writelen);
-            memcpy(pktdata,buffer,pktlen);
-            if(YISERR(res=yStreamTransmit(p,YSTREAM_TCP,pktlen,errmsg))) {
-                devReportError(PUSH_LOCATION p,errmsg);
-                YPERF_LEAVE(yUsbWrite);
-                return res;
-            }
-            buffer    += pktlen;
-            writelen  -= pktlen;
-            totalsend += pktlen;
-        }
-        if(YISERR(res=yStreamFlush(p,errmsg))) {
-            devReportError(PUSH_LOCATION p,errmsg);
-            YPERF_LEAVE(yUsbWrite);
-            return res;
-        }
-    }
-
-    res = devPauseIO(PUSH_LOCATION p,errmsg);
-    if(res==YAPI_SUCCESS)
-        res = totalsend;
-    YPERF_LEAVE(yUsbWrite);
-    return res;
-}
-
-
-
-int  yUsbReadNonBlock(YIOHDL_internal *ioghdl, char *buffer, int len,char *errmsg)
-{
-    yPrivDeviceSt *p;
-    u16 readed;
-    int res;
-
-    YPERF_ENTER(yUsbReadNonBlock);
-
-    p=findDevFromIOHdl(ioghdl);
-    if(p==NULL){
-        YPERF_LEAVE(yUsbReadNonBlock);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-
-    res =devCheckIO(PUSH_LOCATION p,ioghdl,errmsg);
-    if(YISERR(res)){
-        YPERF_LEAVE(yUsbReadNonBlock);
-        return res ;
-    }
-    if(p->pendingIO.callback){
-        YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-        YPERF_LEAVE(yUsbReadNonBlock);
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Operation not supported on async IO");
-    }
-
-    if(YISERR(res=yDispatchReceive(p, 0, errmsg))){
-        devReportError(PUSH_LOCATION p,errmsg);
-        YPERF_LEAVE(yUsbReadNonBlock);
-        return res;
-    }
-    if(len > HTTP_RAW_BUFF_SIZE){
-        len = HTTP_RAW_BUFF_SIZE;
-    }
-    //get all available data
-    readed=yPopFifo(&p->http_fifo,(u8*)buffer,(u16)len);
-    YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-    YPERF_LEAVE(yUsbReadNonBlock);
-    return readed;
-}
-
-
-
-
-
-int  yUsbReadBlock(YIOHDL_internal *ioghdl, char *buffer, int len,u64 blockUntil,char *errmsg)
-{
-    yPrivDeviceSt *p;
-    u16 readed, avail;
-    int res;
-
-    YPERF_ENTER(yUsbReadBlock);
-
-    p=findDevFromIOHdl(ioghdl);
-    if(p==NULL){
-        YPERF_LEAVE(yUsbReadBlock);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    res =devCheckIO(PUSH_LOCATION p,ioghdl,errmsg);
-    if(YISERR(res)){
-        YPERF_LEAVE(yUsbReadBlock);
-        return res ;
-    }
-    if(p->pendingIO.callback){
-        YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-        YPERF_LEAVE(yUsbReadBlock);
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Operation not supported on async IO");
-    }
-
-    avail = yFifoGetUsed(&p->http_fifo);
-    if(YISERR(res=yDispatchReceive(p,(avail==0 ? blockUntil : 0) ,errmsg))){
-        devReportError(PUSH_LOCATION p,errmsg);
-        YPERF_LEAVE(yUsbReadBlock);
-        return res;
-    }
-    if(len > HTTP_RAW_BUFF_SIZE){
-        len = HTTP_RAW_BUFF_SIZE;
-    }
-    //get all available data
-    readed=yPopFifo(&p->http_fifo,(u8*)buffer,(u16)len);
-    YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-    YPERF_LEAVE(yUsbReadBlock);
-    return readed;
-}
-
-
-
-
-int  yUsbEOF(YIOHDL_internal *ioghdl,char *errmsg)
-{
-    yPrivDeviceSt *p;
-    int res;
-
-    YPERF_ENTER(yUsbEOF);
-
-    p=findDevFromIOHdl(ioghdl);
-    if(p==NULL){
-        YPERF_LEAVE(yUsbEOF);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    res =devCheckIO(PUSH_LOCATION p,ioghdl,errmsg);
-    if(YISERR(res)){
-        YPERF_LEAVE(yUsbEOF);
-        return res;
-    }
-    if(p->pendingIO.callback){
-        YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-        YPERF_LEAVE(yUsbEOF);
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Operation not supported on async IO");
-    }
-    if(YISERR(res=yDispatchReceive(p,0,errmsg))){
-        devReportError(PUSH_LOCATION p,errmsg);
-        YPERF_LEAVE(yUsbEOF);
-        return res;
-    }
-    res=0;
-    if(yFifoGetUsed(&p->http_fifo)==0 && p->httpstate == YHTTP_CLOSE_BY_DEV){
-        //dbglog("* yUsbEOF for %d is TRUE\n",p->iohdl);
-        res =1;
-        p->pendingIO.flags |= YIO_REMOTE_CLOSE;
-    }
-    devPauseIO(PUSH_LOCATION p,NULL);
-    YPERF_LEAVE(yUsbEOF);
-    return res;
-}
-
-
-
-int  yUsbClose(YIOHDL_internal *ioghdl,char *errmsg)
-{
-    yPrivDeviceSt *p;
-    u8  *pktdata;
-    u8  maxpktlen;
-    u16 deviceDead = 0;
-    int res;
-
-    YPERF_ENTER(yUsbClose);
-
-    p = findDevFromIOHdl(ioghdl);
-    if (p == NULL) {
-        YPERF_LEAVE(yUsbClose);
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    //dbglog("* yUsbClose for %d, httpstate=%d\n",p->iohdl,p->httpstate);
-    if(p->httpstate == YHTTP_CLOSED || p->httpstate == YHTTP_CLOSE_BY_API) {
-        dbglog("yUsb double-close");
-        YPERF_LEAVE(yUsbClose);
-        return YAPI_SUCCESS;
-    }
-    res = devCheckIO(PUSH_LOCATION p,ioghdl,errmsg);
-    if(YISERR(res)) {
-        YPERF_LEAVE(yUsbClose);
-        return res;
-    }
-    if(p->pendingIO.callback){
-        YPROPERR(devPauseIO(PUSH_LOCATION p,errmsg));
-        YPERF_LEAVE(yUsbClose);
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"Operation not supported on async IO");
-    }
-
-    // send connection close
-    if(!yStreamGetTxBuff(p,&pktdata, &maxpktlen)) {
-        if(YISERR(yStreamFlush(p,errmsg))) {
-            dbglog("Unable to flush pending data");
-            deviceDead = 1;
-        }
-        yStreamGetTxBuff(p,&pktdata, &maxpktlen);
-    }
-    if (!deviceDead && p->httpstate >= YHTTP_INREQUEST) {
-        if(YISERR(yStreamTransmit(p,YSTREAM_TCP_CLOSE,0,errmsg))) {
-            dbglog("Unable to send connection close");
-            deviceDead = 1;
-        } else if(YISERR(yStreamFlush(p,errmsg))) {
-            dbglog("Unable to flush connection close");
-            deviceDead = 1;
-        }
-    }
-    if (p->httpstate == YHTTP_OPENED || p->httpstate == YHTTP_CLOSE_BY_DEV || deviceDead) {
-        p->httpstate = YHTTP_CLOSED;
-    } else {
-        //wait for the device close packet
-        u64 timeout = yapiGetTickCount() + 100;
-        p->httpstate = YHTTP_CLOSE_BY_API;
-        while (!YISERR(yDispatchReceive(p, 5, errmsg))) {
-            if(p->httpstate == YHTTP_CLOSED) {
-                // received close from device
-                break;
-            }
-            if(timeout<yapiGetTickCount()) {
-                const char* err = "yUSBClose without device ack";
-                dbglog("%s\n", err);
-                devReportError(PUSH_LOCATION p, err);
-                break;
-            }
-        }
-    }
-    yFifoEmpty(&p->http_fifo);
-    memset(&p->pendingIO, 0, sizeof(USB_HDL));
-    ioghdl->type=YIO_INVALID;
-    res =devStopIO(PUSH_LOCATION p,errmsg);
-    yapiPullDeviceLog(p->infos.serial);
-    YPERF_LEAVE(yUsbClose);
-    return res;
-}
-
-#if 0
-// Implemented but never tested
-
-int  yUsbSendMeta(const char *device, USB_Meta_Pkt *pkt, int len, char *errmsg)
-{
-    yPrivDeviceSt *dev;
-    u8  *pktdata;
-    u8  maxpktlen;
-    int res;
-
-    YPERF_ENTER(yUsbSendMeta);
-
-    dev=findDev(device,FIND_FROM_ANY);
-    if(dev==NULL){
-        return YERR(YAPI_DEVICE_NOT_FOUND);
-    }
-    res = devStartIdle(PUSH_LOCATION dev,errmsg);
-    if (res == YAPI_SUCCESS) {
-        if (yStreamGetTxBuff(dev, &pktdata, &maxpktlen) && maxpktlen >= len) {
-            memcpy(pktdata, (u8 *)pkt, len);
-            YPROPERR(yStreamTransmit(dev, YSTREAM_META, len, errmsg));
-            YPROPERR(yStreamFlush(dev, errmsg));
-        }
-        devStopIdle(PUSH_LOCATION dev);
-    }
-
-    YPERF_LEAVE(yUsbSendMeta);
-    return res;
-}
-
-#endif
--- a/Sources/cpplib/yapi/ytcp.c
+++ /dev/null
@@ -1,3565 +0,0 @@
-/*********************************************************************
- *
- * $Id: ytcp.c 33735 2018-12-14 16:06:53Z seb $
- *
- * Implementation of a client TCP stack
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#define __FILE_ID__  "ytcp"
-#define _WINSOCK_DEPRECATED_NO_WARNINGS
-
-#include "ydef.h"
-#if defined(WINDOWS_API) && !defined(_MSC_VER)
-#define _WIN32_WINNT 0x501
-#endif
-#ifdef WINDOWS_API
-typedef int socklen_t;
-#if defined(__BORLANDC__)
-#pragma warn -8004
-#pragma warn -8019
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#pragma warn +8004
-#pragma warn +8019
-#else
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#endif
-#endif
-#include "ytcp.h"
-#include "yproto.h"
-#include "yhash.h"
-
-#ifdef WIN32
-#ifndef WINCE
-#include <iphlpapi.h>
-#if defined(_MSC_VER) || defined (__BORLANDC__)
-#pragma comment(lib, "Ws2_32.lib")
-#endif
-#else
-        #pragma comment(lib, "Ws2.lib")
-#endif
-#else
-    #include <unistd.h>
-    #include <fcntl.h>
-    #include <netdb.h>
-#endif
-
-
-//#define DEBUG_SLOW_TCP
-//#define TRACE_TCP_REQ
-//#define PERF_TCP_FUNCTIONS
-#ifdef PERF_TCP_FUNCTIONS
-
-
-typedef struct {
-    yPerfMon  TCPOpen_socket;
-    yPerfMon  TCPOpen_connect;
-    yPerfMon  TCPOpen_setsockopt_noblock;
-    yPerfMon  TCPOpen_setsockopt_nodelay;
-    yPerfMon  TCPOpenReq_wait;
-    yPerfMon  TCPOpenReq;
-    yPerfMon  tmp1;
-    yPerfMon  tmp2;
-    yPerfMon  tmp3;
-    yPerfMon  tmp4;
-} yTcpPerfMonSt;
-
-yTcpPerfMonSt yTcpPerf;
-
-
-#define YPERF_TCP_ENTER(NAME) {yTcpPerf.NAME.count++;yTcpPerf.NAME.tmp=yapiGetTickCount();}
-#define YPERF_TCP_LEAVE(NAME) {yTcpPerf.NAME.leave++;yTcpPerf.NAME.totaltime += yapiGetTickCount()- yTcpPerf.NAME.tmp;}
-
-
-void dumpYTcpPerf(void)
-{
-    dumpYPerfEntry(&yTcpPerf.TCPOpen_socket,"TCPOpen:socket");
-    dumpYPerfEntry(&yTcpPerf.TCPOpen_connect,"TCPOpen:connect");
-    dumpYPerfEntry(&yTcpPerf.TCPOpen_setsockopt_noblock,"TCPOpen:sockopt_noblock");
-    dumpYPerfEntry(&yTcpPerf.TCPOpen_setsockopt_nodelay,"TCPOpen:sockopt_nodelay");
-    dumpYPerfEntry(&yTcpPerf.TCPOpenReq_wait,"TCPOpenReq:wait");
-    dumpYPerfEntry(&yTcpPerf.TCPOpenReq,"TCPOpenReq");
-    dumpYPerfEntry(&yTcpPerf.tmp1,"TCP:tmp1");
-    dumpYPerfEntry(&yTcpPerf.tmp2,"TCP:tmp2");
-    dumpYPerfEntry(&yTcpPerf.tmp3,"TCP:tmp3");
-    dumpYPerfEntry(&yTcpPerf.tmp4,"TCP:tmp4");
-}
-#else
-#define YPERF_TCP_ENTER(NAME)
-#define YPERF_TCP_LEAVE(NAME)
-#endif
-
-
-void yDupSet(char** storage, const char* val)
-{
-    int len = (val ? (int)strlen(val) + 1 : 1);
-
-    if (*storage) yFree(*storage);
-    *storage = (char*)yMalloc(len);
-    if (val) {
-        memcpy(*storage, val, len);
-    } else {
-        **storage = 0;
-    }
-}
-
-int yNetSetErrEx(u32 line, unsigned err, char* errmsg)
-{
-    int len;
-    if (errmsg == NULL)
-        return YAPI_IO_ERROR;
-    YSPRINTF(errmsg,YOCTO_ERRMSG_LEN, "%s:%d:tcp(%d):",__FILE_ID__, line, err);
-    dbglog("yNetSetErrEx -> %s:%d:tcp(%d)\n",__FILE_ID__,line,err);
-
-#if defined(WINDOWS_API) && !defined(WINCE)
-    len = (int)strlen(errmsg);
-    FormatMessageA(
-        FORMAT_MESSAGE_FROM_SYSTEM |
-        FORMAT_MESSAGE_IGNORE_INSERTS,
-        NULL,
-        err,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-        (LPSTR)(errmsg + len),
-        YOCTO_ERRMSG_LEN - len, NULL);
-#else
-    len=YSTRLEN(errmsg);
-    strcpy(errmsg+len, strerror((int)err));
-#endif
-    return YAPI_IO_ERROR;
-}
-#if 1
-#define yNetLogErr()  yNetLogErrEx(__LINE__,SOCK_ERR)
-
-static int yNetLogErrEx(u32 line, unsigned err)
-{
-    int retval;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    retval = yNetSetErrEx(line, err, errmsg);
-    dbglog("%s",errmsg);
-    return retval;
-}
-#endif
-
-#ifdef DEBUG_SOCKET_USAGE
-
-#define yclosesocket(skt) yclosesocket_ex(__FILE_ID__, __LINE__, skt)
-void yclosesocket_ex(const char *file, int line, YSOCKET skt)
-{
-    dbglogf(file, line, "close socket %x\n", skt);
-    closesocket(skt);
-}
-
-
-#define ysocket(domain, type, protocol) ysocket_ex(__FILE_ID__, __LINE__, domain, type, protocol)
-YSOCKET ysocket_ex(const char *file, int line, int domain, int type, int protocol)
-{
-    YSOCKET skt = socket(domain, type, protocol);
-    dbglogf(file, line, "open socket %x (%x,%x,%x)\n", skt, domain, type, protocol);
-    return skt;
-}
-
-#define ysend(skt, buf, len, flags) ysend_ex(__FILE_ID__, __LINE__, skt, buf, len, flags)
-int ysend_ex(const char * file, int line, YSOCKET skt, const char* buffer, int tosend, int  flags)
-{
-    int res = (int)send(skt, buffer, tosend, flags);
-    //dbglogf(file, line, "send socket %x (%d,%x -> %d)\n", skt, tosend, flags, res);
-    return  res;
-}
-
-#define yrecv(skt, buf, len, flags) yrecv_ex(__FILE_ID__, __LINE__, skt, buf, len, flags)
-int yrecv_ex(const char * file, int line, YSOCKET skt, char *buf, int len, int flags)
-{
-    int res = recv(skt, buf, len, flags);
-    //dbglogf(file, line, "read socket %x (%d,%x -> %d)\n", skt, len, flags, res);
-    return  res;
-}
-
-#else
-#define yclosesocket(skt) closesocket(skt)
-#define ysocket(domain, type, protocol) socket(domain, type, protocol)
-#define ysend(skt, buf, len, flags) send(skt, buf, len, flags)
-#define yrecv(skt, buf, len, flags) recv(skt, buf, len, flags)
-#endif
-
-void yInitWakeUpSocket(WakeUpSocket* wuce)
-{
-    wuce->listensock = INVALID_SOCKET;
-    wuce->signalsock = INVALID_SOCKET;
-}
-
-
-int yStartWakeUpSocket(WakeUpSocket* wuce, char* errmsg)
-{
-    u32 optval;
-    socklen_t localh_size;
-    struct sockaddr_in localh;
-
-    if (wuce->listensock != INVALID_SOCKET || wuce->signalsock != INVALID_SOCKET) {
-        return YERRMSG(YAPI_INVALID_ARGUMENT,"WakeUpSocket already Started");
-    }
-    //create socket
-    wuce->listensock = ysocket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
-    if (wuce->listensock == INVALID_SOCKET) {
-        return yNetSetErr();
-    }
-    optval = 1;
-    setsockopt(wuce->listensock,SOL_SOCKET,SO_REUSEADDR, (char *)&optval, sizeof(optval));
-
-    localh_size = sizeof(localh);
-    // set port to 0 since we accept any port
-    memset(&localh, 0, localh_size);
-    localh.sin_family = AF_INET;
-    localh.sin_addr.s_addr = inet_addr("127.0.0.1");
-    if (bind(wuce->listensock, (struct sockaddr *)&localh, localh_size) < 0) {
-        return yNetSetErr();
-    }
-    if (getsockname(wuce->listensock, (struct sockaddr *)&localh, &localh_size) < 0) {
-        return yNetSetErr();
-    }
-    wuce->signalsock = ysocket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
-    if (wuce->signalsock == INVALID_SOCKET) {
-        return yNetSetErr();
-    }
-    if (connect(wuce->signalsock, (struct sockaddr *)&localh, localh_size) < 0) {
-        return yNetSetErr();
-    }
-    return YAPI_SUCCESS;
-}
-
-int yDringWakeUpSocket(WakeUpSocket* wuce, u8 signal, char* errmsg)
-{
-    if (ysend(wuce->signalsock,(char*)&signal,1,SEND_NOSIGPIPE) < 0) {
-        return yNetSetErr();
-    }
-    return YAPI_SUCCESS;
-}
-
-int yConsumeWakeUpSocket(WakeUpSocket* wuce, char* errmsg)
-{
-    u8 signal = 0;
-
-    if (yrecv(wuce->listensock,(char*)&signal,1,0) < 0) {
-        return yNetSetErr();
-    }
-    return signal;
-}
-
-void yFreeWakeUpSocket(WakeUpSocket* wuce)
-{
-    if (wuce->listensock != INVALID_SOCKET) {
-        yclosesocket(wuce->listensock);
-        wuce->listensock = INVALID_SOCKET;
-    }
-    if (wuce->signalsock != INVALID_SOCKET) {
-        yclosesocket(wuce->signalsock);
-        wuce->signalsock = INVALID_SOCKET;
-    }
-}
-
-
-u32 yResolveDNS(const char* name, char* errmsg)
-{
-    u32 ipv4 = 0;
-
-    struct addrinfo *infos, *p;
-    if (getaddrinfo(name,NULL,NULL, &infos) != 0) {
-        REPORT_ERR("Unable to resolve host name");
-        return 0;
-    }
-
-    // Retrieve each address and print out the hex bytes
-    for (p = infos; p != NULL; p = p->ai_next) {
-        if (p->ai_family == AF_INET) {
-            ipv4 = ((struct sockaddr_in *)p->ai_addr)->sin_addr.s_addr;
-            break;
-        }
-    }
-    freeaddrinfo(infos);
-    return ipv4;
-}
-
-
-#define YDNS_CACHE_SIZE 16
-#define YDNS_CACHE_VALIDITY 600000u //10 minutes
-
-typedef struct
-{
-    yUrlRef url;
-    u32 ip;
-    u64 time;
-} DnsCache;
-
-DnsCache dnsCache[YDNS_CACHE_SIZE];
-
-
-static u32 resolveDNSCache(yUrlRef url, char* errmsg)
-{
-    int i, firstFree = -1;
-    char buffer[YOCTO_HOSTNAME_NAME];
-    u32 ip;
-
-    for (i = 0; i < YDNS_CACHE_SIZE; i++) {
-        if (dnsCache[i].url == url) {
-            break;
-        }
-        if (firstFree < 0 && dnsCache[i].url == INVALID_HASH_IDX) {
-            firstFree = i;
-        }
-    }
-    if (i < YDNS_CACHE_SIZE) {
-        if ((u64)(yapiGetTickCount() - dnsCache[i].time) <= YDNS_CACHE_VALIDITY) {
-            return dnsCache[i].ip;
-        }
-        firstFree = i;
-    }
-    yHashGetUrlPort(url, buffer, NULL, NULL, NULL, NULL, NULL);
-    ip = yResolveDNS(buffer, errmsg);
-    if (ip != 0 && firstFree < YDNS_CACHE_SIZE) {
-        dnsCache[firstFree].url = url;
-        dnsCache[firstFree].ip = ip;
-        dnsCache[firstFree].time = yapiGetTickCount();
-    }
-    return ip;
-}
-
-
-/********************************************************************************
-* Pure TCP functions
-*******************************************************************************/
-
-int yTcpInit(char* errmsg)
-{
-    int i;
-#ifdef WINDOWS_API
-    // Initialize Winsock 2.2
-    WSADATA wsaData;
-    int iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
-    if (iResult != 0) {
-        return YERRMSG(YAPI_IO_ERROR,"Unable to start Windows Socket");
-    }
-#endif
-    TCPLOG("yTcpInit\n");
-    for (i = 0; i < YDNS_CACHE_SIZE; i++) {
-        dnsCache[i].url = INVALID_HASH_IDX;
-    }
-    return YAPI_SUCCESS;
-}
-
-void yTcpShutdown(void)
-{
-    TCPLOG("yTcpShutdown\n");
-#ifdef PERF_TCP_FUNCTIONS
-    dumpYTcpPerf();
-#endif
-#ifdef WINDOWS_API
-    WSACleanup();
-#endif
-}
-
-
-#define DEFAULT_TCP_ROUND_TRIP_TIME  30
-#define DEFAULT_TCP_MAX_WINDOW_SIZE  (4*65536)
-
-static int yTcpOpen(YSOCKET* newskt, u32 ip, u16 port, u64 mstimeout, char* errmsg)
-{
-    struct sockaddr_in clientService;
-    int iResult;
-    u_long flags;
-    YSOCKET skt;
-    fd_set readfds, writefds, exceptfds;
-    struct timeval timeout;
-    int tcp_sendbuffer;
-#ifdef WINDOWS_API
-    char noDelay = 1;
-    int optlen;
-#else
-    int  noDelay=1;
-    socklen_t optlen;
-#ifdef SO_NOSIGPIPE
-    int  noSigpipe=1;
-#endif
-#endif
-
-    TCPLOG("yTcpOpen %p [dst=%x:%d %dms]\n", newskt, ip, port, mstimeout);
-
-    YPERF_TCP_ENTER(TCPOpen_socket);
-    *newskt = INVALID_SOCKET;
-    skt = ysocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-    YPERF_TCP_LEAVE(TCPOpen_socket);
-    if (skt == INVALID_SOCKET) {
-        REPORT_ERR("Error at socket()");
-        return YAPI_IO_ERROR;
-    }
-    //dbglog("ytcpOpen %X:%x: skt= %x\n",ip,port,skt);
-    YPERF_TCP_ENTER(TCPOpen_connect);
-    memset(&clientService, 0, sizeof(clientService));
-    //----------------------
-    // The sockaddr_in structure specifies the address family,
-    // IP address, and port of the server to be connected to.
-    clientService.sin_family = AF_INET;
-    clientService.sin_addr.s_addr = ip;
-    clientService.sin_port = htons(port);
-
-    //----------------------
-    // Connect to server.
-    YPERF_TCP_ENTER(TCPOpen_setsockopt_noblock);
-    //set socket as non blocking
-#ifdef WINDOWS_API
-    flags = 1;
-    ioctlsocket(skt, FIONBIO, &flags);
-#else
-    flags = fcntl(skt, F_GETFL, 0);
-    fcntl(skt, F_SETFL, flags | O_NONBLOCK);
-#ifdef SO_NOSIGPIPE
-    setsockopt(skt, SOL_SOCKET, SO_NOSIGPIPE, (void *)&noSigpipe, sizeof(int));
-#endif
-#endif
-    YPERF_TCP_LEAVE(TCPOpen_setsockopt_noblock);
-    connect(skt, (struct sockaddr *)&clientService, sizeof(clientService));
-
-    // wait for the connection with a select
-    memset(&timeout, 0, sizeof(timeout));
-    if (mstimeout != 0) {
-        u64 nbsec = mstimeout / 1000;
-        timeout.tv_sec = (long)nbsec;
-        timeout.tv_usec = ((int)(mstimeout - (nbsec * 1000))) * 1000;
-    } else {
-        timeout.tv_sec = 20;
-    }
-    FD_ZERO(&readfds);
-    FD_ZERO(&writefds);
-    FD_ZERO(&exceptfds);
-    FD_SET(skt, &readfds);
-    FD_SET(skt, &writefds);
-    FD_SET(skt, &exceptfds);
-    iResult = select((int)skt + 1, &readfds, &writefds, &exceptfds, &timeout);
-    if (iResult < 0) {
-        REPORT_ERR("Unable to connect to server");
-        yclosesocket(skt);
-        return YAPI_IO_ERROR;
-    }
-    if (FD_ISSET(skt, &exceptfds)) {
-        yclosesocket(skt);
-        return YERRMSG(YAPI_IO_ERROR, "Unable to connect to server");
-    }
-    if (!FD_ISSET(skt, &writefds)) {
-        yclosesocket(skt);
-        return YERRMSG(YAPI_IO_ERROR, "Unable to connect to server");
-    }
-    YPERF_TCP_LEAVE(TCPOpen_connect);
-    if (iResult == SOCKET_ERROR) {
-        REPORT_ERR("Unable to connect to server");
-        yclosesocket(skt);
-        return YAPI_IO_ERROR;
-    }
-    YPERF_TCP_ENTER(TCPOpen_setsockopt_nodelay);
-    if (setsockopt(skt, IPPROTO_TCP, TCP_NODELAY, &noDelay, sizeof(noDelay)) < 0) {
-#if 0
-        switch(errno) {
-            case EBADF:
-                dbglog("The argument sockfd is not a valid descriptor.\n");
-                break;
-            case EFAULT:
-                dbglog("The address pointed to by optval is not in a valid part of the process address space. For getsockopt(), "
-                        "this error may also be returned if optlen is not in a valid part of the process address space.\n");
-                break;
-            case EINVAL:
-                dbglog("optlen invalid in setsockopt(). In some cases this error can also occur for an invalid value in optval "
-                       "(e.g., for the IP_ADD_MEMBERSHIP option described in ip(7)).\n");
-                break;
-            case ENOPROTOOPT:
-                dbglog("The option is unknown at the level indicated.\n");
-                break;
-            case ENOTSOCK:
-                dbglog("The argument sockfd is a file, not a socket.\n");
-                break;
-        }
-#endif
-        dbglog("SetSockOpt TCP_NODELAY failed %d\n",errno);
-    }
-    YPERF_TCP_LEAVE(TCPOpen_setsockopt_nodelay);
-
-    // Get buffer size
-    optlen = sizeof(tcp_sendbuffer);
-    if (getsockopt(skt, SOL_SOCKET, SO_SNDBUF, (void*)&tcp_sendbuffer, &optlen) >= 0) {
-#if 0
-        dbglog("Default windows size is %d\n", tcp_sendbuffer);
-#endif
-        if (tcp_sendbuffer < DEFAULT_TCP_MAX_WINDOW_SIZE) {
-            // Set buffer size to 64k
-            tcp_sendbuffer = DEFAULT_TCP_MAX_WINDOW_SIZE;
-            if (setsockopt(skt, SOL_SOCKET, SO_SNDBUF, (void*)&tcp_sendbuffer, sizeof(tcp_sendbuffer)) < 0) {
-#if 0
-                switch (errno) {
-                case EBADF:
-                    dbglog("The argument sockfd is not a valid descriptor.\n");
-                    break;
-                case EFAULT:
-                    dbglog("The address pointed to by optval is not in a valid part of the process address space. For getsockopt(), "
-                        "this error may also be returned if optlen is not in a valid part of the process address space.\n");
-                    break;
-                case EINVAL:
-                    dbglog("optlen invalid in setsockopt(). In some cases this error can also occur for an invalid value in optval "
-                        "(e.g., for the IP_ADD_MEMBERSHIP option described in ip(7)).\n");
-                    break;
-                case ENOPROTOOPT:
-                    dbglog("The option is unknown at the level indicated.\n");
-                    break;
-                case ENOTSOCK:
-                    dbglog("The argument sockfd is a file, not a socket.\n");
-                    break;
-                }
-#endif
-                dbglog("SetSockOpt SO_SNDBUF %d failed %d\n", tcp_sendbuffer, errno);
-            }
-        }
-    } else {
-        dbglog("getsockopt: unable to get tcp buffer size\n");
-    }
-
-    *newskt = skt;
-
-    return YAPI_SUCCESS;
-}
-
-static void yTcpClose(YSOCKET skt)
-{
-    // cleanup
-    yclosesocket(skt);
-}
-
-
-// check it a socket is still valid and empty (ie: nothing to read and writable)
-// return 1 if the socket is valid or a error code
-static int yTcpCheckSocketStillValid(YSOCKET skt, char* errmsg)
-{
-    int iResult, res;
-    fd_set readfds, writefds, exceptfds;
-    struct timeval timeout;
-
-    // Send an initial buffer
-#ifndef WINDOWS_API
-retry:
-#endif
-    memset(&timeout, 0, sizeof(timeout));
-    FD_ZERO(&readfds);
-    FD_ZERO(&writefds);
-    FD_ZERO(&exceptfds);
-    FD_SET(skt,&readfds);
-    FD_SET(skt,&writefds);
-    FD_SET(skt,&exceptfds);
-    res = select((int)skt + 1, &readfds, &writefds, &exceptfds, &timeout);
-    if (res < 0) {
-#ifndef WINDOWS_API
-        if(SOCK_ERR ==  EAGAIN){
-            goto retry;
-        } else
-#endif
-        {
-            res = yNetSetErr();
-            yTcpClose(skt);
-            return res;
-        }
-    }
-    if (FD_ISSET(skt,&exceptfds)) {
-        yTcpClose(skt);
-        return YERRMSG(YAPI_IO_ERROR, "Exception on socket");
-    }
-    if (!FD_ISSET(skt,&writefds)) {
-        yTcpClose(skt);
-        return YERRMSG(YAPI_IO_ERROR, "Socket not ready for write");
-    }
-
-    if (FD_ISSET(skt,&readfds)) {
-        char buffer[128];
-        iResult = (int)yrecv(skt, buffer, sizeof(buffer), 0);
-        if (iResult == 0) {
-            yTcpClose(skt);
-            return YERR(YAPI_NO_MORE_DATA);
-        }
-        if (iResult < 0) {
-            yTcpClose(skt);
-            return YERR(YAPI_IO_ERROR);
-        } else {
-            yTcpClose(skt);
-            return YERR(YAPI_DOUBLE_ACCES);
-        }
-    }
-    return 1;
-}
-
-
-static int yTcpWrite(YSOCKET skt, const char* buffer, int len, char* errmsg)
-{
-    int res;
-    int tosend = len;
-    const char* p = buffer;
-
-    while (tosend > 0) {
-        res = (int)ysend(skt, p, tosend, SEND_NOSIGPIPE);
-        if (res == SOCKET_ERROR) {
-#ifdef WINDOWS_API
-            if (SOCK_ERR != WSAEWOULDBLOCK)
-#else
-            if(SOCK_ERR != EAGAIN)
-
-#endif
-            {
-                return yNetSetErr();
-            }
-
-        } else {
-            tosend -= res;
-            p += res;
-            // unable to send all data
-            // wait a bit with a select
-            if (tosend != res) {
-                struct timeval timeout;
-                fd_set fds;
-                memset(&timeout, 0, sizeof(timeout));
-                // Upload of large files (external firmware updates) may need
-                // a long time to process (on OSX: seen more than 40 seconds !)
-                timeout.tv_sec = 60;
-                FD_ZERO(&fds);
-                FD_SET(skt,&fds);
-                res = select((int)skt + 1,NULL, &fds,NULL, &timeout);
-                if (res < 0) {
-#ifndef WINDOWS_API
-                    if(SOCK_ERR ==  EAGAIN){
-                        continue;
-                    } else
-#endif
-                    {
-                        return yNetSetErr();
-                    }
-                } else if (res == 0) {
-                    return YERRMSG(YAPI_TIMEOUT, "Timeout during TCP write");
-                }
-            }
-        }
-    }
-    return len;
-}
-
-
-static int yTcpRead(YSOCKET skt, u8* buffer, int len, char* errmsg)
-{
-    int iResult = (int)yrecv(skt, (char*)buffer, len, 0);
-
-    if (iResult == 0) {
-        return YERR(YAPI_NO_MORE_DATA);
-    } else if (iResult < 0) {
-#ifdef WINDOWS_API
-        if (SOCK_ERR == WSAEWOULDBLOCK) {
-            return 0;
-        }
-#else
-        if(SOCK_ERR == EAGAIN){
-            return 0;
-        }
-#endif
-        REPORT_ERR("read failed");
-        return YAPI_IO_ERROR;
-    }
-    return iResult;
-}
-
-static u32 decodeHex(const char* p, int nbdigit)
-{
-    u32 ret = 0;
-    int i;
-    for (i = nbdigit - 1; i >= 0; i--, p++) {
-        u32 digit;
-        if (*p >= 'a' && *p <= 'f') {
-            digit = 10 + *p - 'a';
-        } else if (*p >= 'A' && *p <= 'F') {
-            digit = 10 + *p - 'A';
-        } else if (*p >= '0' && *p <= '9') {
-            digit = *p - '0';
-        } else {
-            return 0;
-        }
-        ret += digit << (4 * i);
-    }
-    return ret;
-}
-
-
-int yTcpDownload(const char* host, const char* url, u8** out_buffer, u32 mstimeout, char* errmsg)
-{
-    YSOCKET skt;
-    u32 ip;
-    int res, len, readed;
-    char request[512];
-    u8* replybuf = yMalloc(512);
-    int replybufsize = 512;
-    int replysize = 0;
-    fd_set fds;
-    u64 expiration;
-
-    ip = yResolveDNS(host, errmsg);
-    if (ip == 0) {
-        yFree(replybuf);
-        return YAPI_IO_ERROR;
-    }
-    expiration = yapiGetTickCount() + mstimeout;
-    if (yTcpOpen(&skt, ip, 80, mstimeout, errmsg) < 0) {
-        yTcpClose(skt);
-        yFree(replybuf);
-        return YAPI_IO_ERROR;
-    }
-    len = YSPRINTF(request, 512, "GET %s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n"
-                   "Accept-Encoding:\r\nUser-Agent: Yoctopuce\r\n\r\n", url, host);
-    //write header
-    res = yTcpWrite(skt, request, len, errmsg);
-    if (YISERR(res)) {
-        goto exit;
-    }
-    while (expiration - yapiGetTickCount() > 0) {
-        struct timeval timeout;
-        u64 ms = expiration - yapiGetTickCount();
-        memset(&timeout, 0, sizeof(timeout));
-        timeout.tv_sec = (long)ms / 1000;
-        timeout.tv_usec = (int)(ms % 1000) * 1000;
-        /* wait for data */
-        FD_ZERO(&fds);
-        FD_SET(skt,&fds);
-        res = select((int)skt + 1, &fds,NULL,NULL, &timeout);
-        if (res < 0) {
-#ifndef WINDOWS_API
-            if(SOCK_ERR ==  EAGAIN){
-                continue;
-            } else
-#endif
-            {
-                res = yNetSetErr();
-                goto exit;
-            }
-        }
-        if (replysize + 256 >= replybufsize) {
-            // need to grow receive buffer
-            int newsize = replybufsize << 1;
-            u8* newbuf = (u8*)yMalloc(newsize);
-            if (replybuf) {
-                memcpy(newbuf, replybuf, replysize);
-                yFree(replybuf);
-            }
-            replybuf = newbuf;
-            replybufsize = newsize;
-        }
-        readed = yTcpRead(skt, replybuf + replysize, replybufsize - replysize, errmsg);
-        if (readed < 0) {
-            // any connection closed by peer ends up with YAPI_NO_MORE_DATA
-            if (readed == YAPI_NO_MORE_DATA) {
-                res = replysize;
-            } else {
-                res = readed;
-            }
-            goto exit;
-        } else {
-            replysize += readed;
-        }
-    }
-    res = YERR(YAPI_TIMEOUT);
-
-exit:
-    yTcpClose(skt);
-
-    if (res < 0) {
-        yFree(replybuf);
-    } else {
-        *out_buffer = replybuf;
-        if (YSTRNCMP((char*)replybuf,"HTTP/1.1 200",12) == 0) {
-            // check if we need to decode chunks encoding
-            int data_ofs = ymemfind(replybuf, res, (u8*)"\r\n\r\n", 4);
-            if (data_ofs > 0) {
-                u8* p = replybuf;
-                u8* d = p + data_ofs;
-                char buffer[128];
-                char* pt;
-                const char* ept = buffer + 128;
-                char c = '\0';
-                int decode_chunk = 0;
-                while (p < d) {
-                    pt = buffer;
-                    while (p < d && pt < ept && (c = *p++) != ':' && c != '\r' && c != '\n') {
-                        if (c != ' ') {
-                            *pt++ = c;
-                        }
-                    }
-                    if (p >= d) {
-                        break;
-                    }
-                    *pt = 0;
-                    if (c == ':') {
-                        int parse_val = 0;
-                        p++;
-                        if (YSTRCMP(buffer, "Transfer-Encoding") == 0) {
-                            parse_val = 1;
-                        }
-                        pt = buffer;
-                        while (p < d && pt < ept && (c = *p++) != '\r' && c != '\n') {
-                            if (c != ' ') {
-                                *pt++ = c;
-                            }
-                        }
-                        *pt = 0;
-                        if (parse_val) {
-                            if (YSTRICMP(buffer, "chunked") == 0) {
-                                decode_chunk = 1;
-                                break;
-                            }
-                        }
-                    }
-                }
-                if (decode_chunk) {
-                    u8* newdata = yMalloc(res);
-                    u8* w = newdata;
-                    u32 chunklen;
-                    data_ofs += 4;
-                    memcpy(w, replybuf, data_ofs);
-                    w += data_ofs;
-                    p = replybuf + data_ofs;
-                    d = replybuf + res;
-                    do {
-                        int nbdigit = 0;
-                        pt = buffer;
-                        while (p < d && pt < ept && (c = *p++) != '\n') {
-                            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) {
-                                *pt++ = c;
-                                nbdigit++;
-                            }
-                        }
-                        *pt = 0;
-                        chunklen = decodeHex(buffer, nbdigit);
-                        if (chunklen) {
-                            memcpy(w, p, chunklen);
-                            p += chunklen;
-                        }
-                    } while (chunklen);
-                    *out_buffer = newdata;
-                    yFree(replybuf);
-                }
-            }
-
-        }
-
-
-    }
-    return res;
-}
-
-
-static int yTcpCheckReqTimeout(struct _RequestSt* req, char* errmsg)
-{
-    if (req->timeout_tm != 0) {
-        u64 now = yapiGetTickCount();
-        u64 duration = now - req->open_tm;
-        u64 last_io = (req->write_tm > req->read_tm ? req->write_tm : req->read_tm);
-        u64 idle_durration = now - last_io;
-
-        if (idle_durration < YIO_IDLE_TCP_TIMEOUT) {
-            return YAPI_SUCCESS;
-        }
-#ifdef DEBUG_SLOW_TCP
-        else {
-            u64 last_wr = now - req->write_tm;
-            u64 last_rd = now - req->read_tm;
-
-            dbglog("Long Idle TCP request %p = %"FMTu64"ms total = %"FMTu64"ms (read=%"FMTu64"ms write=%"FMTu64")\n",
-                req, idle_durration, duration, last_rd, last_wr);
-        }
-#endif
-        if (duration > req->timeout_tm) {
-            req->errcode = YAPI_TIMEOUT;
-            YSPRINTF(req->errmsg, YOCTO_ERRMSG_LEN, "TCP request took too long (%dms)", duration);
-            return YERRMSG(YAPI_TIMEOUT, req->errmsg);
-        }
-#ifdef DEBUG_SLOW_TCP
-        else {
-            if (duration > (req->timeout_tm - (req->timeout_tm / 4))) {
-                dbglog("Slow TCP request %p = %dms\n",req,duration);
-                dbglog("req = %s\n",req->headerbuf);
-            }
-        }
-#endif
-
-    }
-    return YAPI_SUCCESS;
-}
-
-
-/********************************************************************************
-* HTTP request functions (HTTP request that DO NOT use WebSocket)
-*******************************************************************************/
-
-
-// access mutex taken by caller
-static int yHTTPOpenReqEx(struct _RequestSt* req, u64 mstimout, char* errmsg)
-{
-    char buffer[YOCTO_HOSTNAME_NAME], *p, *last, *end;
-    u32 ip;
-    u16 port;
-    int res;
-
-    YASSERT(req->proto == PROTO_AUTO || req->proto == PROTO_HTTP);
-
-    switch (yHashGetUrlPort(req->hub->url, buffer, &port, NULL, NULL, NULL, NULL)) {
-    case NAME_URL:
-        ip = resolveDNSCache(req->hub->url, errmsg);
-        if (ip == 0) {
-            YPERF_TCP_LEAVE(tmp1);
-            return YAPI_IO_ERROR;
-        }
-        break;
-    case IP_URL:
-        ip = inet_addr(buffer);
-        break;
-    default:
-        res = YERRMSG(YAPI_IO_ERROR, "not an IP hub");
-        req->http.skt = INVALID_SOCKET;
-        TCPLOG("yTcpOpenReqEx error%p[%x]\n", req, req->http.skt);
-        return res;
-    }
-    TCPLOG("yTcpOpenReqEx %p [%x:%x %d]\n", req, req->http.skt, req->http.reuseskt, mstimout);
-
-    req->replypos = -1; // not ready to consume until header found
-    req->replysize = 0;
-    memset(req->replybuf, 0, req->replybufsize);
-    req->errcode = YAPI_SUCCESS;
-
-
-    if (req->http.reuseskt != INVALID_SOCKET && (res = yTcpCheckSocketStillValid(req->http.reuseskt, NULL)) == 1) {
-        req->http.skt = req->http.reuseskt;
-        req->http.reuseskt = INVALID_SOCKET;
-    } else {
-        req->http.reuseskt = INVALID_SOCKET;
-        res = yTcpOpen(&req->http.skt, ip, port, mstimout, errmsg);
-        if (YISERR(res)) {
-            // yTcpOpen has reset the socket to INVALID
-            yTcpClose(req->http.skt);
-            req->http.skt = INVALID_SOCKET;
-            TCPLOG("yTcpOpenReqEx error %p [%x]\n", req, req->http.skt);
-            return res;
-        }
-    }
-
-    p = req->headerbuf;
-    //skip first line
-    while (*p && *p != '\r') p++;
-    end = p;
-    last = p;
-
-    while (*p == '\r' && *(p + 1) == '\n' && *(p + 2) != '\r') {
-        p += 2;
-        while (*p && *p != '\r') p++;
-        if (YSTRNCMP(last,"\r\nContent-Type",strlen("\r\nContent-Type")) == 0) {
-            unsigned len = (unsigned)(p - last);
-            if (last != end) {
-                memcpy(end, last, len);
-            }
-            end += len;
-        }
-        last = p;
-    }
-    *end++ = '\r';
-    *end++ = '\n';
-    // insert authorization header in needed
-    yEnterCriticalSection(&req->hub->access);
-    if (req->hub->http.s_user && req->hub->http.s_realm) {
-        char *method = req->headerbuf, *uri;
-        char* auth = end;
-        // null-terminate method and URI for digest computation
-        // ReSharper disable once CppPossiblyErroneousEmptyStatements
-        for (uri = method; *uri != ' '; uri++);
-        *uri++ = 0;
-        // ReSharper disable once CppPossiblyErroneousEmptyStatements
-        for (p = uri; *p != ' '; p++);
-        *p = 0;
-        yDigestAuthorization(auth, (int)(req->headerbuf + req->headerbufsize - auth), req->hub->http.s_user, req->hub->http.s_realm, req->hub->http.s_ha1,
-                             req->hub->http.s_nonce, req->hub->http.s_opaque, &req->hub->http.nc, method, uri);
-        // restore space separator after method and URI
-        *--uri = ' ';
-        *p = ' ';
-        // prepare to complete request
-        end = auth + strlen(auth);
-    }
-    yLeaveCriticalSection(&req->hub->access);
-    if (req->flags & TCPREQ_KEEPALIVE) {
-        YSTRCPY(end, (int)(req->headerbuf + req->headerbufsize - end), "\r\n");
-    } else {
-        YSTRCPY(end, (int)(req->headerbuf + req->headerbufsize - end), "Connection: close\r\n\r\n");
-    }
-    //write header
-    res = yTcpWrite(req->http.skt, req->headerbuf, (int)strlen(req->headerbuf), errmsg);
-    if (YISERR(res)) {
-        yTcpClose(req->http.skt);
-        req->http.skt = INVALID_SOCKET;
-        return res;
-    }
-    if (req->bodysize > 0) {
-        //write body
-        res = yTcpWrite(req->http.skt, req->bodybuf, req->bodysize, errmsg);
-        if (YISERR(res)) {
-            yTcpClose(req->http.skt);
-            req->http.skt = INVALID_SOCKET;
-            TCPLOG("yTcpOpenReqEx write failed for Req %p[%x]\n", req, req->http.skt);
-            return res;
-        }
-    }
-    req->write_tm = yapiGetTickCount();
-
-    if (req->hub->wuce.listensock != INVALID_SOCKET) {
-        return yDringWakeUpSocket(&req->hub->wuce, 1, errmsg);
-    } else {
-        return YAPI_SUCCESS;
-    }
-}
-
-
-static void yHTTPCloseReqEx(struct _RequestSt* req, int canReuseSocket)
-{
-    TCPLOG("yHTTPCloseReqEx %p[%d]\n",req, canReuseSocket);
-
-    // mutex already taken by caller
-    req->flags &= ~TCPREQ_KEEPALIVE;
-    if (req->callback) {
-        u32 len = req->replysize - req->replypos;
-        u8* ptr = req->replybuf + req->replypos;
-        if (req->errcode == YAPI_NO_MORE_DATA) {
-            req->callback(req->context, ptr, len, YAPI_SUCCESS, "");
-        } else {
-            req->callback(req->context, ptr, len, req->errcode, req->errmsg);
-        }
-        req->callback = NULL;
-        // ASYNC Request are automatically released
-        req->flags &= ~TCPREQ_IN_USE;
-    }
-
-    if (req->http.skt != INVALID_SOCKET) {
-        if (canReuseSocket) {
-            req->http.reuseskt = req->http.skt;
-        } else {
-            yTcpClose(req->http.skt);
-        }
-        req->http.skt = INVALID_SOCKET;
-    }
-    ySetEvent(&req->finished);
-}
-
-
-static int yHTTPMultiSelectReq(struct _RequestSt** reqs, int size, u64 ms, WakeUpSocket* wuce, char* errmsg)
-{
-    fd_set fds;
-    struct timeval timeout;
-    int res, i;
-    YSOCKET sktmax = 0;
-
-    memset(&timeout, 0, sizeof(timeout));
-    timeout.tv_sec = (long)ms / 1000;
-    timeout.tv_usec = (int)(ms % 1000) * 1000;
-    /* wait for data */
-    //dbglog("select %p\n", reqs);
-
-
-    FD_ZERO(&fds);
-    if (wuce) {
-        //dbglog("listensock %p %d\n", reqs, wuce->listensock);
-        FD_SET(wuce->listensock, &fds);
-        sktmax = wuce->listensock;
-    }
-    for (i = 0; i < size; i++) {
-        struct _RequestSt* req;
-        req = reqs[i];
-        YASSERT(req->proto == PROTO_AUTO || req->proto == PROTO_HTTP);
-        if (req->http.skt == INVALID_SOCKET) {
-            return YERR(YAPI_INVALID_ARGUMENT);
-        } else {
-            //dbglog("sock %p %p:%d\n", reqs, req, req->http.skt);
-            FD_SET(req->http.skt, &fds);
-            if (req->http.skt > sktmax)
-                sktmax = req->http.skt;
-        }
-    }
-    if (sktmax == 0) {
-        return YAPI_SUCCESS;
-    }
-    res = select((int)sktmax + 1, &fds, NULL, NULL, &timeout);
-    if (res < 0) {
-#ifndef WINDOWS_API
-        if(SOCK_ERR ==  EAGAIN){
-            return 0;
-        } else
-#endif
-        {
-            res = yNetSetErr();
-            for (i = 0; i < size; i++) {
-                TCPLOG("yHTTPSelectReq %p[%X] (%s)\n", reqs[i], reqs[i]->http.skt, errmsg);
-            }
-            return res;
-        }
-    }
-    if (res != 0) {
-        if (wuce && FD_ISSET(wuce->listensock,&fds)) {
-            YPROPERR(yConsumeWakeUpSocket(wuce, errmsg));
-        }
-        for (i = 0; i < size; i++) {
-            struct _RequestSt* req;
-            req = reqs[i];
-            if (FD_ISSET(req->http.skt, &fds)) {
-                yEnterCriticalSection(&req->access);
-                if (req->replysize >= req->replybufsize - 256) {
-                    // need to grow receive buffer
-                    int newsize = req->replybufsize << 1;
-                    u8* newbuf = (u8*)yMalloc(newsize);
-                    memcpy(newbuf, req->replybuf, req->replysize);
-                    yFree(req->replybuf);
-                    req->replybuf = newbuf;
-                    req->replybufsize = newsize;
-                }
-                res = yTcpRead(req->http.skt, req->replybuf + req->replysize, req->replybufsize - req->replysize, errmsg);
-                //dbglog("check %x:%x:%X\n", check, check2, size);
-
-                req->read_tm = yapiGetTickCount();
-                if (res < 0) {
-                    // any connection closed by peer ends up with YAPI_NO_MORE_DATA
-                    req->replypos = 0;
-                    req->errcode = YERRTO((YRETCODE) res,req->errmsg);
-                    TCPLOG("yHTTPSelectReq %p[%x] connection closed by peer\n",req,req->http.skt);
-                    yHTTPCloseReqEx(req, 0);
-                } else if (res > 0) {
-                    req->replysize += res;
-                    if (req->replypos < 0) {
-                        // Need to analyze http headers
-                        if (req->replysize == 8 && !memcmp(req->replybuf, "0K\r\n\r\n\r\n", 8)) {
-                            TCPLOG("yHTTPSelectReq %p[%x] ultrashort reply\n",req,req->http.skt);
-                            // successful abbreviated reply (keepalive)
-                            req->replypos = 0;
-                            req->replybuf[0] = 'O';
-                            req->errcode = YERRTO(YAPI_NO_MORE_DATA, req->errmsg);
-                            yHTTPCloseReqEx(req, 1);
-                        } else if (req->replysize >= 4 && !memcmp(req->replybuf, "OK\r\n", 4)) {
-                            // successful short reply, let it go through
-                            req->replypos = 0;
-                        } else if (req->replysize >= 12) {
-                            if (memcmp(req->replybuf, "HTTP/1.1 401", 12) != 0) {
-                                // no authentication required, let it go through
-                                req->replypos = 0;
-                            } else {
-                                // authentication required, process authentication headers
-                                char *method = NULL, *realm = NULL, *qop = NULL, *nonce = NULL, *opaque = NULL;
-
-                                if (!req->hub->http.s_user || req->retryCount++ > 3) {
-                                    // No credential provided, give up immediately
-                                    req->replypos = 0;
-                                    req->replysize = 0;
-                                    req->errcode = YERRTO(YAPI_UNAUTHORIZED, req->errmsg);
-                                    yHTTPCloseReqEx(req, 0);
-                                } else if (yParseWWWAuthenticate((char*)req->replybuf, req->replysize, &method, &realm, &qop, &nonce, &opaque) >= 0) {
-                                    // Authentication header fully received, we can close the connection
-                                    if (!strcmp(method, "Digest") && !strcmp(qop, "auth")) {
-                                        // partial close to reopen with authentication settings
-                                        yTcpClose(req->http.skt);
-                                        req->http.skt = INVALID_SOCKET;
-                                        // device requests Digest qop-authentication, good
-                                        yEnterCriticalSection(&req->hub->access);
-                                        yDupSet(&req->hub->http.s_realm, realm);
-                                        yDupSet(&req->hub->http.s_nonce, nonce);
-                                        yDupSet(&req->hub->http.s_opaque, opaque);
-                                        if (req->hub->http.s_user && req->hub->http.s_pwd) {
-                                            ComputeAuthHA1(req->hub->http.s_ha1, req->hub->http.s_user, req->hub->http.s_pwd, req->hub->http.s_realm);
-                                        }
-                                        req->hub->http.nc = 0;
-                                        yLeaveCriticalSection(&req->hub->access);
-                                        // reopen connection with proper auth parameters
-                                        // callback and context parameters are preserved
-                                        req->errcode = yHTTPOpenReqEx(req, req->timeout_tm, req->errmsg);
-                                        if (YISERR(req->errcode)) {
-                                            yHTTPCloseReqEx(req, 0);
-                                        }
-                                    } else {
-                                        // unsupported authentication method for devices, give up
-                                        req->replypos = 0;
-                                        req->errcode = YERRTO(YAPI_UNAUTHORIZED, req->errmsg);
-                                        yHTTPCloseReqEx(req, 0);
-                                    }
-                                }
-                            }
-                        }
-                    }
-                    if (req->errcode == YAPI_SUCCESS) {
-                        req->errcode = yTcpCheckReqTimeout(req, req->errmsg);
-                    }
-                }
-                yLeaveCriticalSection(&req->access);
-            }
-        }
-    }
-
-    return YAPI_SUCCESS;
-}
-
-
-/********************************************************************************
-* WebSocket implementation for generic requests
-*******************************************************************************/
-#if 0
-static void dumpReqQueue(const char * msg, HubSt* hub, int tcpchan)
-{
-    struct _RequestSt* req;
-    char buffer[1024];
-    req = hub->ws.chan[tcpchan].requests;
-    YSPRINTF(buffer,2048,"dmp_%s(%d):", msg, tcpchan);
-    dbglog("%s\n", buffer);
-    while (req != NULL ) {
-        char sbuffer[512];
-        YSPRINTF(sbuffer,512," %p(%d:%d %d->%d)", req, req->state, req->ws.asyncId, req->ws.requestpos,req->ws.requestsize);
-        dbglog("%s\n", sbuffer);
-        req = req->ws.next;
-    }
-}
-
-static void dumpbin(char *out, u8* buffer, int pktlen)
-{
-    int i;
-    for (i = 0; i  < pktlen ;i++)
-    {
-        u8 val = *buffer++;
-        if (val <32 ) {
-            val = ' ';
-        } else if (val > 126) {
-            val = '~';
-        }
-        *out++ = val;
-    }
-}
-#endif
-
-
-#define MAX_QUEUE_SIZE 16
-
-static int yWSOpenReqEx(struct _RequestSt* req, int tcpchan, u64 mstimeout, char* errmsg)
-{
-    HubSt* hub = req->hub;
-    RequestSt* r;
-    int headlen;
-    u8* p;
-    int count = 0;
-    u64 start = yapiGetTickCount();
-    YASSERT(req->proto == PROTO_WEBSOCKET);
-
-
-    // merge first line and header
-    headlen = YSTRLEN(req->headerbuf);
-    req->ws.requestsize = headlen + 4 + req->bodysize;
-    req->ws.requestbuf = yMalloc(req->ws.requestsize);
-    p = req->ws.requestbuf;
-    memcpy(p, req->headerbuf, headlen);
-    p += headlen;
-    //todo: create request buffer more efficiently
-    if (req->bodysize) {
-        memcpy(p, req->bodybuf, req->bodysize);
-    } else {
-        memcpy(p, "\r\n\r\n", 4);
-    }
-    req->ws.channel = tcpchan;
-    req->timeout_tm = mstimeout;
-    YASSERT(tcpchan < MAX_ASYNC_TCPCHAN);
-
-retry:
-    if (start + mstimeout == yapiGetTickCount()) {
-        return YERRMSG(YAPI_IO_ERROR, "Unable to queue request (WebSocket)");
-    }
-    if (count) {
-        yApproximateSleep(100);
-    }
-
-    if (req->hub->ws.base_state != WS_BASE_CONNECTED) {
-        return YERRMSG(YAPI_IO_ERROR, "Hub is not ready (WebSocket)");
-    }
-
-
-
-    yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-    if (req->callback) {
-        yEnterCriticalSection(&hub->access);
-        req->ws.asyncId = hub->ws.s_next_async_id++;
-        if (hub->ws.s_next_async_id >= 127) {
-            hub->ws.s_next_async_id = 48;
-        }
-        yLeaveCriticalSection(&hub->access);
-    }
-    req->ws.next = NULL; // just in case
-    if (hub->ws.chan[tcpchan].requests) {
-        count = 0;
-        r = hub->ws.chan[tcpchan].requests;
-        while (r->ws.next && count < MAX_QUEUE_SIZE) {
-            r = r->ws.next;
-            count++;
-        }
-        if (count== MAX_QUEUE_SIZE && r->ws.next) {
-            //too many request in queue sleep a bit
-            yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-            goto retry;
-        }
-
-        r->ws.next = req;
-    } else {
-        hub->ws.chan[tcpchan].requests = req;
-    }
-#if 0
-    WSLOG("req(%s:%p): open req chan=%d timeout=%dms asyncId=%d\n", req->hub->name, req, tcpchan, (int)mstimeout, req->ws.asyncId);
-    dumpReqQueue("open", hub, tcpchan);
-    {
-        char dump_buf[512];
-        int len = req->ws.requestsize >=512 ? 511:req->ws.requestsize;
-        dumpbin(dump_buf,req->ws.requestbuf,len);
-        dump_buf[len] = 0;
-        WSLOG("uop(%p):%s\n", req, dump_buf);
-    }
-#endif
-    yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-    req->write_tm = yapiGetTickCount();
-    return yDringWakeUpSocket(&hub->wuce, 1, errmsg);
-}
-
-
-static int yWSSelectReq(struct _RequestSt* req, u64 mstimeout, char* errmsg)
-{
-    int done = yWaitForEvent(&req->finished, (int)mstimeout);
-
-    REQLOG("ws_req:%p: select for %d ms %d\n", req, (int)mstimeout, done);
-
-    if (done) {
-        req->errcode = YAPI_NO_MORE_DATA;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static void yWSCloseReqEx(struct _RequestSt* req, int takeCS)
-{
-    HubSt* hub = req->hub;
-    RequestSt *r, *p;
-    int tcpchan;
-    u32 len;
-    u8* ptr;
-#ifdef DEBUG_WEBSOCKET
-    u64 duration;
-    duration = yapiGetTickCount() - req->open_tm;
-    WSLOG("req(%s:%p) close req after %"FMTu64"ms (%"FMTu64"ms) with %d bytes errcode = %d\n", req->hub->name, req, duration, (req->write_tm - req->open_tm), req->replysize, req->errcode);
-#endif
-
-    YASSERT(req->proto == PROTO_WEBSOCKET);
-    if (req->callback) {
-        // async close
-        len = req->replysize - req->replypos;
-        ptr = req->replybuf + req->replypos;
-        if (req->errcode == YAPI_NO_MORE_DATA) {
-            req->callback(req->context, ptr, len, YAPI_SUCCESS, "");
-        } else {
-            req->callback(req->context, ptr, len, req->errcode, req->errmsg);
-        }
-        req->callback = NULL;
-    }
-
-
-    tcpchan = req->ws.channel;
-    YASSERT(tcpchan < MAX_ASYNC_TCPCHAN);
-    if (takeCS) {
-        yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-    }
-    r = hub->ws.chan[tcpchan].requests;
-    p = NULL;
-    while (r && r != req) {
-        p = r;
-        r = r->ws.next;
-
-    }
-    YASSERT(r);
-    if (r) {
-        if (p == NULL) {
-            hub->ws.chan[tcpchan].requests = r->ws.next;
-        } else {
-            p->ws.next = r->ws.next;
-        }
-    }
-    if (takeCS) {
-        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-    }
-}
-
-
-/********************************************************************************
-* Generic Request functions (HTTP or WS)
-*******************************************************************************/
-
-#ifdef TRACE_TCP_REQ
-
-static void dumpTCPReq(const char *fileid, int lineno, struct _RequestSt *req)
-{
-    int w;
-    int has_cs  =yTryEnterCriticalSection(&req->access);
-    const char *proto;
-    const char *state;
-
-    dbglog("dump TCPReq %p from %s:%d\n", req, fileid, lineno);
-    if (req->hub){
-        dbglog("Hub: %s\n", req->hub->name);
-    } else{
-        dbglog("Hub: null\n");
-    }
-
-
-    switch (req->state) {
-        case REQ_CLOSED:
-            state ="state=REQ_CLOSED";
-            break;
-        case REQ_OPEN:
-            state ="state=REQ_OPEN";
-            break;
-        case REQ_CLOSED_BY_HUB:
-            state ="state=REQ_CLOSED_BY_HUB";
-            break;
-        case REQ_CLOSED_BY_API:
-            state ="state=REQ_CLOSED_BY_API";
-            break;
-        case REQ_ERROR:
-            state ="state=REQ_ERROR";
-            break;
-        default:
-            state ="state=??";
-            break;
-    }
-
-    dbglog("%s retcode=%d (retrycount=%d) errmsg=%s\n", state, req->errcode, req->retryCount, req->errmsg);
-    switch(req->proto){
-        case PROTO_AUTO: proto ="PROTO_AUTO"; break;
-        case PROTO_HTTP: proto ="PROTO_HTTP"; break;
-        case PROTO_WEBSOCKET: proto ="PROTO_WEBSOCKET"; break;
-        default: proto ="unk"; break;
-    }
-    dbglog("proto=%s socket=%x (reuse=%x) flags=%x\n", proto, req->http.skt, req->http.reuseskt, req->flags);
-    dbglog("time open=%"FMTx64" last read=%"FMTx64" last write=%"FMTx64"  timeout=%"FMTx64"\n", req->open_tm, req->read_tm, req->write_tm, req->timeout_tm);
-    dbglog("read=%d (readpos=%d)\n", req->replysize, req->replysize);
-    dbglog("callback=%p context=%p\n", req->callback, req->context);
-    if (req->headerbuf){
-        dbglog("req[%s]\n", req->headerbuf);
-    } else {
-        dbglog("null\n");
-    }
-    w = yWaitForEvent(&req->finished, 0);
-    dbglog("finished=%d\n", w);
-    if (has_cs) {
-        yLeaveCriticalSection(&req->access);
-    }
-
-}
-#endif
-
-
-struct _RequestSt* yReqAlloc(struct _HubSt* hub)
-{
-    struct _RequestSt* req = yMalloc(sizeof(struct _RequestSt));
-    memset(req, 0, sizeof(struct _RequestSt));
-    yHashGetUrlPort(hub->url, NULL, NULL, &req->proto, NULL, NULL, NULL);
-    TCPLOG("yTcpInitReq %p[%x:%x]\n", req, hub->url, req->proto);
-    req->replybufsize = 1500;
-    req->replybuf = (u8*)yMalloc(req->replybufsize);
-    yInitializeCriticalSection(&req->access);
-    yCreateManualEvent(&req->finished, 1);
-    req->hub = hub;
-    switch (req->proto) {
-    case PROTO_AUTO:
-    case PROTO_HTTP:
-        req->http.reuseskt = INVALID_SOCKET;
-        req->http.skt = INVALID_SOCKET;
-        break;
-    case PROTO_WEBSOCKET:
-        break;
-    }
-    return req;
-}
-
-
-int yReqOpen(struct _RequestSt* req, int wait_for_start, int tcpchan, const char* request, int reqlen, u64 mstimeout, yapiRequestAsyncCallback callback, void* context, RequestProgress progress_cb, void* progress_ctx, char* errmsg)
-{
-    int minlen, i, res;
-    u64 startwait;
-
-    YPERF_TCP_ENTER(TCPOpenReq);
-    if (wait_for_start <= 0) {
-        yEnterCriticalSection(&req->access);
-        if (req->flags & TCPREQ_IN_USE) {
-            yLeaveCriticalSection(&req->access);
-            return YERR(YAPI_DEVICE_BUSY);
-        }
-    } else {
-        YPERF_TCP_ENTER(TCPOpenReq_wait);
-        yEnterCriticalSection(&req->access);
-        startwait = yapiGetTickCount();
-        while (req->flags & TCPREQ_IN_USE) {
-            u64 duration;
-            // There is an ongoing request to be finished
-            yLeaveCriticalSection(&req->access);
-            duration = yapiGetTickCount() - startwait;
-            if (duration > wait_for_start) {
-                dbglog("Last request in not finished after %"FMTu64" ms\n", duration);
-#ifdef TRACE_TCP_REQ
-                dumpTCPReq(__FILE_ID__, __LINE__, req);
-#endif
-                return YERRMSG(YAPI_TIMEOUT, "last TCP request is not finished");
-            }
-            yWaitForEvent(&req->finished, 100);
-            yEnterCriticalSection(&req->access);
-        }
-        YPERF_TCP_LEAVE(TCPOpenReq_wait);
-    }
-
-
-    req->flags = 0;
-    if (request[0] == 'G' && request[1] == 'E' && request[2] == 'T') {
-        //for GET request discard all except the first line
-        for (i = 0; i < reqlen; i++) {
-            if (request[i] == '\r') {
-                reqlen = i;
-                break;
-            }
-        }
-        if (i > 3) {
-            if (request[i - 3] == '&' && request[i - 2] == '.' && request[i - 1] == ' ') {
-                req->flags |= TCPREQ_KEEPALIVE;
-            }
-        }
-        req->bodysize = 0;
-    } else {
-        const char* p = request;
-        int bodylen = reqlen - 4;
-
-        while (bodylen > 0 && (p[0] != '\r' || p[1] != '\n' ||
-            p[2] != '\r' || p[3] != '\n')) {
-            p++;
-            bodylen--;
-        }
-        p += 4;
-        reqlen = (int)(p - request);
-        // Build a request body buffer
-        if (req->bodybufsize < bodylen) {
-            if (req->bodybuf) yFree(req->bodybuf);
-            req->bodybufsize = bodylen + (bodylen >> 1);
-            req->bodybuf = (char*)yMalloc(req->bodybufsize);
-        }
-        memcpy(req->bodybuf, p, bodylen);
-        req->bodysize = bodylen;
-    }
-    // Build a request buffer with at least a terminal NUL but
-    // include space for Connection: close and Authorization: headers
-    minlen = reqlen + 400;
-    if (req->headerbufsize < minlen) {
-        if (req->headerbuf) yFree(req->headerbuf);
-        req->headerbufsize = minlen + (reqlen >> 1);
-        req->headerbuf = (char*)yMalloc(req->headerbufsize);
-    }
-    memcpy(req->headerbuf, request, reqlen);
-    req->headerbuf[reqlen] = 0;
-    req->retryCount = 0;
-    req->callback = callback;
-    req->context = context;
-    req->progressCb = progress_cb;
-    req->progressCtx = progress_ctx;
-    req->read_tm = req->write_tm = req->open_tm = yapiGetTickCount();
-    req->timeout_tm = mstimeout;
-    req->state = REQ_OPEN;
-
-
-    // Really build and send the request
-    if (req->proto == PROTO_AUTO || req->proto == PROTO_HTTP) {
-        res = yHTTPOpenReqEx(req, mstimeout, errmsg);
-    } else {
-        res = yWSOpenReqEx(req, tcpchan, mstimeout, errmsg);
-    }
-    if (res == YAPI_SUCCESS) {
-        req->errmsg[0] = '\0';
-        req->flags |= TCPREQ_IN_USE;
-        yResetEvent(&req->finished);
-    }
-
-    yLeaveCriticalSection(&req->access);
-
-    YPERF_TCP_LEAVE(TCPOpenReq);
-    return res;
-}
-
-int yReqSelect(struct _RequestSt* tcpreq, u64 ms, char* errmsg)
-{
-    if (tcpreq->proto == PROTO_AUTO || tcpreq->proto == PROTO_HTTP) {
-        return yHTTPMultiSelectReq(&tcpreq, 1, ms, NULL, errmsg);
-    } else {
-        return yWSSelectReq(tcpreq, ms, errmsg);
-    }
-}
-
-int yReqMultiSelect(struct _RequestSt** tcpreq, int size, u64 ms, WakeUpSocket* wuce, char* errmsg)
-{
-    // multi select make no sense in WebSocket since all data come from the same socket
-    return yHTTPMultiSelectReq(tcpreq, size, ms, wuce, errmsg);
-}
-
-
-int yReqIsEof(struct _RequestSt* req, char* errmsg)
-{
-    int res;
-    yEnterCriticalSection(&req->access);
-    if (req->errcode == YAPI_NO_MORE_DATA) {
-        res = 1;
-    } else if (req->errcode == 0) {
-        res = req->errcode = yTcpCheckReqTimeout(req, errmsg);
-    } else if (req->errcode == YAPI_UNAUTHORIZED) {
-        res = YERRMSG((YRETCODE) req->errcode, "Access denied, authorization required");
-    } else {
-        res = YERRMSG((YRETCODE) req->errcode, req->errmsg);
-    }
-    yLeaveCriticalSection(&req->access);
-    return res;
-}
-
-
-int yReqGet(struct _RequestSt* req, u8** buffer)
-{
-    int avail;
-
-    yEnterCriticalSection(&req->access);
-    yTcpCheckReqTimeout(req, req->errmsg);
-    if (req->replypos < 0) {
-        // data is not yet ready to consume (still processing header)
-        avail = 0;
-    } else {
-        avail = req->replysize - req->replypos;
-        if (buffer) {
-            *buffer = req->replybuf + req->replypos;
-        }
-    }
-    yLeaveCriticalSection(&req->access);
-
-    return avail;
-}
-
-
-int yReqRead(struct _RequestSt* req, u8* buffer, int len)
-{
-    int avail;
-
-    yEnterCriticalSection(&req->access);
-    yTcpCheckReqTimeout(req, req->errmsg);
-    if (req->replypos < 0) {
-        // data is not yet ready to consume (still processing header)
-        len = 0;
-    } else {
-        avail = req->replysize - req->replypos;
-        if (len > avail) {
-            len = avail;
-        }
-        if (len && buffer) {
-            memcpy(buffer, req->replybuf + req->replypos, len);
-        }
-        if (req->replypos + len == req->replysize) {
-            req->replypos = 0;
-            req->replysize = 0;
-            if (req->proto == PROTO_WEBSOCKET) {
-                if (req->state == REQ_CLOSED || req->state == REQ_CLOSED_BY_HUB) {
-                    req->errcode = YAPI_NO_MORE_DATA;
-                }
-            }
-
-        } else {
-            req->replypos += len;
-        }
-    }
-    yLeaveCriticalSection(&req->access);
-
-    return len;
-}
-
-
-void yReqClose(struct _RequestSt* req)
-{
-    TCPLOG("yTcpCloseReq %p\n", req);
-#if 0
-    {
-        u64 now = yapiGetTickCount();
-        u64 duration = now - req->open_tm;
-        u64 last_wr = req->write_tm - req->open_tm;
-        u64 last_rd = req->read_tm - req->open_tm;
-
-        dbglog("request %p  total=%"FMTu64"ms (read=%"FMTu64"ms write=%"FMTu64")\n",
-            req, duration, last_rd, last_wr);
-    }
-#endif
-    yEnterCriticalSection(&req->access);
-    if (req->flags & TCPREQ_IN_USE) {
-
-        if (req->proto == PROTO_AUTO || req->proto == PROTO_HTTP) {
-            yHTTPCloseReqEx(req, 0);
-        } else {
-#if 0
-            u64 last = req->ws.last_write_tm - req->open_tm;
-            u64 first = req->ws.first_write_tm - req->open_tm;
-
-            dbglog("request.ws %p first_write=%"FMTu64"ms last_write=%"FMTu64")\n",
-                req, first, last);
-#endif
-            yWSCloseReqEx(req, 1);
-        }
-        req->flags &= ~TCPREQ_IN_USE;
-    }
-    yLeaveCriticalSection(&req->access);
-}
-
-
-int yReqIsAsync(struct _RequestSt* req)
-{
-    int res;
-    yEnterCriticalSection(&req->access);
-    res = (req->flags & TCPREQ_IN_USE) && (req->callback != NULL);
-    yLeaveCriticalSection(&req->access);
-    return res;
-}
-
-
-void yReqFree(struct _RequestSt* req)
-{
-    TCPLOG("yTcpFreeReq %p\n",req);
-    if (req->proto == PROTO_AUTO || req->proto == PROTO_HTTP) {
-        if (req->http.skt != INVALID_SOCKET) {
-            yTcpClose(req->http.skt);
-        }
-        if (req->http.reuseskt != INVALID_SOCKET) {
-            yTcpClose(req->http.reuseskt);
-        }
-    } else {
-        if (req->ws.requestbuf) yFree(req->ws.requestbuf);
-    }
-    if (req->headerbuf) yFree(req->headerbuf);
-    if (req->bodybuf) yFree(req->bodybuf);
-    if (req->replybuf) yFree(req->replybuf);
-    yCloseEvent(&req->finished);
-    yDeleteCriticalSection(&req->access);
-    yFree(req);
-    //memset(req, 0, sizeof(struct _RequestSt));
-}
-
-
-int yReqHasPending(struct _HubSt* hub)
-{
-    int i;
-    RequestSt* req = NULL;
-
-    if (hub->proto == PROTO_AUTO || hub->proto == PROTO_HTTP) {
-        for (i = 0; i < ALLOC_YDX_PER_HUB; i++) {
-            req = yContext->tcpreq[i];
-            if (req && yReqIsAsync(req)) {
-                return 1;
-            }
-        }
-    } else {
-        int tcpchan;
-        for (tcpchan = 0; tcpchan < MAX_ASYNC_TCPCHAN; tcpchan++) {
-            yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-            if (hub->ws.chan[tcpchan].requests) {
-                req = hub->ws.chan[tcpchan].requests;
-                while (req && req->ws.requestsize == req->ws.requestpos && req->state == REQ_CLOSED) {
-                    req = req->ws.next;
-                }
-                if (req != NULL) {
-                    //dbglog("still request pending on hub %s (%p)\n", hub->name, req);
-                    yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-                    return 1;
-                }
-            }
-            yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-        }
-    }
-    return 0;
-}
-
-
-/********************************************************************************
-* WebSocket functions
-*******************************************************************************/
-
-static const char* ws_header_start = " HTTP/1.1\r\nSec-WebSocket-Version: 13\r\nUser-Agent: Yoctopuce\r\nSec-WebSocket-Key: ";
-static const char* ws_header_end = "\r\nConnection: keep-alive, Upgrade\r\nUpgrade: websocket\r\n\r\n";
-
-#define YRand32() rand()
-
-/*****************************************************************************
-Function:
-WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen,
-BYTE* cDestData, WORD wDestLen)
-
-Description:
-Encodes a binary array to Base-64.
-
-Precondition:
-None
-
-Parameters:
-cSourceData - Pointer to a string of binary data
-wSourceLen  - Length of the binary source data
-cDestData   - Pointer to write the Base-64 encoded data
-wDestLen    - Maximum length that can be written to cDestData
-
-Returns:
-Number of encoded bytes written to cDestData.  This will always be
-a multiple of 4.
-
-Remarks:
-Encoding cannot be performed in-place.  If cSourceData overlaps with
-cDestData, the behavior is undefined.
-
-Encoded data is always at least 1/3 larger than the source data.  It may
-be 1 or 2 bytes larger than that.
-***************************************************************************/
-static u16 Base64Encode(const u8* cSourceData, u16 wSourceLen, u8* cDestData, u16 wDestLen)
-{
-    u8 i, j;
-    u8 vOutput[4];
-    u16 wOutputLen;
-
-    wOutputLen = 0;
-    while (wDestLen >= 4u) {
-        // Start out treating the output as all padding
-        vOutput[0] = 0xFF;
-        vOutput[1] = 0xFF;
-        vOutput[2] = 0xFF;
-        vOutput[3] = 0xFF;
-
-        // Get 3 input octets and split them into 4 output hextets (6-bits each)
-        if (wSourceLen == 0u)
-            break;
-        i = *cSourceData++;
-        wSourceLen--;
-        vOutput[0] = (i & 0xFC) >> 2;
-        vOutput[1] = (i & 0x03) << 4;
-        if (wSourceLen) {
-            i = *cSourceData++;
-            wSourceLen--;
-            vOutput[1] |= (i & 0xF0) >> 4;
-            vOutput[2] = (i & 0x0F) << 2;
-            if (wSourceLen) {
-                i = *cSourceData++;
-                wSourceLen--;
-                vOutput[2] |= (i & 0xC0) >> 6;
-                vOutput[3] = i & 0x3F;
-            }
-        }
-
-        // Convert hextets into Base 64 alphabet and store result
-        for (i = 0; i < 4u; i++) {
-            j = vOutput[i];
-
-            if (j <= 25u)
-                j += 'A' - 0;
-            else if (j <= 51u)
-                j += 'a' - 26;
-            else if (j <= 61u)
-                j += '0' - 52;
-            else if (j == 62u)
-                j = '+';
-            else if (j == 63u)
-                j = '/';
-            else // Padding
-                j = '=';
-
-            *cDestData++ = j;
-        }
-
-        // Update counters
-        wDestLen -= 4;
-        wOutputLen += 4;
-    }
-
-    return wOutputLen;
-}
-
-
-/********************************************************************************
-* WebSocket internal function
-*******************************************************************************/
-
-
-//todo: factorize  GenereateWebSockeyKey + VerifyWebsocketKey
-
-// compute a new nonce for http request
-// the buffer passed as argument must be at least 28 bytes long
-static int GenereateWebSockeyKey(const u8* url, u32 urllen, char* buffer)
-{
-    u32 salt[2];
-    HASH_SUM ctx;
-    u8 rawbuff[16];
-
-    // Our nonce is base64_encoded [ MD5( Rand32,(ytime^Rand), ) ]
-    salt[0] = YRand32();
-    salt[1] = yapiGetTickCount() & 0xff;
-    MD5Initialize(&ctx);
-    MD5AddData(&ctx, (u8*)salt, 2);
-    MD5AddData(&ctx, url, urllen);
-    MD5Calculate(&ctx, rawbuff);
-    return Base64Encode(rawbuff, 16, (u8*)buffer, 28);
-}
-
-
-static int VerifyWebsocketKey(const char* data, u16 hdrlen, const char* reference, u16 reference_len)
-{
-    u8 buf[80];
-    const char* magic = YOCTO_WEBSOCKET_MAGIC;
-    u8* sha1;
-
-    // compute correct key
-    if (hdrlen >= sizeof(buf)) {
-#ifndef MICROCHIP_API
-        dbglog("Bad WebSocket header (%d)\n", hdrlen);
-#else
-        ylog("WS!");
-#endif
-        return 0;
-    }
-    memcpy(buf, reference, reference_len);
-#ifdef USE_FAR_YFSTR
-    apiGetStr(magic.hofs, (char*)buf + CbCtx.websocketkey.len);
-#else
-    memcpy(buf + reference_len, magic, YOCTO_WEBSOCKET_MAGIC_LEN + 1);
-#endif
-    sha1 = ySHA1((char *)buf);
-    Base64Encode(sha1, 20, buf, 80);
-    if (memcmp(buf, data, hdrlen) == 0) {
-        return 1;
-    }
-    return 0;
-}
-
-
-#define WS_CONNEXION_TIMEOUT 10000
-#define WS_MAX_DATA_LEN  124
-
-
-/*
-*   send WebSocket frame for a hub
-*/
-static int ws_sendFrame(HubSt* hub, int stream, int tcpchan, const u8* data, int datalen, char* errmsg)
-{
-    u32 buffer_32[33];
-    u32 mask;
-    int i;
-    WSStreamHead strym;
-    u8* p = (u8*)buffer_32;
-#ifdef DEBUG_SLOW_TCP
-    u64 start = yapiGetTickCount();
-#endif
-    int tcp_write_res;
-
-    YASSERT(datalen <= WS_MAX_DATA_LEN);
-#ifdef DEBUG_WEBSOCKET
-    // disable masking for debugging
-    mask = 0;
-#else
-    mask = YRand32();
-#endif
-    // do not start at offset zero on purpose
-    // we want the buffer to be aligned on u32
-    p[0] = 0x82;
-    p[1] = (u8)(datalen + 1) | 0x80;;
-    p[2] = ((u8*)&mask)[2];
-    p[3] = ((u8*)&mask)[3];
-
-    p[4] = ((u8*)&mask)[0];
-    p[5] = ((u8*)&mask)[1];
-    strym.tcpchan = tcpchan;
-    strym.stream = stream;
-    p[6] = strym.encaps ^ p[2];
-    if (datalen) {
-        p[7] = *data ^ p[3];
-    }
-    if (datalen > 1) {
-        memcpy(buffer_32 + 2, data + 1, datalen - 1);
-        for (i = 0; i < (datalen - 1 + 3) >> 2; i++) {
-            buffer_32[i + 2] ^= mask;
-        }
-    }
-    tcp_write_res = yTcpWrite(hub->ws.skt, (char*)p, datalen + 7, errmsg);
-#ifdef DEBUG_SLOW_TCP
-    u64 delta = yapiGetTickCount() - start;
-    if (delta > 10) {
-        dbglog("WS: yTcpWrite took %"FMTu64"ms (stream=%d chan=%d res=%d)\n", delta, strym.stream, strym.tcpchan, tcp_write_res);
-    }
-#endif
-    return tcp_write_res;
-}
-
-/*
-*   send authentication meta
-*/
-static int ws_sendAuthenticationMeta(HubSt* hub, char* errmsg)
-{
-    USB_Meta_Pkt meta_out;
-    memset(&meta_out, 0, sizeof(USB_Meta_Pkt));
-    meta_out.auth.metaType = USB_META_WS_AUTHENTICATION;
-
-#if 1
-    if (hub->ws.remoteVersion < USB_META_WS_PROTO_V2) {
-        meta_out.auth.version = USB_META_WS_PROTO_V1;
-    } else {
-        meta_out.auth.version = USB_META_WS_PROTO_V2;
-    }
-#else
-    meta_out.auth.version = USB_META_WS_PROTO_V1;
-#endif
-    if (hub->ws.user != INVALID_HASH_IDX && hub->ws.pass != INVALID_HASH_IDX) {
-        u8 ha1[16];
-        const char* user = yHashGetStrPtr(hub->ws.user);
-        const char* pass = yHashGetStrPtr(hub->ws.pass);
-        meta_out.auth.flags = USB_META_WS_AUTH_FLAGS_VALID;
-        meta_out.auth.nonce = INTEL_U32(hub->ws.nounce);
-        ComputeAuthHA1(ha1, user, pass, hub->ws.serial);
-        CheckWSAuth(hub->ws.remoteNounce, ha1, NULL, meta_out.auth.sha1);
-    }
-    return ws_sendFrame(hub,YSTREAM_META, 0, (const u8*)&meta_out, USB_META_WS_AUTHENTICATION_SIZE, errmsg);
-}
-
-static void ws_appendTCPData(RequestSt* req, u8* buffer, int pktlen, int isClose)
-{
-    if (pktlen) {
-        if (req->replybufsize < req->replysize + pktlen) {
-            u8* newbuff;
-            req->replybufsize <<= 1;
-            newbuff = yMalloc(req->replybufsize);
-            memcpy(newbuff, req->replybuf, req->replysize);
-            yFree(req->replybuf);
-            req->replybuf = newbuff;
-        }
-
-        memcpy(req->replybuf + req->replysize, buffer, pktlen);
-        req->replysize += pktlen;
-    }
-    req->read_tm = yapiGetTickCount();
-    if (isClose) {
-        yEnterCriticalSection(&req->access);
-        req->state = REQ_CLOSED;
-        yLeaveCriticalSection(&req->access);
-        ySetEvent(&req->finished);
-        if (req->callback != NULL) {
-            // async request are automatically closed
-            yWSCloseReqEx(req, 0);
-            yReqFree(req);
-        }
-    }
-}
-
-/*
-*   ws_parseIncomingFrame parse incoming WebSocket frame
-*/
-static int ws_parseIncomingFrame(HubSt* hub, u8* buffer, int pktlen, char* errmsg)
-{
-    WSStreamHead strym;
-    RequestSt* req;
-    int flags;
-    const char* user;
-    const char* pass;
-    int maxtcpws;
-#ifdef DEBUG_WEBSOCKET
-    u64 reltime = yapiGetTickCount() - hub->ws.connectionTime;
-#endif
-
-    YASSERT(pktlen > 0);
-    strym.encaps = buffer[0];
-    buffer++;
-    pktlen--;
-    switch (strym.stream) {
-    case YSTREAM_TCP_NOTIF:
-        if (pktlen > 0) {
-#if 0
-        {
-                FILE *f;
-                //printf("%s", buffer);
-                YASSERT(YFOPEN(&f, "req_trace\\api_not.txt", "ab") == 0);
-                fwrite(buffer, 1, pktlen, f);
-                fclose(f);
-            }
-#endif
-            yPushFifo(&hub->not_fifo, buffer, pktlen);
-            while (handleNetNotification(hub));
-        }
-        break;
-    case YSTREAM_EMPTY:
-        return YAPI_SUCCESS;
-    case YSTREAM_TCP_ASYNCCLOSE:
-        yEnterCriticalSection(&hub->ws.chan[strym.tcpchan].access);
-        req = hub->ws.chan[strym.tcpchan].requests;
-        while (req != NULL && req->state != REQ_OPEN && req->state != REQ_CLOSED_BY_HUB) {
-            req = req->ws.next;
-        }
-#if 0
-        {
-            char dump_buf[512];
-            dumpbin(dump_buf,buffer, pktlen);
-            dump_buf[pktlen] = 0;
-            WSLOG("use(%p):%s\n", req, dump_buf);
-        }
-#endif
-        if (req == NULL) {
-            dbglog("Drop incoming TCP traffic on channel (%d/%d)\n", strym.stream, strym.tcpchan);
-        } else {
-            int asyncid = buffer[pktlen - 1];
-            pktlen--;
-            if (req->ws.asyncId != asyncid) {
-                YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "WS: Incorrect async-close signature on tcpChan %d %p (%d:%d)\n", strym.tcpchan, req, req->ws.asyncId, asyncid);
-                //dumpReqQueue("recv",hub, strym.tcpchan);
-                yLeaveCriticalSection(&hub->ws.chan[strym.tcpchan].access);
-                return YAPI_IO_ERROR;
-            }
-            WSLOG("req(%s:%p) close async %d\n", req->hub->name, req, req->ws.asyncId);
-            ws_appendTCPData(req, buffer, pktlen, 1);
-        }
-        yLeaveCriticalSection(&hub->ws.chan[strym.tcpchan].access);
-        break;
-    case YSTREAM_TCP:
-    case YSTREAM_TCP_CLOSE:
-        yEnterCriticalSection(&hub->ws.chan[strym.tcpchan].access);
-        req = hub->ws.chan[strym.tcpchan].requests;
-        while (req != NULL && req->state != REQ_OPEN && req->state != REQ_CLOSED_BY_HUB) {
-            req = req->ws.next;
-        }
-#if 0
-        {
-            char dump_buf[512];
-            dumpbin(dump_buf,buffer, pktlen);
-            dump_buf[pktlen] = 0;
-            WSLOG("use(%p):%s\n", req, dump_buf);
-        }
-#endif
-        if (req == NULL) {
-            dbglog("Drop incoming TCP traffic on channel (%d/%d)\n", strym.stream, strym.tcpchan);
-        } else {
-            if (strym.stream == YSTREAM_TCP_CLOSE) {
-                int res = ws_sendFrame(hub, YSTREAM_TCP_CLOSE, strym.tcpchan, NULL, 0, errmsg);
-                if (res < 0) {
-                    WSLOG("req(%s:%p) unable to ack remote close (%d/%s)\n", req->hub->name, req, res, errmsg);
-                }
-                //WSLOG("req(%s:%p) close\n", req->hub->name, req);
-            }
-            ws_appendTCPData(req, buffer, pktlen, strym.stream == YSTREAM_TCP_CLOSE);
-        }
-        yLeaveCriticalSection(&hub->ws.chan[strym.tcpchan].access);
-        break;
-    case YSTREAM_META: {
-        USB_Meta_Pkt* meta = (USB_Meta_Pkt*)(buffer);
-        //WSLOG("%"FMTu64": META type=%d len=%d\n",reltime, meta->announce.metaType, pktlen);
-        switch (meta->announce.metaType) {
-        case USB_META_WS_ANNOUNCE:
-            if (meta->announce.version < USB_META_WS_PROTO_V1 || pktlen < USB_META_WS_ANNOUNCE_SIZE) {
-                return YAPI_SUCCESS;
-            }
-            hub->ws.remoteVersion = meta->announce.version;
-            hub->ws.remoteNounce = INTEL_U32(meta->announce.nonce);
-            maxtcpws = INTEL_U16(meta->announce.maxtcpws);
-            if (maxtcpws > 0) {
-                hub->ws.tcpMaxWindowSize = maxtcpws;
-            }
-            YSTRCPY(hub->ws.serial, YOCTO_SERIAL_LEN, meta->announce.serial);
-            WSLOG("hub(%s) Announce: %s (v%d / %x)\n", hub->name, meta->announce.serial, meta->announce.version, hub->ws.remoteNounce);
-            hub->ws.nounce = YRand32();
-            hub->ws.base_state = WS_BASE_AUTHENTICATING;
-            hub->ws.connectionTime = yapiGetTickCount();
-            return ws_sendAuthenticationMeta(hub, errmsg);
-        case USB_META_WS_AUTHENTICATION:
-            if (hub->ws.base_state != WS_BASE_AUTHENTICATING)
-                return YAPI_SUCCESS;
-            if (meta->auth.version < USB_META_WS_PROTO_V1 || (u32)pktlen < USB_META_WS_AUTHENTICATION_SIZE) {
-                return YAPI_SUCCESS;
-            }
-            hub->ws.tcpRoundTripTime = (u32)(yapiGetTickCount() - hub->ws.connectionTime + 1);
-            if (hub->ws.tcpMaxWindowSize < 2048 && hub->ws.tcpRoundTripTime < 7) {
-                // Fix overly optimistic round-trip on YoctoHubs
-                hub->ws.tcpRoundTripTime = 7;
-            }
-#ifdef DEBUG_WEBSOCKET
-            {
-                int uploadRate = hub->ws.tcpMaxWindowSize * 1000 / hub->ws.tcpRoundTripTime;
-                dbglog("RTT=%dms, WS=%d, uploadRate=%f KB/s\n", hub->ws.tcpRoundTripTime, hub->ws.tcpMaxWindowSize, uploadRate/1000.0);
-            }
-#endif
-
-            flags = meta->auth.flags;
-            if ((flags & USB_META_WS_AUTH_FLAGS_RW) != 0) {
-                hub->rw_access = 1;
-            }
-            if (hub->ws.user != INVALID_HASH_IDX) {
-                user = yHashGetStrPtr(hub->ws.user);
-            } else {
-                user = "";
-            }
-
-            if (hub->ws.pass != INVALID_HASH_IDX) {
-                pass = yHashGetStrPtr(hub->ws.pass);
-            } else {
-                pass = "";
-            }
-            if ((flags & USB_META_WS_AUTH_FLAGS_VALID) != 0) {
-                u8 ha1[16];
-                ComputeAuthHA1(ha1, user, pass, hub->ws.serial);
-                if (CheckWSAuth(hub->ws.nounce, ha1, meta->auth.sha1, NULL)) {
-                    hub->ws.base_state = WS_BASE_CONNECTED;
-                    hub->state = NET_HUB_ESTABLISHED;
-                    hub->retryCount = 0;
-                    hub->attemptDelay = 500;
-                    WSLOG("hub(%s): connected as %s\n", hub->name, user);
-                } else {
-                    YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Authentication as %s failed (%s:%d)", user, __FILE_ID__, __LINE__);
-                    return YAPI_UNAUTHORIZED;
-                }
-            } else {
-                if (hub->ws.user == INVALID_HASH_IDX) {
-                    hub->ws.base_state = WS_BASE_CONNECTED;
-                    hub->state = NET_HUB_ESTABLISHED;
-                    hub->retryCount = 0;
-                    hub->attemptDelay = 500;
-                    WSLOG("hub(%s): connected\n",hub->name);
-                } else {
-                    if (YSTRCMP(user,"admin") == 0 && !hub->rw_access) {
-                        YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Authentication as %s failed", user);
-                    } else {
-                        YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Authentication error : hub has no password for %s", user);
-                    }
-                    return YAPI_UNAUTHORIZED;
-                }
-            }
-            break;
-        case USB_META_WS_ERROR:
-            if (INTEL_U16(meta->error.htmlcode) == 401) {
-                return YERR(YAPI_UNAUTHORIZED);
-            } else {
-                YSPRINTF(errmsg, YOCTO_ERRMSG_LEN, "Remote hub closed connection with error %d", INTEL_U16(meta->error.htmlcode));
-                return YAPI_IO_ERROR;
-            }
-        case USB_META_ACK_UPLOAD: {
-            int tcpchan = meta->uploadAck.tcpchan;
-            yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-            req = hub->ws.chan[tcpchan].requests;
-            while (req != NULL && req->state != REQ_OPEN && req->state != REQ_CLOSED_BY_HUB) {
-                req = req->ws.next;
-            }
-            if (req) {
-                u32 ackBytes = meta->uploadAck.totalBytes[0] + (meta->uploadAck.totalBytes[1] << 8) + (meta->uploadAck.totalBytes[2] << 16) + (meta->uploadAck.totalBytes[3] << 24);
-                u64 ackTime = yapiGetTickCount();
-                if (hub->ws.chan[tcpchan].lastUploadAckTime && ackBytes > hub->ws.chan[tcpchan].lastUploadAckBytes) {
-                    int deltaBytes;
-                    u64 deltaTime;
-                    u32 newRate;
-                    hub->ws.chan[tcpchan].lastUploadAckBytes = ackBytes;
-                    hub->ws.chan[tcpchan].lastUploadAckTime = ackTime;
-
-                    deltaBytes = ackBytes - hub->ws.chan[tcpchan].lastUploadRateBytes;
-                    deltaTime = ackTime - hub->ws.chan[tcpchan].lastUploadRateTime;
-                    WSLOG("delta  bytes=%d  time=%"FMTu64"ms\n",deltaBytes, deltaTime);
-                    if (deltaTime < 500) {
-                        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-                        break; // wait more
-                    }
-                    if (deltaTime < 1000 && deltaBytes < 65536) {
-                        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-                        break; // wait more
-                    }
-                    hub->ws.chan[tcpchan].lastUploadRateBytes = ackBytes;
-                    hub->ws.chan[tcpchan].lastUploadRateTime = ackTime;
-                    if (req->progressCb && req->ws.requestsize) {
-                        req->progressCb(req->progressCtx, ackBytes, req->ws.requestsize);
-                    }
-                    newRate = (u32)(deltaBytes * 1000 / deltaTime);
-                    hub->ws.uploadRate = (u32)(0.8 * hub->ws.uploadRate + 0.3 * newRate);
-                    WSLOG("New rate: %.2f KB/s (based on %.2f KB in %.2fs)\n", hub->ws.uploadRate / 1000.0, deltaBytes / 1000.0, deltaTime / 1000.0);
-                } else {
-                    WSLOG("First ack received (rate=%d)\n", hub->ws.uploadRate);
-                    hub->ws.chan[tcpchan].lastUploadAckBytes = ackBytes;
-                    hub->ws.chan[tcpchan].lastUploadAckTime = ackTime;
-                    hub->ws.chan[tcpchan].lastUploadRateBytes = ackBytes;
-                    hub->ws.chan[tcpchan].lastUploadRateTime = ackTime;
-                    if (req->progressCb && req->ws.requestsize) {
-                        req->progressCb(req->progressCtx, ackBytes, req->ws.requestsize);
-                    }
-                }
-            }
-            yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-        }
-        break;
-        default:
-            WSLOG("unhandled Meta pkt %d\n", meta->announce.metaType);
-            break;
-        }
-    }
-    break;
-    case YSTREAM_NOTICE:
-    case YSTREAM_REPORT:
-    case YSTREAM_REPORT_V2:
-    case YSTREAM_NOTICE_V2:
-    default:
-        dbglog("Invalid WS stream type (%d)\n", strym.stream);
-    }
-    return YAPI_SUCCESS;
-}
-
-// return 1 if there is still a request pending, 0 if all is done, -1 on error
-static int ws_requestStillPending(HubSt* hub)
-{
-    int tcpchan;
-    for (tcpchan = 0; tcpchan < MAX_ASYNC_TCPCHAN; tcpchan++) {
-        RequestSt* req = NULL;
-        yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-        req = hub->ws.chan[tcpchan].requests;
-        while (req && req->state == REQ_CLOSED) {
-            req = req->ws.next;
-        }
-        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-        if (req) {
-            return 1;
-        }
-    }
-    return 0;
-}
-
-
-static RequestSt* getNextReqToSend(HubSt* hub, int tcpchan)
-{
-    RequestSt* req = hub->ws.chan[tcpchan].requests;
-    while (req) {
-        if (req->ws.requestpos < req->ws.requestsize && req->state == REQ_OPEN) {
-            return req;
-        }
-        if (req->ws.asyncId) {
-            req = req->ws.next;
-        } else {
-            return NULL;
-        }
-    }
-
-    return req;
-}
-
-/*
-*   look through all pending request if there is some data that we can send
-*
-*/
-static int ws_processRequests(HubSt* hub, char* errmsg)
-{
-    int tcpchan;
-    int res;
-
-    if (hub->ws.next_transmit_tm && hub->ws.next_transmit_tm > yapiGetTickCount()) {
-        //u64 wait = hub->ws.next_transmit_tm - yapiGetTickCount();
-        //WSLOG("skip reqProcess for %"FMTu64" ms\n", wait);
-        return YAPI_SUCCESS;
-    }
-
-    for (tcpchan = 0; tcpchan < MAX_ASYNC_TCPCHAN; tcpchan++) {
-        yEnterCriticalSection(&hub->ws.chan[tcpchan].access);
-        if (hub->ws.chan[tcpchan].requests) {
-            RequestSt* req;
-            while ((req = getNextReqToSend(hub, tcpchan)) != NULL) {
-                int throttle_start = req->ws.requestpos;
-                int throttle_end = req->ws.requestsize;
-                if (throttle_end > 2108 && hub->ws.remoteVersion >= USB_META_WS_PROTO_V2 && tcpchan == 0) {
-                    // Perform throttling on large uploads
-                    if (req->ws.requestpos == 0) {
-                        // First chunk is always first multiple of full window (124 bytes) above 2KB
-                        throttle_end = 2108;
-                        // Prepare to compute effective transfer rate
-                        hub->ws.chan[tcpchan].lastUploadAckBytes = 0;
-                        hub->ws.chan[tcpchan].lastUploadAckTime = 0;
-                        // Start with initial RTT based estimate
-                        hub->ws.uploadRate = hub->ws.tcpMaxWindowSize * 1000 / hub->ws.tcpRoundTripTime;
-                    } else if (hub->ws.chan[tcpchan].lastUploadAckTime == 0) {
-                        // first block not yet acked, wait more
-                        //WSLOG("wait for first ack");
-                        throttle_end = 0;
-                    } else {
-                        // adapt window frame to available bandwidth
-                        int bytesOnTheAir = req->ws.requestpos - hub->ws.chan[tcpchan].lastUploadAckBytes;
-                        u32 uploadRate = hub->ws.uploadRate;
-                        u64 timeOnTheAir = (yapiGetTickCount() - hub->ws.chan[tcpchan].lastUploadAckTime);
-                        u64 toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + (uploadRate * timeOnTheAir / 1000);
-                        if (toBeSent + bytesOnTheAir > DEFAULT_TCP_MAX_WINDOW_SIZE) {
-                            toBeSent = DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
-                        }
-                        WSLOG("throttling: %d bytes/s (%"FMTu64" + %d = %"FMTu64")\n", hub->ws.uploadRate, toBeSent, bytesOnTheAir, bytesOnTheAir + toBeSent);
-                        if (toBeSent < 64) {
-                            u64 waitTime = 1000 * (128 - toBeSent) / hub->ws.uploadRate;
-                            if (waitTime < 2) waitTime = 2;
-                            hub->ws.next_transmit_tm = yapiGetTickCount() + waitTime;
-                            WSLOG("WS: %d sent %"FMTu64"ms ago, waiting %"FMTu64"ms...\n", bytesOnTheAir, timeOnTheAir, waitTime);
-                            throttle_end = 0;
-                        }
-                        if (throttle_end > req->ws.requestpos + toBeSent) {
-                            // when sending partial content, round up to full frames
-                            if (toBeSent > 124) {
-                                toBeSent = (toBeSent / 124) * 124;
-                            }
-                            throttle_end = req->ws.requestpos + (u32)toBeSent;
-                        }
-                    }
-                }
-                while (req->ws.requestpos < throttle_end) {
-                    int stream = YSTREAM_TCP;
-                    int datalen = throttle_end - req->ws.requestpos;
-                    if (datalen > WS_MAX_DATA_LEN) {
-                        datalen = WS_MAX_DATA_LEN;
-                    }
-                    if (req->ws.requestpos == 0) {
-                        req->ws.first_write_tm = yapiGetTickCount();
-                    }
-
-                    if (req->ws.asyncId && (req->ws.requestpos + datalen == req->ws.requestsize)) {
-                        // last frame of an async request
-                        u8 tmp_data[128];
-
-                        if (datalen == WS_MAX_DATA_LEN) {
-                            // last frame is already full we must send the async close in another one
-                            res = ws_sendFrame(hub, stream, tcpchan, req->ws.requestbuf + req->ws.requestpos, datalen, errmsg);
-                            if (YISERR(res)) {
-                                req->errcode = res;
-                                YSTRCPY(req->errmsg, YOCTO_ERRMSG_LEN, errmsg);
-                                yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-                                ySetEvent(&req->finished);
-                                return res;
-                            }
-                            WSLOG("ws_req:%p: send %d bytes on chan%d (%d/%d)\n", req, datalen, tcpchan, req->ws.requestpos, req->ws.requestsize);
-                            req->ws.requestpos += datalen;
-                            datalen = 0;
-                        }
-                        stream = YSTREAM_TCP_ASYNCCLOSE;
-                        if (datalen) {
-                            memcpy(tmp_data, req->ws.requestbuf + req->ws.requestpos, datalen);
-                        }
-                        tmp_data[datalen] = req->ws.asyncId;
-                        res = ws_sendFrame(hub, stream, tcpchan, tmp_data, datalen + 1, errmsg);
-                        WSLOG("req(%s:%p) sent async close chan%d:%d\n", req->hub->name, req, tcpchan,req->ws.asyncId);
-                        //dumpReqQueue("as_c", req->hub, tcpchan);
-                        req->ws.last_write_tm = yapiGetTickCount();
-                    } else {
-                        res = ws_sendFrame(hub, stream, tcpchan, req->ws.requestbuf + req->ws.requestpos, datalen, errmsg);
-                        req->ws.last_write_tm = yapiGetTickCount();
-                        //WSLOG("ws_req:%p: sent %d bytes on chan%d (%d/%d)\n", req, datalen, tcpchan, req->ws.requestpos, req->ws.requestsize);
-                    }
-                    if (YISERR(res)) {
-                        req->errcode = res;
-                        YSTRCPY(req->errmsg, YOCTO_ERRMSG_LEN, errmsg);
-                        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-                        ySetEvent(&req->finished);
-                        return res;
-                    }
-                    req->ws.requestpos += datalen;
-                }
-                if (req->ws.requestpos < req->ws.requestsize) {
-                    int sent = req->ws.requestpos - throttle_start;
-                    // not completely sent, cannot do more for now
-                    if (sent && hub->ws.uploadRate > 0) {
-                        u64 waitTime = 1000 * sent / hub->ws.uploadRate;
-                        if (waitTime < 2) waitTime = 2;
-                        hub->ws.next_transmit_tm = yapiGetTickCount() + waitTime;
-                        WSLOG("Sent %dbytes, waiting %"FMTu64"ms...\n", sent, waitTime);
-                    } else {
-                        hub->ws.next_transmit_tm = yapiGetTickCount() + 100;
-                    }
-                    break;
-                }
-            }
-        }
-        yLeaveCriticalSection(&hub->ws.chan[tcpchan].access);
-
-    }
-    return YAPI_SUCCESS;
-}
-
-
-/*
-*   Open Base tcp socket (done in background by yws_thread)
-*/
-static int ws_openBaseSocket(HubSt* basehub, int first_notification_connection, int mstimout, char* errmsg)
-{
-    char buffer[YOCTO_HOSTNAME_NAME];
-    u32 ip;
-    u16 port;
-    yAsbUrlProto proto;
-    yStrRef user, pass, subdomain;
-    int res, request_len;
-    char request[256];
-    char subdomain_buf[32];
-    struct _WSNetHubSt* wshub = &basehub->ws;
-
-    wshub->base_state = 0;
-    wshub->strym_state = 0;
-    wshub->remoteVersion = 0;
-    wshub->remoteNounce = 0;
-    wshub->nounce = 0;
-    wshub->bws_open_tm = 0;
-    wshub->bws_timeout_tm = 0;
-    wshub->bws_read_tm = 0;
-    wshub->next_transmit_tm = 0;
-    wshub->connectionTime = 0;
-    wshub->tcpRoundTripTime = 0;
-    wshub->tcpMaxWindowSize = 0;
-    wshub->uploadRate = 0;
-    wshub->openRequests = 0;
-
-    wshub->skt = INVALID_SOCKET;
-    wshub->s_next_async_id = 48;
-
-    switch (yHashGetUrlPort(basehub->url, buffer, &port, &proto, &user, &pass, &subdomain)) {
-    case NAME_URL:
-        ip = resolveDNSCache(basehub->url, errmsg);
-        if (ip == 0) {
-            return YAPI_IO_ERROR;
-        }
-        break;
-    case IP_URL:
-        ip = inet_addr(buffer);
-        break;
-    default:
-        return YERRMSG(YAPI_IO_ERROR, "not an IP hub");
-    }
-    if (proto == PROTO_HTTP) {
-        return YERRMSG(YAPI_IO_ERROR, "not a WebSocket url");
-    }
-    if (subdomain == INVALID_HASH_IDX) {
-        subdomain_buf[0] = 0;
-    } else {
-        YSPRINTF(subdomain_buf, 32, "/%s", yHashGetStrPtr(subdomain));
-    }
-
-    WSLOG("hub(%s) try to open WS connection at %d\n", basehub->name, basehub->notifAbsPos);
-    if (first_notification_connection) {
-        YSPRINTF(request, 256, "GET %s/not.byn", subdomain_buf);
-    } else {
-        YSPRINTF(request, 256, "GET %s/not.byn?abs=%u", subdomain_buf, basehub->notifAbsPos);
-    }
-
-    res = yTcpOpen(&wshub->skt, ip, port, mstimout, errmsg);
-    if (YISERR(res)) {
-        // yTcpOpen has reset the socket to INVALID
-        yTcpClose(wshub->skt);
-        wshub->skt = INVALID_SOCKET;
-        return res;
-    }
-    wshub->bws_open_tm = yapiGetTickCount();
-    wshub->bws_timeout_tm = mstimout;
-    wshub->user = user;
-    wshub->pass = pass;
-    //write header
-    request_len = YSTRLEN(request);
-
-    res = yTcpWrite(wshub->skt, request, request_len, errmsg);
-    if (YISERR(res)) {
-        yTcpClose(wshub->skt);
-        wshub->skt = INVALID_SOCKET;
-        return res;
-    }
-    res = yTcpWrite(wshub->skt, ws_header_start, YSTRLEN(ws_header_start), errmsg);
-    if (YISERR(res)) {
-        yTcpClose(wshub->skt);
-        wshub->skt = INVALID_SOCKET;
-        return res;
-    }
-
-    wshub->websocket_key_len = GenereateWebSockeyKey((u8*)request, request_len, wshub->websocket_key);
-    res = yTcpWrite(wshub->skt, wshub->websocket_key, wshub->websocket_key_len, errmsg);
-    if (YISERR(res)) {
-        yTcpClose(wshub->skt);
-        wshub->skt = INVALID_SOCKET;
-        return res;
-    }
-
-    res = yTcpWrite(wshub->skt, ws_header_end, YSTRLEN(ws_header_end), errmsg);
-    if (YISERR(res)) {
-        yTcpClose(wshub->skt);
-        wshub->skt = INVALID_SOCKET;
-        return res;
-    }
-
-    return YAPI_SUCCESS;
-}
-
-
-/*
-*   Close Base tcp socket (done in background by yws_thread)
-*/
-static void ws_closeBaseSocket(struct _WSNetHubSt* base_req)
-{
-    yTcpClose(base_req->skt);
-    base_req->skt = INVALID_SOCKET;
-    yFifoEmpty(&base_req->mainfifo);
-}
-
-
-/*
-*   select used by background thread
-*/
-static int ws_thread_select(struct _WSNetHubSt* base_req, u64 ms, WakeUpSocket* wuce, char* errmsg)
-{
-    fd_set fds;
-    struct timeval timeout;
-    int res;
-    YSOCKET sktmax = 0;
-
-    memset(&timeout, 0, sizeof(timeout));
-    timeout.tv_sec = (long)ms / 1000;
-    timeout.tv_usec = (int)(ms % 1000) * 1000;
-    /* wait for data */
-    FD_ZERO(&fds);
-    if (wuce) {
-        FD_SET(wuce->listensock, &fds);
-        sktmax = wuce->listensock;
-    }
-
-    if (base_req->skt == INVALID_SOCKET) {
-        return YERR(YAPI_INVALID_ARGUMENT);
-    } else {
-        FD_SET(base_req->skt, &fds);
-        if (base_req->skt > sktmax)
-            sktmax = base_req->skt;
-    }
-    if (sktmax == 0) {
-        return YAPI_SUCCESS;
-    }
-    res = select((int)sktmax + 1, &fds, NULL, NULL, &timeout);
-    if (res < 0) {
-#ifndef WINDOWS_API
-        if (SOCK_ERR == EAGAIN) {
-            return 0;
-        } else
-#endif
-        {
-            res = yNetSetErr();
-            return res;
-        }
-    }
-    if (res != 0) {
-        if (wuce && FD_ISSET(wuce->listensock, &fds)) {
-            int signal = yConsumeWakeUpSocket(wuce, errmsg);
-            //dbglog("exit from sleep with WUCE (%d)\n", signal);
-            YPROPERR(signal);
-        }
-        if (FD_ISSET(base_req->skt, &fds)) {
-            int avail = yFifoGetFree(&base_req->mainfifo);
-            int readed = 0;
-            if (avail) {
-                u8 buffer[2048];
-                if (avail > 2048) {
-                    avail = 2048;
-                }
-                readed = yTcpRead(base_req->skt, buffer, avail, errmsg);
-                if (readed > 0) {
-                    yPushFifo(&base_req->mainfifo, buffer, readed);
-                }
-            }
-            return readed;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-static void ws_threadUpdateRetryCount(HubSt* hub)
-{
-    hub->attemptDelay = 500 << hub->retryCount;
-    if (hub->attemptDelay > 8000)
-        hub->attemptDelay = 8000;
-    hub->retryCount++;
-#ifdef DEBUG_WEBSOCKET
-    dbglog("hub(%s): IO error on ws_thread:(%d) %s\n", hub->name, hub->errcode, hub->errmsg);
-    dbglog("hub(%s): retry in %dms (%d retries)\n", hub->name, hub->attemptDelay, hub->retryCount);
-#endif
-}
-
-/**
- *   Background  thread for WebSocket Hub
- */
-void* ws_thread(void* ctx)
-{
-    char* p;
-    yThread* thread = (yThread*)ctx;
-    char errmsg[YOCTO_ERRMSG_LEN];
-    HubSt* hub = (HubSt*)thread->ctx;
-    int res;
-    int first_notification_connection = 1;
-    u8 header[8];
-    char buffer[2048];
-    int buffer_ofs = 0;
-    int continue_processing;
-
-
-    yThreadSignalStart(thread);
-    WSLOG("hub(%s) start thread \n", hub->name);
-
-    while (!yThreadMustEnd(thread) && hub->state != NET_HUB_TOCLOSE) {
-
-        WSLOG("hub(%s) try to open base socket (%d/%dms/%d)\n", hub->name, hub->retryCount, hub->attemptDelay, hub->state);
-        if (hub->retryCount > 0) {
-            u64 timeout = yapiGetTickCount() + hub->attemptDelay;
-            do {
-                //minimal timeout is always 500
-                yApproximateSleep(100);
-            } while (timeout > yapiGetTickCount());
-        }
-        if (hub->state == NET_HUB_TOCLOSE) {
-            break;
-        }
-        res = ws_openBaseSocket(hub, first_notification_connection, 1000, errmsg);
-        hub->lastAttempt = yapiGetTickCount();
-        if (YISERR(res)) {
-            yEnterCriticalSection(&hub->access);
-            hub->errcode = ySetErr(res, hub->errmsg, errmsg, NULL, 0);
-            yLeaveCriticalSection(&hub->access);
-            ws_threadUpdateRetryCount(hub);
-            continue;
-        }
-        WSLOG("hub(%s) base socket opened (skt=%x)\n", hub->name, hub->ws.skt);
-        hub->state = NET_HUB_TRYING;
-        hub->ws.base_state = WS_BASE_HEADER_SENT;
-        hub->ws.connectionTime = 0;
-        hub->ws.tcpRoundTripTime = DEFAULT_TCP_ROUND_TRIP_TIME;
-        hub->ws.tcpMaxWindowSize = DEFAULT_TCP_MAX_WINDOW_SIZE;
-        errmsg[0] = 0;
-        continue_processing = 1;
-        do {
-            u64 wait;
-            u64 now = yapiGetTickCount();
-            if (hub->ws.next_transmit_tm >= now) {
-                wait = hub->ws.next_transmit_tm - now;
-            } else {
-                wait = 1000;
-            }
-            //dbglog("select %"FMTu64"ms on main socket\n", wait);
-            res = ws_thread_select(&hub->ws, wait, &hub->wuce, errmsg);
-            if (YISERR(res)) {
-                WSLOG("hub(%s) ws_thread_select error %d:%s\n", hub->name, res, errmsg);
-            }
-
-            if (res > 0) {
-                int need_more_data = 0;
-                int avail, rw;
-                int hdrlen;
-                u32 mask;
-                int websocket_ok = 0;
-                int pktlen;
-                do {
-                    u16 pos;
-                    //something to handle;
-                    switch (hub->ws.base_state) {
-                    case WS_BASE_HEADER_SENT:
-                        pos = ySeekFifo(&hub->ws.mainfifo, (const u8*)"\r\n\r\n", 4, 0, 0, 0);
-                        if (pos == 0xffff) {
-                            if ((u64)(yapiGetTickCount() - hub->lastAttempt) > WS_CONNEXION_TIMEOUT) {
-                                res = YERR(YAPI_TIMEOUT);
-                            } else {
-                                need_more_data = 1;
-                            }
-                            break;
-                        } else if (pos >= 2044) {
-                            res = YERRMSG(YAPI_IO_ERROR, "Bad reply header");
-                            // fatal error do not retry to reconnect
-                            hub->state = NET_HUB_TOCLOSE;
-                            break;
-                        }
-                        pos = ySeekFifo(&hub->ws.mainfifo, (const u8*)"\r\n", 2, 0, 0, 0);
-                        yPopFifo(&hub->ws.mainfifo, (u8*)buffer, pos + 2);
-                        if (YSTRNCMP(buffer, "HTTP/1.1 ", 9) != 0) {
-                            res = YERRMSG(YAPI_IO_ERROR, "Bad reply header");
-                            // fatal error do not retry to reconnect
-                            hub->state = NET_HUB_TOCLOSE;
-                            break;
-                        }
-                        p = buffer + 9;
-                        if (YSTRNCMP(p, "101", 3) != 0) {
-                            res = YERRMSG(YAPI_IO_ERROR, "hub does not support WebSocket");
-                            // fatal error do not retry to reconnect
-                            hub->state = NET_HUB_TOCLOSE;
-                            break;
-                        }
-                        websocket_ok = 0;
-                        pos = ySeekFifo(&hub->ws.mainfifo, (const u8*)"\r\n", 2, 0, 0, 0);
-                        while (pos != 0) {
-                            yPopFifo(&hub->ws.mainfifo, (u8*)buffer, pos + 2);
-                            if (pos > 22 && YSTRNICMP(buffer, "Sec-WebSocket-Accept: ", 22) == 0) {
-                                if (!VerifyWebsocketKey(buffer + 22, pos, hub->ws.websocket_key, hub->ws.websocket_key_len)) {
-                                    websocket_ok = 1;
-                                } else {
-                                    res = YERRMSG(YAPI_IO_ERROR, "hub does not use same WebSocket protocol");
-                                    // fatal error do not retry to reconnect
-                                    hub->state = NET_HUB_TOCLOSE;
-                                    break;
-                                }
-                            }
-                            if ((u64)(yapiGetTickCount() - hub->lastAttempt) > WS_CONNEXION_TIMEOUT) {
-                                res = YERR(YAPI_TIMEOUT);
-                                break;
-                            }
-                            pos = ySeekFifo(&hub->ws.mainfifo, (const u8*)"\r\n", 2, 0, 0, 0);
-                        }
-                        yPopFifo(&hub->ws.mainfifo, NULL, 2);
-                        if (websocket_ok) {
-                            hub->ws.base_state = WS_BASE_SOCKET_UPGRADED;
-                            buffer_ofs = 0;
-                        } else {
-                            res = YERRMSG(YAPI_IO_ERROR, "Invalid WebSocket header");
-                            // fatal error do not retry to reconnect
-                            hub->state = NET_HUB_TOCLOSE;
-                        }
-                        break;
-                    case WS_BASE_SOCKET_UPGRADED:
-                    case WS_BASE_AUTHENTICATING:
-                    case WS_BASE_CONNECTED:
-
-                        avail = yFifoGetUsed(&hub->ws.mainfifo);
-                        if (avail < 2) {
-                            need_more_data = 1;
-                            break;
-                        }
-                        rw = (avail < 7 ? avail : 7);
-                        yPeekFifo(&hub->ws.mainfifo, header, rw, 0);
-                        pktlen = header[1] & 0x7f;
-                        if (pktlen > 125) {
-                            // Unsupported long frame, drop all incoming data (probably 1+ frame(s))
-                            res = YERRMSG(YAPI_IO_ERROR, "Unsupported long WebSocket frame");
-                            break;
-                        }
-
-                        if (header[1] & 0x80) {
-                            // masked frame
-                            hdrlen = 6;
-                            if (avail < hdrlen + pktlen) {
-                                need_more_data = 1;
-                                break;
-                            }
-                            memcpy(&mask, header + 2, sizeof(u32));
-                        } else {
-                            // plain frame
-                            hdrlen = 2;
-                            if (avail < hdrlen + pktlen) {
-                                need_more_data = 1;
-                                break;
-                            }
-                            mask = 0;
-                        }
-
-                        if ((header[0] & 0x7f) != 0x02) {
-                            // Non-data frame
-                            if (header[0] == 0x88) {
-                                //if (USBTCPIsPutReady(sock) < 8) return;
-                                // websocket close, reply with a close
-                                header[0] = 0x88;
-                                header[1] = 0x82;
-                                mask = YRand32();
-                                memcpy(header + 2, &mask, sizeof(u32));
-                                header[6] = 0x03 ^ ((u8 *)&mask)[0];
-                                header[7] = 0xe8 ^ ((u8 *)&mask)[1];
-                                res = yTcpWrite(hub->ws.skt, (char*)header, 8, errmsg);
-                                if (YISERR(res)) {
-                                    break;
-                                }
-                                res = YAPI_NO_MORE_DATA;
-                                YSTRCPY(errmsg, YOCTO_ERRMSG_LEN,"WebSocket connection close received");
-                                hub->ws.base_state = WS_BASE_OFFLINE;
-#ifdef DEBUG_WEBSOCKET
-                                dbglog("WS: IO error on base socket of %s(%X): %s\n", hub->name, hub->url, errmsg);
-#endif
-                            } else {
-                                // unhandled packet
-                                dbglog("unhandled packet:%x%x\n", header[0], header[1]);
-                            }
-                            yPopFifo(&hub->ws.mainfifo, NULL, hdrlen + pktlen);
-                            break;
-                        }
-                        // drop frame header
-                        yPopFifo(&hub->ws.mainfifo, NULL, hdrlen);
-                        // append
-                        yPopFifo(&hub->ws.mainfifo, (u8*)buffer + buffer_ofs, pktlen);
-                        if (mask) {
-                            int i;
-                            for (i = 0; i < (pktlen + 1 + 3) >> 2; i++) {
-                                buffer[buffer_ofs + i] ^= mask;
-                            }
-                        }
-
-                        if (header[0] == 0x02) {
-                            //  fragmented binary frame
-                            WSStreamHead strym;
-                            strym.encaps = buffer[buffer_ofs];
-                            if (strym.stream == YSTREAM_META) {
-                                // unsupported fragmented META stream, should never happen
-                                dbglog("Warning:fragmented META\n");
-                                break;
-                            }
-                            buffer_ofs += pktlen;
-                            break;
-                        }
-                        request_pending_logs(hub);
-                        res = ws_parseIncomingFrame(hub, (u8*)buffer, buffer_ofs + pktlen, errmsg);
-                        if (YISERR(res)) {
-                            WSLOG("hub(%s) ws_parseIncomingFrame error %d:%s\n", hub->name, res, errmsg);
-                            break;
-                        }
-                        buffer_ofs = 0;
-                        break;
-                    case WS_BASE_OFFLINE:
-                        break;
-                    }
-                } while (!need_more_data && !YISERR(res));
-            }
-            if (!YISERR(res)) {
-                res = ws_processRequests(hub, errmsg);
-                if (YISERR(res)) {
-                    WSLOG("hub(%s) ws_processRequests error %d:%s\n", hub->name, res, errmsg);
-                }
-            }
-
-            if (YISERR(res)) {
-                continue_processing = 0;
-            } else if ((yThreadMustEnd(thread) || hub->state == NET_HUB_TOCLOSE) && !ws_requestStillPending(hub)) {
-                continue_processing = 0;
-            }
-        } while (continue_processing);
-        if (YISERR(res)) {
-            WSLOG("hub(%s) IO error %d:%s\n", hub->name,res, errmsg);
-            yEnterCriticalSection(&hub->access);
-            hub->errcode = ySetErr(res, hub->errmsg, errmsg, NULL, 0);
-            yLeaveCriticalSection(&hub->access);
-            ws_threadUpdateRetryCount(hub);
-        }
-        WSLOG("hub(%s) close base socket %d:%s\n", hub->name, res, errmsg);
-        ws_closeBaseSocket(&hub->ws);
-        if (hub->state != NET_HUB_TOCLOSE) {
-            hub->state = NET_HUB_DISCONNECTED;
-        }
-    }
-    WSLOG("hub(%s) exit thread \n", hub->name);
-    hub->state = NET_HUB_CLOSED;
-    yThreadSignalEnd(thread);
-    return NULL;
-}
-
-
-/********************************************************************************
- * UDP functions
- *******************************************************************************/
-
-//#define DEBUG_NET_DETECTION
-
-os_ifaces detectedIfaces[NB_OS_IFACES];
-int nbDetectedIfaces = 0;
-
-#ifdef DEBUG_NET_DETECTION
-
-void ip2a(u32 ip, char *buffer)
-{
-    unsigned char bytes[4];
-    bytes[0] = ip & 0xFF;
-    bytes[1] = (ip >> 8) & 0xFF;
-    bytes[2] = (ip >> 16) & 0xFF;
-    bytes[3] = (ip >> 24) & 0xFF;
-    YSPRINTF(buffer, 125, "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
-}
-#endif
-
-
-#ifdef WINDOWS_API
-YSTATIC int yDetectNetworkInterfaces(u32 only_ip)
-{
-    INTERFACE_INFO winIfaces[NB_OS_IFACES];
-    DWORD returnedSize, nbifaces, i;
-    SOCKET sock;
-
-    nbDetectedIfaces = 0;
-    memset(detectedIfaces, 0, sizeof(detectedIfaces));
-    sock = WSASocket(AF_INET, SOCK_DGRAM, 0, 0, 0, 0);
-    if (sock == INVALID_SOCKET) {
-        yNetLogErr();
-        return -1;
-    }
-    if (WSAIoctl(sock, SIO_GET_INTERFACE_LIST, NULL, 0, winIfaces, sizeof(winIfaces), &returnedSize, NULL, NULL) < 0) {
-        yNetLogErr();
-        return -1;
-    }
-
-    nbifaces = returnedSize / sizeof(INTERFACE_INFO);
-#ifdef DEBUG_NET_DETECTION
-    dbglog("windows returned %d interfaces\n", nbifaces);
-#endif
-    for (i = 0; i < nbifaces; i++) {
-        if (winIfaces[i].iiFlags & IFF_LOOPBACK)
-            continue;
-        if (winIfaces[i].iiFlags & IFF_UP) {
-            if (winIfaces[i].iiFlags & IFF_MULTICAST)
-                detectedIfaces[nbDetectedIfaces].flags |= OS_IFACE_CAN_MCAST;
-            if (only_ip != 0 && only_ip != winIfaces[i].iiAddress.AddressIn.sin_addr.S_un.S_addr) {
-                continue;
-            }
-            detectedIfaces[nbDetectedIfaces].ip = winIfaces[i].iiAddress.AddressIn.sin_addr.S_un.S_addr;
-            detectedIfaces[nbDetectedIfaces].netmask = winIfaces[i].iiNetmask.AddressIn.sin_addr.S_un.S_addr;
-#ifdef DEBUG_NET_DETECTION
-            {
-                char buffer[128];
-                ip2a(detectedIfaces[nbDetectedIfaces].ip, buffer);
-                dbglog(" iface%d: ip %s\n", nbifaces, buffer);
-            }
-#endif
-            nbDetectedIfaces++;
-        }
-    }
-#ifdef DEBUG_NET_DETECTION
-    dbglog("%d interfaces are usable\n", nbDetectedIfaces);
-#endif
-    return nbDetectedIfaces;
-}
-#else
-
-#include <net/if.h>
-#include <ifaddrs.h>
-YSTATIC int yDetectNetworkInterfaces(u32 only_ip)
-{
-    struct ifaddrs *if_addrs = NULL;
-    struct ifaddrs *p = NULL;
-#if 1
-    nbDetectedIfaces = 0;
-    memset(detectedIfaces, 0, sizeof(detectedIfaces));
-    if (getifaddrs(&if_addrs) != 0){
-        yNetLogErr();
-        return -1;
-    }
-    p = if_addrs;
-    while (p) {
-        if (p->ifa_addr && p->ifa_addr->sa_family == AF_INET) {
-            struct sockaddr_in *tmp;
-            u32 ip, netmask;
-            tmp = (struct sockaddr_in*)p->ifa_addr;
-            ip = tmp->sin_addr.s_addr;
-            if (only_ip != 0 && only_ip != ip){
-                p = p->ifa_next;
-                continue;
-            }
-            tmp = (struct sockaddr_in*)p->ifa_netmask;
-            netmask = tmp->sin_addr.s_addr;
-            if ((p->ifa_flags & IFF_LOOPBACK) == 0){
-                if (p->ifa_flags & IFF_UP && p->ifa_flags & IFF_RUNNING){
-#ifdef DEBUG_NET_DETECTION
-                    ylogf("%s : ", p->ifa_name);
-                    ylogIP(ip);
-                    ylogf("/");
-                    ylogIP(netmask);
-                    ylogf(" (%X)\n", p->ifa_flags);
-#endif
-                    if (p->ifa_flags & IFF_MULTICAST){
-                        detectedIfaces[nbDetectedIfaces].flags |= OS_IFACE_CAN_MCAST;
-                    }
-                    detectedIfaces[nbDetectedIfaces].ip = ip;
-                    detectedIfaces[nbDetectedIfaces].netmask = netmask;
-                    nbDetectedIfaces++;
-                }
-            }
-#ifdef DEBUG_NET_DETECTION
-            else {
-                ylogf("drop %s : ", p->ifa_name);
-                ylogIP(ip);
-                ylogf("/");
-                ylogIP(netmask);
-                ylogf(" (%X)\n", p->ifa_flags);
-            }
-#endif
-        }
-        p = p->ifa_next;
-    }
-
-#else
-    nbDetectedIfaces = 1;
-    memset(detectedIfaces, 0, sizeof(detectedIfaces));
-    detectedIfaces[0].flags |= OS_IFACE_CAN_MCAST;
-    detectedIfaces[0].ip = INADDR_ANY;
-#endif
-    return nbDetectedIfaces;
-}
-
-#endif
-
-
-static const char* discovery =
-    "M-SEARCH * HTTP/1.1\r\n"
-    "HOST:" YSSDP_MCAST_ADDR_STR ":" TOSTRING(YSSDP_PORT) "\r\n"
-    "MAN:\"ssdp:discover\"\r\n"
-    "MX:5\r\n"
-    "ST:" YSSDP_URN_YOCTOPUCE"\r\n"
-    "\r\n";
-
-
-#define SSDP_NOTIFY "NOTIFY * HTTP/1.1\r\n"
-#define SSDP_M_SEARCH "M-SEARCH * HTTP/1.1\r\n"
-#define SSDP_HTTP "HTTP/1.1 200 OK\r\n"
-#define SSDP_LINE_MAX_LEN 80u
-
-#define UDP_IN_FIFO yFifoBuf
-
-
-static char hexatochar(char hi_c, char lo_c)
-{
-    u8 hi, lo;
-    hi = ((u8)(hi_c) & 0x1f) ^ 0x10;
-    lo = ((u8)(lo_c) & 0x1f) ^ 0x10;
-    if (hi & 0x10) hi -= 7;
-    if (lo & 0x10) lo -= 7;
-    return (hi << 4) + lo;
-}
-
-static int uuidToSerial(const char* uuid, char* serial)
-{
-    int i;
-    int len, padlen;
-    char* s = serial;
-    const char* u = uuid;
-
-    for (i = 0, u = uuid; i < 4; i++, u += 2) {
-        *s++ = hexatochar(*u, *(u + 1));
-    }
-    u++;
-    for (; i < 6; i++, u += 2) {
-        *s++ = hexatochar(*u, *(u + 1));
-    }
-    u++;
-    for (; i < 8; i++, u += 2) {
-        *s++ = hexatochar(*u, *(u + 1));
-    }
-    *s++ = '-';
-    u = strstr(uuid, "-COFF-EE");
-    if (u == NULL) {
-        return -1;
-    }
-    u += 8;
-    while (*u == '0') u++;
-    len = YSTRLEN(u);
-    if (YSTRNCMP(serial, "VIRTHUB0", YOCTO_BASE_SERIAL_LEN) == 0) {
-        padlen = YOCTO_SERIAL_SEED_SIZE - 1;
-    } else {
-        padlen = 5;
-    }
-    for (i = len; i < padlen; i++) {
-        *s++ = '0';
-    }
-    *s = 0;
-    YSTRCAT(serial, YOCTO_SERIAL_LEN, u);
-    return 0;
-}
-
-
-static void ySSDPUpdateCache(SSDPInfos* SSDP, const char* uuid, const char* url, int cacheValidity)
-{
-    int i;
-
-    if (cacheValidity <= 0)
-        cacheValidity = 1800;
-    cacheValidity *= 1000;
-
-    for (i = 0; i < NB_SSDP_CACHE_ENTRY; i++) {
-        SSDP_CACHE_ENTRY* p = SSDP->SSDPCache[i];
-        if (p == NULL)
-            break;
-        if (YSTRCMP(uuid,p->uuid) == 0) {
-            p->detectedTime = yapiGetTickCount();
-            p->maxAge = cacheValidity;
-
-            if (YSTRCMP(url, p->url)) {
-                if (SSDP->callback) {
-                    SSDP->callback(p->serial, url, p->url);
-                }
-                YSTRCPY(p->url, SSDP_URL_LEN, url);
-            } else {
-                if (SSDP->callback) {
-                    SSDP->callback(p->serial, url, NULL);
-                }
-            }
-            return;
-        }
-    }
-    if (i < NB_SSDP_CACHE_ENTRY) {
-        SSDP_CACHE_ENTRY* p = (SSDP_CACHE_ENTRY*)yMalloc(sizeof(SSDP_CACHE_ENTRY));
-        YSTRCPY(p->uuid, SSDP_URL_LEN, uuid);
-        if (uuidToSerial(p->uuid, p->serial) < 0) {
-            yFree(p);
-            return;
-        }
-        YSTRCPY(p->url,SSDP_URL_LEN,url);
-        p->detectedTime = yapiGetTickCount();
-        p->maxAge = cacheValidity;
-        SSDP->SSDPCache[i] = p;
-        if (SSDP->callback) {
-            SSDP->callback(p->serial, p->url, NULL);
-        }
-    }
-}
-
-static void ySSDPCheckExpiration(SSDPInfos* SSDP)
-{
-    int i;
-    u64 now = yapiGetTickCount();
-
-    for (i = 0; i < NB_SSDP_CACHE_ENTRY; i++) {
-        SSDP_CACHE_ENTRY* p = SSDP->SSDPCache[i];
-        if (p == NULL)
-            break;
-        if ((u64)(now - p->detectedTime) > p->maxAge) {
-            p->maxAge = 0;
-            if (SSDP->callback) {
-                SSDP->callback(p->serial, NULL, p->url);
-            }
-        }
-    }
-}
-
-
-static void ySSDP_parseSSPDMessage(SSDPInfos* SSDP, char* message, int msg_len)
-{
-    int len = 0;
-    char *p, *start, *lastsep;
-    char* location = NULL;
-    char* usn = NULL;
-    char* cache = NULL;
-
-    if (len >= msg_len) {
-        return;
-    }
-
-    if (memcmp(message,SSDP_HTTP,YSTRLEN(SSDP_HTTP)) == 0) {
-        len = YSTRLEN(SSDP_HTTP);
-    } else if (memcmp(message,SSDP_NOTIFY,YSTRLEN(SSDP_NOTIFY)) == 0) {
-        len = YSTRLEN(SSDP_NOTIFY);
-    }
-    if (len) {
-        //dbglog("SSDP Message:\n%s\n",message);
-        start = p = lastsep = message + len;
-        msg_len -= len;
-        while (msg_len && *p) {
-            switch (*p) {
-            case ':':
-                if (lastsep == start) {
-                    lastsep = p;
-                }
-                break;
-            case '\r':
-                if (p == start) {
-                    // \r\n\r\n ->end
-                    if (msg_len > 1) msg_len = 1;
-                    break;
-                }
-
-                if (lastsep == start) {
-                    //no : on the line -> drop this message
-                    return;
-                }
-                *lastsep++ = 0;
-                if (*lastsep == ' ') lastsep++;
-                *p = 0;
-                if (strcmp(start, "LOCATION") == 0) {
-                    location = lastsep;
-                } else if (strcmp(start, "USN") == 0) {
-                    usn = lastsep;
-                } else if (strcmp(start, "CACHE-CONTROL") == 0) {
-                    cache = lastsep;
-                }
-                break;
-            case '\n':
-                start = lastsep = p + 1;
-                break;
-            }
-            p++;
-            msg_len--;
-        }
-        if (location && usn && cache) {
-            const char *uuid, *urn;
-            int cacheVal;
-            //dbglog("SSDP: location: %s %s %s\n\n",location,usn,cache);
-            // parse USN
-            p = usn;
-            // ReSharper disable once CppPossiblyErroneousEmptyStatements
-            while (*p && *p++ != ':');
-            if (!*p) return;
-            uuid = p;
-            // ReSharper disable once CppPossiblyErroneousEmptyStatements
-            while (*p && *p++ != ':');
-            if (*p != ':') return;
-            *(p++ - 1) = 0;
-            if (!*p) return;
-            urn = p;
-            // parse Location
-            if (YSTRNCMP(location,"http://",7) == 0) {
-                location += 7;
-            }
-            p = location;
-            while (*p && *p != '/') p++;
-            if (*p == '/') *p = 0;
-            p = cache;
-            // ReSharper disable once CppPossiblyErroneousEmptyStatements
-            while (*p && *p++ != '=');
-            if (!*p) return;
-            cacheVal = atoi(p);
-            if (YSTRCMP(urn,YSSDP_URN_YOCTOPUCE) == 0) {
-                ySSDPUpdateCache(SSDP, uuid, location, cacheVal);
-            }
-        }
-    }
-#if 0
-    else {
-        dbglog("SSDP drop invalid message:\n%s\n",message);
-    }
-#endif
-}
-
-
-static void* ySSDP_thread(void* ctx)
-{
-    yThread* thread = (yThread*)ctx;
-    SSDPInfos* SSDP = (SSDPInfos*)thread->ctx;
-    fd_set fds;
-    u8 buffer[1536];
-    struct timeval timeout;
-    int res, received, i;
-    YSOCKET sktmax;
-    yFifoBuf inFifo;
-
-
-    yThreadSignalStart(thread);
-    yFifoInit(&inFifo,buffer,sizeof(buffer));
-
-    while (!yThreadMustEnd(thread)) {
-        memset(&timeout, 0, sizeof(timeout));
-        timeout.tv_sec = (long)1;
-        timeout.tv_usec = (int)0;
-        /* wait for data */
-        FD_ZERO(&fds);
-        sktmax = 0;
-        for (i = 0; i < nbDetectedIfaces; i++) {
-            FD_SET(SSDP->request_sock[i], &fds);
-            if (SSDP->request_sock[i] > sktmax) {
-                sktmax = SSDP->request_sock[i];
-            }
-            if (SSDP->notify_sock[i] != INVALID_SOCKET) {
-                FD_SET(SSDP->notify_sock[i], &fds);
-                if (SSDP->notify_sock[i] > sktmax) {
-                    sktmax = SSDP->notify_sock[i];
-                }
-            }
-        }
-        res = select((int)sktmax + 1, &fds, NULL, NULL, &timeout);
-        if (res < 0) {
-#ifndef WINDOWS_API
-            if(SOCK_ERR ==  EAGAIN){
-                continue;
-            } else
-#endif
-            {
-                yNetLogErr();
-                break;
-            }
-        }
-
-        if (!yContext) continue;
-        ySSDPCheckExpiration(SSDP);
-        if (res != 0) {
-            for (i = 0; i < nbDetectedIfaces; i++) {
-                if (FD_ISSET(SSDP->request_sock[i], &fds)) {
-                    received = (int)yrecv(SSDP->request_sock[i], (char*)buffer, sizeof(buffer)-1, 0);
-                    if (received > 0) {
-                        buffer[received] = 0;
-                        ySSDP_parseSSPDMessage(SSDP, (char*)buffer, received);
-                    }
-                }
-                if (FD_ISSET(SSDP->notify_sock[i], &fds)) {
-                    received = (int)yrecv(SSDP->notify_sock[i], (char *)buffer, sizeof(buffer)-1, 0);
-                    if (received > 0) {
-                        buffer[received] = 0;
-                        ySSDP_parseSSPDMessage(SSDP, (char*)buffer, received);
-                    }
-                }
-            }
-        }
-    }
-    yFifoCleanup(&inFifo);
-    yThreadSignalEnd(thread);
-    return NULL;
-}
-
-
-int ySSDPDiscover(SSDPInfos* SSDP, char* errmsg)
-{
-    int sent, len, i;
-    struct sockaddr_in sockaddr_dst;
-
-    for (i = 0; i < nbDetectedIfaces; i++) {
-        memset(&sockaddr_dst, 0, sizeof(struct sockaddr_in));
-        sockaddr_dst.sin_family = AF_INET;
-        sockaddr_dst.sin_port = htons(YSSDP_PORT);
-        sockaddr_dst.sin_addr.s_addr = inet_addr(YSSDP_MCAST_ADDR_STR);
-        len = (int)strlen(discovery);
-        sent = (int)sendto(SSDP->request_sock[i], discovery, len, 0, (struct sockaddr *)&sockaddr_dst, sizeof(struct sockaddr_in));
-        if (sent < 0) {
-            return yNetSetErr();
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-
-int ySSDPStart(SSDPInfos* SSDP, ssdpHubDiscoveryCallback callback, char* errmsg)
-{
-    u32 optval;
-    int i;
-    socklen_t socksize;
-    struct sockaddr_in sockaddr;
-    struct ip_mreq mcast_membership;
-
-    if (SSDP->started)
-        return YAPI_SUCCESS;
-
-    memset(SSDP, 0, sizeof(SSDPInfos));
-    SSDP->callback = callback;
-    yDetectNetworkInterfaces(0);
-
-    for (i = 0; i < nbDetectedIfaces; i++) {
-        //create M-search socket
-        SSDP->request_sock[i] = ysocket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (SSDP->request_sock[i] == INVALID_SOCKET) {
-            return yNetSetErr();
-        }
-
-        optval = 1;
-        setsockopt(SSDP->request_sock[i], SOL_SOCKET, SO_REUSEADDR, (char *)&optval, sizeof(optval));
-#ifdef SO_REUSEPORT
-        setsockopt(SSDP->request_sock[i], SOL_SOCKET, SO_REUSEPORT, (char *)&optval, sizeof(optval));
-#endif
-
-        // set port to 0 since we accept any port
-        socksize = sizeof(sockaddr);
-        memset(&sockaddr, 0, socksize);
-        sockaddr.sin_family = AF_INET;
-        sockaddr.sin_addr.s_addr = detectedIfaces[i].ip;
-        if (bind(SSDP->request_sock[i], (struct sockaddr*)&sockaddr, socksize) < 0) {
-            return yNetSetErr();
-        }
-        //create NOTIFY socket
-        SSDP->notify_sock[i] = ysocket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (SSDP->notify_sock[i] == INVALID_SOCKET) {
-            return yNetSetErr();
-        }
-
-        optval = 1;
-        setsockopt(SSDP->notify_sock[i], SOL_SOCKET, SO_REUSEADDR, (char *)&optval, sizeof(optval));
-#ifdef SO_REUSEPORT
-        setsockopt(SSDP->notify_sock[i], SOL_SOCKET, SO_REUSEPORT, (char *)&optval, sizeof(optval));
-#endif
-
-        // set port to 0 since we accept any port
-        socksize = sizeof(sockaddr);
-        memset(&sockaddr, 0, socksize);
-        sockaddr.sin_family = AF_INET;
-        sockaddr.sin_port = htons(YSSDP_PORT);
-        sockaddr.sin_addr.s_addr = INADDR_ANY;
-        if (bind(SSDP->notify_sock[i], (struct sockaddr *)&sockaddr, socksize) < 0) {
-            return yNetSetErr();
-        }
-
-        mcast_membership.imr_multiaddr.s_addr = inet_addr(YSSDP_MCAST_ADDR_STR);
-        mcast_membership.imr_interface.s_addr = INADDR_ANY;
-        if (setsockopt(SSDP->notify_sock[i], IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&mcast_membership, sizeof(mcast_membership)) < 0) {
-            dbglog("Unable to add multicast membership for SSDP");
-            yNetLogErr();
-            yclosesocket(SSDP->notify_sock[i]);
-            SSDP->notify_sock[i] = INVALID_SOCKET;
-        }
-    }
-    //yThreadCreate will not create a new thread if there is already one running
-    if (yThreadCreate(&SSDP->thread, ySSDP_thread, SSDP) < 0) {
-        return YERRMSG(YAPI_IO_ERROR,"Unable to start helper thread");
-    }
-    SSDP->started++;
-    return ySSDPDiscover(SSDP, errmsg);
-    //return YAPI_SUCCESS;
-}
-
-
-void ySSDPStop(SSDPInfos* SSDP)
-{
-    int i;
-
-    if (yThreadIsRunning(&SSDP->thread)) {
-        u64 timeref;
-        yThreadRequestEnd(&SSDP->thread);
-        timeref = yapiGetTickCount();
-        while (yThreadIsRunning(&SSDP->thread) && (yapiGetTickCount() - timeref < 1000)) {
-            yApproximateSleep(10);
-        }
-        yThreadKill(&SSDP->thread);
-    }
-
-    //unregister all detected hubs
-    for (i = 0; i < NB_SSDP_CACHE_ENTRY; i++) {
-        SSDP_CACHE_ENTRY* p = SSDP->SSDPCache[i];
-        if (p == NULL)
-            continue;
-        if (p->maxAge) {
-            yapiUnregisterHub(p->url);
-            p->maxAge = 0;
-            if (SSDP->callback)
-                SSDP->callback(p->serial, NULL, p->url);
-        }
-        yFree(p);
-    }
-
-    for (i = 0; i < nbDetectedIfaces; i++) {
-
-        if (SSDP->request_sock[i] != INVALID_SOCKET) {
-            yclosesocket(SSDP->request_sock[i]);
-            SSDP->request_sock[i] = INVALID_SOCKET;
-        }
-        if (SSDP->notify_sock[i] != INVALID_SOCKET) {
-            yclosesocket(SSDP->notify_sock[i]);
-            SSDP->notify_sock[i] = INVALID_SOCKET;
-        }
-    }
-    SSDP->started--;
-}
--- a/Sources/cpplib/yapi/ytcp.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/*********************************************************************
- *
- * $Id: ytcp.h 26764 2017-03-16 09:19:55Z seb $
- *
- *  Declaration of a client TCP stack
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YTCP_H
-#define YTCP_H
-
-
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-#include "ydef.h"
-
-
-#ifdef WINDOWS_API
-/**************************************************************
- *
- *  WINDOWS IMPLEMENTATION
- *
- **************************************************************/
-
-//SOCKET RELATED DEFIITIONS AND INCLUDE
-#else
-#define SOCKET_ERROR -1
-#define INVALID_SOCKET -1
-#define closesocket(s) close(s)
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netinet/tcp.h>
-#endif
-
-#ifdef MSG_NOSIGNAL
-#define SEND_NOSIGPIPE MSG_NOSIGNAL
-#else
-#define SEND_NOSIGPIPE 0
-#endif
-
-#ifdef WINDOWS_API
-#define SOCK_ERR    (WSAGetLastError())
-#else
-#define SOCK_ERR    (errno)
-#endif
-#define REPORT_ERR(msg) if(errmsg){ YSPRINTF(errmsg,YOCTO_ERRMSG_LEN,"%s (%s:%d / errno=%d)",(msg), __FILE_ID__, __LINE__, SOCK_ERR);errmsg[YOCTO_ERRMSG_LEN-1]='\0';}
-
-#define yNetSetErr()  yNetSetErrEx(__LINE__,SOCK_ERR,errmsg)
-
-int yNetSetErrEx(u32 line,unsigned err,char *errmsg);
-
-#define YTCP_REMOTE_CLOSE 1
-
-struct _HubSt;
-struct _RequestSt;
-
-typedef struct {
-    YSOCKET listensock;
-    YSOCKET signalsock;
-} WakeUpSocket;
-
-void yDupSet(char **storage, const char *val);
-void yInitWakeUpSocket(WakeUpSocket *wuce);
-int  yStartWakeUpSocket(WakeUpSocket *wuce, char *errmsg);
-int  yDringWakeUpSocket(WakeUpSocket *wuce, u8 signal, char *errmsg);
-int  yConsumeWakeUpSocket(WakeUpSocket *wuce, char *errmsg);
-void yFreeWakeUpSocket(WakeUpSocket *wuce);
-int yTcpDownload(const char *host, const char *url, u8 **out_buffer, u32 mstimeout, char *errmsg);
-
-int  yTcpInit(char *errmsg);
-void yTcpShutdown(void);
-u32  yResolveDNS(const char *name,char *errmsg);
-
-
-
-struct _RequestSt * yReqAlloc( struct _HubSt *hub);
-int  yReqOpen(struct _RequestSt *tcpreq, int wait_for_start, int tcpchan, const char *request, int reqlen, u64 mstimeout, yapiRequestAsyncCallback callback, void *context, yapiRequestProgressCallback progress_cb, void *progress_ctx, char *errmsg);
-int  yReqIsAsync(struct _RequestSt *req);
-int  yReqSelect(struct _RequestSt *tcpreq, u64 ms, char *errmsg);
-int  yReqMultiSelect(struct _RequestSt **tcpreq, int size, u64 ms, WakeUpSocket *wuce, char *errmsg);
-int  yReqIsEof(struct _RequestSt *tcpreq, char *errmsg);
-int  yReqGet(struct _RequestSt *tcpreq, u8 **buffer);
-int  yReqRead(struct _RequestSt *rcoreq, u8 *buffer, int len);
-void yReqClose(struct _RequestSt *tcpreq);
-void yReqFree(struct _RequestSt *tcpreq);
-int  yReqHasPending(struct _HubSt *hub);
-
-
-void* ws_thread(void* ctx);
-
-
-#include "ythread.h"
-
-#define OS_IFACE_CAN_MCAST 1
-
-typedef struct {
-    u32 flags;
-    u32 ip;
-    u32 netmask;
-} os_ifaces;
-
-#ifdef YAPI_IN_YDEVICE
-extern os_ifaces detectedIfaces[];
-extern int nbDetectedIfaces;
-int yDetectNetworkInterfaces(u32 only_ip);
-
-#endif
-
-#define SSDP_UUID_LEN   48
-#define SSDP_URL_LEN    48
-
-typedef struct
-{
-    char        serial[YOCTO_SERIAL_LEN];
-    char        uuid[SSDP_UUID_LEN];
-    char        url[SSDP_URL_LEN];
-    u64         detectedTime;
-    u64         maxAge;
-} SSDP_CACHE_ENTRY;
-
-
-// prototype of the ssdp hub discovery callback
-// will be called on discover, refresh, and expiration
-typedef void (*ssdpHubDiscoveryCallback)(const char *serial, const char *urlToRegister, const char *urlToUnregister);
-
-#define NB_SSDP_CACHE_ENTRY 32
-#define NB_OS_IFACES 8
-
-
-typedef struct {
-	int started;
-	ssdpHubDiscoveryCallback callback;
-    YSOCKET request_sock[NB_OS_IFACES];
-    YSOCKET notify_sock[NB_OS_IFACES];
-    yThread thread;
-	SSDP_CACHE_ENTRY*   SSDPCache[NB_SSDP_CACHE_ENTRY];
-} SSDPInfos;
-
-int 	ySSDPStart(SSDPInfos *SSDP, ssdpHubDiscoveryCallback callback, char *errmsg);
-int		ySSDPDiscover(SSDPInfos *SSDP, char *errmsg);
-void	ySSDPStop(SSDPInfos *SSDP);
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
--- a/Sources/cpplib/yapi/ythread.c
+++ /dev/null
@@ -1,738 +0,0 @@
-/*********************************************************************
- *
- * $Id: ythread.c 33735 2018-12-14 16:06:53Z seb $
- *
- * OS-independent thread and synchronization library
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#include "ythread.h"
-#define __FILE_ID__  "ythread"
-
-
-#ifdef WINDOWS_API
-
-static DWORD yTlsBucket = TLS_OUT_OF_INDEXES;
-static DWORD yNextThreadIdx = 1;
-
-void yCreateEvent(yEvent *event)
-{
-    *event = CreateEvent(0, 0, 0, 0);
-}
-
-void yCreateManualEvent(yEvent *event, int initialState)
-{
-    *event = CreateEvent(0, TRUE, initialState != 0, 0);
-}
-
-
-void ySetEvent(yEvent *ev)
-{
-    SetEvent(*ev);
-}
-
-void yResetEvent(yEvent *ev)
-{
-    ResetEvent(*ev);
-}
-
-
-
-int    yWaitForEvent(yEvent *ev, int time)
-{
-    DWORD usec;
-    DWORD res;
-    if (time < 0) {
-        usec = INFINITE;
-    } else {
-        usec = time;
-    }
-    res = WaitForSingleObject(*ev, usec);
-    return res == WAIT_OBJECT_0;
-}
-
-void   yCloseEvent(yEvent *ev)
-{
-    CloseHandle(*ev);
-}
-
-
-static int    yCreateDetachedThreadEx(osThread *th_hdl, void* (*fun)(void *), void *arg)
-{
-    *th_hdl = CreateThread(
-        NULL,                   // default security attributes
-        0,                      // use default stack size
-        (LPTHREAD_START_ROUTINE)fun,   // thread function name
-        arg,                    // argument to thread function
-        0,                      // use default creation flags
-        NULL);
-    if (*th_hdl == NULL) {
-        return -1;
-    }
-    return 0;
-}
-
-
-static void    yReleaseDetachedThreadEx(osThread *th_hdl)
-{
-    CloseHandle(*th_hdl);
-}
-
-
-static int    yWaitEndThread(osThread *th)
-{
-    DWORD result = WaitForSingleObject(*th, INFINITE);
-    return result == WAIT_OBJECT_0 ? 0 : -1;
-}
-
-static void yKillThread(osThread *th)
-{
-    TerminateThread(*th, 0);
-}
-
-
-int    yThreadIndex(void)
-{
-    u8*  tls_ptr;
-
-    if (yTlsBucket == TLS_OUT_OF_INDEXES) {
-        // Only happens the very first time, from main thread
-        yTlsBucket = TlsAlloc();
-    }
-    tls_ptr = TlsGetValue(yTlsBucket);
-    if (tls_ptr == 0) {
-        // tiny risk of race condition, but thread idx is only
-        // used for debug log purposes and is not sensitive
-        DWORD res = yNextThreadIdx++;
-        TlsSetValue(yTlsBucket, ((u8*)NULL) + res);
-        return res;
-    } else {
-        return  (int)(tls_ptr - ((u8*)NULL));
-    }
-}
-
-#else
-#include <sys/time.h>
-#include <pthread.h>
-#include <errno.h>
-
-static pthread_once_t yInitKeyOnce = PTHREAD_ONCE_INIT;
-static pthread_key_t yTsdKey;
-static unsigned yNextThreadIdx = 1;
-
-static void initTsdKey()
-{
-    pthread_key_create(&yTsdKey, NULL);
-}
-
-void yCreateEvent(yEvent *ev)
-{
-    pthread_cond_init(&ev->cond, NULL);
-    pthread_mutex_init(&ev->mtx, NULL);
-    ev->verif = 0;
-    ev->autoreset = 1;
-}
-
-void yCreateManualEvent(yEvent *ev, int initialState)
-{
-    pthread_cond_init(&ev->cond, NULL);
-    pthread_mutex_init(&ev->mtx, NULL);
-    ev->verif = initialState > 0;
-    ev->autoreset = 0;
-}
-
-void    ySetEvent(yEvent *ev)
-{
-    pthread_mutex_lock(&ev->mtx);
-    ev->verif = 1;
-    // set verif to 1 because pthread condition seems
-    // to allow conditional wait to exit event if nobody
-    // has set the alarm (see google or linux books of seb)
-    pthread_cond_signal(&ev->cond);
-    pthread_mutex_unlock(&ev->mtx);
-
-}
-
-void    yResetEvent(yEvent *ev)
-{
-    pthread_mutex_lock(&ev->mtx);
-    ev->verif = 0;
-    pthread_mutex_unlock(&ev->mtx);
-
-}
-
-
-int   yWaitForEvent(yEvent *ev, int time)
-{
-    int retval;
-    pthread_mutex_lock(&ev->mtx);
-    if (!ev->verif) {
-        if (time >= 0) {
-            struct timeval now;
-            struct timespec later;
-            gettimeofday(&now, NULL);
-            later.tv_sec = now.tv_sec + time / 1000;
-            later.tv_nsec = now.tv_usec * 1000 + (time % 1000) * 1000000;
-            if (later.tv_nsec >= 1000000000) {
-                later.tv_sec++;
-                later.tv_nsec -= 1000000000;
-            }
-            pthread_cond_timedwait(&ev->cond, &ev->mtx, &later);
-        } else {
-            pthread_cond_wait(&ev->cond, &ev->mtx);
-        }
-    }
-    retval = ev->verif;
-    if (ev->autoreset)
-        ev->verif = 0;
-    pthread_mutex_unlock(&ev->mtx);
-    return retval;
-
-}
-void   yCloseEvent(yEvent *ev)
-{
-    pthread_cond_destroy(&ev->cond);
-    pthread_mutex_destroy(&ev->mtx);
-}
-
-static int    yCreateDetachedThreadEx(osThread *th, void* (*fun)(void *), void *arg)
-{
-    pthread_attr_t attr;
-    int result;
-
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    if (pthread_create(th, &attr, fun, arg) != 0) {
-        result = -1;
-    } else {
-        result = 0;
-    }
-    pthread_attr_destroy(&attr);
-
-    return result;
-}
-
-static void    yReleaseDetachedThreadEx(osThread *th_hdl)
-{
-}
-
-
-
-static int yWaitEndThread(osThread *th)
-{
-    return pthread_join(*th, NULL);
-}
-
-
-static void yKillThread(osThread *th)
-{
-    pthread_cancel(*th);
-}
-
-int    yThreadIndex(void)
-{
-    int res;
-
-    pthread_once(&yInitKeyOnce, initTsdKey);
-    res = (int)((u8 *)pthread_getspecific(yTsdKey) - (u8 *)NULL);
-    if (!res) {
-        // tiny risk of race condition, but thread idx is only
-        // used for debug log purposes and is not sensitive
-        res = yNextThreadIdx++;
-        pthread_setspecific(yTsdKey, (void*)((u8 *)NULL + res));
-    }
-    return res;
-}
-
-#endif
-
-
-int    yCreateDetachedThread(void* (*fun)(void *), void *arg)
-{
-    osThread th_hdl;
-    if (yCreateDetachedThreadEx(&th_hdl, fun, arg) < 0) {
-        return -1;
-    }
-    yReleaseDetachedThreadEx(&th_hdl);
-    return 0;
-}
-
-
-int    yThreadCreate(yThread *yth, void* (*fun)(void *), void *arg)
-{
-    if (yth->st == YTHREAD_RUNNING)
-        return 0; // already started nothing to do
-    if (yth->st == YTHREAD_NOT_STARTED) {
-        yth->ctx = arg;
-        yCreateEvent(&yth->ev);
-        if (yCreateDetachedThreadEx(&yth->th, fun, yth) < 0) {
-            yCloseEvent(&yth->ev);
-            return-1;
-        }
-        yWaitForEvent(&yth->ev, -1);
-        yCloseEvent(&yth->ev);
-        return 1;
-    }
-    return -1;
-}
-
-int yThreadIsRunning(yThread *yth)
-{
-    if (yth->st == YTHREAD_RUNNING || yth->st == YTHREAD_MUST_STOP)
-        return 1;
-    return 0;
-}
-
-void   yThreadSignalStart(yThread *yth)
-{
-    //send ok to parent thread
-    yth->st = YTHREAD_RUNNING;
-    ySetEvent(&yth->ev);
-}
-
-
-void   yThreadSignalEnd(yThread *yth)
-{
-    yth->st = YTHREAD_STOPED;
-}
-
-void   yThreadRequestEnd(yThread *yth)
-{
-    if (yth->st == YTHREAD_RUNNING) {
-        yth->st = YTHREAD_MUST_STOP;
-    }
-}
-
-int    yThreadMustEnd(yThread *yth)
-{
-    return yth->st != YTHREAD_RUNNING;
-}
-
-void yThreadKill(yThread *yth)
-{
-    if (yThreadIsRunning(yth)) {
-#ifdef WINDOWS_API
-        //means thread still running lets give it some time
-        if (!yWaitForEvent(&yth->th, 1000)) {
-            yKillThread(&yth->th);
-        }
-#else
-        yKillThread(&yth->th);
-#endif
-    } else {
-        yWaitEndThread(&yth->th);
-        yReleaseDetachedThreadEx(&yth->th);
-    }
-}
-
-
-#ifdef DEBUG_CRITICAL_SECTION
-
-//#include "yproto.h"
-/* printf example */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define MAX_DB_CS 128
-
-
-
-
-static u32 nbycs = 0;
-
-#ifdef __arm__
-#define CS_BREAK {while(1);}
-#else
-#if defined(WINDOWS_API) && (_MSC_VER)
-#define CS_BREAK { _asm {int 3}}
-#else
-#define CS_BREAK  {__asm__("int3");}
-#endif
-#endif
-
-#define CS_ASSERT(x)   if(!(x)){printf("ASSERT FAILED:%s:%d (%s:%d)\n",__FILE__ , __LINE__,fileid,lineno);dump_YCS(csptr);CS_BREAK}
-#define CS_TRACK_NO    24
-
-#ifdef WINDOWS_API
-
-static CRITICAL_SECTION CS_CS;
-
-void yInitDebugCS()
-{
-    InitializeCriticalSection(&CS_CS);
-}
-
-void yFreeDebugCS()
-{
-    DeleteCriticalSection(&CS_CS);
-}
-
-
-static void yEnterDebugCS()
-{
-    EnterCriticalSection(&CS_CS);
-}
-
-
-static void yLeaveDebugCS()
-{
-    LeaveCriticalSection(&CS_CS);
-}
-
-
-#else
-static pthread_mutex_t CS_CS;
-
-void yInitDebugCS()
-{
-    pthread_mutex_init(&CS_CS, NULL);
-
-}
-
-void yFreeDebugCS()
-{
-    pthread_mutex_destroy(&CS_CS);
-}
-
-
-static void yEnterDebugCS()
-{
-    pthread_mutex_lock(&CS_CS);
-}
-
-
-static void yLeaveDebugCS()
-{
-    pthread_mutex_unlock(&CS_CS);
-}
-
-#endif
-
-
-static const char* YCS_STATE_STR[] = {
-     "UNALLOCATED",
-     "ALLOCATED",
-     "DELETED"
-};
-
-static const char* YCS_ACTION_STR[] = {
-     "NONE   ",
-     "INIT   ",
-     "LOCK   ",
-     "LOCKTRY",
-     "RELEASE",
-     "DELETE "
-};
-
-static void dump_YCS(yCRITICAL_SECTION *csptr)
-{
-    int i;
-    yCRITICAL_SECTION_ST *ycs = *csptr;
-    const char* state_str;
-    if (csptr == NULL) {
-        printf("NULL csptr");
-        return;
-    }
-    if (ycs->state < sizeof(YCS_STATE_STR)) {
-        state_str= YCS_STATE_STR[ycs->state];
-    } else {
-        state_str = "INVALID";
-    }
-    printf("%p:%02x: state=%s lock=%d\n", ycs, ycs->no, state_str, ycs->lock);
-    for (i = 0; i < YCS_NB_TRACE; i++) {
-        u32 action = ycs->last_actions[i].action;
-        const char* action_str = "INVALID";
-        const char* file_str = ycs->last_actions[i].fileid;
-        if (action < sizeof(YCS_ACTION_STR)) {
-            action_str = YCS_ACTION_STR[action];
-        }
-        if (file_str == NULL) {
-            file_str = "NULL";
-        }
-        printf(" - %s on %s:%d  (th=%d)\n", action_str,
-            file_str, ycs->last_actions[i].lineno, ycs->last_actions[i].thread);
-    }
-}
-
-
-static void pushCSAction(int threadid, const char* fileid, int lineno, yCRITICAL_SECTION_ST *csptr, YCS_ACTION action)
-{
-    memmove(&csptr->last_actions[1], &csptr->last_actions[0], sizeof(YCS_LOC)*(YCS_NB_TRACE - 1));
-    csptr->last_actions[0].thread = threadid;
-    csptr->last_actions[0].fileid = fileid;
-    csptr->last_actions[0].lineno = lineno;
-    csptr->last_actions[0].action = action;
-}
-
-
-void yDbgInitializeCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *csptr)
-{
-    int res;
-    int threadid = yThreadIndex();
-    *csptr = malloc(sizeof(yCRITICAL_SECTION_ST));
-    memset(*csptr, 0, sizeof(yCRITICAL_SECTION_ST));
-    yEnterDebugCS();
-    (*csptr)->no = nbycs++;
-    yLeaveDebugCS();
-    if ((*csptr)->no == CS_TRACK_NO || CS_TRACK_NO < 0) {
-        printf("NEW CS on %s:%d:%p (%d)\n", fileid, lineno, (*csptr), (*csptr)->no);
-    }
-
-    (*csptr)->state = YCS_ALLOCATED;
-    pushCSAction(threadid, fileid, lineno, (*csptr), YCS_INIT);
-#if MICROCHIP_API
-    (*csptr)->cs = 0;
-    res = 0;
-#elif defined(WINDOWS_API)
-    res = 0;
-    InitializeCriticalSection(&((*csptr)->cs));
-#else
-    res = pthread_mutex_init(&((*csptr)->cs), NULL);
-#endif
-    //EnterCriticalSection(&((*csptr)->cs));
-    //LeaveCriticalSection(&((*csptr)->cs));
-#if 0
-    CS_ASSERT(res == 0);
-    res = pthread_mutex_lock(&((*csptr)->cs));
-    CS_ASSERT(res == 0);
-    res = pthread_mutex_unlock(&((*csptr)->cs));
-#endif
-    CS_ASSERT(res == 0);
-    }
-
-
-void yDbgEnterCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *csptr)
-{
-    int res;
-    int threadid = yThreadIndex();
-
-    CS_ASSERT((*csptr)->no < nbycs);
-    CS_ASSERT((*csptr)->state == YCS_ALLOCATED);
-
-    if ((*csptr)->no == CS_TRACK_NO || CS_TRACK_NO < 0) {
-        printf("enter CS on %s:%d:%p (%d)\n", fileid, lineno, (*csptr), (*csptr)->no);
-}
-
-#if MICROCHIP_API
-    (*csptr)->cs = 1;
-#elif defined(WINDOWS_API)
-    res = 0;
-    EnterCriticalSection(&((*csptr)->cs));
-#else
-    res = pthread_mutex_lock(&((*csptr)->cs));
-#endif
-    CS_ASSERT(res == 0);
-    CS_ASSERT((*csptr)->lock == 0);
-    (*csptr)->lock++;
-    pushCSAction(threadid, fileid, lineno, (*csptr), YCS_LOCK);
-}
-
-
-int yDbgTryEnterCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *csptr)
-{
-    int res;
-    int threadid = yThreadIndex();
-
-    CS_ASSERT((*csptr)->no < nbycs);
-    CS_ASSERT((*csptr)->state == YCS_ALLOCATED);
-
-    if ((*csptr)->no == CS_TRACK_NO || CS_TRACK_NO < 0) {
-        printf("enter CS on %s:%d:%p (%d)\n", fileid, lineno, (*csptr), (*csptr)->no);
-    }
-
-
-#if MICROCHIP_API
-    if ((*csptr)->cs)
-        return 0;
-    (*csptr)->cs = 1;
-#elif defined(WINDOWS_API)
-    res = TryEnterCriticalSection(&((*csptr)->cs));
-    if (res == 0)
-        return 0;
-    CS_ASSERT(res == 1);
-#else
-    res = pthread_mutex_trylock(&((*csptr)->cs));
-    if (res == EBUSY)
-        return 0;
-    CS_ASSERT(res == 0);
-#endif
-    CS_ASSERT((*csptr)->lock == 0);
-    (*csptr)->lock++;
-    pushCSAction(threadid, fileid, lineno, (*csptr), YCS_LOCKTRY);
-    return 1;
-    }
-
-
-void yDbgLeaveCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *csptr)
-{
-    int res;
-    int threadid = yThreadIndex();
-
-
-    CS_ASSERT((*csptr)->no < nbycs);
-    CS_ASSERT((*csptr)->state == YCS_ALLOCATED);
-    CS_ASSERT((*csptr)->lock == 1);
-    if ((*csptr)->no == CS_TRACK_NO || CS_TRACK_NO < 0) {
-        printf("leave CS on %s:%d:%p (%d)\n", fileid, lineno, (*csptr), (*csptr)->no);
-    }
-
-    (*csptr)->lock--;
-    pushCSAction(threadid, fileid, lineno, (*csptr), YCS_RELEASE);
-
-#if MICROCHIP_API
-    (*csptr)->cs = 0;
-    res = 0;
-#elif defined(WINDOWS_API)
-    res = 0;
-    LeaveCriticalSection(&((*csptr)->cs));
-#else
-    res = pthread_mutex_unlock(&((*csptr)->cs));
-#endif
-    CS_ASSERT(res == 0);
-}
-
-void yDbgDeleteCriticalSection(const char* fileid, int lineno, yCRITICAL_SECTION *csptr)
-{
-    int res;
-    int threadid = yThreadIndex();
-
-
-    CS_ASSERT((*csptr)->no < nbycs);
-    CS_ASSERT((*csptr)->state == YCS_ALLOCATED);
-    CS_ASSERT((*csptr)->lock == 0);
-
-    if ((*csptr)->no == CS_TRACK_NO || CS_TRACK_NO < 0) {
-        printf("delete CS on %s:%d:%p (%p)\n", fileid, lineno, (*csptr), &((*csptr)->cs));
-    }
-
-#if MICROCHIP_API
-    (*csptr)->cs = 0xCA;
-    res = 0;
-#elif defined(WINDOWS_API)
-    res = 0;
-    DeleteCriticalSection(&((*csptr)->cs));
-#else
-    res = pthread_mutex_destroy(&((*csptr)->cs));
-#endif
-    CS_ASSERT(res == 0);
-    (*csptr)->state = YCS_DELETED;
-    pushCSAction(threadid, fileid, lineno, (*csptr), YCS_DELETE);
-}
-
-#elif !defined(MICROCHIP_API)
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-typedef struct {
-#if defined(WINDOWS_API)
-    CRITICAL_SECTION             cs;
-#else
-    pthread_mutex_t              cs;
-#endif
-} yCRITICAL_SECTION_ST;
-
-
-void yInitializeCriticalSection(yCRITICAL_SECTION *cs)
-{
-    yCRITICAL_SECTION_ST *ycsptr;
-    ycsptr = (yCRITICAL_SECTION_ST*)malloc(sizeof(yCRITICAL_SECTION_ST));
-    memset(ycsptr, 0, sizeof(yCRITICAL_SECTION_ST));
-#if defined(WINDOWS_API)
-    InitializeCriticalSection(&(ycsptr->cs));
-#else
-    {
-        pthread_mutexattr_t attr;
-        pthread_mutexattr_init(&attr);
-        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
-        pthread_mutex_init(&(ycsptr->cs), &attr);
-    }
-#endif
-    *cs = ycsptr;
-}
-
-void yEnterCriticalSection(yCRITICAL_SECTION *cs)
-{
-    yCRITICAL_SECTION_ST *ycsptr = (yCRITICAL_SECTION_ST*)(*cs);
-#if defined(WINDOWS_API)
-    EnterCriticalSection(&(ycsptr->cs));
-#else
-    pthread_mutex_lock(&(ycsptr->cs));
-#endif
-}
-
-int yTryEnterCriticalSection(yCRITICAL_SECTION *cs)
-{
-    yCRITICAL_SECTION_ST *ycsptr = (yCRITICAL_SECTION_ST*)(*cs);
-#if defined(WINDOWS_API)
-    return TryEnterCriticalSection(&(ycsptr->cs));
-#else
-    {
-        int res = pthread_mutex_trylock(&(ycsptr->cs));
-        if (res == EBUSY)
-            return 0;
-        return 1;
-    }
-#endif
-}
-
-void yLeaveCriticalSection(yCRITICAL_SECTION *cs)
-{
-    yCRITICAL_SECTION_ST *ycsptr = (yCRITICAL_SECTION_ST*)(*cs);
-#if defined(WINDOWS_API)
-    LeaveCriticalSection(&(ycsptr->cs));
-#else
-    pthread_mutex_unlock(&(ycsptr->cs));
-#endif
-}
-
-void yDeleteCriticalSection(yCRITICAL_SECTION *cs)
-{
-    yCRITICAL_SECTION_ST *ycsptr = (yCRITICAL_SECTION_ST*)(*cs);
-#if defined(WINDOWS_API)
-    DeleteCriticalSection(&(ycsptr->cs));
-#else
-    pthread_mutex_destroy(&(ycsptr->cs));
-#endif
-    free(*cs);
-    *cs = NULL;
-}
-
-#endif
-
-
--- a/Sources/cpplib/yapi/ythread.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*********************************************************************
- *
- * $Id: ythread.h 26764 2017-03-16 09:19:55Z seb $
- *
- * OS-independent thread and synchronization library
- *
- * - - - - - - - - - License information: - - - - - - - - - 
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing 
- *  with Yoctopuce products. 
- *
- *  You may reproduce and distribute copies of this file in 
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain 
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and 
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YTHREAD_H
-#define YTHREAD_H
-#include "ydef.h"
-
-/*********************************************************************
- * EVENT FUNCTION 
- *********************************************************************/
-
-#ifdef WINDOWS_API
-#if defined(__BORLANDC__)
-#pragma warn -8019
-#include <windows.h>
-#pragma warn +8019
-#else
-#include <windows.h>
-#endif
-typedef HANDLE yEvent;
-#else
-#include <pthread.h>
-
-
-typedef struct {
-    pthread_cond_t   cond;
-    pthread_mutex_t  mtx;
-    int              verif;
-    int              autoreset;
-} yEvent;
-
-#endif
-
-void   yCreateEvent(yEvent *ev);
-void   yCreateManualEvent(yEvent *event,int initialState);
-void   ySetEvent(yEvent* ev);
-void   yResetEvent(yEvent *ev);
-int    yWaitForEvent(yEvent *ev,int time);
-void   yCloseEvent(yEvent *ev);
-
-
-/*********************************************************************
- * THREAD FUNCTION 
- *********************************************************************/
-#ifdef WIN32
-typedef HANDLE      osThread;
-#else
-typedef pthread_t   osThread;
-#endif
-
-typedef enum {
-    YTHREAD_NOT_STARTED=0,
-    YTHREAD_RUNNING,
-    YTHREAD_MUST_STOP,
-    YTHREAD_STOPED
-} YTHREAD_STATE;
-
-
-typedef struct {
-	void 			*ctx;
-	yEvent 			ev;
-	YTHREAD_STATE 	st;
-	osThread   		th;
-} yThread;
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-    
-int    yCreateDetachedThread(void* (*fun)(void *), void *arg);
-    
-int    yThreadCreate(yThread *yth,void* (*fun)(void *), void *arg);
-int    yThreadIsRunning(yThread *yth);
-void   yThreadSignalStart(yThread *yth);
-void   yThreadSignalEnd(yThread *yth);
-void   yThreadRequestEnd(yThread *yth);
-int    yThreadMustEnd(yThread *yth);
-void   yThreadKill(yThread *yth);
-int    yThreadIndex(void);
-
-#ifdef  __cplusplus
-}
-#endif
-    
-#endif
-
-
--- a/Sources/cpplib/yapi/yversion.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef YOCTO_API_BUILD_NO
-#define YOCTO_API_BUILD_NO          "33831"
-#endif
-#define YBUILD_33831
-
-#ifndef YOCTO_API_BUILD_DATE
-#ifndef RC_INVOKED
-#define YOCTO_API_BUILD_DATE          "" __DATE__ " " __TIME__ ""
-#else
-#define YOCTO_API_BUILD_DATE          "PATCH_WITH_DATE"
-#endif
-#endif
--- a/Sources/cpplib/yocto_accelerometer.cpp
+++ /dev/null
@@ -1,426 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_accelerometer.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindAccelerometer(), the high-level API for Accelerometer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_accelerometer.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "accelerometer"
-
-YAccelerometer::YAccelerometer(const string& func): YSensor(func)
-//--- (YAccelerometer initialization)
-    ,_bandwidth(BANDWIDTH_INVALID)
-    ,_xValue(XVALUE_INVALID)
-    ,_yValue(YVALUE_INVALID)
-    ,_zValue(ZVALUE_INVALID)
-    ,_gravityCancellation(GRAVITYCANCELLATION_INVALID)
-    ,_valueCallbackAccelerometer(NULL)
-    ,_timedReportCallbackAccelerometer(NULL)
-//--- (end of YAccelerometer initialization)
-{
-    _className="Accelerometer";
-}
-
-YAccelerometer::~YAccelerometer()
-{
-//--- (YAccelerometer cleanup)
-//--- (end of YAccelerometer cleanup)
-}
-//--- (YAccelerometer implementation)
-// static attributes
-const double YAccelerometer::XVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YAccelerometer::YVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YAccelerometer::ZVALUE_INVALID = YAPI_INVALID_DOUBLE;
-
-int YAccelerometer::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("bandwidth")) {
-        _bandwidth =  json_val->getInt("bandwidth");
-    }
-    if(json_val->has("xValue")) {
-        _xValue =  floor(json_val->getDouble("xValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("yValue")) {
-        _yValue =  floor(json_val->getDouble("yValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("zValue")) {
-        _zValue =  floor(json_val->getDouble("zValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("gravityCancellation")) {
-        _gravityCancellation =  (Y_GRAVITYCANCELLATION_enum)json_val->getInt("gravityCancellation");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
- *
- * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
- */
-int YAccelerometer::get_bandwidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAccelerometer::BANDWIDTH_INVALID;
-                }
-            }
-        }
-        res = _bandwidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
- * frequency is lower, the device performs averaging.
- *
- * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAccelerometer::set_bandwidth(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("bandwidth", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the X component of the acceleration, as a floating point number.
- *
- * @return a floating point number corresponding to the X component of the acceleration, as a floating point number
- *
- * On failure, throws an exception or returns Y_XVALUE_INVALID.
- */
-double YAccelerometer::get_xValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAccelerometer::XVALUE_INVALID;
-                }
-            }
-        }
-        res = _xValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Y component of the acceleration, as a floating point number.
- *
- * @return a floating point number corresponding to the Y component of the acceleration, as a floating point number
- *
- * On failure, throws an exception or returns Y_YVALUE_INVALID.
- */
-double YAccelerometer::get_yValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAccelerometer::YVALUE_INVALID;
-                }
-            }
-        }
-        res = _yValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Z component of the acceleration, as a floating point number.
- *
- * @return a floating point number corresponding to the Z component of the acceleration, as a floating point number
- *
- * On failure, throws an exception or returns Y_ZVALUE_INVALID.
- */
-double YAccelerometer::get_zValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAccelerometer::ZVALUE_INVALID;
-                }
-            }
-        }
-        res = _zValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_GRAVITYCANCELLATION_enum YAccelerometer::get_gravityCancellation(void)
-{
-    Y_GRAVITYCANCELLATION_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAccelerometer::GRAVITYCANCELLATION_INVALID;
-                }
-            }
-        }
-        res = _gravityCancellation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YAccelerometer::set_gravityCancellation(Y_GRAVITYCANCELLATION_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("gravityCancellation", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an accelerometer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the accelerometer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAccelerometer.isOnline() to test if the accelerometer is
- * indeed online at a given time. In case of ambiguity when looking for
- * an accelerometer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the accelerometer
- *
- * @return a YAccelerometer object allowing you to drive the accelerometer.
- */
-YAccelerometer* YAccelerometer::FindAccelerometer(string func)
-{
-    YAccelerometer* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YAccelerometer*) YFunction::_FindFromCache("Accelerometer", func);
-        if (obj == NULL) {
-            obj = new YAccelerometer(func);
-            YFunction::_AddToCache("Accelerometer", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YAccelerometer::registerValueCallback(YAccelerometerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackAccelerometer = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YAccelerometer::_invokeValueCallback(string value)
-{
-    if (_valueCallbackAccelerometer != NULL) {
-        _valueCallbackAccelerometer(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YAccelerometer::registerTimedReportCallback(YAccelerometerTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackAccelerometer = callback;
-    return 0;
-}
-
-int YAccelerometer::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackAccelerometer != NULL) {
-        _timedReportCallbackAccelerometer(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YAccelerometer *YAccelerometer::nextAccelerometer(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YAccelerometer::FindAccelerometer(hwid);
-}
-
-YAccelerometer* YAccelerometer::FirstAccelerometer(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Accelerometer", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YAccelerometer::FindAccelerometer(serial+"."+funcId);
-}
-
-//--- (end of YAccelerometer implementation)
-
-//--- (YAccelerometer functions)
-//--- (end of YAccelerometer functions)
--- a/Sources/cpplib/yocto_accelerometer.h
+++ /dev/null
@@ -1,338 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_accelerometer.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindAccelerometer(), the high-level API for Accelerometer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_ACCELEROMETER_H
-#define YOCTO_ACCELEROMETER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YAccelerometer return codes)
-//--- (end of YAccelerometer return codes)
-//--- (YAccelerometer yapiwrapper)
-//--- (end of YAccelerometer yapiwrapper)
-//--- (YAccelerometer definitions)
-class YAccelerometer; // forward declaration
-
-typedef void (*YAccelerometerValueCallback)(YAccelerometer *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YAccelerometerTimedReportCallback)(YAccelerometer *func, YMeasure measure);
-#ifndef _Y_GRAVITYCANCELLATION_ENUM
-#define _Y_GRAVITYCANCELLATION_ENUM
-typedef enum {
-    Y_GRAVITYCANCELLATION_OFF = 0,
-    Y_GRAVITYCANCELLATION_ON = 1,
-    Y_GRAVITYCANCELLATION_INVALID = -1,
-} Y_GRAVITYCANCELLATION_enum;
-#endif
-#define Y_BANDWIDTH_INVALID             (YAPI_INVALID_INT)
-#define Y_XVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_YVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_ZVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-//--- (end of YAccelerometer definitions)
-
-//--- (YAccelerometer declaration)
-/**
- * YAccelerometer Class: Accelerometer function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YAccelerometer: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YAccelerometer declaration)
-protected:
-    //--- (YAccelerometer attributes)
-    // Attributes (function value cache)
-    int             _bandwidth;
-    double          _xValue;
-    double          _yValue;
-    double          _zValue;
-    Y_GRAVITYCANCELLATION_enum _gravityCancellation;
-    YAccelerometerValueCallback _valueCallbackAccelerometer;
-    YAccelerometerTimedReportCallback _timedReportCallbackAccelerometer;
-
-    friend YAccelerometer *yFindAccelerometer(const string& func);
-    friend YAccelerometer *yFirstAccelerometer(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindAccelerometer factory function to instantiate
-    YAccelerometer(const string& func);
-    //--- (end of YAccelerometer attributes)
-
-public:
-    virtual ~YAccelerometer();
-    //--- (YAccelerometer accessors declaration)
-
-    static const int BANDWIDTH_INVALID = YAPI_INVALID_INT;
-    static const double XVALUE_INVALID;
-    static const double YVALUE_INVALID;
-    static const double ZVALUE_INVALID;
-    static const Y_GRAVITYCANCELLATION_enum GRAVITYCANCELLATION_OFF = Y_GRAVITYCANCELLATION_OFF;
-    static const Y_GRAVITYCANCELLATION_enum GRAVITYCANCELLATION_ON = Y_GRAVITYCANCELLATION_ON;
-    static const Y_GRAVITYCANCELLATION_enum GRAVITYCANCELLATION_INVALID = Y_GRAVITYCANCELLATION_INVALID;
-
-    /**
-     * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
-     *
-     * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
-     */
-    int                 get_bandwidth(void);
-
-    inline int          bandwidth(void)
-    { return this->get_bandwidth(); }
-
-    /**
-     * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
-     * frequency is lower, the device performs averaging.
-     *
-     * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bandwidth(int newval);
-    inline int      setBandwidth(int newval)
-    { return this->set_bandwidth(newval); }
-
-    /**
-     * Returns the X component of the acceleration, as a floating point number.
-     *
-     * @return a floating point number corresponding to the X component of the acceleration, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_XVALUE_INVALID.
-     */
-    double              get_xValue(void);
-
-    inline double       xValue(void)
-    { return this->get_xValue(); }
-
-    /**
-     * Returns the Y component of the acceleration, as a floating point number.
-     *
-     * @return a floating point number corresponding to the Y component of the acceleration, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_YVALUE_INVALID.
-     */
-    double              get_yValue(void);
-
-    inline double       yValue(void)
-    { return this->get_yValue(); }
-
-    /**
-     * Returns the Z component of the acceleration, as a floating point number.
-     *
-     * @return a floating point number corresponding to the Z component of the acceleration, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_ZVALUE_INVALID.
-     */
-    double              get_zValue(void);
-
-    inline double       zValue(void)
-    { return this->get_zValue(); }
-
-    Y_GRAVITYCANCELLATION_enum get_gravityCancellation(void);
-
-    inline Y_GRAVITYCANCELLATION_enum gravityCancellation(void)
-    { return this->get_gravityCancellation(); }
-
-    int             set_gravityCancellation(Y_GRAVITYCANCELLATION_enum newval);
-    inline int      setGravityCancellation(Y_GRAVITYCANCELLATION_enum newval)
-    { return this->set_gravityCancellation(newval); }
-
-    /**
-     * Retrieves an accelerometer for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the accelerometer is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YAccelerometer.isOnline() to test if the accelerometer is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an accelerometer by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the accelerometer
-     *
-     * @return a YAccelerometer object allowing you to drive the accelerometer.
-     */
-    static YAccelerometer* FindAccelerometer(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YAccelerometerValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YAccelerometerTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YAccelerometer* Find(string func)
-    { return YAccelerometer::FindAccelerometer(func); }
-
-    /**
-     * Continues the enumeration of accelerometers started using yFirstAccelerometer().
-     * Caution: You can't make any assumption about the returned accelerometers order.
-     * If you want to find a specific an accelerometer, use Accelerometer.findAccelerometer()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YAccelerometer object, corresponding to
-     *         an accelerometer currently online, or a NULL pointer
-     *         if there are no more accelerometers to enumerate.
-     */
-           YAccelerometer  *nextAccelerometer(void);
-    inline YAccelerometer  *next(void)
-    { return this->nextAccelerometer();}
-
-    /**
-     * Starts the enumeration of accelerometers currently accessible.
-     * Use the method YAccelerometer.nextAccelerometer() to iterate on
-     * next accelerometers.
-     *
-     * @return a pointer to a YAccelerometer object, corresponding to
-     *         the first accelerometer currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YAccelerometer* FirstAccelerometer(void);
-    inline static YAccelerometer* First(void)
-    { return YAccelerometer::FirstAccelerometer();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YAccelerometer accessors declaration)
-};
-
-//--- (YAccelerometer functions declaration)
-
-/**
- * Retrieves an accelerometer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the accelerometer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAccelerometer.isOnline() to test if the accelerometer is
- * indeed online at a given time. In case of ambiguity when looking for
- * an accelerometer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the accelerometer
- *
- * @return a YAccelerometer object allowing you to drive the accelerometer.
- */
-inline YAccelerometer* yFindAccelerometer(const string& func)
-{ return YAccelerometer::FindAccelerometer(func);}
-/**
- * Starts the enumeration of accelerometers currently accessible.
- * Use the method YAccelerometer.nextAccelerometer() to iterate on
- * next accelerometers.
- *
- * @return a pointer to a YAccelerometer object, corresponding to
- *         the first accelerometer currently online, or a NULL pointer
- *         if there are none.
- */
-inline YAccelerometer* yFirstAccelerometer(void)
-{ return YAccelerometer::FirstAccelerometer();}
-
-//--- (end of YAccelerometer functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_altitude.cpp
+++ /dev/null
@@ -1,350 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_altitude.cpp 32950 2018-11-05 17:15:46Z seb $
- *
- *  Implements yFindAltitude(), the high-level API for Altitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_altitude.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "altitude"
-
-YAltitude::YAltitude(const string& func): YSensor(func)
-//--- (YAltitude initialization)
-    ,_qnh(QNH_INVALID)
-    ,_technology(TECHNOLOGY_INVALID)
-    ,_valueCallbackAltitude(NULL)
-    ,_timedReportCallbackAltitude(NULL)
-//--- (end of YAltitude initialization)
-{
-    _className="Altitude";
-}
-
-YAltitude::~YAltitude()
-{
-//--- (YAltitude cleanup)
-//--- (end of YAltitude cleanup)
-}
-//--- (YAltitude implementation)
-// static attributes
-const double YAltitude::QNH_INVALID = YAPI_INVALID_DOUBLE;
-const string YAltitude::TECHNOLOGY_INVALID = YAPI_INVALID_STRING;
-
-int YAltitude::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("qnh")) {
-        _qnh =  floor(json_val->getDouble("qnh") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("technology")) {
-        _technology =  json_val->getString("technology");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the current estimated altitude. This allows to compensate for
- * ambient pressure variations and to work in relative mode.
- *
- * @param newval : a floating point number corresponding to the current estimated altitude
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAltitude::set_currentValue(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the barometric pressure adjusted to sea level used to compute
- * the altitude (QNH). This enables you to compensate for atmospheric pressure
- * changes due to weather conditions. Applicable to barometric altimeters only.
- *
- * @param newval : a floating point number corresponding to the barometric pressure adjusted to sea
- * level used to compute
- *         the altitude (QNH)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAltitude::set_qnh(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("qnh", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the barometric pressure adjusted to sea level used to compute
- * the altitude (QNH). Applicable to barometric altimeters only.
- *
- * @return a floating point number corresponding to the barometric pressure adjusted to sea level used to compute
- *         the altitude (QNH)
- *
- * On failure, throws an exception or returns Y_QNH_INVALID.
- */
-double YAltitude::get_qnh(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAltitude::QNH_INVALID;
-                }
-            }
-        }
-        res = _qnh;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the technology used by the sesnor to compute
- * altitude. Possibles values are  "barometric" and "gps"
- *
- * @return a string corresponding to the technology used by the sesnor to compute
- *         altitude
- *
- * On failure, throws an exception or returns Y_TECHNOLOGY_INVALID.
- */
-string YAltitude::get_technology(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAltitude::TECHNOLOGY_INVALID;
-                }
-            }
-        }
-        res = _technology;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an altimeter for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the altimeter is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAltitude.isOnline() to test if the altimeter is
- * indeed online at a given time. In case of ambiguity when looking for
- * an altimeter by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the altimeter
- *
- * @return a YAltitude object allowing you to drive the altimeter.
- */
-YAltitude* YAltitude::FindAltitude(string func)
-{
-    YAltitude* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YAltitude*) YFunction::_FindFromCache("Altitude", func);
-        if (obj == NULL) {
-            obj = new YAltitude(func);
-            YFunction::_AddToCache("Altitude", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YAltitude::registerValueCallback(YAltitudeValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackAltitude = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YAltitude::_invokeValueCallback(string value)
-{
-    if (_valueCallbackAltitude != NULL) {
-        _valueCallbackAltitude(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YAltitude::registerTimedReportCallback(YAltitudeTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackAltitude = callback;
-    return 0;
-}
-
-int YAltitude::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackAltitude != NULL) {
-        _timedReportCallbackAltitude(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YAltitude *YAltitude::nextAltitude(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YAltitude::FindAltitude(hwid);
-}
-
-YAltitude* YAltitude::FirstAltitude(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Altitude", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YAltitude::FindAltitude(serial+"."+funcId);
-}
-
-//--- (end of YAltitude implementation)
-
-//--- (YAltitude functions)
-//--- (end of YAltitude functions)
--- a/Sources/cpplib/yocto_altitude.h
+++ /dev/null
@@ -1,304 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_altitude.h 32950 2018-11-05 17:15:46Z seb $
- *
- *  Declares yFindAltitude(), the high-level API for Altitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_ALTITUDE_H
-#define YOCTO_ALTITUDE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YAltitude return codes)
-//--- (end of YAltitude return codes)
-//--- (YAltitude yapiwrapper)
-//--- (end of YAltitude yapiwrapper)
-//--- (YAltitude definitions)
-class YAltitude; // forward declaration
-
-typedef void (*YAltitudeValueCallback)(YAltitude *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YAltitudeTimedReportCallback)(YAltitude *func, YMeasure measure);
-#define Y_QNH_INVALID                   (YAPI_INVALID_DOUBLE)
-#define Y_TECHNOLOGY_INVALID            (YAPI_INVALID_STRING)
-//--- (end of YAltitude definitions)
-
-//--- (YAltitude declaration)
-/**
- * YAltitude Class: Altitude function interface
- *
- * The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude
- * sensors. It inherits from the YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to configure the barometric pressure adjusted to
- * sea level (QNH) for barometric sensors.
- */
-class YOCTO_CLASS_EXPORT YAltitude: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YAltitude declaration)
-protected:
-    //--- (YAltitude attributes)
-    // Attributes (function value cache)
-    double          _qnh;
-    string          _technology;
-    YAltitudeValueCallback _valueCallbackAltitude;
-    YAltitudeTimedReportCallback _timedReportCallbackAltitude;
-
-    friend YAltitude *yFindAltitude(const string& func);
-    friend YAltitude *yFirstAltitude(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindAltitude factory function to instantiate
-    YAltitude(const string& func);
-    //--- (end of YAltitude attributes)
-
-public:
-    virtual ~YAltitude();
-    //--- (YAltitude accessors declaration)
-
-    static const double QNH_INVALID;
-    static const string TECHNOLOGY_INVALID;
-
-    /**
-     * Changes the current estimated altitude. This allows to compensate for
-     * ambient pressure variations and to work in relative mode.
-     *
-     * @param newval : a floating point number corresponding to the current estimated altitude
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentValue(double newval);
-    inline int      setCurrentValue(double newval)
-    { return this->set_currentValue(newval); }
-
-    /**
-     * Changes the barometric pressure adjusted to sea level used to compute
-     * the altitude (QNH). This enables you to compensate for atmospheric pressure
-     * changes due to weather conditions. Applicable to barometric altimeters only.
-     *
-     * @param newval : a floating point number corresponding to the barometric pressure adjusted to sea
-     * level used to compute
-     *         the altitude (QNH)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_qnh(double newval);
-    inline int      setQnh(double newval)
-    { return this->set_qnh(newval); }
-
-    /**
-     * Returns the barometric pressure adjusted to sea level used to compute
-     * the altitude (QNH). Applicable to barometric altimeters only.
-     *
-     * @return a floating point number corresponding to the barometric pressure adjusted to sea level used to compute
-     *         the altitude (QNH)
-     *
-     * On failure, throws an exception or returns Y_QNH_INVALID.
-     */
-    double              get_qnh(void);
-
-    inline double       qnh(void)
-    { return this->get_qnh(); }
-
-    /**
-     * Returns the technology used by the sesnor to compute
-     * altitude. Possibles values are  "barometric" and "gps"
-     *
-     * @return a string corresponding to the technology used by the sesnor to compute
-     *         altitude
-     *
-     * On failure, throws an exception or returns Y_TECHNOLOGY_INVALID.
-     */
-    string              get_technology(void);
-
-    inline string       technology(void)
-    { return this->get_technology(); }
-
-    /**
-     * Retrieves an altimeter for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the altimeter is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YAltitude.isOnline() to test if the altimeter is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an altimeter by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the altimeter
-     *
-     * @return a YAltitude object allowing you to drive the altimeter.
-     */
-    static YAltitude*   FindAltitude(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YAltitudeValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YAltitudeTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YAltitude* Find(string func)
-    { return YAltitude::FindAltitude(func); }
-
-    /**
-     * Continues the enumeration of altimeters started using yFirstAltitude().
-     * Caution: You can't make any assumption about the returned altimeters order.
-     * If you want to find a specific an altimeter, use Altitude.findAltitude()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YAltitude object, corresponding to
-     *         an altimeter currently online, or a NULL pointer
-     *         if there are no more altimeters to enumerate.
-     */
-           YAltitude       *nextAltitude(void);
-    inline YAltitude       *next(void)
-    { return this->nextAltitude();}
-
-    /**
-     * Starts the enumeration of altimeters currently accessible.
-     * Use the method YAltitude.nextAltitude() to iterate on
-     * next altimeters.
-     *
-     * @return a pointer to a YAltitude object, corresponding to
-     *         the first altimeter currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YAltitude* FirstAltitude(void);
-    inline static YAltitude* First(void)
-    { return YAltitude::FirstAltitude();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YAltitude accessors declaration)
-};
-
-//--- (YAltitude functions declaration)
-
-/**
- * Retrieves an altimeter for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the altimeter is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAltitude.isOnline() to test if the altimeter is
- * indeed online at a given time. In case of ambiguity when looking for
- * an altimeter by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the altimeter
- *
- * @return a YAltitude object allowing you to drive the altimeter.
- */
-inline YAltitude* yFindAltitude(const string& func)
-{ return YAltitude::FindAltitude(func);}
-/**
- * Starts the enumeration of altimeters currently accessible.
- * Use the method YAltitude.nextAltitude() to iterate on
- * next altimeters.
- *
- * @return a pointer to a YAltitude object, corresponding to
- *         the first altimeter currently online, or a NULL pointer
- *         if there are none.
- */
-inline YAltitude* yFirstAltitude(void)
-{ return YAltitude::FirstAltitude();}
-
-//--- (end of YAltitude functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_anbutton.cpp
+++ /dev/null
@@ -1,706 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_anbutton.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindAnButton(), the high-level API for AnButton functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_anbutton.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "anbutton"
-
-YAnButton::YAnButton(const string& func): YFunction(func)
-//--- (YAnButton initialization)
-    ,_calibratedValue(CALIBRATEDVALUE_INVALID)
-    ,_rawValue(RAWVALUE_INVALID)
-    ,_analogCalibration(ANALOGCALIBRATION_INVALID)
-    ,_calibrationMax(CALIBRATIONMAX_INVALID)
-    ,_calibrationMin(CALIBRATIONMIN_INVALID)
-    ,_sensitivity(SENSITIVITY_INVALID)
-    ,_isPressed(ISPRESSED_INVALID)
-    ,_lastTimePressed(LASTTIMEPRESSED_INVALID)
-    ,_lastTimeReleased(LASTTIMERELEASED_INVALID)
-    ,_pulseCounter(PULSECOUNTER_INVALID)
-    ,_pulseTimer(PULSETIMER_INVALID)
-    ,_valueCallbackAnButton(NULL)
-//--- (end of YAnButton initialization)
-{
-    _className="AnButton";
-}
-
-YAnButton::~YAnButton()
-{
-//--- (YAnButton cleanup)
-//--- (end of YAnButton cleanup)
-}
-//--- (YAnButton implementation)
-// static attributes
-
-int YAnButton::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("calibratedValue")) {
-        _calibratedValue =  json_val->getInt("calibratedValue");
-    }
-    if(json_val->has("rawValue")) {
-        _rawValue =  json_val->getInt("rawValue");
-    }
-    if(json_val->has("analogCalibration")) {
-        _analogCalibration =  (Y_ANALOGCALIBRATION_enum)json_val->getInt("analogCalibration");
-    }
-    if(json_val->has("calibrationMax")) {
-        _calibrationMax =  json_val->getInt("calibrationMax");
-    }
-    if(json_val->has("calibrationMin")) {
-        _calibrationMin =  json_val->getInt("calibrationMin");
-    }
-    if(json_val->has("sensitivity")) {
-        _sensitivity =  json_val->getInt("sensitivity");
-    }
-    if(json_val->has("isPressed")) {
-        _isPressed =  (Y_ISPRESSED_enum)json_val->getInt("isPressed");
-    }
-    if(json_val->has("lastTimePressed")) {
-        _lastTimePressed =  json_val->getLong("lastTimePressed");
-    }
-    if(json_val->has("lastTimeReleased")) {
-        _lastTimeReleased =  json_val->getLong("lastTimeReleased");
-    }
-    if(json_val->has("pulseCounter")) {
-        _pulseCounter =  json_val->getLong("pulseCounter");
-    }
-    if(json_val->has("pulseTimer")) {
-        _pulseTimer =  json_val->getLong("pulseTimer");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current calibrated input value (between 0 and 1000, included).
- *
- * @return an integer corresponding to the current calibrated input value (between 0 and 1000, included)
- *
- * On failure, throws an exception or returns Y_CALIBRATEDVALUE_INVALID.
- */
-int YAnButton::get_calibratedValue(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::CALIBRATEDVALUE_INVALID;
-                }
-            }
-        }
-        res = _calibratedValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current measured input value as-is (between 0 and 4095, included).
- *
- * @return an integer corresponding to the current measured input value as-is (between 0 and 4095, included)
- *
- * On failure, throws an exception or returns Y_RAWVALUE_INVALID.
- */
-int YAnButton::get_rawValue(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::RAWVALUE_INVALID;
-                }
-            }
-        }
-        res = _rawValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Tells if a calibration process is currently ongoing.
- *
- * @return either Y_ANALOGCALIBRATION_OFF or Y_ANALOGCALIBRATION_ON
- *
- * On failure, throws an exception or returns Y_ANALOGCALIBRATION_INVALID.
- */
-Y_ANALOGCALIBRATION_enum YAnButton::get_analogCalibration(void)
-{
-    Y_ANALOGCALIBRATION_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::ANALOGCALIBRATION_INVALID;
-                }
-            }
-        }
-        res = _analogCalibration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Starts or stops the calibration process. Remember to call the saveToFlash()
- * method of the module at the end of the calibration if the modification must be kept.
- *
- * @param newval : either Y_ANALOGCALIBRATION_OFF or Y_ANALOGCALIBRATION_ON
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAnButton::set_analogCalibration(Y_ANALOGCALIBRATION_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("analogCalibration", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximal value measured during the calibration (between 0 and 4095, included).
- *
- * @return an integer corresponding to the maximal value measured during the calibration (between 0
- * and 4095, included)
- *
- * On failure, throws an exception or returns Y_CALIBRATIONMAX_INVALID.
- */
-int YAnButton::get_calibrationMax(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::CALIBRATIONMAX_INVALID;
-                }
-            }
-        }
-        res = _calibrationMax;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the maximal calibration value for the input (between 0 and 4095, included), without actually
- * starting the automated calibration.  Remember to call the saveToFlash()
- * method of the module if the modification must be kept.
- *
- * @param newval : an integer corresponding to the maximal calibration value for the input (between 0
- * and 4095, included), without actually
- *         starting the automated calibration
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAnButton::set_calibrationMax(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("calibrationMax", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minimal value measured during the calibration (between 0 and 4095, included).
- *
- * @return an integer corresponding to the minimal value measured during the calibration (between 0
- * and 4095, included)
- *
- * On failure, throws an exception or returns Y_CALIBRATIONMIN_INVALID.
- */
-int YAnButton::get_calibrationMin(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::CALIBRATIONMIN_INVALID;
-                }
-            }
-        }
-        res = _calibrationMin;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minimal calibration value for the input (between 0 and 4095, included), without actually
- * starting the automated calibration.  Remember to call the saveToFlash()
- * method of the module if the modification must be kept.
- *
- * @param newval : an integer corresponding to the minimal calibration value for the input (between 0
- * and 4095, included), without actually
- *         starting the automated calibration
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAnButton::set_calibrationMin(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("calibrationMin", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.
- *
- * @return an integer corresponding to the sensibility for the input (between 1 and 1000) for
- * triggering user callbacks
- *
- * On failure, throws an exception or returns Y_SENSITIVITY_INVALID.
- */
-int YAnButton::get_sensitivity(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::SENSITIVITY_INVALID;
-                }
-            }
-        }
-        res = _sensitivity;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.
- * The sensibility is used to filter variations around a fixed value, but does not preclude the
- * transmission of events when the input value evolves constantly in the same direction.
- * Special case: when the value 1000 is used, the callback will only be thrown when the logical state
- * of the input switches from pressed to released and back.
- * Remember to call the saveToFlash() method of the module if the modification must be kept.
- *
- * @param newval : an integer corresponding to the sensibility for the input (between 1 and 1000) for
- * triggering user callbacks
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAnButton::set_sensitivity(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("sensitivity", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true if the input (considered as binary) is active (closed contact), and false otherwise.
- *
- * @return either Y_ISPRESSED_FALSE or Y_ISPRESSED_TRUE, according to true if the input (considered as
- * binary) is active (closed contact), and false otherwise
- *
- * On failure, throws an exception or returns Y_ISPRESSED_INVALID.
- */
-Y_ISPRESSED_enum YAnButton::get_isPressed(void)
-{
-    Y_ISPRESSED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::ISPRESSED_INVALID;
-                }
-            }
-        }
-        res = _isPressed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of elapsed milliseconds between the module power on and the last time
- * the input button was pressed (the input contact transitioned from open to closed).
- *
- * @return an integer corresponding to the number of elapsed milliseconds between the module power on
- * and the last time
- *         the input button was pressed (the input contact transitioned from open to closed)
- *
- * On failure, throws an exception or returns Y_LASTTIMEPRESSED_INVALID.
- */
-s64 YAnButton::get_lastTimePressed(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::LASTTIMEPRESSED_INVALID;
-                }
-            }
-        }
-        res = _lastTimePressed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of elapsed milliseconds between the module power on and the last time
- * the input button was released (the input contact transitioned from closed to open).
- *
- * @return an integer corresponding to the number of elapsed milliseconds between the module power on
- * and the last time
- *         the input button was released (the input contact transitioned from closed to open)
- *
- * On failure, throws an exception or returns Y_LASTTIMERELEASED_INVALID.
- */
-s64 YAnButton::get_lastTimeReleased(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::LASTTIMERELEASED_INVALID;
-                }
-            }
-        }
-        res = _lastTimeReleased;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the pulse counter value. The value is a 32 bit integer. In case
- * of overflow (>=2^32), the counter will wrap. To reset the counter, just
- * call the resetCounter() method.
- *
- * @return an integer corresponding to the pulse counter value
- *
- * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
- */
-s64 YAnButton::get_pulseCounter(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::PULSECOUNTER_INVALID;
-                }
-            }
-        }
-        res = _pulseCounter;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YAnButton::set_pulseCounter(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("pulseCounter", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the timer of the pulses counter (ms).
- *
- * @return an integer corresponding to the timer of the pulses counter (ms)
- *
- * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
- */
-s64 YAnButton::get_pulseTimer(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAnButton::PULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _pulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an analog input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the analog input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAnButton.isOnline() to test if the analog input is
- * indeed online at a given time. In case of ambiguity when looking for
- * an analog input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the analog input
- *
- * @return a YAnButton object allowing you to drive the analog input.
- */
-YAnButton* YAnButton::FindAnButton(string func)
-{
-    YAnButton* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YAnButton*) YFunction::_FindFromCache("AnButton", func);
-        if (obj == NULL) {
-            obj = new YAnButton(func);
-            YFunction::_AddToCache("AnButton", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YAnButton::registerValueCallback(YAnButtonValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackAnButton = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YAnButton::_invokeValueCallback(string value)
-{
-    if (_valueCallbackAnButton != NULL) {
-        _valueCallbackAnButton(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Returns the pulse counter value as well as its timer.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAnButton::resetCounter(void)
-{
-    return this->set_pulseCounter(0);
-}
-
-YAnButton *YAnButton::nextAnButton(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YAnButton::FindAnButton(hwid);
-}
-
-YAnButton* YAnButton::FirstAnButton(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("AnButton", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YAnButton::FindAnButton(serial+"."+funcId);
-}
-
-//--- (end of YAnButton implementation)
-
-//--- (YAnButton functions)
-//--- (end of YAnButton functions)
--- a/Sources/cpplib/yocto_anbutton.h
+++ /dev/null
@@ -1,496 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_anbutton.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindAnButton(), the high-level API for AnButton functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_ANBUTTON_H
-#define YOCTO_ANBUTTON_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YAnButton return codes)
-//--- (end of YAnButton return codes)
-//--- (YAnButton yapiwrapper)
-//--- (end of YAnButton yapiwrapper)
-//--- (YAnButton definitions)
-class YAnButton; // forward declaration
-
-typedef void (*YAnButtonValueCallback)(YAnButton *func, const string& functionValue);
-#ifndef _Y_ANALOGCALIBRATION_ENUM
-#define _Y_ANALOGCALIBRATION_ENUM
-typedef enum {
-    Y_ANALOGCALIBRATION_OFF = 0,
-    Y_ANALOGCALIBRATION_ON = 1,
-    Y_ANALOGCALIBRATION_INVALID = -1,
-} Y_ANALOGCALIBRATION_enum;
-#endif
-#ifndef _Y_ISPRESSED_ENUM
-#define _Y_ISPRESSED_ENUM
-typedef enum {
-    Y_ISPRESSED_FALSE = 0,
-    Y_ISPRESSED_TRUE = 1,
-    Y_ISPRESSED_INVALID = -1,
-} Y_ISPRESSED_enum;
-#endif
-#define Y_CALIBRATEDVALUE_INVALID       (YAPI_INVALID_UINT)
-#define Y_RAWVALUE_INVALID              (YAPI_INVALID_UINT)
-#define Y_CALIBRATIONMAX_INVALID        (YAPI_INVALID_UINT)
-#define Y_CALIBRATIONMIN_INVALID        (YAPI_INVALID_UINT)
-#define Y_SENSITIVITY_INVALID           (YAPI_INVALID_UINT)
-#define Y_LASTTIMEPRESSED_INVALID       (YAPI_INVALID_LONG)
-#define Y_LASTTIMERELEASED_INVALID      (YAPI_INVALID_LONG)
-#define Y_PULSECOUNTER_INVALID          (YAPI_INVALID_LONG)
-#define Y_PULSETIMER_INVALID            (YAPI_INVALID_LONG)
-//--- (end of YAnButton definitions)
-
-//--- (YAnButton declaration)
-/**
- * YAnButton Class: AnButton function interface
- *
- * Yoctopuce application programming interface allows you to measure the state
- * of a simple button as well as to read an analog potentiometer (variable resistance).
- * This can be use for instance with a continuous rotating knob, a throttle grip
- * or a joystick. The module is capable to calibrate itself on min and max values,
- * in order to compute a calibrated value that varies proportionally with the
- * potentiometer position, regardless of its total resistance.
- */
-class YOCTO_CLASS_EXPORT YAnButton: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YAnButton declaration)
-protected:
-    //--- (YAnButton attributes)
-    // Attributes (function value cache)
-    int             _calibratedValue;
-    int             _rawValue;
-    Y_ANALOGCALIBRATION_enum _analogCalibration;
-    int             _calibrationMax;
-    int             _calibrationMin;
-    int             _sensitivity;
-    Y_ISPRESSED_enum _isPressed;
-    s64             _lastTimePressed;
-    s64             _lastTimeReleased;
-    s64             _pulseCounter;
-    s64             _pulseTimer;
-    YAnButtonValueCallback _valueCallbackAnButton;
-
-    friend YAnButton *yFindAnButton(const string& func);
-    friend YAnButton *yFirstAnButton(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindAnButton factory function to instantiate
-    YAnButton(const string& func);
-    //--- (end of YAnButton attributes)
-
-public:
-    virtual ~YAnButton();
-    //--- (YAnButton accessors declaration)
-
-    static const int CALIBRATEDVALUE_INVALID = YAPI_INVALID_UINT;
-    static const int RAWVALUE_INVALID = YAPI_INVALID_UINT;
-    static const Y_ANALOGCALIBRATION_enum ANALOGCALIBRATION_OFF = Y_ANALOGCALIBRATION_OFF;
-    static const Y_ANALOGCALIBRATION_enum ANALOGCALIBRATION_ON = Y_ANALOGCALIBRATION_ON;
-    static const Y_ANALOGCALIBRATION_enum ANALOGCALIBRATION_INVALID = Y_ANALOGCALIBRATION_INVALID;
-    static const int CALIBRATIONMAX_INVALID = YAPI_INVALID_UINT;
-    static const int CALIBRATIONMIN_INVALID = YAPI_INVALID_UINT;
-    static const int SENSITIVITY_INVALID = YAPI_INVALID_UINT;
-    static const Y_ISPRESSED_enum ISPRESSED_FALSE = Y_ISPRESSED_FALSE;
-    static const Y_ISPRESSED_enum ISPRESSED_TRUE = Y_ISPRESSED_TRUE;
-    static const Y_ISPRESSED_enum ISPRESSED_INVALID = Y_ISPRESSED_INVALID;
-    static const s64 LASTTIMEPRESSED_INVALID = YAPI_INVALID_LONG;
-    static const s64 LASTTIMERELEASED_INVALID = YAPI_INVALID_LONG;
-    static const s64 PULSECOUNTER_INVALID = YAPI_INVALID_LONG;
-    static const s64 PULSETIMER_INVALID = YAPI_INVALID_LONG;
-
-    /**
-     * Returns the current calibrated input value (between 0 and 1000, included).
-     *
-     * @return an integer corresponding to the current calibrated input value (between 0 and 1000, included)
-     *
-     * On failure, throws an exception or returns Y_CALIBRATEDVALUE_INVALID.
-     */
-    int                 get_calibratedValue(void);
-
-    inline int          calibratedValue(void)
-    { return this->get_calibratedValue(); }
-
-    /**
-     * Returns the current measured input value as-is (between 0 and 4095, included).
-     *
-     * @return an integer corresponding to the current measured input value as-is (between 0 and 4095, included)
-     *
-     * On failure, throws an exception or returns Y_RAWVALUE_INVALID.
-     */
-    int                 get_rawValue(void);
-
-    inline int          rawValue(void)
-    { return this->get_rawValue(); }
-
-    /**
-     * Tells if a calibration process is currently ongoing.
-     *
-     * @return either Y_ANALOGCALIBRATION_OFF or Y_ANALOGCALIBRATION_ON
-     *
-     * On failure, throws an exception or returns Y_ANALOGCALIBRATION_INVALID.
-     */
-    Y_ANALOGCALIBRATION_enum get_analogCalibration(void);
-
-    inline Y_ANALOGCALIBRATION_enum analogCalibration(void)
-    { return this->get_analogCalibration(); }
-
-    /**
-     * Starts or stops the calibration process. Remember to call the saveToFlash()
-     * method of the module at the end of the calibration if the modification must be kept.
-     *
-     * @param newval : either Y_ANALOGCALIBRATION_OFF or Y_ANALOGCALIBRATION_ON
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_analogCalibration(Y_ANALOGCALIBRATION_enum newval);
-    inline int      setAnalogCalibration(Y_ANALOGCALIBRATION_enum newval)
-    { return this->set_analogCalibration(newval); }
-
-    /**
-     * Returns the maximal value measured during the calibration (between 0 and 4095, included).
-     *
-     * @return an integer corresponding to the maximal value measured during the calibration (between 0
-     * and 4095, included)
-     *
-     * On failure, throws an exception or returns Y_CALIBRATIONMAX_INVALID.
-     */
-    int                 get_calibrationMax(void);
-
-    inline int          calibrationMax(void)
-    { return this->get_calibrationMax(); }
-
-    /**
-     * Changes the maximal calibration value for the input (between 0 and 4095, included), without actually
-     * starting the automated calibration.  Remember to call the saveToFlash()
-     * method of the module if the modification must be kept.
-     *
-     * @param newval : an integer corresponding to the maximal calibration value for the input (between 0
-     * and 4095, included), without actually
-     *         starting the automated calibration
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_calibrationMax(int newval);
-    inline int      setCalibrationMax(int newval)
-    { return this->set_calibrationMax(newval); }
-
-    /**
-     * Returns the minimal value measured during the calibration (between 0 and 4095, included).
-     *
-     * @return an integer corresponding to the minimal value measured during the calibration (between 0
-     * and 4095, included)
-     *
-     * On failure, throws an exception or returns Y_CALIBRATIONMIN_INVALID.
-     */
-    int                 get_calibrationMin(void);
-
-    inline int          calibrationMin(void)
-    { return this->get_calibrationMin(); }
-
-    /**
-     * Changes the minimal calibration value for the input (between 0 and 4095, included), without actually
-     * starting the automated calibration.  Remember to call the saveToFlash()
-     * method of the module if the modification must be kept.
-     *
-     * @param newval : an integer corresponding to the minimal calibration value for the input (between 0
-     * and 4095, included), without actually
-     *         starting the automated calibration
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_calibrationMin(int newval);
-    inline int      setCalibrationMin(int newval)
-    { return this->set_calibrationMin(newval); }
-
-    /**
-     * Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.
-     *
-     * @return an integer corresponding to the sensibility for the input (between 1 and 1000) for
-     * triggering user callbacks
-     *
-     * On failure, throws an exception or returns Y_SENSITIVITY_INVALID.
-     */
-    int                 get_sensitivity(void);
-
-    inline int          sensitivity(void)
-    { return this->get_sensitivity(); }
-
-    /**
-     * Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.
-     * The sensibility is used to filter variations around a fixed value, but does not preclude the
-     * transmission of events when the input value evolves constantly in the same direction.
-     * Special case: when the value 1000 is used, the callback will only be thrown when the logical state
-     * of the input switches from pressed to released and back.
-     * Remember to call the saveToFlash() method of the module if the modification must be kept.
-     *
-     * @param newval : an integer corresponding to the sensibility for the input (between 1 and 1000) for
-     * triggering user callbacks
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_sensitivity(int newval);
-    inline int      setSensitivity(int newval)
-    { return this->set_sensitivity(newval); }
-
-    /**
-     * Returns true if the input (considered as binary) is active (closed contact), and false otherwise.
-     *
-     * @return either Y_ISPRESSED_FALSE or Y_ISPRESSED_TRUE, according to true if the input (considered as
-     * binary) is active (closed contact), and false otherwise
-     *
-     * On failure, throws an exception or returns Y_ISPRESSED_INVALID.
-     */
-    Y_ISPRESSED_enum    get_isPressed(void);
-
-    inline Y_ISPRESSED_enum isPressed(void)
-    { return this->get_isPressed(); }
-
-    /**
-     * Returns the number of elapsed milliseconds between the module power on and the last time
-     * the input button was pressed (the input contact transitioned from open to closed).
-     *
-     * @return an integer corresponding to the number of elapsed milliseconds between the module power on
-     * and the last time
-     *         the input button was pressed (the input contact transitioned from open to closed)
-     *
-     * On failure, throws an exception or returns Y_LASTTIMEPRESSED_INVALID.
-     */
-    s64                 get_lastTimePressed(void);
-
-    inline s64          lastTimePressed(void)
-    { return this->get_lastTimePressed(); }
-
-    /**
-     * Returns the number of elapsed milliseconds between the module power on and the last time
-     * the input button was released (the input contact transitioned from closed to open).
-     *
-     * @return an integer corresponding to the number of elapsed milliseconds between the module power on
-     * and the last time
-     *         the input button was released (the input contact transitioned from closed to open)
-     *
-     * On failure, throws an exception or returns Y_LASTTIMERELEASED_INVALID.
-     */
-    s64                 get_lastTimeReleased(void);
-
-    inline s64          lastTimeReleased(void)
-    { return this->get_lastTimeReleased(); }
-
-    /**
-     * Returns the pulse counter value. The value is a 32 bit integer. In case
-     * of overflow (>=2^32), the counter will wrap. To reset the counter, just
-     * call the resetCounter() method.
-     *
-     * @return an integer corresponding to the pulse counter value
-     *
-     * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
-     */
-    s64                 get_pulseCounter(void);
-
-    inline s64          pulseCounter(void)
-    { return this->get_pulseCounter(); }
-
-    int             set_pulseCounter(s64 newval);
-    inline int      setPulseCounter(s64 newval)
-    { return this->set_pulseCounter(newval); }
-
-    /**
-     * Returns the timer of the pulses counter (ms).
-     *
-     * @return an integer corresponding to the timer of the pulses counter (ms)
-     *
-     * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
-     */
-    s64                 get_pulseTimer(void);
-
-    inline s64          pulseTimer(void)
-    { return this->get_pulseTimer(); }
-
-    /**
-     * Retrieves an analog input for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the analog input is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YAnButton.isOnline() to test if the analog input is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an analog input by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the analog input
-     *
-     * @return a YAnButton object allowing you to drive the analog input.
-     */
-    static YAnButton*   FindAnButton(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YAnButtonValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Returns the pulse counter value as well as its timer.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetCounter(void);
-
-
-    inline static YAnButton* Find(string func)
-    { return YAnButton::FindAnButton(func); }
-
-    /**
-     * Continues the enumeration of analog inputs started using yFirstAnButton().
-     * Caution: You can't make any assumption about the returned analog inputs order.
-     * If you want to find a specific an analog input, use AnButton.findAnButton()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YAnButton object, corresponding to
-     *         an analog input currently online, or a NULL pointer
-     *         if there are no more analog inputs to enumerate.
-     */
-           YAnButton       *nextAnButton(void);
-    inline YAnButton       *next(void)
-    { return this->nextAnButton();}
-
-    /**
-     * Starts the enumeration of analog inputs currently accessible.
-     * Use the method YAnButton.nextAnButton() to iterate on
-     * next analog inputs.
-     *
-     * @return a pointer to a YAnButton object, corresponding to
-     *         the first analog input currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YAnButton* FirstAnButton(void);
-    inline static YAnButton* First(void)
-    { return YAnButton::FirstAnButton();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YAnButton accessors declaration)
-};
-
-//--- (YAnButton functions declaration)
-
-/**
- * Retrieves an analog input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the analog input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAnButton.isOnline() to test if the analog input is
- * indeed online at a given time. In case of ambiguity when looking for
- * an analog input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the analog input
- *
- * @return a YAnButton object allowing you to drive the analog input.
- */
-inline YAnButton* yFindAnButton(const string& func)
-{ return YAnButton::FindAnButton(func);}
-/**
- * Starts the enumeration of analog inputs currently accessible.
- * Use the method YAnButton.nextAnButton() to iterate on
- * next analog inputs.
- *
- * @return a pointer to a YAnButton object, corresponding to
- *         the first analog input currently online, or a NULL pointer
- *         if there are none.
- */
-inline YAnButton* yFirstAnButton(void)
-{ return YAnButton::FirstAnButton();}
-
-//--- (end of YAnButton functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_api.cpp
+++ /dev/null
@@ -1,9177 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_api.cpp 33821 2018-12-21 13:57:06Z seb $
- *
- * High-level programming interface, common to all modules
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-#define __FILE_ID__ "yocto_api"
-#define _CRT_SECURE_NO_DEPRECATE
-#include "yocto_api.h"
-#include "yapi/yapi.h"
-
-#ifdef WINDOWS_API
-#include <Windows.h>
-#define yySleep(ms)          Sleep(ms)
-#else
-#include <unistd.h>
-#define yySleep(ms)          usleep(ms*1000)
-#endif
-
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <cfloat>
-#include <cmath>
-#include <time.h>
-#include <stdarg.h>
-#include <math.h>
-#define YMEMORY_ALLOW_MALLOC
-#include "yapi/yproto.h"
-#include <iostream>
-
-static yCRITICAL_SECTION _updateDeviceList_CS;
-static yCRITICAL_SECTION _handleEvent_CS;
-
-static std::vector<YFunction*> _FunctionCallbacks;
-static std::vector<YFunction*> _TimedReportCallbackList;
-static std::map<YModule*, int> _moduleCallbackList;
-
-const string YFunction::HARDWAREID_INVALID = YAPI_INVALID_STRING;
-const string YFunction::FUNCTIONID_INVALID = YAPI_INVALID_STRING;
-const string YFunction::FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
-
-const double YDataStream::DATA_INVALID = Y_DATA_INVALID;
-
-int _ystrpos(const string& haystack, const string& needle)
-{
-    size_t pos = haystack.find(needle);
-    if (pos == string::npos) {
-        return -1;
-    }
-    return (int)pos;
-}
-
-vector<string> _strsplit(const string& str, char delimiter)
-{
-    vector<string> res;
-    size_t pos = 0;
-    size_t found;
-
-    do {
-        found = str.find(delimiter, pos);
-        if (found != std::string::npos) {
-            res.push_back(str.substr(pos, found - pos));
-            pos = found + 1;
-        }
-    } while (found != std::string::npos);
-    res.push_back(str.substr(pos));
-    return res;
-}
-
-
-YJSONContent* YJSONContent::ParseJson(const string& data, int start, int stop)
-{
-    int cur_pos = YJSONContent::SkipGarbage(data, start, stop);
-    YJSONContent* res;
-    if (data[cur_pos] == '[') {
-        res = new YJSONArray(data, start, stop);
-    } else if (data[cur_pos] == '{') {
-        res = new YJSONObject(data, start, stop);
-    } else if (data[cur_pos] == '"') {
-        res = new YJSONString(data, start, stop);
-    } else {
-        res = new YJSONNumber(data, start, stop);
-    }
-    res->parse();
-    return res;
-}
-
-YJSONContent::YJSONContent(const string& data, int start, int stop, YJSONType type)
-{
-    _data = data;
-    _data_start = start;
-    _data_boundary = stop;
-    _type = type;
-}
-
-YJSONContent::YJSONContent(YJSONType type)
-{
-    _data = ""; //todo: check not null
-}
-
-YJSONContent::YJSONContent(YJSONContent* ref)
-{
-    _data = ref->_data;
-    _data_start = ref->_data_start;
-    _data_boundary = ref->_data_boundary;
-    _data_len = ref->_data_len;
-    _type = ref->_type;
-}
-
-
-YJSONContent::~YJSONContent()
-{
-    _data = "";
-}
-
-YJSONType YJSONContent::getJSONType()
-{
-    return _type;
-}
-
-int YJSONContent::SkipGarbage(const string& data, int start, int stop)
-{
-    if (data.length() <= (unsigned)start) {
-        return start;
-    }
-    char sti = data[start];
-    while (start < stop && (sti == '\n' || sti == '\r' || sti == ' ')) {
-        start++;
-    }
-    return start;
-}
-
-string YJSONContent::FormatError(const string& errmsg, int cur_pos)
-{
-    int ststart = cur_pos - 10;
-    int stend = cur_pos + 10;
-    if (ststart < 0)
-        ststart = 0;
-    if (stend > _data_boundary)
-        stend = _data_boundary;
-    if (_data == "") {
-        //todo: check not null
-        return errmsg;
-    }
-    return errmsg + " near " + _data.substr(ststart, cur_pos - ststart) + _data.substr(cur_pos, stend - cur_pos);
-}
-
-
-YJSONArray::YJSONArray(const string& data, int start, int stop) : YJSONContent(data, start, stop, ARRAY)
-{ }
-
-
-YJSONArray::YJSONArray() : YJSONContent(ARRAY)
-{ }
-
-YJSONArray::YJSONArray(YJSONArray* ref) : YJSONContent(ref)
-{
-    for (unsigned i = 0; i < ref->_arrayValue.size(); i++) {
-        YJSONType type = ref->_arrayValue[i]->getJSONType();
-        switch (type) {
-        case ARRAY: {
-            YJSONArray* tmp = new YJSONArray((YJSONArray*)ref->_arrayValue[i]);
-            _arrayValue.push_back(tmp);
-        }
-        break;
-        case NUMBER: {
-            YJSONNumber* tmp = new YJSONNumber((YJSONNumber*)ref->_arrayValue[i]);
-            _arrayValue.push_back(tmp);
-        }
-        break;
-        case STRING: {
-            YJSONString* tmp = new YJSONString((YJSONString*)ref->_arrayValue[i]);
-            _arrayValue.push_back(tmp);
-        }
-        break;
-        case OBJECT: {
-            YJSONObject* tmp = new YJSONObject((YJSONObject*)ref->_arrayValue[i]);
-            _arrayValue.push_back(tmp);
-        }
-        break;
-        }
-    }
-}
-
-
-YJSONArray::~YJSONArray()
-{
-    for (unsigned i = 0; i < _arrayValue.size(); i++) {
-        delete _arrayValue[i];
-    }
-    _arrayValue.clear();
-}
-
-int YJSONArray::length()
-{
-    return (int)_arrayValue.size();
-}
-
-int YJSONArray::parse()
-{
-    int cur_pos = SkipGarbage(_data, _data_start, _data_boundary);
-
-    if (_data[cur_pos] != '[') {
-        throw YAPI_Exception(YAPI_IO_ERROR, FormatError("Opening braces was expected", cur_pos));
-    }
-    cur_pos++;
-    Tjstate state = JWAITFORDATA;
-
-    while (cur_pos < _data_boundary) {
-        char sti = _data[cur_pos];
-        switch (state) {
-        case JWAITFORDATA:
-            if (sti == '{') {
-                YJSONObject* jobj = new YJSONObject(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _arrayValue.push_back(jobj);
-                state = JWAITFORNEXTARRAYITEM;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '[') {
-                YJSONArray* jobj = new YJSONArray(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _arrayValue.push_back(jobj);
-                state = JWAITFORNEXTARRAYITEM;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '"') {
-                YJSONString* jobj = new YJSONString(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _arrayValue.push_back(jobj);
-                state = JWAITFORNEXTARRAYITEM;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '-' || (sti >= '0' && sti <= '9')) {
-                YJSONNumber* jobj = new YJSONNumber(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _arrayValue.push_back(jobj);
-                state = JWAITFORNEXTARRAYITEM;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == ']') {
-                _data_len = cur_pos + 1 - _data_start;
-                return _data_len;
-            } else if (sti != ' ' && sti != '\n' && sti != '\r') {
-                throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting  \",0..9,t or f", cur_pos));
-            }
-            break;
-        case JWAITFORNEXTARRAYITEM:
-            if (sti == ',') {
-                state = JWAITFORDATA;
-            } else if (sti == ']') {
-                _data_len = cur_pos + 1 - _data_start;
-                return _data_len;
-            } else {
-                if (sti != ' ' && sti != '\n' && sti != '\r') {
-                    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting ,", cur_pos));
-                }
-            }
-            break;
-        default:
-            throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid state for YJSONObject", cur_pos));
-        }
-        cur_pos++;
-    }
-    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("unexpected end of data", cur_pos));
-}
-
-YJSONObject* YJSONArray::getYJSONObject(int i)
-{
-    return (YJSONObject*)_arrayValue[i];
-}
-
-string YJSONArray::getString(int i)
-{
-    YJSONString* ystr = (YJSONString*)_arrayValue[i];
-    return ystr->getString();
-}
-
-YJSONContent* YJSONArray::get(int i)
-{
-    return _arrayValue[i];
-}
-
-YJSONArray* YJSONArray::getYJSONArray(int i)
-{
-    return (YJSONArray*)_arrayValue[i];
-}
-
-int YJSONArray::getInt(int i)
-{
-    YJSONNumber* ystr = (YJSONNumber*)_arrayValue[i];
-    return ystr->getInt();
-}
-
-s64 YJSONArray::getLong(int i)
-{
-    YJSONNumber* ystr = (YJSONNumber*)_arrayValue[i];
-    return ystr->getLong();
-}
-
-void YJSONArray::put(const string& flatAttr)
-{
-    YJSONString* strobj = new YJSONString();
-    strobj->setContent(flatAttr);
-    _arrayValue.push_back(strobj);
-}
-
-string YJSONArray::toJSON()
-{
-    string res = "[";
-    string sep = "";
-    unsigned int i;
-    for (i = 0; i < _arrayValue.size(); i++) {
-        YJSONContent* yjsonContent = _arrayValue[i];
-        string subres = yjsonContent->toJSON();
-        res += sep;
-        res += subres;
-        sep = ",";
-    }
-    res += ']';
-    return res;
-}
-
-string YJSONArray::toString()
-{
-    string res = "[";
-    string sep = "";
-    unsigned int i;
-    for (i = 0; i < _arrayValue.size(); i++) {
-        YJSONContent* yjsonContent = _arrayValue[i];
-        string subres = yjsonContent->toString();
-        res += sep;
-        res += subres;
-        sep = ",";
-    }
-    res += ']';
-    return res;
-}
-
-
-YJSONString::YJSONString(const string& data, int start, int stop) : YJSONContent(data, start, stop, STRING)
-{ }
-
-YJSONString::YJSONString() : YJSONContent(STRING)
-{ }
-
-YJSONString::YJSONString(YJSONString* ref) : YJSONContent(ref)
-{
-    _stringValue = ref->_stringValue;
-}
-
-int YJSONString::parse()
-{
-    string value = "";
-    int cur_pos = SkipGarbage(_data, _data_start, _data_boundary);
-
-    if (_data[cur_pos] != '"') {
-        throw YAPI_Exception(YAPI_IO_ERROR, FormatError("double quote was expected", cur_pos));
-    }
-    cur_pos++;
-    int str_start = cur_pos;
-    Tjstate state = JWAITFORSTRINGVALUE;
-
-    while (cur_pos < _data_boundary) {
-        unsigned char sti = _data[cur_pos];
-        switch (state) {
-        case JWAITFORSTRINGVALUE:
-            if (sti == '\\') {
-                value += _data.substr(str_start, cur_pos - str_start);
-                str_start = cur_pos;
-                state = JWAITFORSTRINGVALUE_ESC;
-            } else if (sti == '"') {
-                value += _data.substr(str_start, cur_pos - str_start);
-                _stringValue = value;
-                _data_len = (cur_pos + 1) - _data_start;
-                return _data_len;
-            } else if (sti < 32) {
-                throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting string value", cur_pos));
-            }
-            break;
-        case JWAITFORSTRINGVALUE_ESC:
-            value += sti;
-            state = JWAITFORSTRINGVALUE;
-            str_start = cur_pos + 1;
-            break;
-        default:
-            throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid state for YJSONObject", cur_pos));
-        }
-        cur_pos++;
-    }
-    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("unexpected end of data", cur_pos));
-}
-
-string YJSONString::toJSON()
-{
-    string res = "\"";
-    const char* c = _stringValue.c_str();
-    while (*c) {
-        switch (*c) {
-        case '"':
-            res += "\\\"";
-            break;
-        case '\\':
-            res += "\\\\";
-            break;
-        case '/':
-            res += "\\/";
-            break;
-        case '\b':
-            res += "\\b";
-            break;
-        case '\f':
-            res += "\\f";
-            break;
-        case '\n':
-            res += "\\n";
-            break;
-        case '\r':
-            res += "\\r";
-            break;
-        case '\t':
-            res += "\\t";
-            break;
-        default:
-            res += *c;
-            break;
-        }
-        c++;
-    }
-    res += '"';
-    return res;
-}
-
-string YJSONString::getString()
-{
-    return _stringValue;
-}
-
-string YJSONString::toString()
-{
-    return _stringValue;
-}
-
-void YJSONString::setContent(const string& value)
-{
-    _stringValue = value;
-}
-
-
-YJSONNumber::YJSONNumber(const string& data, int start, int stop) : YJSONContent(data, start, stop, NUMBER), _intValue(0), _doubleValue(0), _isFloat(false)
-{ }
-
-YJSONNumber::YJSONNumber(YJSONNumber* ref) : YJSONContent(ref)
-{
-    _intValue = ref->_intValue;
-    _doubleValue = ref->_doubleValue;
-    _isFloat = ref->_isFloat;
-}
-
-
-int YJSONNumber::parse()
-{
-    bool neg = false;
-    int start;
-    char sti;
-    int cur_pos = SkipGarbage(_data, _data_start, _data_boundary);
-    sti = _data[cur_pos];
-    if (sti == '-') {
-        neg = true;
-        cur_pos++;
-    }
-    start = cur_pos;
-    while (cur_pos < _data_boundary) {
-        sti = _data[cur_pos];
-        if (sti == '.' && _isFloat == false) {
-            string int_part = _data.substr(start, cur_pos - start);
-            _intValue = yatoi((int_part).c_str());
-            _isFloat = true;
-        } else if (sti < '0' || sti > '9') {
-            string numberpart = _data.substr(start, cur_pos - start);
-            if (_isFloat) {
-                _doubleValue = atof((numberpart).c_str());
-            } else {
-                _intValue = yatoi((numberpart).c_str());
-            }
-            if (neg) {
-                _doubleValue = 0 - _doubleValue;
-                _intValue = 0 - _intValue;
-            }
-            return cur_pos - _data_start;
-        }
-        cur_pos++;
-    }
-    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("unexpected end of data", cur_pos));
-}
-
-string YJSONNumber::toJSON()
-{
-    if (_isFloat)
-        return YapiWrapper::ysprintf("%f", _doubleValue);
-    else
-        return YapiWrapper::ysprintf("%d", _intValue);
-}
-
-s64 YJSONNumber::getLong()
-{
-    if (_isFloat)
-        return (s64)_doubleValue;
-    else
-        return _intValue;
-}
-
-int YJSONNumber::getInt()
-{
-    if (_isFloat)
-        return (int)_doubleValue;
-    else
-        return (int)_intValue;
-}
-
-double YJSONNumber::getDouble()
-{
-    if (_isFloat)
-        return _doubleValue;
-    else
-        return (double)_intValue;
-}
-
-string YJSONNumber::toString()
-{
-    if (_isFloat)
-        return YapiWrapper::ysprintf("%f", _doubleValue);
-    else
-        return YapiWrapper::ysprintf("%d", _intValue);
-}
-
-
-YJSONObject::YJSONObject(const string& data) : YJSONContent(data, 0, (int)data.length(), OBJECT)
-{ }
-
-YJSONObject::YJSONObject(const string& data, int start, int len) : YJSONContent(data, start, len, OBJECT)
-{ }
-
-YJSONObject::YJSONObject(YJSONObject* ref) : YJSONContent(ref)
-{
-    for (unsigned i = 0; i < ref->_keys.size(); i++) {
-        string key = ref->_keys[i];
-        _keys.push_back(key);
-        YJSONType type = ref->_parsed[key]->getJSONType();
-        switch (type) {
-        case ARRAY:
-            _parsed[key] = new YJSONArray((YJSONArray*)ref->_parsed[key]);
-            break;
-        case NUMBER:
-            _parsed[key] = new YJSONNumber((YJSONNumber*)ref->_parsed[key]);
-            break;
-        case STRING:
-            _parsed[key] = new YJSONString((YJSONString*)ref->_parsed[key]);
-            break;
-        case OBJECT:
-            _parsed[key] = new YJSONObject((YJSONObject*)ref->_parsed[key]);
-            break;
-        }
-    }
-}
-
-YJSONObject::~YJSONObject()
-{
-    //printf("relase YJSONObject\n");
-    for (unsigned i = 0; i < _keys.size(); i++) {
-        delete _parsed[_keys[i]];
-    }
-    _parsed.clear();
-    _keys.clear();
-}
-
-int YJSONObject::parse()
-{
-    string current_name = "";
-    int name_start = _data_start;
-    int cur_pos = SkipGarbage(_data, _data_start, _data_boundary);
-
-    if (_data.length() <= (unsigned)cur_pos || _data[cur_pos] != '{') {
-        throw YAPI_Exception(YAPI_IO_ERROR, FormatError("Opening braces was expected", cur_pos));
-    }
-    cur_pos++;
-    Tjstate state = JWAITFORNAME;
-
-    while (cur_pos < _data_boundary) {
-        char sti = _data[cur_pos];
-        switch (state) {
-        case JWAITFORNAME:
-            if (sti == '"') {
-                state = JWAITFORENDOFNAME;
-                name_start = cur_pos + 1;
-            } else if (sti == '}') {
-                _data_len = cur_pos + 1 - _data_start;
-                return _data_len;
-            } else {
-                if (sti != ' ' && sti != '\n' && sti != '\r') {
-                    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting \"", cur_pos));
-                }
-            }
-            break;
-        case JWAITFORENDOFNAME:
-            if (sti == '"') {
-                current_name = _data.substr(name_start, cur_pos - name_start);
-                state = JWAITFORCOLON;
-
-            } else {
-                if (sti < 32) {
-                    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting an identifier compliant char", cur_pos));
-                }
-            }
-            break;
-        case JWAITFORCOLON:
-            if (sti == ':') {
-                state = JWAITFORDATA;
-            } else {
-                if (sti != ' ' && sti != '\n' && sti != '\r') {
-                    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting \"", cur_pos));
-                }
-            }
-            break;
-        case JWAITFORDATA:
-            if (sti == '{') {
-                YJSONObject* jobj = new YJSONObject(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _parsed[current_name] = jobj;
-                _keys.push_back(current_name);
-                state = JWAITFORNEXTSTRUCTMEMBER;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '[') {
-                YJSONArray* jobj = new YJSONArray(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _parsed[current_name] = jobj;
-                _keys.push_back(current_name);
-                state = JWAITFORNEXTSTRUCTMEMBER;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '"') {
-                YJSONString* jobj = new YJSONString(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _parsed[current_name] = jobj;
-                _keys.push_back(current_name);
-                state = JWAITFORNEXTSTRUCTMEMBER;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti == '-' || (sti >= '0' && sti <= '9')) {
-                YJSONNumber* jobj = new YJSONNumber(_data, cur_pos, _data_boundary);
-                int len = jobj->parse();
-                cur_pos += len;
-                _parsed[current_name] = jobj;
-                _keys.push_back(current_name);
-                state = JWAITFORNEXTSTRUCTMEMBER;
-                //cur_pos is already incremented
-                continue;
-            } else if (sti != ' ' && sti != '\n' && sti != '\r') {
-                throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting  \",0..9,t or f", cur_pos));
-            }
-            break;
-        case JWAITFORNEXTSTRUCTMEMBER:
-            if (sti == ',') {
-                state = JWAITFORNAME;
-                name_start = cur_pos + 1;
-            } else if (sti == '}') {
-                _data_len = cur_pos + 1 - _data_start;
-                return _data_len;
-            } else {
-                if (sti != ' ' && sti != '\n' && sti != '\r') {
-                    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid char: was expecting ,", cur_pos));
-                }
-            }
-            break;
-        default:
-            throw YAPI_Exception(YAPI_IO_ERROR, FormatError("invalid state for YJSONObject", cur_pos));
-        }
-        cur_pos++;
-    }
-    throw YAPI_Exception(YAPI_IO_ERROR, FormatError("unexpected end of data", cur_pos));
-}
-
-bool YJSONObject::has(const string& key)
-{
-    if (_parsed.find(key) == _parsed.end()) {
-        return false;
-    } else {
-        return true;
-    }
-}
-
-YJSONObject* YJSONObject::getYJSONObject(const string& key)
-{
-    return (YJSONObject*)_parsed[key];
-}
-
-YJSONString* YJSONObject::getYJSONString(const string& key)
-{
-    return (YJSONString*)_parsed[key];
-}
-
-YJSONArray* YJSONObject::getYJSONArray(const string& key)
-{
-    return (YJSONArray*)_parsed[key];
-}
-
-vector<string> YJSONObject::keys()
-{
-    vector<string> v;
-    for (map<string, YJSONContent*>::iterator it = _parsed.begin(); it != _parsed.end(); ++it) {
-        v.push_back(it->first);
-    }
-    return v;
-}
-
-YJSONNumber* YJSONObject::getYJSONNumber(const string& key)
-{
-    return (YJSONNumber*)_parsed[key];
-}
-
-string YJSONObject::getString(const string& key)
-{
-    YJSONString* ystr = (YJSONString*)_parsed[key];
-    return ystr->getString();
-}
-
-int YJSONObject::getInt(const string& key)
-{
-    YJSONNumber* yint = (YJSONNumber*)_parsed[key];
-    return yint->getInt();
-}
-
-YJSONContent* YJSONObject::get(const string& key)
-{
-    return _parsed[key];
-}
-
-s64 YJSONObject::getLong(const string& key)
-{
-    YJSONNumber* yint = (YJSONNumber*)_parsed[key];
-    return yint->getLong();
-}
-
-double YJSONObject::getDouble(const string& key)
-{
-    YJSONNumber* yint = (YJSONNumber*)_parsed[key];
-    return yint->getDouble();
-}
-
-string YJSONObject::toJSON()
-{
-    string res = "{";
-    string sep = "";
-    unsigned int i;
-    for (i = 0; i < _keys.size(); i++) {
-        string key = _keys[i];
-        YJSONContent* subContent = _parsed[key];
-        string subres = subContent->toJSON();
-        res += sep;
-        res += '"';
-        res += key;
-        res += "\":";
-        res += subres;
-        sep = ",";
-    }
-    res += '}';
-    return res;
-}
-
-string YJSONObject::toString()
-{
-    string res = "{";
-    string sep = "";
-    unsigned int i;
-    for (i = 0; i < _keys.size(); i++) {
-        string key = _keys[i];
-        YJSONContent* subContent = _parsed[key];
-        string subres = subContent->toString();
-        res += sep;
-        res += '"';
-        res += key;
-        res += "\":";
-        res += subres;
-        sep = ",";
-    }
-    res += '}';
-    return res;
-}
-
-
-void YJSONObject::parseWithRef(YJSONObject* reference)
-{
-    if (reference != NULL) {
-        try {
-            YJSONArray* yzon = new YJSONArray(_data, _data_start, _data_boundary);
-            yzon->parse();
-            convert(reference, yzon);
-            delete yzon;
-            return;
-        } catch (std::exception) { }
-    }
-    this->parse();
-}
-
-void YJSONObject::convert(YJSONObject* reference, YJSONArray* newArray)
-{
-    int length = newArray->length();
-    for (int i = 0; i < length; i++) {
-        string key = reference->getKeyFromIdx(i);
-        YJSONContent* item = newArray->get(i);
-        YJSONContent* reference_item = reference->get(key);
-        YJSONType type = item->getJSONType();
-        if (type == reference_item->getJSONType()) {
-            switch (type) {
-            case ARRAY:
-                _parsed[key] = new YJSONArray((YJSONArray*)item);
-                break;
-            case NUMBER:
-                _parsed[key] = new YJSONNumber((YJSONNumber*)item);
-                break;
-            case STRING:
-                _parsed[key] = new YJSONString((YJSONString*)item);
-                break;
-            case OBJECT:
-                _parsed[key] = new YJSONObject((YJSONObject*)item);
-                break;
-            }
-            _keys.push_back(key);
-        } else if (type == ARRAY && reference_item->getJSONType() == OBJECT) {
-            YJSONObject* jobj = new YJSONObject(item->_data, item->_data_start, reference_item->_data_boundary);
-            jobj->convert((YJSONObject*)reference_item, (YJSONArray*)item);
-            _parsed[key] = jobj;
-            _keys.push_back(key);
-        } else {
-            throw YAPI_Exception(YAPI_IO_ERROR, "Unable to convert JZON struct");
-
-        }
-    }
-}
-
-string YJSONObject::getKeyFromIdx(int i)
-{
-    return _keys[i];
-}
-
-
-YDataStream::YDataStream(YFunction* parent):
-    //--- (generated code: YDataStream initialization)
-    _parent(NULL)
-    ,_runNo(0)
-    ,_utcStamp(0)
-    ,_nCols(0)
-    ,_nRows(0)
-    ,_startTime(0.0)
-    ,_duration(0.0)
-    ,_dataSamplesInterval(0.0)
-    ,_firstMeasureDuration(0.0)
-    ,_isClosed(0)
-    ,_isAvg(0)
-    ,_minVal(0.0)
-    ,_avgVal(0.0)
-    ,_maxVal(0.0)
-    ,_caltyp(0)
-//--- (end of generated code: YDataStream initialization)
-{
-    _parent = parent;
-}
-
-
-// YDataStream constructor for the new datalogger
-YDataStream::YDataStream(YFunction* parent, YDataSet& dataset, const vector<int>& encoded):
-    //--- (generated code: YDataStream initialization)
-    _parent(NULL)
-    ,_runNo(0)
-    ,_utcStamp(0)
-    ,_nCols(0)
-    ,_nRows(0)
-    ,_startTime(0.0)
-    ,_duration(0.0)
-    ,_dataSamplesInterval(0.0)
-    ,_firstMeasureDuration(0.0)
-    ,_isClosed(0)
-    ,_isAvg(0)
-    ,_minVal(0.0)
-    ,_avgVal(0.0)
-    ,_maxVal(0.0)
-    ,_caltyp(0)
-//--- (end of generated code: YDataStream initialization)
-{
-    _parent = parent;
-    this->_initFromDataSet(&dataset, encoded);
-}
-
-
-YDataStream::~YDataStream()
-{
-    _columnNames.clear();
-    _calpar.clear();
-    _calraw.clear();
-    _calref.clear();
-    _values.clear();
-}
-
-// YDataSet constructor, when instantiated directly by a function
-YDataSet::YDataSet(YFunction* parent, const string& functionId, const string& unit, double startTime, double endTime):
-    //--- (generated code: YDataSet initialization)
-    _parent(NULL)
-    ,_startTimeMs(0.0)
-    ,_endTimeMs(0.0)
-    ,_progress(0)
-    ,_summaryMinVal(0.0)
-    ,_summaryMaxVal(0.0)
-    ,_summaryTotalAvg(0.0)
-    ,_summaryTotalTime(0.0)
-//--- (end of generated code: YDataSet initialization)
-{
-    _parent = parent;
-    _functionId = functionId;
-    _unit = unit;
-    _startTimeMs = startTime*1000;
-    _endTimeMs = endTime*1000;
-    _summary = YMeasure(0, 0, 0, 0, 0);
-    _progress = -1;
-}
-
-// YDataSet constructor for the new datalogger
-YDataSet::YDataSet(YFunction* parent):
-    //--- (generated code: YDataSet initialization)
-    _parent(NULL)
-    ,_startTimeMs(0.0)
-    ,_endTimeMs(0.0)
-    ,_progress(0)
-    ,_summaryMinVal(0.0)
-    ,_summaryMaxVal(0.0)
-    ,_summaryTotalAvg(0.0)
-    ,_summaryTotalTime(0.0)
-//--- (end of generated code: YDataSet initialization)
-{
-    _parent = parent;
-    _startTimeMs = 0;
-    _endTimeMs = 0;
-    _summary = YMeasure(0, 0, 0, 0, 0);
-}
-
-// YDataSet parser for stream list
-int YDataSet::_parse(const string& json)
-{
-    yJsonStateMachine j;
-
-    // Parse JSON data
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return YAPI_NOT_SUPPORTED;
-    }
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "id")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return YAPI_NOT_SUPPORTED;
-            }
-            _functionId = _parent->_parseString(j);
-        } else if (!strcmp(j.token, "unit")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return YAPI_NOT_SUPPORTED;
-            }
-            _unit = _parent->_parseString(j);
-        } else if (!strcmp(j.token, "calib")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return YAPI_NOT_SUPPORTED;
-            }
-            _calib = YAPI::_decodeFloats(_parent->_parseString(j));
-            _calib[0] = _calib[0] / 1000;
-        } else if (!strcmp(j.token, "cal")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return YAPI_NOT_SUPPORTED;
-            }
-            if (_calib.size() == 0) {
-                _calib = YAPI::_decodeWords(_parent->_parseString(j));
-            }
-        } else if (!strcmp(j.token, "streams")) {
-            YDataStream* stream;
-            double streamEndTime;
-            double streamStartTime;
-            _streams = vector<YDataStream*>();
-            _preview = vector<YMeasure>();
-            _measures = vector<YMeasure>();
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.token[0] != '[') {
-                return YAPI_NOT_SUPPORTED;
-            }
-            // select streams for specified timeframe
-            while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.token[0] != ']') {
-                stream = _parent->_findDataStream(*this, _parent->_parseString(j));
-                // the timestamp in the data streams is the end of the measure, so the actual
-                // measurement start time is computed as one interval before the first timestamp
-                streamStartTime = floor(stream->get_realStartTimeUTC() * 1000 + 0.5);
-                streamEndTime = streamStartTime + floor(stream->get_realDuration() * 1000 +0.5);
-                if (_startTimeMs > 0 && streamEndTime <= _startTimeMs) {
-                    // this stream is too early, drop it
-                } else if (_endTimeMs > 0 && streamStartTime >= _endTimeMs) {
-                    // this stream is too late, drop it
-                } else {
-                    _streams.push_back(stream);
-                }
-            }
-        } else {
-            yJsonSkip(&j, 1);
-        }
-    }
-    _progress = 0;
-    return this->get_progress();
-}
-
-
-YFirmwareUpdate::YFirmwareUpdate(string serialNumber, string path, string settings) :
-    //--- (generated code: YFirmwareUpdate initialization)
-    _progress_c(0)
-    ,_progress(0)
-    ,_restore_step(0)
-    ,_force(0)
-//--- (end of generated code: YFirmwareUpdate initialization)
-{
-    _serial = serialNumber;
-    _settings = settings;
-    _firmwarepath = path;
-}
-
-YFirmwareUpdate::YFirmwareUpdate(string serialNumber, string path, string settings, bool force) :
-    //--- (generated code: YFirmwareUpdate initialization)
-    _progress_c(0)
-    ,_progress(0)
-    ,_restore_step(0)
-    ,_force(0)
-//--- (end of generated code: YFirmwareUpdate initialization)
-{
-    _serial = serialNumber;
-    _settings = settings;
-    _firmwarepath = path;
-    _force = force;
-}
-
-YFirmwareUpdate::YFirmwareUpdate() :
-    //--- (generated code: YFirmwareUpdate initialization)
-    _progress_c(0)
-    ,_progress(0)
-    ,_restore_step(0)
-    ,_force(0)
-//--- (end of generated code: YFirmwareUpdate initialization)
-{}
-
-
-//--- (generated code: YFirmwareUpdate implementation)
-// static attributes
-
-
-int YFirmwareUpdate::_processMore(int newupdate)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    YModule* m = NULL;
-    int res = 0;
-    string serial;
-    string firmwarepath;
-    string settings;
-    string prod_prefix;
-    int force = 0;
-    if ((_progress_c < 100) && (_progress_c != YAPI_VERSION_MISMATCH)) {
-        serial = _serial;
-        firmwarepath = _firmwarepath;
-        settings = _settings;
-        if (_force) {
-            force = 1;
-        } else {
-            force = 0;
-        }
-        res = yapiUpdateFirmwareEx(serial.c_str(), firmwarepath.c_str(), settings.c_str(), force, newupdate, errmsg);
-        if ((res == YAPI_VERSION_MISMATCH) && ((int)(_settings).size() != 0)) {
-            _progress_c = res;
-            _progress_msg = string(errmsg);
-            return _progress;
-        }
-        if (res < 0) {
-            _progress = res;
-            _progress_msg = string(errmsg);
-            return res;
-        }
-        _progress_c = res;
-        _progress = ((_progress_c * 9) / (10));
-        _progress_msg = string(errmsg);
-    } else {
-        if (((int)(_settings).size() != 0)) {
-            _progress_msg = "restoring settings";
-            m = YModule::FindModule(_serial + ".module");
-            if (!(m->isOnline())) {
-                return _progress;
-            }
-            if (_progress < 95) {
-                prod_prefix = (m->get_productName()).substr( 0, 8);
-                if (prod_prefix == "YoctoHub") {
-                    {string ignore_error; YAPI::Sleep(1000, ignore_error);};
-                    _progress = _progress + 1;
-                    return _progress;
-                } else {
-                    _progress = 95;
-                }
-            }
-            if (_progress < 100) {
-                m->set_allSettingsAndFiles(_settings);
-                m->saveToFlash();
-                _settings = string(0, (char)0);
-                if (_progress_c == YAPI_VERSION_MISMATCH) {
-                    _progress = YAPI_IO_ERROR;
-                    _progress_msg = "Unable to update firmware";
-                } else {
-                    _progress = 100;
-                    _progress_msg = "success";
-                }
-            }
-        } else {
-            _progress = 100;
-            _progress_msg = "success";
-        }
-    }
-    return _progress;
-}
-
-/**
- * Returns a list of all the modules in "firmware update" mode. Only devices
- * connected over USB are listed. For devices connected to a YoctoHub, you
- * must connect yourself to the YoctoHub web interface.
- *
- * @return an array of strings containing the serial numbers of devices in "firmware update" mode.
- */
-vector<string> YFirmwareUpdate::GetAllBootLoaders(void)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char smallbuff[1024];
-    char *bigbuff;
-    int buffsize = 0;
-    int fullsize = 0;
-    int yapi_res = 0;
-    string bootloader_list;
-    vector<string> bootladers;
-    fullsize = 0;
-    yapi_res = yapiGetBootloaders(smallbuff, 1024, &fullsize, errmsg);
-    if (yapi_res < 0) {
-        return bootladers;
-    }
-    if (fullsize <= 1024) {
-        bootloader_list = string(smallbuff, yapi_res);
-    } else {
-        buffsize = fullsize;
-        bigbuff = (char *)malloc(buffsize);
-        yapi_res = yapiGetBootloaders(bigbuff, buffsize, &fullsize, errmsg);
-        if (yapi_res < 0) {
-            free(bigbuff);
-            return bootladers;
-        } else {
-            bootloader_list = string(bigbuff, yapi_res);
-        }
-        free(bigbuff);
-    }
-    if (!(bootloader_list == "")) {
-        bootladers = _strsplit(bootloader_list,',');
-    }
-    return bootladers;
-}
-
-/**
- * Test if the byn file is valid for this module. It is possible to pass a directory instead of a file.
- * In that case, this method returns the path of the most recent appropriate byn file. This method will
- * ignore any firmware older than minrelease.
- *
- * @param serial : the serial number of the module to update
- * @param path : the path of a byn file or a directory that contains byn files
- * @param minrelease : a positive integer
- *
- * @return : the path of the byn file to use, or an empty string if no byn files matches the requirement
- *
- * On failure, returns a string that starts with "error:".
- */
-string YFirmwareUpdate::CheckFirmware(string serial,string path,int minrelease)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char smallbuff[1024];
-    char *bigbuff;
-    int buffsize = 0;
-    int fullsize = 0;
-    int res = 0;
-    string firmware_path;
-    string release;
-    fullsize = 0;
-    release = YapiWrapper::ysprintf("%d",minrelease);
-    res = yapiCheckFirmware(serial.c_str(), release.c_str(), path.c_str(), smallbuff, 1024, &fullsize, errmsg);
-    if (res < 0) {
-        firmware_path = "error:" + string(errmsg);
-        return "error:" + string(errmsg);
-    }
-    if (fullsize <= 1024) {
-        firmware_path = string(smallbuff, fullsize);
-    } else {
-        buffsize = fullsize;
-        bigbuff = (char *)malloc(buffsize);
-        res = yapiCheckFirmware(serial.c_str(), release.c_str(), path.c_str(), bigbuff, buffsize, &fullsize, errmsg);
-        if (res < 0) {
-            firmware_path = "error:" + string(errmsg);
-        } else {
-            firmware_path = string(bigbuff, fullsize);
-        }
-        free(bigbuff);
-    }
-    return firmware_path;
-}
-
-/**
- * Returns the progress of the firmware update, on a scale from 0 to 100. When the object is
- * instantiated, the progress is zero. The value is updated during the firmware update process until
- * the value of 100 is reached. The 100 value means that the firmware update was completed
- * successfully. If an error occurs during the firmware update, a negative value is returned, and the
- * error message can be retrieved with get_progressMessage.
- *
- * @return an integer in the range 0 to 100 (percentage of completion)
- *         or a negative error code in case of failure.
- */
-int YFirmwareUpdate::get_progress(void)
-{
-    if (_progress >= 0) {
-        this->_processMore(0);
-    }
-    return _progress;
-}
-
-/**
- * Returns the last progress message of the firmware update process. If an error occurs during the
- * firmware update process, the error message is returned
- *
- * @return a string  with the latest progress message, or the error message.
- */
-string YFirmwareUpdate::get_progressMessage(void)
-{
-    return _progress_msg;
-}
-
-/**
- * Starts the firmware update process. This method starts the firmware update process in background. This method
- * returns immediately. You can monitor the progress of the firmware update with the get_progress()
- * and get_progressMessage() methods.
- *
- * @return an integer in the range 0 to 100 (percentage of completion),
- *         or a negative error code in case of failure.
- *
- * On failure returns a negative error code.
- */
-int YFirmwareUpdate::startUpdate(void)
-{
-    string err;
-    int leng = 0;
-    err = _settings;
-    leng = (int)(err).length();
-    if ((leng >= 6) && ("error:" == (err).substr(0, 6))) {
-        _progress = -1;
-        _progress_msg = (err).substr( 6, leng - 6);
-    } else {
-        _progress = 0;
-        _progress_c = 0;
-        this->_processMore(1);
-    }
-    return _progress;
-}
-//--- (end of generated code: YFirmwareUpdate implementation)
-
-
-//--- (generated code: YDataStream implementation)
-// static attributes
-
-
-int YDataStream::_initFromDataSet(YDataSet* dataset,vector<int> encoded)
-{
-    int val = 0;
-    int i = 0;
-    int maxpos = 0;
-    int ms_offset = 0;
-    int samplesPerHour = 0;
-    double fRaw = 0.0;
-    double fRef = 0.0;
-    vector<int> iCalib;
-    // decode sequence header to extract data
-    _runNo = encoded[0] + (((encoded[1]) << (16)));
-    _utcStamp = encoded[2] + (((encoded[3]) << (16)));
-    val = encoded[4];
-    _isAvg = (((val) & (0x100)) == 0);
-    samplesPerHour = ((val) & (0xff));
-    if (((val) & (0x100)) != 0) {
-        samplesPerHour = samplesPerHour * 3600;
-    } else {
-        if (((val) & (0x200)) != 0) {
-            samplesPerHour = samplesPerHour * 60;
-        }
-    }
-    _dataSamplesInterval = 3600.0 / samplesPerHour;
-    ms_offset = encoded[6];
-    if (ms_offset < 1000) {
-        // new encoding -> add the ms to the UTC timestamp
-        _startTime = _utcStamp + (ms_offset / 1000.0);
-    } else {
-        // legacy encoding subtract the measure interval form the UTC timestamp
-        _startTime = _utcStamp -  _dataSamplesInterval;
-    }
-    _firstMeasureDuration = encoded[5];
-    if (!(_isAvg)) {
-        _firstMeasureDuration = _firstMeasureDuration / 1000.0;
-    }
-    val = encoded[7];
-    _isClosed = (val != 0xffff);
-    if (val == 0xffff) {
-        val = 0;
-    }
-    _nRows = val;
-    _duration = _nRows * _dataSamplesInterval;
-    // precompute decoding parameters
-    iCalib = dataset->_get_calibration();
-    _caltyp = iCalib[0];
-    if (_caltyp != 0) {
-        _calhdl = YAPI::_getCalibrationHandler(_caltyp);
-        maxpos = (int)iCalib.size();
-        _calpar.clear();
-        _calraw.clear();
-        _calref.clear();
-        i = 1;
-        while (i < maxpos) {
-            _calpar.push_back(iCalib[i]);
-            i = i + 1;
-        }
-        i = 1;
-        while (i + 1 < maxpos) {
-            fRaw = iCalib[i];
-            fRaw = fRaw / 1000.0;
-            fRef = iCalib[i + 1];
-            fRef = fRef / 1000.0;
-            _calraw.push_back(fRaw);
-            _calref.push_back(fRef);
-            i = i + 2;
-        }
-    }
-    // preload column names for backward-compatibility
-    _functionId = dataset->get_functionId();
-    if (_isAvg) {
-        _columnNames.clear();
-        _columnNames.push_back(YapiWrapper::ysprintf("%s_min",_functionId.c_str()));
-        _columnNames.push_back(YapiWrapper::ysprintf("%s_avg",_functionId.c_str()));
-        _columnNames.push_back(YapiWrapper::ysprintf("%s_max",_functionId.c_str()));
-        _nCols = 3;
-    } else {
-        _columnNames.clear();
-        _columnNames.push_back(_functionId);
-        _nCols = 1;
-    }
-    // decode min/avg/max values for the sequence
-    if (_nRows > 0) {
-        _avgVal = this->_decodeAvg(encoded[8] + (((((encoded[9]) ^ (0x8000))) << (16))), 1);
-        _minVal = this->_decodeVal(encoded[10] + (((encoded[11]) << (16))));
-        _maxVal = this->_decodeVal(encoded[12] + (((encoded[13]) << (16))));
-    }
-    return 0;
-}
-
-int YDataStream::_parseStream(string sdata)
-{
-    int idx = 0;
-    vector<int> udat;
-    vector<double> dat;
-    if ((int)(sdata).size() == 0) {
-        _nRows = 0;
-        return YAPI_SUCCESS;
-    }
-
-    udat = YAPI::_decodeWords(_parent->_json_get_string(sdata));
-    _values.clear();
-    idx = 0;
-    if (_isAvg) {
-        while (idx + 3 < (int)udat.size()) {
-            dat.clear();
-            dat.push_back(this->_decodeVal(udat[idx + 2] + (((udat[idx + 3]) << (16)))));
-            dat.push_back(this->_decodeAvg(udat[idx] + (((((udat[idx + 1]) ^ (0x8000))) << (16))), 1));
-            dat.push_back(this->_decodeVal(udat[idx + 4] + (((udat[idx + 5]) << (16)))));
-            idx = idx + 6;
-            _values.push_back(dat);
-        }
-    } else {
-        while (idx + 1 < (int)udat.size()) {
-            dat.clear();
-            dat.push_back(this->_decodeAvg(udat[idx] + (((((udat[idx + 1]) ^ (0x8000))) << (16))), 1));
-            _values.push_back(dat);
-            idx = idx + 2;
-        }
-    }
-
-    _nRows = (int)_values.size();
-    return YAPI_SUCCESS;
-}
-
-string YDataStream::_get_url(void)
-{
-    string url;
-    url = YapiWrapper::ysprintf("logger.json?id=%s&run=%d&utc=%u",
-    _functionId.c_str(),_runNo,_utcStamp);
-    return url;
-}
-
-int YDataStream::loadStream(void)
-{
-    return this->_parseStream(_parent->_download(this->_get_url()));
-}
-
-double YDataStream::_decodeVal(int w)
-{
-    double val = 0.0;
-    val = w;
-    val = val / 1000.0;
-    if (_caltyp != 0) {
-        if (_calhdl != NULL) {
-            val = _calhdl(val, _caltyp, _calpar, _calraw, _calref);
-        }
-    }
-    return val;
-}
-
-double YDataStream::_decodeAvg(int dw,int count)
-{
-    double val = 0.0;
-    val = dw;
-    val = val / 1000.0;
-    if (_caltyp != 0) {
-        if (_calhdl != NULL) {
-            val = _calhdl(val, _caltyp, _calpar, _calraw, _calref);
-        }
-    }
-    return val;
-}
-
-bool YDataStream::isClosed(void)
-{
-    return _isClosed;
-}
-
-/**
- * Returns the run index of the data stream. A run can be made of
- * multiple datastreams, for different time intervals.
- *
- * @return an unsigned number corresponding to the run index.
- */
-int YDataStream::get_runIndex(void)
-{
-    return _runNo;
-}
-
-/**
- * Returns the relative start time of the data stream, measured in seconds.
- * For recent firmwares, the value is relative to the present time,
- * which means the value is always negative.
- * If the device uses a firmware older than version 13000, value is
- * relative to the start of the time the device was powered on, and
- * is always positive.
- * If you need an absolute UTC timestamp, use get_realStartTimeUTC().
- *
- * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
- *
- * @return an unsigned number corresponding to the number of seconds
- *         between the start of the run and the beginning of this data
- *         stream.
- */
-int YDataStream::get_startTime(void)
-{
-    return (int)(_utcStamp - ((unsigned)time(NULL)));
-}
-
-/**
- * Returns the start time of the data stream, relative to the Jan 1, 1970.
- * If the UTC time was not set in the datalogger at the time of the recording
- * of this data stream, this method returns 0.
- *
- * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
- *
- * @return an unsigned number corresponding to the number of seconds
- *         between the Jan 1, 1970 and the beginning of this data
- *         stream (i.e. Unix time representation of the absolute time).
- */
-s64 YDataStream::get_startTimeUTC(void)
-{
-    return (int) floor(_startTime+0.5);
-}
-
-/**
- * Returns the start time of the data stream, relative to the Jan 1, 1970.
- * If the UTC time was not set in the datalogger at the time of the recording
- * of this data stream, this method returns 0.
- *
- * @return a floating-point number  corresponding to the number of seconds
- *         between the Jan 1, 1970 and the beginning of this data
- *         stream (i.e. Unix time representation of the absolute time).
- */
-double YDataStream::get_realStartTimeUTC(void)
-{
-    return _startTime;
-}
-
-/**
- * Returns the number of milliseconds between two consecutive
- * rows of this data stream. By default, the data logger records one row
- * per second, but the recording frequency can be changed for
- * each device function
- *
- * @return an unsigned number corresponding to a number of milliseconds.
- */
-int YDataStream::get_dataSamplesIntervalMs(void)
-{
-    return (int) floor(_dataSamplesInterval*1000+0.5);
-}
-
-double YDataStream::get_dataSamplesInterval(void)
-{
-    return _dataSamplesInterval;
-}
-
-double YDataStream::get_firstDataSamplesInterval(void)
-{
-    return _firstMeasureDuration;
-}
-
-/**
- * Returns the number of data rows present in this stream.
- *
- * If the device uses a firmware older than version 13000,
- * this method fetches the whole data stream from the device
- * if not yet done, which can cause a little delay.
- *
- * @return an unsigned number corresponding to the number of rows.
- *
- * On failure, throws an exception or returns zero.
- */
-int YDataStream::get_rowCount(void)
-{
-    if ((_nRows != 0) && _isClosed) {
-        return _nRows;
-    }
-    this->loadStream();
-    return _nRows;
-}
-
-/**
- * Returns the number of data columns present in this stream.
- * The meaning of the values present in each column can be obtained
- * using the method get_columnNames().
- *
- * If the device uses a firmware older than version 13000,
- * this method fetches the whole data stream from the device
- * if not yet done, which can cause a little delay.
- *
- * @return an unsigned number corresponding to the number of columns.
- *
- * On failure, throws an exception or returns zero.
- */
-int YDataStream::get_columnCount(void)
-{
-    if (_nCols != 0) {
-        return _nCols;
-    }
-    this->loadStream();
-    return _nCols;
-}
-
-/**
- * Returns the title (or meaning) of each data column present in this stream.
- * In most case, the title of the data column is the hardware identifier
- * of the sensor that produced the data. For streams recorded at a lower
- * recording rate, the dataLogger stores the min, average and max value
- * during each measure interval into three columns with suffixes _min,
- * _avg and _max respectively.
- *
- * If the device uses a firmware older than version 13000,
- * this method fetches the whole data stream from the device
- * if not yet done, which can cause a little delay.
- *
- * @return a list containing as many strings as there are columns in the
- *         data stream.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<string> YDataStream::get_columnNames(void)
-{
-    if ((int)_columnNames.size() != 0) {
-        return _columnNames;
-    }
-    this->loadStream();
-    return _columnNames;
-}
-
-/**
- * Returns the smallest measure observed within this stream.
- * If the device uses a firmware older than version 13000,
- * this method will always return Y_DATA_INVALID.
- *
- * @return a floating-point number corresponding to the smallest value,
- *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
- *
- * On failure, throws an exception or returns Y_DATA_INVALID.
- */
-double YDataStream::get_minValue(void)
-{
-    return _minVal;
-}
-
-/**
- * Returns the average of all measures observed within this stream.
- * If the device uses a firmware older than version 13000,
- * this method will always return Y_DATA_INVALID.
- *
- * @return a floating-point number corresponding to the average value,
- *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
- *
- * On failure, throws an exception or returns Y_DATA_INVALID.
- */
-double YDataStream::get_averageValue(void)
-{
-    return _avgVal;
-}
-
-/**
- * Returns the largest measure observed within this stream.
- * If the device uses a firmware older than version 13000,
- * this method will always return Y_DATA_INVALID.
- *
- * @return a floating-point number corresponding to the largest value,
- *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
- *
- * On failure, throws an exception or returns Y_DATA_INVALID.
- */
-double YDataStream::get_maxValue(void)
-{
-    return _maxVal;
-}
-
-double YDataStream::get_realDuration(void)
-{
-    if (_isClosed) {
-        return _duration;
-    }
-    return (double) ((unsigned)time(NULL)) - _utcStamp;
-}
-
-/**
- * Returns the whole data set contained in the stream, as a bidimensional
- * table of numbers.
- * The meaning of the values present in each column can be obtained
- * using the method get_columnNames().
- *
- * This method fetches the whole data stream from the device,
- * if not yet done.
- *
- * @return a list containing as many elements as there are rows in the
- *         data stream. Each row itself is a list of floating-point
- *         numbers.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector< vector<double> > YDataStream::get_dataRows(void)
-{
-    if (((int)_values.size() == 0) || !(_isClosed)) {
-        this->loadStream();
-    }
-    return _values;
-}
-
-/**
- * Returns a single measure from the data stream, specified by its
- * row and column index.
- * The meaning of the values present in each column can be obtained
- * using the method get_columnNames().
- *
- * This method fetches the whole data stream from the device,
- * if not yet done.
- *
- * @param row : row index
- * @param col : column index
- *
- * @return a floating-point number
- *
- * On failure, throws an exception or returns Y_DATA_INVALID.
- */
-double YDataStream::get_data(int row,int col)
-{
-    if (((int)_values.size() == 0) || !(_isClosed)) {
-        this->loadStream();
-    }
-    if (row >= (int)_values.size()) {
-        return Y_DATA_INVALID;
-    }
-    if (col >= (int)_values[row].size()) {
-        return Y_DATA_INVALID;
-    }
-    return _values[row][col];
-}
-//--- (end of generated code: YDataStream implementation)
-
-YMeasure::YMeasure(double start, double end, double minVal, double avgVal, double maxVal):
-    //--- (generated code: YMeasure initialization)
-    _start(0.0)
-    ,_end(0.0)
-    ,_minVal(0.0)
-    ,_avgVal(0.0)
-    ,_maxVal(0.0)
-//--- (end of generated code: YMeasure initialization)
-{
-    _start = start;
-    _end = end;
-    _minVal = minVal;
-    _avgVal = avgVal;
-    _maxVal = maxVal;
-    _startTime_t = (time_t)(start + 0.5);
-    _stopTime_t = (time_t)(end + 0.5);
-}
-
-YMeasure::YMeasure():
-    //--- (generated code: YMeasure initialization)
-    _start(0.0)
-    ,_end(0.0)
-    ,_minVal(0.0)
-    ,_avgVal(0.0)
-    ,_maxVal(0.0)
-//--- (end of generated code: YMeasure initialization)
-{
-    _start = 0;
-    _end = 0;
-    _minVal = 0;
-    _avgVal = 0;
-    _maxVal = 0;
-    _startTime_t = 0;
-    _stopTime_t = 0;
-}
-
-//--- (generated code: YMeasure implementation)
-// static attributes
-
-
-/**
- * Returns the start time of the measure, relative to the Jan 1, 1970 UTC
- * (Unix timestamp). When the recording rate is higher then 1 sample
- * per second, the timestamp may have a fractional part.
- *
- * @return an floating point number corresponding to the number of seconds
- *         between the Jan 1, 1970 UTC and the beginning of this measure.
- */
-double YMeasure::get_startTimeUTC(void)
-{
-    return _start;
-}
-
-/**
- * Returns the end time of the measure, relative to the Jan 1, 1970 UTC
- * (Unix timestamp). When the recording rate is higher than 1 sample
- * per second, the timestamp may have a fractional part.
- *
- * @return an floating point number corresponding to the number of seconds
- *         between the Jan 1, 1970 UTC and the end of this measure.
- */
-double YMeasure::get_endTimeUTC(void)
-{
-    return _end;
-}
-
-/**
- * Returns the smallest value observed during the time interval
- * covered by this measure.
- *
- * @return a floating-point number corresponding to the smallest value observed.
- */
-double YMeasure::get_minValue(void)
-{
-    return _minVal;
-}
-
-/**
- * Returns the average value observed during the time interval
- * covered by this measure.
- *
- * @return a floating-point number corresponding to the average value observed.
- */
-double YMeasure::get_averageValue(void)
-{
-    return _avgVal;
-}
-
-/**
- * Returns the largest value observed during the time interval
- * covered by this measure.
- *
- * @return a floating-point number corresponding to the largest value observed.
- */
-double YMeasure::get_maxValue(void)
-{
-    return _maxVal;
-}
-//--- (end of generated code: YMeasure implementation)
-
-time_t* YMeasure::get_startTimeUTC_asTime_t(time_t* time)
-{
-    if (time) {
-        memcpy(time, &this->_startTime_t, sizeof(time_t));
-    }
-    return &this->_startTime_t;
-}
-
-time_t* YMeasure::get_endTimeUTC_asTime_t(time_t* time)
-{
-    if (time) {
-        memcpy(time, &this->_stopTime_t, sizeof(time_t));
-    }
-    return &this->_stopTime_t;
-}
-
-//--- (generated code: YDataSet implementation)
-// static attributes
-
-
-vector<int> YDataSet::_get_calibration(void)
-{
-    return _calib;
-}
-
-int YDataSet::loadSummary(string data)
-{
-    vector< vector<double> > dataRows;
-    double tim = 0.0;
-    double mitv = 0.0;
-    double itv = 0.0;
-    double fitv = 0.0;
-    double end_ = 0.0;
-    int nCols = 0;
-    int minCol = 0;
-    int avgCol = 0;
-    int maxCol = 0;
-    int res = 0;
-    int m_pos = 0;
-    double previewTotalTime = 0.0;
-    double previewTotalAvg = 0.0;
-    double previewMinVal = 0.0;
-    double previewMaxVal = 0.0;
-    double previewAvgVal = 0.0;
-    double previewStartMs = 0.0;
-    double previewStopMs = 0.0;
-    double previewDuration = 0.0;
-    double streamStartTimeMs = 0.0;
-    double streamDuration = 0.0;
-    double streamEndTimeMs = 0.0;
-    double minVal = 0.0;
-    double avgVal = 0.0;
-    double maxVal = 0.0;
-    double summaryStartMs = 0.0;
-    double summaryStopMs = 0.0;
-    double summaryTotalTime = 0.0;
-    double summaryTotalAvg = 0.0;
-    double summaryMinVal = 0.0;
-    double summaryMaxVal = 0.0;
-    string url;
-    string strdata;
-    vector<double> measure_data;
-
-    if (_progress < 0) {
-        strdata = data;
-        if (strdata == "{}") {
-            _parent->_throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
-            return YAPI_VERSION_MISMATCH;
-        }
-        res = this->_parse(strdata);
-        if (res < 0) {
-            return res;
-        }
-    }
-    summaryTotalTime = 0;
-    summaryTotalAvg = 0;
-    summaryMinVal = YAPI_MAX_DOUBLE;
-    summaryMaxVal = YAPI_MIN_DOUBLE;
-    summaryStartMs = YAPI_MAX_DOUBLE;
-    summaryStopMs = YAPI_MIN_DOUBLE;
-
-    // Parse complete streams
-    for (unsigned ii = 0; ii <  _streams.size(); ii++) {
-        streamStartTimeMs = floor( _streams[ii]->get_realStartTimeUTC() *1000+0.5);
-        streamDuration =  _streams[ii]->get_realDuration() ;
-        streamEndTimeMs = streamStartTimeMs + floor(streamDuration * 1000+0.5);
-        if ((streamStartTimeMs >= _startTimeMs) && ((_endTimeMs == 0) || (streamEndTimeMs <= _endTimeMs))) {
-            // stream that are completely inside the dataset
-            previewMinVal =  _streams[ii]->get_minValue();
-            previewAvgVal =  _streams[ii]->get_averageValue();
-            previewMaxVal =  _streams[ii]->get_maxValue();
-            previewStartMs = streamStartTimeMs;
-            previewStopMs = streamEndTimeMs;
-            previewDuration = streamDuration;
-        } else {
-            // stream that are partially in the dataset
-            // we need to parse data to filter value outside the dataset
-            url =  _streams[ii]->_get_url();
-            data = _parent->_download(url);
-            _streams[ii]->_parseStream(data);
-            dataRows =  _streams[ii]->get_dataRows();
-            if ((int)dataRows.size() == 0) {
-                return this->get_progress();
-            }
-            tim = streamStartTimeMs;
-            fitv = floor( _streams[ii]->get_firstDataSamplesInterval() * 1000+0.5);
-            itv = floor( _streams[ii]->get_dataSamplesInterval() * 1000+0.5);
-            nCols = (int)dataRows[0].size();
-            minCol = 0;
-            if (nCols > 2) {
-                avgCol = 1;
-            } else {
-                avgCol = 0;
-            }
-            if (nCols > 2) {
-                maxCol = 2;
-            } else {
-                maxCol = 0;
-            }
-            previewTotalTime = 0;
-            previewTotalAvg = 0;
-            previewStartMs = streamEndTimeMs;
-            previewStopMs = streamStartTimeMs;
-            previewMinVal = YAPI_MAX_DOUBLE;
-            previewMaxVal = YAPI_MIN_DOUBLE;
-            m_pos = 0;
-            while (m_pos < (int)dataRows.size()) {
-                measure_data  = dataRows[m_pos];
-                if (m_pos == 0) {
-                    mitv = fitv;
-                } else {
-                    mitv = itv;
-                }
-                end_ = tim + mitv;
-                if ((end_ > _startTimeMs) && ((_endTimeMs == 0) || (tim < _endTimeMs))) {
-                    minVal = measure_data[minCol];
-                    avgVal = measure_data[avgCol];
-                    maxVal = measure_data[maxCol];
-                    if (previewStartMs > tim) {
-                        previewStartMs = tim;
-                    }
-                    if (previewStopMs < end_) {
-                        previewStopMs = end_;
-                    }
-                    if (previewMinVal > minVal) {
-                        previewMinVal = minVal;
-                    }
-                    if (previewMaxVal < maxVal) {
-                        previewMaxVal = maxVal;
-                    }
-                    previewTotalAvg = previewTotalAvg + (avgVal * mitv);
-                    previewTotalTime = previewTotalTime + mitv;
-                }
-                tim = end_;
-                m_pos = m_pos + 1;
-            }
-            if (previewTotalTime > 0) {
-                previewAvgVal = previewTotalAvg / previewTotalTime;
-                previewDuration = (previewStopMs - previewStartMs) / 1000.0;
-            } else {
-                previewAvgVal = 0.0;
-                previewDuration = 0.0;
-            }
-        }
-        _preview.push_back(YMeasure( previewStartMs / 1000.0, previewStopMs / 1000.0, previewMinVal, previewAvgVal,previewMaxVal));
-        if (summaryMinVal > previewMinVal) {
-            summaryMinVal = previewMinVal;
-        }
-        if (summaryMaxVal < previewMaxVal) {
-            summaryMaxVal = previewMaxVal;
-        }
-        if (summaryStartMs > previewStartMs) {
-            summaryStartMs = previewStartMs;
-        }
-        if (summaryStopMs < previewStopMs) {
-            summaryStopMs = previewStopMs;
-        }
-        summaryTotalAvg = summaryTotalAvg + (previewAvgVal * previewDuration);
-        summaryTotalTime = summaryTotalTime + previewDuration;
-    }
-    if ((_startTimeMs == 0) || (_startTimeMs > summaryStartMs)) {
-        _startTimeMs = summaryStartMs;
-    }
-    if ((_endTimeMs == 0) || (_endTimeMs < summaryStopMs)) {
-        _endTimeMs = summaryStopMs;
-    }
-    if (summaryTotalTime > 0) {
-        _summary = YMeasure( summaryStartMs / 1000.0 , summaryStopMs / 1000.0 , summaryMinVal, summaryTotalAvg / summaryTotalTime,summaryMaxVal);
-    } else {
-        _summary = YMeasure( 0.0 , 0.0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE,YAPI_INVALID_DOUBLE);
-    }
-    return this->get_progress();
-}
-
-int YDataSet::processMore(int progress,string data)
-{
-    YDataStream* stream = NULL;
-    vector< vector<double> > dataRows;
-    double tim = 0.0;
-    double itv = 0.0;
-    double fitv = 0.0;
-    double end_ = 0.0;
-    int nCols = 0;
-    int minCol = 0;
-    int avgCol = 0;
-    int maxCol = 0;
-    bool firstMeasure = 0;
-
-    if (progress != _progress) {
-        return _progress;
-    }
-    if (_progress < 0) {
-        return this->loadSummary(data);
-    }
-    stream = _streams[_progress];
-    stream->_parseStream(data);
-    dataRows = stream->get_dataRows();
-    _progress = _progress + 1;
-    if ((int)dataRows.size() == 0) {
-        return this->get_progress();
-    }
-    tim = floor(stream->get_realStartTimeUTC() * 1000+0.5);
-    fitv = floor(stream->get_firstDataSamplesInterval() * 1000+0.5);
-    itv = floor(stream->get_dataSamplesInterval() * 1000+0.5);
-    if (fitv == 0) {
-        fitv = itv;
-    }
-    if (tim < itv) {
-        tim = itv;
-    }
-    nCols = (int)dataRows[0].size();
-    minCol = 0;
-    if (nCols > 2) {
-        avgCol = 1;
-    } else {
-        avgCol = 0;
-    }
-    if (nCols > 2) {
-        maxCol = 2;
-    } else {
-        maxCol = 0;
-    }
-
-    firstMeasure = true;
-    for (unsigned ii = 0; ii < dataRows.size(); ii++) {
-        if (firstMeasure) {
-            end_ = tim + fitv;
-            firstMeasure = false;
-        } else {
-            end_ = tim + itv;
-        }
-        if ((end_ > _startTimeMs) && ((_endTimeMs == 0) || (tim < _endTimeMs))) {
-            _measures.push_back(YMeasure(tim / 1000, end_ / 1000,
-            dataRows[ii][minCol],
-            dataRows[ii][avgCol],dataRows[ii][maxCol]));
-        }
-        tim = end_;
-    }
-    return this->get_progress();
-}
-
-vector<YDataStream*> YDataSet::get_privateDataStreams(void)
-{
-    return _streams;
-}
-
-/**
- * Returns the unique hardware identifier of the function who performed the measures,
- * in the form SERIAL.FUNCTIONID. The unique hardware identifier is composed of the
- * device serial number and of the hardware identifier of the function
- * (for example THRMCPL1-123456.temperature1)
- *
- * @return a string that uniquely identifies the function (ex: THRMCPL1-123456.temperature1)
- *
- * On failure, throws an exception or returns  Y_HARDWAREID_INVALID.
- */
-string YDataSet::get_hardwareId(void)
-{
-    YModule* mo = NULL;
-    if (!(_hardwareId == "")) {
-        return _hardwareId;
-    }
-    mo = _parent->get_module();
-    _hardwareId = YapiWrapper::ysprintf("%s.%s", mo->get_serialNumber().c_str(),this->get_functionId().c_str());
-    return _hardwareId;
-}
-
-/**
- * Returns the hardware identifier of the function that performed the measure,
- * without reference to the module. For example temperature1.
- *
- * @return a string that identifies the function (ex: temperature1)
- */
-string YDataSet::get_functionId(void)
-{
-    return _functionId;
-}
-
-/**
- * Returns the measuring unit for the measured value.
- *
- * @return a string that represents a physical unit.
- *
- * On failure, throws an exception or returns  Y_UNIT_INVALID.
- */
-string YDataSet::get_unit(void)
-{
-    return _unit;
-}
-
-/**
- * Returns the start time of the dataset, relative to the Jan 1, 1970.
- * When the YDataSet is created, the start time is the value passed
- * in parameter to the get_dataSet() function. After the
- * very first call to loadMore(), the start time is updated
- * to reflect the timestamp of the first measure actually found in the
- * dataLogger within the specified range.
- *
- * <b>DEPRECATED</b>: This method has been replaced by get_summary()
- * which contain more precise informations on the YDataSet.
- *
- * @return an unsigned number corresponding to the number of seconds
- *         between the Jan 1, 1970 and the beginning of this data
- *         set (i.e. Unix time representation of the absolute time).
- */
-s64 YDataSet::get_startTimeUTC(void)
-{
-    return this->imm_get_startTimeUTC();
-}
-
-s64 YDataSet::imm_get_startTimeUTC(void)
-{
-    return (s64) (_startTimeMs / 1000.0);
-}
-
-/**
- * Returns the end time of the dataset, relative to the Jan 1, 1970.
- * When the YDataSet is created, the end time is the value passed
- * in parameter to the get_dataSet() function. After the
- * very first call to loadMore(), the end time is updated
- * to reflect the timestamp of the last measure actually found in the
- * dataLogger within the specified range.
- *
- * <b>DEPRECATED</b>: This method has been replaced by get_summary()
- * which contain more precise informations on the YDataSet.
- *
- *
- * @return an unsigned number corresponding to the number of seconds
- *         between the Jan 1, 1970 and the end of this data
- *         set (i.e. Unix time representation of the absolute time).
- */
-s64 YDataSet::get_endTimeUTC(void)
-{
-    return this->imm_get_endTimeUTC();
-}
-
-s64 YDataSet::imm_get_endTimeUTC(void)
-{
-    return (s64) floor(_endTimeMs / 1000.0+0.5);
-}
-
-/**
- * Returns the progress of the downloads of the measures from the data logger,
- * on a scale from 0 to 100. When the object is instantiated by get_dataSet,
- * the progress is zero. Each time loadMore() is invoked, the progress
- * is updated, to reach the value 100 only once all measures have been loaded.
- *
- * @return an integer in the range 0 to 100 (percentage of completion).
- */
-int YDataSet::get_progress(void)
-{
-    if (_progress < 0) {
-        return 0;
-    }
-    // index not yet loaded
-    if (_progress >= (int)_streams.size()) {
-        return 100;
-    }
-    return ((1 + (1 + _progress) * 98) / ((1 + (int)_streams.size())));
-}
-
-/**
- * Loads the the next block of measures from the dataLogger, and updates
- * the progress indicator.
- *
- * @return an integer in the range 0 to 100 (percentage of completion),
- *         or a negative error code in case of failure.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataSet::loadMore(void)
-{
-    string url;
-    YDataStream* stream = NULL;
-    if (_progress < 0) {
-        url = YapiWrapper::ysprintf("logger.json?id=%s",_functionId.c_str());
-        if (_startTimeMs != 0) {
-            url = YapiWrapper::ysprintf("%s&from=%u",url.c_str(),this->imm_get_startTimeUTC());
-        }
-        if (_endTimeMs != 0) {
-            url = YapiWrapper::ysprintf("%s&to=%u",url.c_str(),this->imm_get_endTimeUTC()+1);
-        }
-    } else {
-        if (_progress >= (int)_streams.size()) {
-            return 100;
-        } else {
-            stream = _streams[_progress];
-            url = stream->_get_url();
-        }
-    }
-    try {
-        return this->processMore(_progress, _parent->_download(url));
-    } catch (std::exception& e) {
-        e.what();
-        return this->processMore(_progress, _parent->_download(url));
-    }
-}
-
-/**
- * Returns an YMeasure object which summarizes the whole
- * DataSet. In includes the following information:
- * - the start of a time interval
- * - the end of a time interval
- * - the minimal value observed during the time interval
- * - the average value observed during the time interval
- * - the maximal value observed during the time interval
- *
- * This summary is available as soon as loadMore() has
- * been called for the first time.
- *
- * @return an YMeasure object
- */
-YMeasure YDataSet::get_summary(void)
-{
-    return _summary;
-}
-
-/**
- * Returns a condensed version of the measures that can
- * retrieved in this YDataSet, as a list of YMeasure
- * objects. Each item includes:
- * - the start of a time interval
- * - the end of a time interval
- * - the minimal value observed during the time interval
- * - the average value observed during the time interval
- * - the maximal value observed during the time interval
- *
- * This preview is available as soon as loadMore() has
- * been called for the first time.
- *
- * @return a table of records, where each record depicts the
- *         measured values during a time interval
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<YMeasure> YDataSet::get_preview(void)
-{
-    return _preview;
-}
-
-/**
- * Returns the detailed set of measures for the time interval corresponding
- * to a given condensed measures previously returned by get_preview().
- * The result is provided as a list of YMeasure objects.
- *
- * @param measure : condensed measure from the list previously returned by
- *         get_preview().
- *
- * @return a table of records, where each record depicts the
- *         measured values during a time interval
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<YMeasure> YDataSet::get_measuresAt(YMeasure measure)
-{
-    double startUtcMs = 0.0;
-    YDataStream* stream = NULL;
-    vector< vector<double> > dataRows;
-    vector<YMeasure> measures;
-    double tim = 0.0;
-    double itv = 0.0;
-    double end_ = 0.0;
-    int nCols = 0;
-    int minCol = 0;
-    int avgCol = 0;
-    int maxCol = 0;
-
-    startUtcMs = measure.get_startTimeUTC() * 1000;
-    stream = NULL;
-    for (unsigned ii = 0; ii < _streams.size(); ii++) {
-        if (floor(_streams[ii]->get_realStartTimeUTC() *1000+0.5) == startUtcMs) {
-            stream = _streams[ii];
-        }
-    }
-    if (stream == NULL) {
-        return measures;
-    }
-    dataRows = stream->get_dataRows();
-    if ((int)dataRows.size() == 0) {
-        return measures;
-    }
-    tim = floor(stream->get_realStartTimeUTC() * 1000+0.5);
-    itv = floor(stream->get_dataSamplesInterval() * 1000+0.5);
-    if (tim < itv) {
-        tim = itv;
-    }
-    nCols = (int)dataRows[0].size();
-    minCol = 0;
-    if (nCols > 2) {
-        avgCol = 1;
-    } else {
-        avgCol = 0;
-    }
-    if (nCols > 2) {
-        maxCol = 2;
-    } else {
-        maxCol = 0;
-    }
-
-    for (unsigned ii = 0; ii < dataRows.size(); ii++) {
-        end_ = tim + itv;
-        if ((end_ > _startTimeMs) && ((_endTimeMs == 0) || (tim < _endTimeMs))) {
-            measures.push_back(YMeasure(tim / 1000.0, end_ / 1000.0,
-            dataRows[ii][minCol],
-            dataRows[ii][avgCol],dataRows[ii][maxCol]));
-        }
-        tim = end_;
-    }
-    return measures;
-}
-
-/**
- * Returns all measured values currently available for this DataSet,
- * as a list of YMeasure objects. Each item includes:
- * - the start of the measure time interval
- * - the end of the measure time interval
- * - the minimal value observed during the time interval
- * - the average value observed during the time interval
- * - the maximal value observed during the time interval
- *
- * Before calling this method, you should call loadMore()
- * to load data from the device. You may have to call loadMore()
- * several time until all rows are loaded, but you can start
- * looking at available data rows before the load is complete.
- *
- * The oldest measures are always loaded first, and the most
- * recent measures will be loaded last. As a result, timestamps
- * are normally sorted in ascending order within the measure table,
- * unless there was an unexpected adjustment of the datalogger UTC
- * clock.
- *
- * @return a table of records, where each record depicts the
- *         measured value for a given time interval
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<YMeasure> YDataSet::get_measures(void)
-{
-    return _measures;
-}
-//--- (end of generated code: YDataSet implementation)
-
-
-YAPIContext::YAPIContext():
-    //--- (generated code: YAPIContext initialization)
-    _defaultCacheValidity(5)
-//--- (end of generated code: YAPIContext initialization)
-{}
-
-YAPIContext::~YAPIContext()
-{
-    //--- (generated code: YAPIContext cleanup)
-//--- (end of generated code: YAPIContext cleanup)
-}
-
-//--- (generated code: YAPIContext implementation)
-// static attributes
-
-
-/**
- * Change the time between each forced enumeration of the YoctoHub used.
- * By default, the library performs a complete enumeration every 10 seconds.
- * To reduce network traffic it is possible to increase this delay.
- * This is particularly useful when a YoctoHub is connected to a GSM network
- * where the traffic is charged. This setting does not affect modules connected by USB,
- * nor the operation of arrival/removal callbacks.
- * Note: This function must be called after yInitAPI.
- *
- * @param deviceListValidity : number of seconds between each enumeration.
- * @noreturn
- */
-void YAPIContext::SetDeviceListValidity(int deviceListValidity)
-{
-    yapiSetNetDevListValidity(deviceListValidity);
-}
-
-/**
- * Returns the time between each forced enumeration of the YoctoHub used.
- * Note: This function must be called after yInitAPI.
- *
- * @return the number of seconds between each enumeration.
- */
-int YAPIContext::GetDeviceListValidity(void)
-{
-    int res = 0;
-    res = yapiGetNetDevListValidity();
-    return res;
-}
-
-/**
- * Change the validity period of the data loaded by the library.
- * By default, when accessing a module, all the attributes of the
- * module functions are automatically kept in cache for the standard
- * duration (5 ms). This method can be used to change this standard duration,
- * for example in order to reduce network or USB traffic. This parameter
- * does not affect value change callbacks
- * Note: This function must be called after yInitAPI.
- *
- * @param cacheValidityMs : an integer corresponding to the validity attributed to the
- *         loaded function parameters, in milliseconds.
- * @noreturn
- */
-void YAPIContext::SetCacheValidity(u64 cacheValidityMs)
-{
-    _defaultCacheValidity = cacheValidityMs;
-}
-
-/**
- * Returns the validity period of the data loaded by the library.
- * This method returns the cache validity of all attributes
- * module functions.
- * Note: This function must be called after yInitAPI .
- *
- * @return an integer corresponding to the validity attributed to the
- *         loaded function parameters, in milliseconds
- */
-u64 YAPIContext::GetCacheValidity(void)
-{
-    return _defaultCacheValidity;
-}
-//--- (end of generated code: YAPIContext implementation)
-
-//--- (generated code: YAPIContext functions)
-//--- (end of generated code: YAPIContext functions)
-
-
-std::map<string, YFunction*> YFunction::_cache;
-
-
-// Constructor is protected. Use the device-specific factory function to instantiate
-YFunction::YFunction(const string& func):
-    _className("Function"), _func(func),
-    _lastErrorType(YAPI_SUCCESS), _lastErrorMsg(""),
-    _fundescr(Y_FUNCTIONDESCRIPTOR_INVALID), _userData(NULL)
-
-    //--- (generated code: YFunction initialization)
-    ,_logicalName(LOGICALNAME_INVALID)
-    ,_advertisedValue(ADVERTISEDVALUE_INVALID)
-    ,_valueCallbackFunction(NULL)
-    ,_cacheExpiration(0)
-//--- (end of generated code: YFunction initialization)
-{
-    yInitializeCriticalSection(&_this_cs);
-}
-
-YFunction::~YFunction()
-{
-    //--- (generated code: YFunction cleanup)
-//--- (end of generated code: YFunction cleanup)
-    _clearDataStreamCache();
-    yDeleteCriticalSection(&_this_cs);
-}
-
-
-// function cache methods
-YFunction* YFunction::_FindFromCache(const string& classname, const string& func)
-{
-    if (_cache.find(classname + "_" + func) != _cache.end())
-        return _cache[classname + "_" + func];
-    return NULL;
-}
-
-void YFunction::_AddToCache(const string& classname, const string& func, YFunction* obj)
-{
-    _cache[classname + "_" + func] = obj;
-}
-
-void YFunction::_ClearCache()
-{
-    for (std::map<string, YFunction*>::iterator cache_iterator = _cache.begin();
-         cache_iterator != _cache.end(); ++cache_iterator) {
-        delete cache_iterator->second;
-    }
-    _cache.clear();
-    _cache = std::map<string, YFunction*>();
-}
-
-
-//--- (generated code: YFunction implementation)
-// static attributes
-const string YFunction::LOGICALNAME_INVALID = YAPI_INVALID_STRING;
-const string YFunction::ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
-
-int YFunction::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("logicalName")) {
-        _logicalName =  json_val->getString("logicalName");
-    }
-    if(json_val->has("advertisedValue")) {
-        _advertisedValue =  json_val->getString("advertisedValue");
-    }
-    return 0;
-}
-
-
-/**
- * Returns the logical name of the function.
- *
- * @return a string corresponding to the logical name of the function
- *
- * On failure, throws an exception or returns Y_LOGICALNAME_INVALID.
- */
-string YFunction::get_logicalName(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YFunction::LOGICALNAME_INVALID;
-                }
-            }
-        }
-        res = _logicalName;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the logical name of the function. You can use yCheckLogicalName()
- * prior to this call to make sure that your parameter is valid.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the logical name of the function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFunction::set_logicalName(const string& newval)
-{
-    string rest_val;
-    int res;
-    if (!YAPI::CheckLogicalName(newval)) {
-        _throw(YAPI_INVALID_ARGUMENT, "Invalid name :" + newval);
-        return YAPI_INVALID_ARGUMENT;
-    }
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("logicalName", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns a short string representing the current state of the function.
- *
- * @return a string corresponding to a short string representing the current state of the function
- *
- * On failure, throws an exception or returns Y_ADVERTISEDVALUE_INVALID.
- */
-string YFunction::get_advertisedValue(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YFunction::ADVERTISEDVALUE_INVALID;
-                }
-            }
-        }
-        res = _advertisedValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YFunction::set_advertisedValue(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("advertisedValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a function for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the function is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YFunction.isOnline() to test if the function is
- * indeed online at a given time. In case of ambiguity when looking for
- * a function by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the function
- *
- * @return a YFunction object allowing you to drive the function.
- */
-YFunction* YFunction::FindFunction(string func)
-{
-    YFunction* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YFunction*) YFunction::_FindFromCache("Function", func);
-        if (obj == NULL) {
-            obj = new YFunction(func);
-            YFunction::_AddToCache("Function", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YFunction::registerValueCallback(YFunctionValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackFunction = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YFunction::_invokeValueCallback(string value)
-{
-    if (_valueCallbackFunction != NULL) {
-        _valueCallbackFunction(this, value);
-    } else {
-    }
-    return 0;
-}
-
-/**
- * Disables the propagation of every new advertised value to the parent hub.
- * You can use this function to save bandwidth and CPU on computers with limited
- * resources, or to prevent unwanted invocations of the HTTP callback.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFunction::muteValueCallbacks(void)
-{
-    return this->set_advertisedValue("SILENT");
-}
-
-/**
- * Re-enables the propagation of every new advertised value to the parent hub.
- * This function reverts the effect of a previous call to muteValueCallbacks().
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFunction::unmuteValueCallbacks(void)
-{
-    return this->set_advertisedValue("");
-}
-
-/**
- * Returns the current value of a single function attribute, as a text string, as quickly as
- * possible but without using the cached value.
- *
- * @param attrName : the name of the requested attribute
- *
- * @return a string with the value of the the attribute
- *
- * On failure, throws an exception or returns an empty string.
- */
-string YFunction::loadAttribute(string attrName)
-{
-    string url;
-    string attrVal;
-    url = YapiWrapper::ysprintf("api/%s/%s", this->get_functionId().c_str(),attrName.c_str());
-    attrVal = this->_download(url);
-    return attrVal;
-}
-
-int YFunction::_parserHelper(void)
-{
-    return 0;
-}
-
-YFunction *YFunction::nextFunction(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YFunction::FindFunction(hwid);
-}
-
-YFunction* YFunction::FirstFunction(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Function", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YFunction::FindFunction(serial+"."+funcId);
-}
-
-//--- (end of generated code: YFunction implementation)
-
-//--- (generated code: YFunction functions)
-//--- (end of generated code: YFunction functions)
-
-void YFunction::_throw(YRETCODE errType, string errMsg)
-{
-    _lastErrorType = errType;
-    _lastErrorMsg = errMsg;
-    // Method used to throw exceptions or save error type/message
-    if (!YAPI::ExceptionsDisabled) {
-        throw YAPI_Exception(errType, errMsg);
-    }
-}
-
-// Method used to resolve our name to our unique function descriptor (may trigger a hub scan)
-YRETCODE YFunction::_getDescriptor(YFUN_DESCR& fundescr, string& errmsg)
-{
-    int res;
-    YFUN_DESCR tmp_fundescr;
-
-    tmp_fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-    if (YISERR(tmp_fundescr)) {
-        res = YapiWrapper::updateDeviceList(true, errmsg);
-        if (YISERR(res)) {
-            return (YRETCODE)res;
-        }
-        tmp_fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-        if (YISERR(tmp_fundescr)) {
-            return (YRETCODE)tmp_fundescr;
-        }
-    }
-    _fundescr = fundescr = tmp_fundescr;
-    return YAPI_SUCCESS;
-}
-
-// Return a pointer to our device caching object (may trigger a hub scan)
-YRETCODE YFunction::_getDevice(YDevice*& dev, string& errmsg)
-{
-    YFUN_DESCR fundescr;
-    YDEV_DESCR devdescr;
-    YRETCODE res;
-
-    // Resolve function name
-    res = _getDescriptor(fundescr, errmsg);
-    if (YISERR(res)) return res;
-
-    // Get device descriptor
-    devdescr = YapiWrapper::getDeviceByFunction(fundescr, errmsg);
-    if (YISERR(devdescr)) return (YRETCODE)devdescr;
-
-    // Get device object
-    dev = YDevice::getDevice(devdescr);
-
-    return YAPI_SUCCESS;
-}
-
-// Return the next known function of current class listed in the yellow pages
-YRETCODE YFunction::_nextFunction(string& hwid)
-{
-    vector<YFUN_DESCR> v_fundescr;
-    YFUN_DESCR fundescr;
-    YDEV_DESCR devdescr;
-    string serial, funcId, funcName, funcVal, errmsg;
-    int res;
-
-    res = _getDescriptor(fundescr, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    res = YapiWrapper::getFunctionsByClass(_className, fundescr, v_fundescr, sizeof(YFUN_DESCR), errmsg);
-    if (YISERR((YRETCODE)res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    if (v_fundescr.size() == 0) {
-        hwid = "";
-        return YAPI_SUCCESS;
-    }
-    res = YapiWrapper::getFunctionInfo(v_fundescr[0], devdescr, serial, funcId, funcName, funcVal, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    hwid = serial + "." + funcId;
-
-    return YAPI_SUCCESS;
-}
-
-// Parse a long JSON string
-string YFunction::_parseString(yJsonStateMachine& j)
-{
-    string res;
-
-    do {
-#ifdef WINDOWS_API
-        res += j.token;
-#else
-        char buffer[128];
-        char *pt, *s;
-        s = j.token;
-        pt = buffer;
-        while (*s) {
-            unsigned char c = *s++;
-            if (c < 128) {
-                *pt++ = c;
-            } else {
-                // UTF8-encode character
-                *pt++ = 0xc2 + (c>0xbf ? 1 : 0);
-                *pt++ = (c & 0x3f) + 0x80;
-            }
-        }
-        *pt = 0;
-        res += buffer;
-#endif
-    } while (j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL);
-
-    return res;
-}
-
-string YFunction::_json_get_key(const string& json, const string& key)
-{
-    yJsonStateMachine j;
-
-    // Parse JSON data for the device and locate our function in it
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        this->_throw(YAPI_IO_ERROR, "JSON structure expected");
-        return YAPI_INVALID_STRING;
-    }
-    while (yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, key.c_str())) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                this->_throw(YAPI_IO_ERROR, "JSON structure expected");
-                return YAPI_INVALID_STRING;
-            }
-            return _parseString(j);
-        }
-        yJsonSkip(&j, 1);
-    }
-    this->_throw(YAPI_IO_ERROR, "invalid JSON structure");
-    return YAPI_INVALID_STRING;
-}
-
-string YFunction::_json_get_string(const string& json)
-{
-    yJsonStateMachine j;
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRING) {
-        this->_throw(YAPI_IO_ERROR, "JSON string expected");
-        return "";
-    }
-    return _parseString(j);
-}
-
-vector<string> YFunction::_json_get_array(const string& json)
-{
-    vector<string> res;
-    yJsonStateMachine j;
-    const char *json_cstr, *last;
-    string backup = json;
-    j.src = json_cstr = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_ARRAY) {
-        this->_throw(YAPI_IO_ERROR, "JSON structure expected");
-        return res;
-    }
-    int depth = j.depth;
-    do {
-        last = j.src;
-        while (yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-            if (j.next == YJSON_PARSE_STRINGCONT || j.depth > depth) {
-                continue;
-            }
-            break;
-        }
-        if (j.st == YJSON_PARSE_ERROR) {
-            this->_throw(YAPI_IO_ERROR, "invalid JSON structure");
-            return res;
-        }
-
-        if (j.depth == depth) {
-            long location, length;
-            while (*last == ',' || *last == '\n') {
-                last++;
-            }
-            location = (long)(last - json_cstr);
-            length = (long)(j.src - last);
-            string item = json.substr(location, length);
-            res.push_back(item);
-        }
-    } while (j.st != YJSON_PARSE_ARRAY);
-    return res;
-}
-
-string YFunction::_get_json_path(const string& json, const string& path)
-{
-    const char* json_data = json.c_str();
-    int len = (int)(json.length() & 0x0fffffff);
-    const char* p;
-    char errbuff[YOCTO_ERRMSG_LEN];
-    int res;
-
-    res = yapiJsonGetPath(path.c_str(), json_data, len, &p, errbuff);
-    if (res >= 0) {
-        string result = string(p, res);
-        if (res > 0) {
-            yapiFreeMem((void*)p);
-        }
-        return result;
-    }
-    return "";
-}
-
-string YFunction::_decode_json_string(const string& json)
-{
-    int len = (int)(json.length() & 0x0fffffff);
-    char buffer[128];
-    char* p = buffer;
-    int decoded_len;
-
-    if (len >= 127) {
-        p = (char*)malloc(len + 1);
-
-    }
-    decoded_len = yapiJsonDecodeString(json.c_str(), p);
-    string result = string(p, decoded_len);
-    if (len >= 127) {
-        free(p);
-    }
-    return result;
-}
-
-static string __escapeAttr(const string& changeval)
-{
-    const char* p;
-    unsigned char c;
-    unsigned char esc[3];
-    string escaped = "";
-    esc[0] = '%';
-    for (p = changeval.c_str(); (c = *p) != 0; p++) {
-        if (c <= ' ' || (c > 'z' && c != '~') || c == '"' || c == '%' || c == '&' ||
-            c == '+' || c == '<' || c == '=' || c == '>' || c == '\\' || c == '^' || c == '`') {
-            if ((c == 0xc2 || c == 0xc3) && (p[1] & 0xc0) == 0x80) {
-                // UTF8-encoded ISO-8859-1 character: translate to plain ISO-8859-1
-                c = (c & 1) * 0x40;
-                p++;
-                c += *p;
-            }
-            esc[1] = (c >= 0xa0 ? (c >> 4) - 10 + 'A' : (c >> 4) + '0');
-            c &= 0xf;
-            esc[2] = (c >= 0xa ? c - 10 + 'A' : c + '0');
-            escaped.append((char*)esc, 3);
-        } else {
-            escaped.append((char*)&c, 1);
-        }
-    }
-    return escaped;
-}
-
-
-string YFunction::_escapeAttr(const string& changeval)
-{
-    return __escapeAttr(changeval);
-}
-
-
-YRETCODE YFunction::_buildSetRequest(const string& changeattr, const string* changeval, string& request, string& errmsg)
-{
-    int res;
-    YFUN_DESCR fundesc;
-    char funcid[YOCTO_FUNCTION_LEN];
-    char errbuff[YOCTO_ERRMSG_LEN];
-
-
-    // Resolve the function name
-    res = _getDescriptor(fundesc, errmsg);
-    if (YISERR(res)) {
-        return (YRETCODE)res;
-    }
-
-    if (YISERR(res=yapiGetFunctionInfo(fundesc, NULL, NULL, funcid, NULL, NULL,errbuff))) {
-        errmsg = errbuff;
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    request = "GET /api/";
-    request.append(funcid);
-    request.append("/");
-    //request.append(".json/");
-
-    if (changeattr != "") {
-        request.append(changeattr);
-        if (changeval) {
-            request.append("?");
-            request.append(changeattr);
-            request.append("=");
-            request.append(_escapeAttr(*changeval));
-        }
-    }
-    // don't append HTTP/1.1 so that we get light headers from hub
-    // but append &. suffix to enable connection keepalive on newer hubs
-    request.append("&. \r\n\r\n");
-    return YAPI_SUCCESS;
-}
-
-
-int YFunction::_parse(YJSONObject* j)
-{
-    this->_parseAttr(j);
-    this->_parserHelper();
-    return 0;
-}
-
-// Set an attribute in the function, and parse the resulting new function state
-YRETCODE YFunction::_setAttr(string attrname, string newvalue)
-{
-    string errmsg, request;
-    int res;
-    YDevice* dev;
-
-    // Execute http request
-    res = _buildSetRequest(attrname, &newvalue, request, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    // Get device Object
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-
-    res = dev->HTTPRequestAsync(0, request, NULL, NULL, errmsg);
-    if (YISERR(res)) {
-        // Check if an update of the device list does not solve the issue
-        res = YapiWrapper::updateDeviceList(true, errmsg);
-        if (YISERR(res)) {
-            _throw((YRETCODE)res, errmsg);
-            return (YRETCODE)res;
-        }
-        res = dev->HTTPRequestAsync(0, request, NULL, NULL, errmsg);
-        if (YISERR(res)) {
-            _throw((YRETCODE)res, errmsg);
-            return (YRETCODE)res;
-        }
-    }
-    if (_cacheExpiration != 0) {
-        _cacheExpiration = 0;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-// Method used to send http request to the device (not the function)
-string YFunction::_requestEx(int channel, const string& request, yapiRequestProgressCallback callback, void* context)
-{
-    YDevice* dev;
-    string errmsg, buffer;
-    int res;
-
-
-    // Resolve our reference to our device, load REST API
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-    res = dev->HTTPRequest(channel, request, buffer, callback, context, errmsg);
-    if (YISERR(res)) {
-        // Check if an update of the device list does notb solve the issue
-        res = YapiWrapper::updateDeviceList(true, errmsg);
-        if (YISERR(res)) {
-            this->_throw((YRETCODE)res, errmsg);
-            return YAPI_INVALID_STRING;
-        }
-        res = dev->HTTPRequest(channel, request, buffer, callback, context, errmsg);
-        if (YISERR(res)) {
-            this->_throw((YRETCODE)res, errmsg);
-            return YAPI_INVALID_STRING;
-        }
-    }
-    if (0 != buffer.find("OK\r\n")) {
-        if (0 != buffer.find("HTTP/1.1 200 OK\r\n")) {
-            this->_throw(YAPI_IO_ERROR, "http request failed");
-            return YAPI_INVALID_STRING;
-        }
-    }
-    return buffer;
-}
-
-string YFunction::_request(const string& request)
-{
-    return _requestEx(0, request, NULL, NULL);
-}
-
-
-// Method used to send http request to the device (not the function)
-string YFunction::_download(const string& url)
-{
-    string request, buffer;
-    size_t found;
-
-    request = "GET /" + url + " HTTP/1.1\r\n\r\n";
-    buffer = this->_request(request);
-    found = buffer.find("\r\n\r\n");
-    if (string::npos == found) {
-        this->_throw(YAPI_IO_ERROR, "http request failed");
-        return YAPI_INVALID_STRING;
-    }
-
-    return buffer.substr(found + 4);
-}
-
-
-// Method used to upload a file to the device
-YRETCODE YFunction::_uploadWithProgress(const string& path, const string& content, yapiRequestProgressCallback callback, void* context)
-{
-    string request, buffer;
-    string boundary;
-    size_t found;
-
-    request = "POST /upload.html HTTP/1.1\r\n";
-    string body = "Content-Disposition: form-data; name=\"" + path + "\"; filename=\"api\"\r\n" +
-        "Content-Type: application/octet-stream\r\n" +
-        "Content-Transfer-Encoding: binary\r\n\r\n" + content;
-    do {
-        boundary = YapiWrapper::ysprintf("Zz%06xzZ", rand() & 0xffffff);
-    } while (body.find(boundary) != string::npos);
-    request += "Content-Type: multipart/form-data; boundary=" + boundary + "\r\n";
-    request += "\r\n--" + boundary + "\r\n" + body + "\r\n--" + boundary + "--\r\n";
-    buffer = this->_requestEx(0, request, callback, context);
-    found = buffer.find("\r\n\r\n");
-    if (string::npos == found) {
-        this->_throw(YAPI_IO_ERROR, "http request failed");
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-// Method used to upload a file to the device
-YRETCODE YFunction::_upload(const string& path, const string& content)
-{
-    return this->_uploadWithProgress(path, content, NULL, NULL);
-}
-
-
-// Method used to cache DataStream objects (new DataLogger)
-YDataStream* YFunction::_findDataStream(YDataSet& dataset, const string& def)
-{
-    string key = dataset.get_functionId() + ":" + def;
-    if (_dataStreams.find(key) != _dataStreams.end())
-        return _dataStreams[key];
-
-    vector<int> words = YAPI::_decodeWords(def);
-    if (words.size() < 14) {
-        _throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
-    }
-    YDataStream* newDataStream = new YDataStream(this, dataset, words);
-    _dataStreams[key] = newDataStream;
-    return newDataStream;
-}
-
-// Method used to clear cache of DataStream object (undocumented)
-void YFunction::_clearDataStreamCache()
-{
-    std::map<string, YDataStream*>::iterator it;
-    for (it = _dataStreams.begin(); it != _dataStreams.end(); ++it) {
-        YDataStream* ds = it->second;
-
-        delete(ds);
-    }
-    _dataStreams.clear();
-}
-
-
-// Return a string that describes the function (class and logical name or hardware id)
-string YFunction::describe(void)
-{
-    YFUN_DESCR fundescr;
-    YDEV_DESCR devdescr;
-    string errmsg, serial, funcId, funcName, funcValue;
-    string descr = _func;
-    string res;
-
-    yEnterCriticalSection(&_this_cs);
-    fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-    if (!YISERR(fundescr) && !YISERR(YapiWrapper::getFunctionInfo(fundescr, devdescr, serial, funcId, funcName, funcValue, errmsg))) {
-        res = _className + "(" + _func + ")=" + serial + "." + funcId;
-    } else {
-        res = _className + "(" + _func + ")=unresolved";
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-// Return a string that describes the function (class and logical name or hardware id)
-string YFunction::get_friendlyName(void)
-{
-    YFUN_DESCR fundescr, moddescr;
-    YDEV_DESCR devdescr;
-    YRETCODE retcode;
-    string errmsg, serial, funcId, funcName, funcValue;
-    string mod_serial, mod_funcId, mod_funcname;
-
-    yEnterCriticalSection(&_this_cs);
-    // Resolve the function name
-    retcode = _getDescriptor(fundescr, errmsg);
-    if (!YISERR(retcode) && !YISERR(YapiWrapper::getFunctionInfo(fundescr, devdescr, serial, funcId, funcName, funcValue, errmsg))) {
-        if (funcName != "") {
-            funcId = funcName;
-        }
-
-        moddescr = YapiWrapper::getFunction("Module", serial, errmsg);
-        if (!YISERR(moddescr) && !YISERR(YapiWrapper::getFunctionInfo(moddescr, devdescr, mod_serial, mod_funcId, mod_funcname, funcValue, errmsg))) {
-            if (mod_funcname != "") {
-                yLeaveCriticalSection(&_this_cs);
-                return mod_funcname + "." + funcId;
-            }
-        }
-        yLeaveCriticalSection(&_this_cs);
-        return serial + "." + funcId;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    _throw((YRETCODE)YAPI::DEVICE_NOT_FOUND, errmsg);
-    return Y_FRIENDLYNAME_INVALID;
-}
-
-
-/**
- * Returns the unique hardware identifier of the function in the form SERIAL.FUNCTIONID.
- * The unique hardware identifier is composed of the device serial
- * number and of the hardware identifier of the function (for example RELAYLO1-123456.relay1).
- *
- * @return a string that uniquely identifies the function (ex: RELAYLO1-123456.relay1)
- *
- * On failure, throws an exception or returns  Y_HARDWAREID_INVALID.
- */
-string YFunction::get_hardwareId(void)
-{
-    YRETCODE retcode;
-    YFUN_DESCR fundesc;
-    string errmsg;
-    char snum[YOCTO_SERIAL_LEN];
-    char funcid[YOCTO_FUNCTION_LEN];
-    char errbuff[YOCTO_ERRMSG_LEN];
-
-    yEnterCriticalSection(&_this_cs);
-    // Resolve the function name
-    retcode = _getDescriptor(fundesc, errmsg);
-    if (YISERR(retcode)) {
-        yLeaveCriticalSection(&_this_cs);
-        _throw(retcode, errmsg);
-        return HARDWAREID_INVALID;
-    }
-    if (YISERR(retcode=yapiGetFunctionInfo(fundesc, NULL, snum, funcid, NULL, NULL,errbuff))) {
-        errmsg = errbuff;
-        yLeaveCriticalSection(&_this_cs);
-        _throw(retcode, errmsg);
-        return HARDWAREID_INVALID;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return string(snum) + string(".") + string(funcid);
-}
-
-/**
- * Returns the hardware identifier of the function, without reference to the module. For example
- * relay1
- *
- * @return a string that identifies the function (ex: relay1)
- *
- * On failure, throws an exception or returns  Y_FUNCTIONID_INVALID.
- */
-string YFunction::get_functionId(void)
-{
-    YRETCODE retcode;
-    YFUN_DESCR fundesc;
-    string errmsg;
-    char funcid[YOCTO_FUNCTION_LEN];
-    char errbuff[YOCTO_ERRMSG_LEN];
-
-    yEnterCriticalSection(&_this_cs);
-    // Resolve the function name
-    retcode = _getDescriptor(fundesc, errmsg);
-    if (YISERR(retcode)) {
-        yLeaveCriticalSection(&_this_cs);
-        _throw(retcode, errmsg);
-        return HARDWAREID_INVALID;
-    }
-    if (YISERR(retcode=yapiGetFunctionInfo(fundesc, NULL, NULL, funcid, NULL, NULL,errbuff))) {
-        errmsg = errbuff;
-        yLeaveCriticalSection(&_this_cs);
-        _throw(retcode, errmsg);
-        return HARDWAREID_INVALID;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return string(funcid);
-}
-
-
-/**
- * Returns the numerical error code of the latest error with the function.
- * This method is mostly useful when using the Yoctopuce library with
- * exceptions disabled.
- *
- * @return a number corresponding to the code of the latest error that occurred while
- *         using the function object
- */
-YRETCODE YFunction::get_errorType(void)
-{
-    return _lastErrorType;
-}
-
-/**
- * Returns the error message of the latest error with the function.
- * This method is mostly useful when using the Yoctopuce library with
- * exceptions disabled.
- *
- * @return a string corresponding to the latest error message that occured while
- *         using the function object
- */
-string YFunction::get_errorMessage(void)
-{
-    return _lastErrorMsg;
-}
-
-/**
- * Checks if the function is currently reachable, without raising any error.
- * If there is a cached value for the function in cache, that has not yet
- * expired, the device is considered reachable.
- * No exception is raised if there is an error while trying to contact the
- * device hosting the function.
- *
- * @return true if the function can be reached, and false otherwise
- */
-bool YFunction::isOnline(void)
-{
-    YDevice* dev;
-    string errmsg;
-    YJSONObject* apires;
-
-    yEnterCriticalSection(&_this_cs);
-    try {
-        // A valid value in cache means that the device is online
-        if (_cacheExpiration > yapiGetTickCount()) {
-            yLeaveCriticalSection(&_this_cs);
-            return true;
-        }
-
-        // Check that the function is available, without throwing exceptions
-        if (YISERR(_getDevice(dev, errmsg))) {
-            yLeaveCriticalSection(&_this_cs);
-            return false;
-        }
-
-        // Try to execute a function request to be positively sure that the device is ready
-        if (YISERR(dev->requestAPI(apires, errmsg))) {
-            yLeaveCriticalSection(&_this_cs);
-            return false;
-        }
-
-        // Preload the function data, since we have it in device cache
-        this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity());
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        return false;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return true;
-}
-
-YRETCODE YFunction::_load_unsafe(u64 msValidity)
-{
-    YJSONObject *j, *node;
-    YDevice* dev;
-    string errmsg;
-    YFUN_DESCR fundescr;
-    int res;
-    char errbuf[YOCTO_ERRMSG_LEN];
-    char serial[YOCTO_SERIAL_LEN];
-    char funcId[YOCTO_FUNCTION_LEN];
-
-    // Resolve our reference to our device, load REST API
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    res = dev->requestAPI(j, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-
-    // Get our function Id
-    fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-    if (YISERR(fundescr)) {
-        _throw((YRETCODE)fundescr, errmsg);
-        return (YRETCODE)fundescr;
-    }
-    res = yapiGetFunctionInfo(fundescr, NULL, serial, funcId, NULL, NULL, errbuf);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errbuf);
-        return (YRETCODE)res;
-    }
-    _cacheExpiration = yapiGetTickCount() + msValidity;
-    _serial = serial;
-    _funId = funcId;
-    _hwId = _serial + '.' + _funId;
-
-    try {
-        node = j->getYJSONObject(funcId);
-    } catch (std::exception ex) {
-        _throw(YAPI_IO_ERROR, "unexpected JSON structure: missing function " + _funId);
-        return YAPI_IO_ERROR;
-    }
-    _parse(node);
-    return YAPI_SUCCESS;
-}
-
-
-/**
- * Preloads the function cache with a specified validity duration.
- * By default, whenever accessing a device, all function attributes
- * are kept in cache for the standard duration (5 ms). This method can be
- * used to temporarily mark the cache as valid for a longer period, in order
- * to reduce network traffic for instance.
- *
- * @param msValidity : an integer corresponding to the validity attributed to the
- *         loaded function parameters, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YFunction::load(int msValidity)
-{
-    YRETCODE res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = this->_load_unsafe(msValidity);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-
-/**
- * Invalidates the cache. Invalidates the cache of the function attributes. Forces the
- * next call to get_xxx() or loadxxx() to use values that come from the device.
- *
- * @noreturn
- */
-void YFunction::clearCache()
-{
-    YDevice* dev;
-    string errmsg, apires;
-
-
-    yEnterCriticalSection(&_this_cs);
-    // Resolve our reference to our device, load REST API
-    int res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_this_cs);
-        return;
-    }
-    dev->clearCache(false);
-    if (_cacheExpiration) {
-        _cacheExpiration = yapiGetTickCount();
-    }
-    yLeaveCriticalSection(&_this_cs);
-}
-
-
-/**
- * Gets the YModule object for the device on which the function is located.
- * If the function cannot be located on any module, the returned instance of
- * YModule is not shown as on-line.
- *
- * @return an instance of YModule
- */
-YModule* YFunction::get_module(void)
-{
-    YFUN_DESCR fundescr;
-    YDEV_DESCR devdescr;
-    string errmsg, serial, funcId, funcName, funcValue;
-
-    yEnterCriticalSection(&_this_cs);
-    fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-    if (!YISERR(fundescr)) {
-        if (!YISERR(YapiWrapper::getFunctionInfo(fundescr, devdescr, serial, funcId, funcName, funcValue, errmsg))) {
-            yLeaveCriticalSection(&_this_cs);
-            return yFindModule(serial + ".module");
-        }
-    }
-    // return a true YModule object even if it is not a module valid for communicating
-    yLeaveCriticalSection(&_this_cs);
-    return yFindModule(string("module_of_") + _className + "_" + _func);
-}
-
-
-/**
- * Returns the value of the userData attribute, as previously stored using method
- * set_userData.
- * This attribute is never touched directly by the API, and is at disposal of the caller to
- * store a context.
- *
- * @return the object stored previously by the caller.
- */
-void* YFunction::get_userData(void)
-{
-    void* res;
-    yEnterCriticalSection(&_this_cs);
-    res = _userData;
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-
-/**
- * Stores a user context provided as argument in the userData attribute of the function.
- * This attribute is never touched by the API, and is at disposal of the caller to store a context.
- *
- * @param data : any kind of object to be stored
- * @noreturn
- */
-void YFunction::set_userData(void* data)
-{
-    yEnterCriticalSection(&_this_cs);
-    _userData = data;
-    yLeaveCriticalSection(&_this_cs);
-}
-
-
-/**
- * Returns a unique identifier of type YFUN_DESCR corresponding to the function.
- * This identifier can be used to test if two instances of YFunction reference the same
- * physical function on the same physical device.
- *
- * @return an identifier of type YFUN_DESCR.
- *
- * If the function has never been contacted, the returned value is Y_FUNCTIONDESCRIPTOR_INVALID.
- */
-YFUN_DESCR YFunction::get_functionDescriptor(void)
-{
-    // do not take CS un purpose
-    return _fundescr;
-}
-
-void YFunction::_UpdateValueCallbackList(YFunction* func, bool add)
-{
-    if (add) {
-        func->isOnline();
-        vector<YFunction*>::iterator it;
-        for (it = _FunctionCallbacks.begin(); it < _FunctionCallbacks.end(); it++) {
-            if (*it == func)
-                return;
-        }
-        _FunctionCallbacks.push_back(func);
-    } else {
-        vector<YFunction*>::iterator it;
-        for (it = _FunctionCallbacks.begin(); it < _FunctionCallbacks.end(); it++) {
-            if (*it == func) {
-                _FunctionCallbacks.erase(it);
-                break;
-            }
-        }
-    }
-}
-
-
-void YFunction::_UpdateTimedReportCallbackList(YFunction* func, bool add)
-{
-    if (add) {
-        func->isOnline();
-        vector<YFunction*>::iterator it;
-        for (it = _TimedReportCallbackList.begin(); it < _TimedReportCallbackList.end(); it++) {
-            if (*it == func)
-                return;
-        }
-        _TimedReportCallbackList.push_back(func);
-    } else {
-        vector<YFunction*>::iterator it;
-        for (it = _TimedReportCallbackList.begin(); it < _TimedReportCallbackList.end(); it++) {
-            if (*it == func) {
-                _TimedReportCallbackList.erase(it);
-                break;
-            }
-        }
-    }
-}
-
-
-void YModule::_updateModuleCallbackList(YModule* module, bool add)
-{
-    map<YModule*, int>::iterator entry = _moduleCallbackList.find(module);
-    if (add) {
-        module->isOnline();
-        if (entry != _moduleCallbackList.end()) {
-            _moduleCallbackList[module]++;
-        } else {
-            _moduleCallbackList[module] = 1;
-        }
-    } else {
-        if (entry != _moduleCallbackList.end()) {
-            if (_moduleCallbackList[module] > 0) {
-                _moduleCallbackList[module]--;
-            }
-        }
-    }
-}
-
-
-// This is the internal device cache object
-vector<YDevice*> YDevice::_devCache;
-
-YDevice::YDevice(YDEV_DESCR devdesc): _devdescr(devdesc), _cacheStamp(0), _cacheJson(NULL), _subpath(NULL)
-{
-    yInitializeCriticalSection(&_lock);
-};
-
-
-YDevice::~YDevice() // destructor
-{
-    clearCache(true);
-    yDeleteCriticalSection(&_lock);
-}
-
-void YDevice::ClearCache()
-{
-    for (unsigned int idx = 0; idx < YDevice::_devCache.size(); idx++) {
-        delete _devCache[idx];
-    }
-    _devCache.clear();
-    _devCache = vector<YDevice*>();
-}
-
-
-YDevice* YDevice::getDevice(YDEV_DESCR devdescr)
-{
-    // Search in cache
-    yEnterCriticalSection(&YAPI::_global_cs);
-    for (unsigned int idx = 0; idx < YDevice::_devCache.size(); idx++) {
-        if (YDevice::_devCache[idx]->_devdescr == devdescr) {
-            yLeaveCriticalSection(&YAPI::_global_cs);
-            return YDevice::_devCache[idx];
-        }
-    }
-
-    // Not found, add new entry
-    YDevice* dev = new YDevice(devdescr);
-    YDevice::_devCache.push_back(dev);
-    yLeaveCriticalSection(&YAPI::_global_cs);
-
-    return dev;
-}
-
-
-YRETCODE YDevice::HTTPRequestPrepare(const string& request, string& fullrequest, char* errbuff)
-{
-    YRETCODE res;
-    size_t pos;
-    // mutex already taken by caller
-    if (_subpath == NULL) {
-        int neededsize;
-        res = yapiGetDevicePath(_devdescr, _rootdevice, NULL, 0, &neededsize, errbuff);
-        if (YISERR(res)) return res;
-        _subpath = new char[neededsize];
-        res = yapiGetDevicePath(_devdescr, _rootdevice, _subpath, neededsize, NULL, errbuff);
-        if (YISERR(res)) return res;
-    }
-    pos = request.find_first_of('/');
-    fullrequest = request.substr(0, pos) + (string)_subpath + request.substr(pos + 1);
-
-    return YAPI_SUCCESS;
-}
-
-
-YRETCODE YDevice::HTTPRequest_unsafe(int channel, const string& request, string& buffer, yapiRequestProgressCallback callback, void* context, string& errmsg)
-{
-    char errbuff[YOCTO_ERRMSG_LEN] = "";
-    YRETCODE res;
-    YIOHDL iohdl;
-    string fullrequest;
-    char* reply;
-    int replysize = 0;
-
-    if (YISERR(res = HTTPRequestPrepare(request, fullrequest, errbuff))) {
-        errmsg = (string)errbuff;
-        return res;
-    }
-    if (YISERR(res = yapiHTTPRequestSyncStartOutOfBand(&iohdl, channel, _rootdevice, fullrequest.data(), (int)fullrequest.size(), &reply, &replysize, callback, context, errbuff))) {
-        errmsg = (string)errbuff;
-        return res;
-    }
-    if (replysize > 0 && reply != NULL) {
-        buffer = string(reply, replysize);
-    } else {
-        buffer = "";
-    }
-    if (YISERR(res = yapiHTTPRequestSyncDone(&iohdl, errbuff))) {
-        errmsg = (string)errbuff;
-        return res;
-    }
-
-    return YAPI_SUCCESS;
-}
-
-
-YRETCODE YDevice::HTTPRequestAsync(int channel, const string& request, HTTPRequestCallback callback, void* context, string& errmsg)
-{
-    char errbuff[YOCTO_ERRMSG_LEN] = "";
-    YRETCODE res = YAPI_SUCCESS;
-    string fullrequest;
-    yEnterCriticalSection(&_lock);
-    _cacheStamp = YAPI::GetTickCount(); //invalidate cache
-    if (YISERR(res=HTTPRequestPrepare(request, fullrequest, errbuff)) ||
-        YISERR(res=yapiHTTPRequestAsyncOutOfBand(channel, _rootdevice, fullrequest.c_str(), (int)fullrequest.length(), NULL, NULL, errbuff))) {
-        errmsg = (string)errbuff;
-    }
-    yLeaveCriticalSection(&_lock);
-    return res;
-}
-
-
-YRETCODE YDevice::HTTPRequest(int channel, const string& request, string& buffer, yapiRequestProgressCallback callback, void* context, string& errmsg)
-{
-    YRETCODE res;
-    int locked = 0;
-    int i;
-
-    for (i = 0; !locked && i < 5; i++) {
-        locked = yTryEnterCriticalSection(&_lock);
-        if (!locked) {
-            yApproximateSleep(50);
-        }
-    }
-    if (!locked) {
-        yEnterCriticalSection(&_lock);
-    }
-    res = HTTPRequest_unsafe(channel, request, buffer, callback, context, errmsg);
-    yLeaveCriticalSection(&_lock);
-    return res;
-}
-
-
-YRETCODE YDevice::requestAPI(YJSONObject*& apires, string& errmsg)
-{
-    yJsonStateMachine j;
-    string rootdev, buffer;
-    string request = "GET /api.json \r\n\r\n";
-    string json_str;
-    int res;
-
-    yEnterCriticalSection(&_lock);
-
-    // Check if we have a valid cache value
-    if (_cacheStamp > YAPI::GetTickCount()) {
-        apires = _cacheJson;
-        yLeaveCriticalSection(&_lock);
-        return YAPI_SUCCESS;
-    }
-    if (_cacheJson == NULL) {
-        request = "GET /api.json \r\n\r\n";
-    } else {
-        string fw_release = _cacheJson->getYJSONObject("module")->getString("firmwareRelease");
-        fw_release = __escapeAttr(fw_release);
-        request = "GET /api.json?fw=" + fw_release + " \r\n\r\n";
-    }
-    // send request, without HTTP/1.1 suffix to get light headers
-    res = this->HTTPRequest_unsafe(0, request, buffer, NULL, NULL, errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_lock);
-        // Check if an update of the device list does not solve the issue
-        res = YapiWrapper::updateDeviceList(true, errmsg);
-        if (YISERR(res)) {
-            return (YRETCODE)res;
-        }
-        yEnterCriticalSection(&_lock);
-        // send request, without HTTP/1.1 suffix to get light headers
-        res = this->HTTPRequest_unsafe(0, request, buffer, NULL, NULL, errmsg);
-        if (YISERR(res)) {
-            yLeaveCriticalSection(&_lock);
-            return (YRETCODE)res;
-        }
-    }
-
-    // Parse HTTP header
-    j.src = buffer.data();
-    j.end = j.src + buffer.size();
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        errmsg = "Failed to parse HTTP header";
-        if (!YAPI::ExceptionsDisabled) {
-            throw YAPI_Exception(YAPI_IO_ERROR, errmsg);
-        }
-        yLeaveCriticalSection(&_lock);
-        return YAPI_IO_ERROR;
-    }
-    if (string(j.token) != "200") {
-        errmsg = string("Unexpected HTTP return code: ") + j.token;
-        if (!YAPI::ExceptionsDisabled) {
-            throw YAPI_Exception(YAPI_IO_ERROR, errmsg);
-        }
-        yLeaveCriticalSection(&_lock);
-        return YAPI_IO_ERROR;
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-        errmsg = "Unexpected HTTP header format";
-        if (!YAPI::ExceptionsDisabled) {
-            throw YAPI_Exception(YAPI_IO_ERROR, errmsg);
-        }
-        yLeaveCriticalSection(&_lock);
-        return YAPI_IO_ERROR;
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || (j.st != YJSON_PARSE_STRUCT && j.st != YJSON_PARSE_ARRAY)) {
-        errmsg = "Unexpected JSON reply format";
-        if (!YAPI::ExceptionsDisabled) {
-            throw YAPI_Exception(YAPI_IO_ERROR, errmsg);
-        }
-        yLeaveCriticalSection(&_lock);
-        return YAPI_IO_ERROR;
-    }
-    // we know for sure that the last character parsed was a '{' or '['
-    do j.src--; while (j.src[0] != '{' && j.src[0] != '[');
-    json_str = string(j.src);
-    try {
-        apires = new YJSONObject(json_str, 0, (int)json_str.length());
-        apires->parseWithRef(_cacheJson);
-    } catch (std::exception ex) {
-        errmsg = "unexpected JSON structure: " + string(ex.what());
-        if (_cacheJson) {
-            delete _cacheJson;
-            _cacheJson = NULL;
-        }
-        yLeaveCriticalSection(&_lock);
-        if (!YAPI::ExceptionsDisabled) {
-            throw YAPI_Exception(YAPI_IO_ERROR, errmsg);
-        }
-        return YAPI_IO_ERROR;
-    }
-    // store result in cache
-    if (_cacheJson) {
-        delete _cacheJson;
-    }
-    _cacheJson = apires;
-    _cacheStamp = yapiGetTickCount() + YAPI::_yapiContext.GetCacheValidity();
-    yLeaveCriticalSection(&_lock);
-
-    return YAPI_SUCCESS;
-}
-
-
-void YDevice::clearCache(bool clearSubpath)
-{
-    yEnterCriticalSection(&_lock);
-    _cacheStamp = 0;
-    if (clearSubpath) {
-        if (_cacheJson) {
-            delete _cacheJson;
-            _cacheJson = NULL;
-        }
-        if (_subpath) {
-            delete _subpath;
-            _subpath = NULL;
-        }
-    }
-    yLeaveCriticalSection(&_lock);
-}
-
-YRETCODE YDevice::getFunctions(vector<YFUN_DESCR>** functions, string& errmsg)
-{
-    yEnterCriticalSection(&_lock);
-    if (_functions.size() == 0) {
-        int res = YapiWrapper::getFunctionsByDevice(_devdescr, 0, _functions, 64, errmsg);
-        if (YISERR(res)) return (YRETCODE)res;
-    }
-    *functions = &_functions;
-    yLeaveCriticalSection(&_lock);
-
-    return YAPI_SUCCESS;
-}
-
-
-queue<yapiGlobalEvent> YAPI::_plug_events;
-queue<yapiDataEvent> YAPI::_data_events;
-
-u64 YAPI::_nextEnum = 0;
-bool YAPI::_apiInitialized = false;
-
-std::map<int, yCalibrationHandler> YAPI::_calibHandlers;
-YHubDiscoveryCallback YAPI::_HubDiscoveryCallback = NULL;
-
-
-// Switch to turn off exceptions and use return codes instead, for source-code compatibility
-// with languages without exception support like pure C
-bool YAPI::ExceptionsDisabled = false;
-
-yCRITICAL_SECTION YAPI::_global_cs;
-YAPIContext YAPI::_yapiContext;
-
-// standard error objects
-const string YAPI::INVALID_STRING = YAPI_INVALID_STRING;
-const double YAPI::INVALID_DOUBLE = (-DBL_MAX);
-
-
-yLogFunction YAPI::LogFunction = NULL;
-yDeviceUpdateCallback YAPI::DeviceArrivalCallback = NULL;
-yDeviceUpdateCallback YAPI::DeviceRemovalCallback = NULL;
-yDeviceUpdateCallback YAPI::DeviceChangeCallback = NULL;
-
-void YAPI::_yapiLogFunctionFwd(const char* log, u32 loglen)
-{
-    if (YAPI::LogFunction)
-        YAPI::LogFunction(string(log));
-}
-
-
-void YAPI::_yapiDeviceLogCallbackFwd(YDEV_DESCR devdesc, const char* line)
-{
-    YModule* module;
-    yDeviceSt infos;
-    string errmsg;
-    YModuleLogCallback callback;
-
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    module = YModule::FindModule(string(infos.serial) + ".module");
-    callback = module->get_logCallback();
-    if (callback) {
-        callback(module, string(line));
-    }
-}
-
-
-void YAPI::_yapiDeviceArrivalCallbackFwd(YDEV_DESCR devdesc)
-{
-    yapiGlobalEvent ev;
-    yapiDataEvent dataEv;
-    yDeviceSt infos;
-    string errmsg;
-    vector<YFunction*>::iterator it;
-
-    YDevice* dev = YDevice::getDevice(devdesc);
-    dev->clearCache(true);
-    dataEv.type = YAPI_FUN_REFRESH;
-    for (it = _FunctionCallbacks.begin(); it < _FunctionCallbacks.end(); it++) {
-        if ((*it)->functionDescriptor() == Y_FUNCTIONDESCRIPTOR_INVALID) {
-            dataEv.fun = *it;
-            _data_events.push(dataEv);
-        }
-    }
-    if (YAPI::DeviceArrivalCallback == NULL) return;
-    ev.type = YAPI_DEV_ARRIVAL;
-    //the function is already thread safe (use yapiLockDeviceCallaback)
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    ev.module = yFindModule(string(infos.serial) + ".module");
-    ev.module->setImmutableAttributes(&infos);
-    _plug_events.push(ev);
-}
-
-void YAPI::_yapiDeviceRemovalCallbackFwd(YDEV_DESCR devdesc)
-{
-    yapiGlobalEvent ev;
-    yDeviceSt infos;
-    string errmsg;
-
-    if (YAPI::DeviceRemovalCallback == NULL) return;
-    ev.type = YAPI_DEV_REMOVAL;
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    ev.module = yFindModule(string(infos.serial) + ".module");
-    //the function is already thread safe (use yapiLockDeviceCallaback)
-    _plug_events.push(ev);
-}
-
-void YAPI::_yapiDeviceChangeCallbackFwd(YDEV_DESCR devdesc)
-{
-    yapiGlobalEvent ev;
-    yDeviceSt infos;
-    string errmsg;
-
-    if (YAPI::DeviceChangeCallback == NULL) return;
-    ev.type = YAPI_DEV_CHANGE;
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    ev.module = yFindModule(string(infos.serial) + ".module");
-    ev.module->setImmutableAttributes(&infos);
-    //the function is already thread safe (use yapiLockDeviceCallaback)
-    _plug_events.push(ev);
-}
-
-void YAPI::_yapiBeaconCallbackFwd(YDEV_DESCR devdesc, int beacon)
-{
-    yapiDataEvent ev;
-    yDeviceSt infos;
-    string errmsg;
-    YModule* module;
-
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    module = yFindModule(string(infos.serial) + ".module");
-    if (_moduleCallbackList.find(module) != _moduleCallbackList.end() && _moduleCallbackList[module] > 0) {
-        ev.type = YAPI_DEV_BEACON;
-        ev.module = module;
-        ev.beacon = beacon;
-        //the function is already thread safe (use yapiLockFunctionCallaback)
-        _data_events.push(ev);
-    }
-}
-
-
-void YAPI::_yapiDeviceConfigChangeCallbackFwd(YDEV_DESCR devdesc)
-{
-    yapiDataEvent ev;
-    yDeviceSt infos;
-    string errmsg;
-    YModule* module;
-
-    if (YapiWrapper::getDeviceInfo(devdesc, infos, errmsg) != YAPI_SUCCESS) return;
-    module = yFindModule(string(infos.serial) + ".module");
-    if (_moduleCallbackList.find(module) != _moduleCallbackList.end() && _moduleCallbackList[module] > 0) {
-        ev.type = YAPI_DEV_CONFCHANGE;
-        ev.module = module;
-        ev.module->setImmutableAttributes(&infos);
-        //the function is already thread safe (use yapiLockFunctionCallaback)
-        _data_events.push(ev);
-    }
-}
-
-void YAPI::_yapiFunctionUpdateCallbackFwd(YAPI_FUNCTION fundesc, const char* value)
-{
-    yapiDataEvent ev;
-
-    //the function is already thread safe (use yapiLockFunctionCallaback)
-    if (value == NULL) {
-        ev.type = YAPI_FUN_UPDATE;
-    } else {
-        ev.type = YAPI_FUN_VALUE;
-        memcpy(ev.value, value,YOCTO_PUBVAL_LEN);
-    }
-    for (unsigned i = 0; i < _FunctionCallbacks.size(); i++) {
-        if (_FunctionCallbacks[i]->get_functionDescriptor() == fundesc) {
-            ev.fun = _FunctionCallbacks[i];
-            _data_events.push(ev);
-        }
-    }
-}
-
-void YAPI::_yapiFunctionTimedReportCallbackFwd(YAPI_FUNCTION fundesc, double timestamp, const u8* bytes, u32 len, double duration)
-{
-    yapiDataEvent ev;
-
-    for (unsigned i = 0; i < _TimedReportCallbackList.size(); i++) {
-        if (_TimedReportCallbackList[i]->get_functionDescriptor() == fundesc) {
-            u32 p = 0;
-            ev.type = YAPI_FUN_TIMEDREPORT;
-            ev.sensor = (YSensor*)_TimedReportCallbackList[i];
-            ev.timestamp = timestamp;
-            ev.duration = duration;
-            ev.len = len;
-            while (p < len) {
-                ev.report[p++] = *bytes++;
-            }
-            _data_events.push(ev);
-        }
-    }
-}
-
-void YAPI::_yapiHubDiscoveryCallbackFwd(const char* serial, const char* url)
-{
-    yapiGlobalEvent ev;
-
-    if (YAPI::_HubDiscoveryCallback == NULL) return;
-    ev.type = YAPI_HUB_DISCOVER;
-    strcpy(ev.serial, serial);
-    strcpy(ev.url, url);
-    _plug_events.push(ev);
-}
-
-
-static double decExp[16] = {
-    1.0e-6, 1.0e-5, 1.0e-4, 1.0e-3, 1.0e-2, 1.0e-1, 1.0,
-    1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5, 1.0e6, 1.0e7, 1.0e8, 1.0e9
-};
-
-// Convert Yoctopuce 16-bit decimal floats to standard double-precision floats
-//
-double YAPI::_decimalToDouble(s16 val)
-{
-    int negate = 0;
-    int mantis = val & 2047;
-    double res;
-
-    if (mantis == 0) return 0.0;
-    if (val < 0) {
-        negate = 1;
-        val = -val;
-    }
-    res = (double)(mantis) * decExp[val >> 11];
-
-    return (negate ? -res : res);
-}
-
-// Convert standard double-precision floats to Yoctopuce 16-bit decimal floats
-//
-s16 YAPI::_doubleToDecimal(double val)
-{
-    int negate = 0;
-    double comp, mant;
-    int decpow;
-    int res;
-
-    if (val == 0.0) {
-        return 0;
-    }
-    if (val < 0) {
-        negate = 1;
-        val = -val;
-    }
-    comp = val / 1999.0;
-    decpow = 0;
-    while (comp > decExp[decpow] && decpow < 15) {
-        decpow++;
-    }
-    mant = val / decExp[decpow];
-    if (decpow == 15 && mant > 2047.0) {
-        res = (15 << 11) + 2047; // overflow
-    } else {
-        res = (decpow << 11) + (int)floor(mant + .5);
-    }
-    return (negate ? -res : res);
-}
-
-yCalibrationHandler YAPI::_getCalibrationHandler(int calibType)
-{
-    if (YAPI::_calibHandlers.find(calibType) == YAPI::_calibHandlers.end()) {
-        return NULL;
-    }
-    return YAPI::_calibHandlers[calibType];
-}
-
-
-// Parse an array of u16 encoded in a base64-like string with memory-based compresssion
-vector<int> YAPI::_decodeWords(string sdat)
-{
-    vector<int> udat;
-
-    for (unsigned p = 0; p < sdat.size();) {
-        unsigned val;
-        unsigned c = sdat[p++];
-        if (c == '*') {
-            val = 0;
-        } else if (c == 'X') {
-            val = 0xffff;
-        } else if (c == 'Y') {
-            val = 0x7fff;
-        } else if (c >= 'a') {
-            int srcpos = (int)udat.size() - 1 - (c - 'a');
-            if (srcpos < 0)
-                val = 0;
-            else
-                val = udat[srcpos];
-        } else {
-            if (p + 2 > sdat.size()) return udat;
-            val = (c - '0');
-            c = sdat[p++];
-            val += (c - '0') << 5;
-            c = sdat[p++];
-            if (c == 'z') c = '\\';
-            val += (c - '0') << 10;
-        }
-        udat.push_back((int)val);
-    }
-    return udat;
-}
-
-// Parse a list of floats and return them as an array of fixed-point 1/1000 numbers
-vector<int> YAPI::_decodeFloats(string sdat)
-{
-    vector<int> idat;
-
-    for (unsigned p = 0; p < sdat.size();) {
-        int val = 0;
-        int sign = 1;
-        int dec = 0;
-        int decInc = 0;
-        unsigned c = sdat[p++];
-        while (c != '-' && (c < '0' || c > '9')) {
-            if (p >= sdat.size()) {
-                return idat;
-            }
-            c = sdat[p++];
-        }
-        if (c == '-') {
-            if (p >= sdat.size()) {
-                return idat;
-            }
-            sign = -sign;
-            c = sdat[p++];
-        }
-        while ((c >= '0' && c <= '9') || c == '.') {
-            if (c == '.') {
-                decInc = 1;
-            } else if (dec < 3) {
-                val = val * 10 + (c - '0');
-                dec += decInc;
-            }
-            if (p < sdat.size()) {
-                c = sdat[p++];
-            } else {
-                c = 0;
-            }
-        }
-        if (dec < 3) {
-            if (dec == 0) val *= 1000;
-            else if (dec == 1) val *= 100;
-            else val *= 10;
-        }
-        idat.push_back(sign * val);
-    }
-    return idat;
-}
-
-
-static const char* hexArray = "0123456789ABCDEF";
-
-string YAPI::_bin2HexStr(const string& data)
-{
-    const u8* ptr = (u8*)data.data();
-    size_t len = data.length();
-    string res = string(len * 2, 0);
-    for (size_t j = 0; j < len; j++, ptr++) {
-        u8 v = *ptr;
-        res[j * 2] = hexArray[v >> 4];
-        res[j * 2 + 1] = hexArray[v & 0x0F];
-    }
-    return res;
-}
-
-string YAPI::_hexStr2Bin(const string& hex_str)
-{
-    size_t len = hex_str.length() / 2;
-    const char* p = hex_str.c_str();
-    string res = string(len, 0);
-    for (size_t i = 0; i < len; i++) {
-        u8 b = 0;
-        int j;
-        for (j = 0; j < 2; j++) {
-            b <<= 4;
-            if (*p >= 'a' && *p <= 'f') {
-                b += 10 + *p - 'a';
-            } else if (*p >= 'A' && *p <= 'F') {
-                b += 10 + *p - 'A';
-            } else if (*p >= '0' && *p <= '9') {
-                b += *p - '0';
-            }
-            p++;
-        }
-        res[i] = b;
-    }
-    return res;
-}
-
-
-s64 yatoi(const char* p)
-{
-    s64 value = 0;
-    bool neg = *p == '-';
-    if (*p == '+' || neg) {
-        p++;
-    }
-    while (*p >= '0' && *p <= '9') {
-        value *= 10;
-        value += *p - '0';
-        p++;
-    }
-    if (neg) {
-        return -value;
-    } else {
-        return value;
-    }
-}
-
-
-/**
- * Returns the version identifier for the Yoctopuce library in use.
- * The version is a string in the form "Major.Minor.Build",
- * for instance "1.01.5535". For languages using an external
- * DLL (for instance C#, VisualBasic or Delphi), the character string
- * includes as well the DLL version, for instance
- * "1.01.5535 (1.01.5439)".
- *
- * If you want to verify in your code that the library version is
- * compatible with the version that you have used during development,
- * verify that the major number is strictly equal and that the minor
- * number is greater or equal. The build number is not relevant
- * with respect to the library compatibility.
- *
- * @return a character string describing the library version.
- */
-string YAPI::GetAPIVersion(void)
-{
-    string version;
-    string date;
-    YapiWrapper::getAPIVersion(version, date);
-    return version;
-}
-
-
-/**
- * Initializes the Yoctopuce programming library explicitly.
- * It is not strictly needed to call yInitAPI(), as the library is
- * automatically  initialized when calling yRegisterHub() for the
- * first time.
- *
- * When Y_DETECT_NONE is used as detection mode,
- * you must explicitly use yRegisterHub() to point the API to the
- * VirtualHub on which your devices are connected before trying to access them.
- *
- * @param mode : an integer corresponding to the type of automatic
- *         device detection to use. Possible values are
- *         Y_DETECT_NONE, Y_DETECT_USB, Y_DETECT_NET,
- *         and Y_DETECT_ALL.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::InitAPI(int mode, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    int i;
-
-    if (YAPI::_apiInitialized)
-        return YAPI_SUCCESS;
-    YRETCODE res = yapiInitAPI(mode, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-        return res;
-    }
-    yapiRegisterLogFunction(YAPI::_yapiLogFunctionFwd);
-    yapiRegisterDeviceLogCallback(YAPI::_yapiDeviceLogCallbackFwd);
-    yapiRegisterDeviceArrivalCallback(YAPI::_yapiDeviceArrivalCallbackFwd);
-    yapiRegisterDeviceRemovalCallback(YAPI::_yapiDeviceRemovalCallbackFwd);
-    yapiRegisterDeviceChangeCallback(YAPI::_yapiDeviceChangeCallbackFwd);
-    yapiRegisterBeaconCallback(YAPI::_yapiBeaconCallbackFwd);
-    yapiRegisterDeviceConfigChangeCallback(YAPI::_yapiDeviceConfigChangeCallbackFwd);
-    yapiRegisterFunctionUpdateCallback(YAPI::_yapiFunctionUpdateCallbackFwd);
-    yapiRegisterTimedReportCallback(YAPI::_yapiFunctionTimedReportCallbackFwd);
-    yapiRegisterHubDiscoveryCallback(YAPI::_yapiHubDiscoveryCallbackFwd);
-
-    yInitializeCriticalSection(&_updateDeviceList_CS);
-    yInitializeCriticalSection(&_handleEvent_CS);
-    yInitializeCriticalSection(&_global_cs);
-    for (i = 0; i <= 20; i++) {
-        YAPI::RegisterCalibrationHandler(i, YAPI::LinearCalibrationHandler);
-    }
-    YAPI::RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, YAPI::LinearCalibrationHandler);
-    YAPI::_apiInitialized = true;
-
-    return YAPI_SUCCESS;
-}
-
-/**
- * Frees dynamically allocated memory blocks used by the Yoctopuce library.
- * It is generally not required to call this function, unless you
- * want to free all dynamically allocated memory blocks in order to
- * track a memory leak for instance.
- * You should not call any other library function after calling
- * yFreeAPI(), or your program will crash.
- */
-void YAPI::FreeAPI(void)
-{
-    if (YAPI::_apiInitialized) {
-        yapiFreeAPI();
-        YAPI::_apiInitialized = false;
-        yDeleteCriticalSection(&_updateDeviceList_CS);
-        yDeleteCriticalSection(&_handleEvent_CS);
-        yDeleteCriticalSection(&_global_cs);
-        YDevice::ClearCache();
-        YFunction::_ClearCache();
-        while (!_plug_events.empty()) {
-            _plug_events.pop();
-        }
-        while (!_data_events.empty()) {
-            _data_events.pop();
-        }
-        _calibHandlers.clear();
-    }
-}
-
-/**
- * Disables the use of exceptions to report runtime errors.
- * When exceptions are disabled, every function returns a specific
- * error value which depends on its type and which is documented in
- * this reference manual.
- */
-void YAPI::DisableExceptions(void)
-{
-    YAPI::ExceptionsDisabled = true;
-}
-
-/**
- * Re-enables the use of exceptions for runtime error handling.
- * Be aware than when exceptions are enabled, every function that fails
- * triggers an exception. If the exception is not caught by the user code,
- * it  either fires the debugger or aborts (i.e. crash) the program.
- * On failure, throws an exception or returns a negative error code.
- */
-void YAPI::EnableExceptions(void)
-{
-    YAPI::ExceptionsDisabled = false;
-}
-
-/**
- * Registers a log callback function. This callback will be called each time
- * the API have something to say. Quite useful to debug the API.
- *
- * @param logfun : a procedure taking a string parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-void YAPI::RegisterLogFunction(yLogFunction logfun)
-{
-    YAPI::LogFunction = logfun;
-}
-
-/**
- * Register a callback function, to be called each time
- * a device is plugged. This callback will be invoked while yUpdateDeviceList
- * is running. You will have to call this function on a regular basis.
- *
- * @param arrivalCallback : a procedure taking a YModule parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-void YAPI::RegisterDeviceArrivalCallback(yDeviceUpdateCallback arrivalCallback)
-{
-    YAPI::DeviceArrivalCallback = arrivalCallback;
-    if (arrivalCallback) {
-        YModule* mod = YModule::FirstModule();
-        while (mod) {
-            if (mod->isOnline()) {
-                yapiLockDeviceCallBack(NULL);
-                _yapiDeviceArrivalCallbackFwd(mod->functionDescriptor());
-                yapiUnlockDeviceCallBack(NULL);
-            }
-            mod = mod->nextModule();
-        }
-    }
-}
-
-/**
- * Register a callback function, to be called each time
- * a device is unplugged. This callback will be invoked while yUpdateDeviceList
- * is running. You will have to call this function on a regular basis.
- *
- * @param removalCallback : a procedure taking a YModule parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-void YAPI::RegisterDeviceRemovalCallback(yDeviceUpdateCallback removalCallback)
-{
-    YAPI::DeviceRemovalCallback = removalCallback;
-}
-
-void YAPI::RegisterDeviceChangeCallback(yDeviceUpdateCallback changeCallback)
-{
-    YAPI::DeviceChangeCallback = changeCallback;
-}
-
-/**
- * Register a callback function, to be called each time an Network Hub send
- * an SSDP message. The callback has two string parameter, the first one
- * contain the serial number of the hub and the second contain the URL of the
- * network hub (this URL can be passed to RegisterHub). This callback will be invoked
- * while yUpdateDeviceList is running. You will have to call this function on a regular basis.
- *
- * @param hubDiscoveryCallback : a procedure taking two string parameter, the serial
- *         number and the hub URL. Use NULL to unregister a previously registered  callback.
- */
-void YAPI::RegisterHubDiscoveryCallback(YHubDiscoveryCallback hubDiscoveryCallback)
-{
-    YAPI::_HubDiscoveryCallback = hubDiscoveryCallback;
-    string error;
-    YAPI::TriggerHubDiscovery(error);
-}
-
-/**
- * Force a hub discovery, if a callback as been registered with yRegisterHubDiscoveryCallback it
- * will be called for each net work hub that will respond to the discovery.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::TriggerHubDiscovery(string& errmsg)
-{
-    YRETCODE res;
-    char errbuf[YOCTO_ERRMSG_LEN];
-    if (!YAPI::_apiInitialized) {
-        res = YAPI::InitAPI(0, errmsg);
-        if (YISERR(res)) return res;
-    }
-    res = yapiTriggerHubDiscovery(errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-// Register a new value calibration handler for a given calibration type
-//
-void YAPI::RegisterCalibrationHandler(int calibrationType, yCalibrationHandler calibrationHandler)
-{
-    YAPI::_calibHandlers[calibrationType] = calibrationHandler;
-}
-
-// Standard value calibration handler (n-point linear error correction)
-//
-double YAPI::LinearCalibrationHandler(double rawValue, int calibType, intArr params, floatArr rawValues, floatArr refValues)
-{
-    double x = rawValues[0];
-    double adj = refValues[0] - x;
-    int i = 0;
-    int npt;
-
-    if (calibType < YOCTO_CALIB_TYPE_OFS) {
-        // calibration types n=1..10 and 11..20 are meant for linear calibration using n points
-        npt = calibType % 10;
-        if (npt > (int)rawValues.size()) npt = (int)rawValues.size();
-        if (npt > (int)refValues.size()) npt = (int)refValues.size();
-    } else {
-        npt = (int)refValues.size();
-    }
-    while (rawValue > rawValues[i] && ++i < npt) {
-        double x2 = x;
-        double adj2 = adj;
-
-        x = rawValues[i];
-        adj = refValues[i] - x;
-
-        if (rawValue < x && x > x2) {
-            adj = adj2 + (adj - adj2) * (rawValue - x2) / (x - x2);
-        }
-    }
-    return rawValue + adj;
-}
-
-
-/**
- * Test if the hub is reachable. This method do not register the hub, it only test if the
- * hub is usable. The url parameter follow the same convention as the RegisterHub
- * method. This method is useful to verify the authentication parameters for a hub. It
- * is possible to force this method to return after mstimeout milliseconds.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param mstimeout : the number of millisecond available to test the connection.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure returns a negative error code.
- */
-YRETCODE YAPI::TestHub(const string& url, int mstimeout, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-    res = yapiTestHub(url.c_str(), mstimeout, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return res;
-}
-
-
-/**
- * Setup the Yoctopuce library to use modules connected on a given machine. The
- * parameter will determine how the API will work. Use the following values:
- *
- * <b>usb</b>: When the usb keyword is used, the API will work with
- * devices connected directly to the USB bus. Some programming languages such a JavaScript,
- * PHP, and Java don't provide direct access to USB hardware, so usb will
- * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
- *
- * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
- * host with the given IP address or hostname. That host can be a regular computer
- * running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or
- * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
- * computer, use the IP address 127.0.0.1.
- *
- * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
- * This a special mode allowing to take control of Yoctopuce devices
- * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
- * need to configure your hub to call your server script on a regular basis.
- * This mode is currently available for PHP and Node.JS only.
- *
- * Be aware that only one application can use direct USB access at a
- * given time on a machine. Multiple access would cause conflicts
- * while trying to access the USB modules. In particular, this means
- * that you must stop the VirtualHub software before starting
- * an application that uses direct USB access. The workaround
- * for this limitation is to setup the library to use the VirtualHub
- * rather than direct USB access.
- *
- * If access control has been activated on the hub, virtual or not, you want to
- * reach, the URL parameter should look like:
- *
- * http://username:password@address:port
- *
- * You can call <i>RegisterHub</i> several times to connect to several machines.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::RegisterHub(const string& url, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-    if (!YAPI::_apiInitialized) {
-        res = YAPI::InitAPI(0, errmsg);
-        if (YISERR(res)) return res;
-    }
-    res = yapiRegisterHub(url.c_str(), errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return res;
-}
-
-/**
- * Fault-tolerant alternative to RegisterHub(). This function has the same
- * purpose and same arguments as RegisterHub(), but does not trigger
- * an error when the selected hub is not available at the time of the function call.
- * This makes it possible to register a network hub independently of the current
- * connectivity, and to try to contact it only when a device is actively needed.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::PreregisterHub(const string& url, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-    if (!YAPI::_apiInitialized) {
-        res = YAPI::InitAPI(0, errmsg);
-        if (YISERR(res)) return res;
-    }
-    res = yapiPreregisterHub(url.c_str(), errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return res;
-}
-
-/**
- * Setup the Yoctopuce library to no more use modules connected on a previously
- * registered machine with RegisterHub.
- *
- * @param url : a string containing either "usb" or the
- *         root URL of the hub to monitor
- */
-void YAPI::UnregisterHub(const string& url)
-{
-    if (!YAPI::_apiInitialized) {
-        return;
-    }
-    yapiUnregisterHub(url.c_str());
-}
-
-
-/**
- * Triggers a (re)detection of connected Yoctopuce modules.
- * The library searches the machines or USB ports previously registered using
- * yRegisterHub(), and invokes any user-defined callback function
- * in case a change in the list of connected devices is detected.
- *
- * This function can be called as frequently as desired to refresh the device list
- * and to make the application aware of hot-plug events. However, since device
- * detection is quite a heavy process, UpdateDeviceList shouldn't be called more
- * than once every two seconds.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::UpdateDeviceList(string& errmsg)
-{
-    if (!YAPI::_apiInitialized) {
-        YRETCODE res = YAPI::InitAPI(0, errmsg);
-        if (YISERR(res)) return res;
-    }
-    // prevent reentrance into this function
-    yEnterCriticalSection(&_updateDeviceList_CS);
-    // call the updateDeviceList of the yapi layer
-    // yapi know when it is needed to do a full update
-    YRETCODE res = YapiWrapper::updateDeviceList(false, errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_updateDeviceList_CS);
-        return res;
-    }
-    // handle other notification
-    res = YapiWrapper::handleEvents(errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_updateDeviceList_CS);
-        return res;
-    }
-    // unpop plug/unplug event and call user callback
-    while (!_plug_events.empty()) {
-        yapiGlobalEvent ev;
-        yapiLockDeviceCallBack(NULL);
-        if (_plug_events.empty()) {
-            yapiUnlockDeviceCallBack(NULL);
-            break;
-        }
-        ev = _plug_events.front();
-        _plug_events.pop();
-        yapiUnlockDeviceCallBack(NULL);
-        switch (ev.type) {
-        case YAPI_DEV_ARRIVAL:
-            if (!YAPI::DeviceArrivalCallback) break;
-            YAPI::DeviceArrivalCallback(ev.module);
-            break;
-        case YAPI_DEV_REMOVAL:
-            if (!YAPI::DeviceRemovalCallback) break;
-            YAPI::DeviceRemovalCallback(ev.module);
-            break;
-        case YAPI_DEV_CHANGE:
-            if (!YAPI::DeviceChangeCallback) break;
-            YAPI::DeviceChangeCallback(ev.module);
-            break;
-        case YAPI_HUB_DISCOVER:
-            if (!YAPI::_HubDiscoveryCallback) break;
-            YAPI::_HubDiscoveryCallback(string(ev.serial), string(ev.url));
-            break;
-        default:
-            break;
-        }
-    }
-    yLeaveCriticalSection(&_updateDeviceList_CS);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Maintains the device-to-library communication channel.
- * If your program includes significant loops, you may want to include
- * a call to this function to make sure that the library takes care of
- * the information pushed by the modules on the communication channels.
- * This is not strictly necessary, but it may improve the reactivity
- * of the library for the following commands.
- *
- * This function may signal an error in case there is a communication problem
- * while contacting a module.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::HandleEvents(string& errmsg)
-{
-    YRETCODE res;
-
-    // prevent reentrance into this function
-    yEnterCriticalSection(&_handleEvent_CS);
-    // handle other notification
-    res = YapiWrapper::handleEvents(errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_handleEvent_CS);
-        return res;
-    }
-    // pop data event and call user callback
-    while (!_data_events.empty()) {
-        yapiDataEvent ev;
-        YSensor* sensor;
-        vector<int> report;
-
-        yapiLockFunctionCallBack(NULL);
-        if (_data_events.empty()) {
-            yapiUnlockFunctionCallBack(NULL);
-            break;
-        }
-        ev = _data_events.front();
-        _data_events.pop();
-        yapiUnlockFunctionCallBack(NULL);
-        switch (ev.type) {
-        case YAPI_FUN_VALUE:
-            ev.fun->_invokeValueCallback((string)ev.value);
-            break;
-        case YAPI_FUN_TIMEDREPORT:
-            if (ev.report[0] <= 2) {
-                sensor = ev.sensor;
-                report.assign(ev.report, ev.report + ev.len);
-                sensor->_invokeTimedReportCallback(sensor->_decodeTimedReport(ev.timestamp, ev.duration, report));
-            }
-            break;
-        case YAPI_FUN_REFRESH:
-            ev.fun->isOnline();
-            break;
-        case YAPI_DEV_CONFCHANGE:
-            ev.module->_invokeConfigChangeCallback();
-            break;
-        case YAPI_DEV_BEACON:
-            ev.module->_invokeBeaconCallback((Y_BEACON_enum)ev.beacon);
-            break;
-        default:
-            break;
-        }
-    }
-    yLeaveCriticalSection(&_handleEvent_CS);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Pauses the execution flow for a specified duration.
- * This function implements a passive waiting loop, meaning that it does not
- * consume CPU cycles significantly. The processor is left available for
- * other threads and processes. During the pause, the library nevertheless
- * reads from time to time information from the Yoctopuce modules by
- * calling yHandleEvents(), in order to stay up-to-date.
- *
- * This function may signal an error in case there is a communication problem
- * while contacting a module.
- *
- * @param ms_duration : an integer corresponding to the duration of the pause,
- *         in milliseconds.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YRETCODE YAPI::Sleep(unsigned ms_duration, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-    u64 waituntil = YAPI::GetTickCount() + ms_duration;
-    do {
-        res = YAPI::HandleEvents(errmsg);
-        if (YISERR(res)) {
-            errmsg = errbuf;
-            return res;
-        }
-        if (waituntil > YAPI::GetTickCount()) {
-            res = yapiSleep(2, errbuf);
-            if (YISERR(res)) {
-                errmsg = errbuf;
-                return res;
-            }
-        }
-    } while (waituntil > YAPI::GetTickCount());
-
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns the current value of a monotone millisecond-based time counter.
- * This counter can be used to compute delays in relation with
- * Yoctopuce devices, which also uses the millisecond as timebase.
- *
- * @return a long integer corresponding to the millisecond counter.
- */
-u64 YAPI::GetTickCount(void)
-{
-    return yapiGetTickCount();
-}
-
-/**
- * Checks if a given string is valid as logical name for a module or a function.
- * A valid logical name has a maximum of 19 characters, all among
- * A..Z, a..z, 0..9, _, and -.
- * If you try to configure a logical name with an incorrect string,
- * the invalid characters are ignored.
- *
- * @param name : a string containing the name to check.
- *
- * @return true if the name is valid, false otherwise.
- */
-bool YAPI::CheckLogicalName(const string& name)
-{
-    return (yapiCheckLogicalName(name.c_str()) != 0);
-}
-
-u16 YapiWrapper::getAPIVersion(string& version, string& date)
-{
-    const char *_ver, *_date;
-    u16 res = yapiGetAPIVersion(&_ver, &_date);
-    version = _ver;
-    date = _date;
-    return res;
-}
-
-YDEV_DESCR YapiWrapper::getDevice(const string& device_str, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YDEV_DESCR res;
-
-    res = yapiGetDevice(device_str.data(), errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return (YDEV_DESCR)res;
-}
-
-int YapiWrapper::getAllDevices(vector<YDEV_DESCR>& buffer, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    int n_elems = 32;
-    int initsize = n_elems * sizeof(YDEV_DESCR);
-    int neededsize, res;
-    YDEV_DESCR* ptr = new YDEV_DESCR[n_elems];
-
-    res = yapiGetAllDevices(ptr, initsize, &neededsize, errbuf);
-    if (YISERR(res)) {
-        delete [] ptr;
-        errmsg = errbuf;
-        return (YRETCODE)res;
-    }
-    if (neededsize > initsize) {
-        delete [] ptr;
-        n_elems = neededsize / sizeof(YDEV_DESCR);
-        initsize = n_elems * sizeof(YDEV_DESCR);
-        ptr = new YDEV_DESCR[n_elems];
-        res = yapiGetAllDevices(ptr, initsize, NULL, errbuf);
-        if (YISERR(res)) {
-            delete [] ptr;
-            errmsg = errbuf;
-            return (YRETCODE)res;
-        }
-    }
-    buffer = vector<YDEV_DESCR>(ptr, ptr + res);
-    delete [] ptr;
-
-    return res;
-}
-
-YRETCODE YapiWrapper::getDeviceInfo(YDEV_DESCR devdesc, yDeviceSt& infos, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res;
-
-    res = yapiGetDeviceInfo(devdesc, &infos, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return res;
-}
-
-YFUN_DESCR YapiWrapper::getFunction(const string& class_str, const string& function_str, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-
-    YFUN_DESCR res = yapiGetFunction(class_str.data(), function_str.data(), errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    }
-    return res;
-}
-
-int YapiWrapper::getFunctionsByClass(const string& class_str, YFUN_DESCR prevfundesc, vector<YFUN_DESCR>& buffer, int maxsize, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    int n_elems = 32;
-    int initsize = n_elems * sizeof(YDEV_DESCR);
-    int neededsize;
-    YFUN_DESCR* ptr = new YFUN_DESCR[n_elems];
-
-    int res = yapiGetFunctionsByClass(class_str.data(), prevfundesc, ptr, initsize, &neededsize, errbuf);
-    if (YISERR(res)) {
-        delete [] ptr;
-        errmsg = errbuf;
-        return res;
-    }
-    if (neededsize > initsize) {
-        delete [] ptr;
-        n_elems = neededsize / sizeof(YFUN_DESCR);
-        initsize = n_elems * sizeof(YFUN_DESCR);
-        ptr = new YFUN_DESCR[n_elems];
-        res = yapiGetFunctionsByClass(class_str.data(), prevfundesc, ptr, initsize, NULL, errbuf);
-        if (YISERR(res)) {
-            delete [] ptr;
-            errmsg = errbuf;
-            return res;
-        }
-    }
-    buffer = vector<YFUN_DESCR>(ptr, ptr + res);
-    delete [] ptr;
-
-    return res;
-}
-
-int YapiWrapper::getFunctionsByDevice(YDEV_DESCR devdesc, YFUN_DESCR prevfundesc, vector<YFUN_DESCR>& buffer, int maxsize, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    int n_elems = 32;
-    int initsize = n_elems * sizeof(YDEV_DESCR);
-    int neededsize;
-    YFUN_DESCR* ptr = new YFUN_DESCR[n_elems];
-
-    int res = yapiGetFunctionsByDevice(devdesc, prevfundesc, ptr, initsize, &neededsize, errbuf);
-    if (YISERR(res)) {
-        delete [] ptr;
-        errmsg = errbuf;
-        return res;
-    }
-    if (neededsize > initsize) {
-        delete [] ptr;
-        n_elems = neededsize / sizeof(YFUN_DESCR);
-        initsize = n_elems * sizeof(YFUN_DESCR);
-        ptr = new YFUN_DESCR[n_elems];
-        res = yapiGetFunctionsByDevice(devdesc, prevfundesc, ptr, initsize, NULL, errbuf);
-        if (YISERR(res)) {
-            delete [] ptr;
-            errmsg = errbuf;
-            return res;
-        }
-    }
-    buffer = vector<YFUN_DESCR>(ptr, ptr + res);
-    delete [] ptr;
-
-    return res;
-}
-
-YDEV_DESCR YapiWrapper::getDeviceByFunction(YFUN_DESCR fundesc, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YDEV_DESCR dev;
-
-    int res = yapiGetFunctionInfo(fundesc, &dev, NULL, NULL, NULL, NULL, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-        return res;
-    }
-
-    return dev;
-}
-
-YRETCODE YapiWrapper::getFunctionInfo(YFUN_DESCR fundesc, YDEV_DESCR& devdescr, string& serial, string& funcId, string& funcName, string& funcVal, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    char snum[YOCTO_SERIAL_LEN];
-    char fnid[YOCTO_FUNCTION_LEN];
-    char fnam[YOCTO_LOGICAL_LEN];
-    char fval[YOCTO_PUBVAL_LEN];
-
-    YRETCODE res = yapiGetFunctionInfoEx(fundesc, &devdescr, snum, fnid, NULL, fnam, fval, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    } else {
-        serial = snum;
-        funcId = fnid;
-        funcName = fnam;
-        funcVal = fval;
-    }
-
-    return res;
-}
-
-YRETCODE YapiWrapper::getFunctionInfoEx(YFUN_DESCR fundesc, YDEV_DESCR& devdescr, string& serial, string& funcId, string& baseType, string& funcName, string& funcVal, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    char snum[YOCTO_SERIAL_LEN];
-    char fnid[YOCTO_FUNCTION_LEN];
-    char fbt[YOCTO_FUNCTION_LEN];
-    char fnam[YOCTO_LOGICAL_LEN];
-    char fval[YOCTO_PUBVAL_LEN];
-
-    YRETCODE res = yapiGetFunctionInfoEx(fundesc, &devdescr, snum, fnid, fbt, fnam, fval, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-    } else {
-        serial = snum;
-        funcId = fnid;
-        baseType = fbt;
-        funcName = fnam;
-        funcVal = fval;
-    }
-
-    return res;
-}
-
-YRETCODE YapiWrapper::updateDeviceList(bool forceupdate, string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res = yapiUpdateDeviceList(forceupdate ? 1 : 0, errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-YRETCODE YapiWrapper::handleEvents(string& errmsg)
-{
-    char errbuf[YOCTO_ERRMSG_LEN];
-    YRETCODE res = yapiHandleEvents(errbuf);
-    if (YISERR(res)) {
-        errmsg = errbuf;
-        return res;
-    }
-    return YAPI_SUCCESS;
-}
-
-
-string YapiWrapper::ysprintf(const char* fmt, ...)
-{
-    va_list args;
-    char on_stack_buffer[1024];
-    int n, size = 1024;
-    char* buffer = on_stack_buffer;
-    string res = "";
-
-    for (int i = 0; i < 13; i++) {
-        va_start(args, fmt);
-        n = vsnprintf(buffer, size, fmt, args);
-        va_end(args);
-        if (n > -1 && n < size) {
-            res = string(buffer);
-            break;
-        }
-
-        if (n > -1) {
-            size = n + 1;
-        } else {
-            size *= 2;
-        }
-        if (buffer != on_stack_buffer) {
-            free(buffer);
-        }
-        buffer = (char*)malloc(size);
-    }
-    if (buffer != on_stack_buffer) {
-        free(buffer);
-    }
-    return res;
-}
-
-
-//--- (generated code: YModule constructor)
-YModule::YModule(const string& func): YFunction(func)
-                                      //--- (end of generated code: YModule constructor)
-                                      //--- (generated code: YModule initialization)
-    ,_productName(PRODUCTNAME_INVALID)
-    ,_serialNumber(SERIALNUMBER_INVALID)
-    ,_productId(PRODUCTID_INVALID)
-    ,_productRelease(PRODUCTRELEASE_INVALID)
-    ,_firmwareRelease(FIRMWARERELEASE_INVALID)
-    ,_persistentSettings(PERSISTENTSETTINGS_INVALID)
-    ,_luminosity(LUMINOSITY_INVALID)
-    ,_beacon(BEACON_INVALID)
-    ,_upTime(UPTIME_INVALID)
-    ,_usbCurrent(USBCURRENT_INVALID)
-    ,_rebootCountdown(REBOOTCOUNTDOWN_INVALID)
-    ,_userVar(USERVAR_INVALID)
-    ,_valueCallbackModule(NULL)
-    ,_logCallback(NULL)
-    ,_confChangeCallback(NULL)
-    ,_beaconCallback(NULL)
-//--- (end of generated code: YModule initialization)
-{
-    _className = "Module";
-}
-
-YModule::~YModule()
-{
-    //--- (generated code: YModule cleanup)
-//--- (end of generated code: YModule cleanup)
-}
-
-
-//--- (generated code: YModule implementation)
-// static attributes
-const string YModule::PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
-const string YModule::SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
-const string YModule::FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
-
-int YModule::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("productName")) {
-        _productName =  json_val->getString("productName");
-    }
-    if(json_val->has("serialNumber")) {
-        _serialNumber =  json_val->getString("serialNumber");
-    }
-    if(json_val->has("productId")) {
-        _productId =  json_val->getInt("productId");
-    }
-    if(json_val->has("productRelease")) {
-        _productRelease =  json_val->getInt("productRelease");
-    }
-    if(json_val->has("firmwareRelease")) {
-        _firmwareRelease =  json_val->getString("firmwareRelease");
-    }
-    if(json_val->has("persistentSettings")) {
-        _persistentSettings =  (Y_PERSISTENTSETTINGS_enum)json_val->getInt("persistentSettings");
-    }
-    if(json_val->has("luminosity")) {
-        _luminosity =  json_val->getInt("luminosity");
-    }
-    if(json_val->has("beacon")) {
-        _beacon =  (Y_BEACON_enum)json_val->getInt("beacon");
-    }
-    if(json_val->has("upTime")) {
-        _upTime =  json_val->getLong("upTime");
-    }
-    if(json_val->has("usbCurrent")) {
-        _usbCurrent =  json_val->getInt("usbCurrent");
-    }
-    if(json_val->has("rebootCountdown")) {
-        _rebootCountdown =  json_val->getInt("rebootCountdown");
-    }
-    if(json_val->has("userVar")) {
-        _userVar =  json_val->getInt("userVar");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the commercial name of the module, as set by the factory.
- *
- * @return a string corresponding to the commercial name of the module, as set by the factory
- *
- * On failure, throws an exception or returns Y_PRODUCTNAME_INVALID.
- */
-string YModule::get_productName(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::PRODUCTNAME_INVALID;
-                }
-            }
-        }
-        res = _productName;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the serial number of the module, as set by the factory.
- *
- * @return a string corresponding to the serial number of the module, as set by the factory
- *
- * On failure, throws an exception or returns Y_SERIALNUMBER_INVALID.
- */
-string YModule::get_serialNumber(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::SERIALNUMBER_INVALID;
-                }
-            }
-        }
-        res = _serialNumber;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the USB device identifier of the module.
- *
- * @return an integer corresponding to the USB device identifier of the module
- *
- * On failure, throws an exception or returns Y_PRODUCTID_INVALID.
- */
-int YModule::get_productId(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::PRODUCTID_INVALID;
-                }
-            }
-        }
-        res = _productId;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the hardware release version of the module.
- *
- * @return an integer corresponding to the hardware release version of the module
- *
- * On failure, throws an exception or returns Y_PRODUCTRELEASE_INVALID.
- */
-int YModule::get_productRelease(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::PRODUCTRELEASE_INVALID;
-                }
-            }
-        }
-        res = _productRelease;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the version of the firmware embedded in the module.
- *
- * @return a string corresponding to the version of the firmware embedded in the module
- *
- * On failure, throws an exception or returns Y_FIRMWARERELEASE_INVALID.
- */
-string YModule::get_firmwareRelease(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::FIRMWARERELEASE_INVALID;
-                }
-            }
-        }
-        res = _firmwareRelease;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current state of persistent module settings.
- *
- * @return a value among Y_PERSISTENTSETTINGS_LOADED, Y_PERSISTENTSETTINGS_SAVED and
- * Y_PERSISTENTSETTINGS_MODIFIED corresponding to the current state of persistent module settings
- *
- * On failure, throws an exception or returns Y_PERSISTENTSETTINGS_INVALID.
- */
-Y_PERSISTENTSETTINGS_enum YModule::get_persistentSettings(void)
-{
-    Y_PERSISTENTSETTINGS_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::PERSISTENTSETTINGS_INVALID;
-                }
-            }
-        }
-        res = _persistentSettings;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YModule::set_persistentSettings(Y_PERSISTENTSETTINGS_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("persistentSettings", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the luminosity of the  module informative LEDs (from 0 to 100).
- *
- * @return an integer corresponding to the luminosity of the  module informative LEDs (from 0 to 100)
- *
- * On failure, throws an exception or returns Y_LUMINOSITY_INVALID.
- */
-int YModule::get_luminosity(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::LUMINOSITY_INVALID;
-                }
-            }
-        }
-        res = _luminosity;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the luminosity of the module informative leds. The parameter is a
- * value between 0 and 100.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : an integer corresponding to the luminosity of the module informative leds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::set_luminosity(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("luminosity", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the localization beacon.
- *
- * @return either Y_BEACON_OFF or Y_BEACON_ON, according to the state of the localization beacon
- *
- * On failure, throws an exception or returns Y_BEACON_INVALID.
- */
-Y_BEACON_enum YModule::get_beacon(void)
-{
-    Y_BEACON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::BEACON_INVALID;
-                }
-            }
-        }
-        res = _beacon;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Turns on or off the module localization beacon.
- *
- * @param newval : either Y_BEACON_OFF or Y_BEACON_ON
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::set_beacon(Y_BEACON_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("beacon", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of milliseconds spent since the module was powered on.
- *
- * @return an integer corresponding to the number of milliseconds spent since the module was powered on
- *
- * On failure, throws an exception or returns Y_UPTIME_INVALID.
- */
-s64 YModule::get_upTime(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::UPTIME_INVALID;
-                }
-            }
-        }
-        res = _upTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current consumed by the module on the USB bus, in milli-amps.
- *
- * @return an integer corresponding to the current consumed by the module on the USB bus, in milli-amps
- *
- * On failure, throws an exception or returns Y_USBCURRENT_INVALID.
- */
-int YModule::get_usbCurrent(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::USBCURRENT_INVALID;
-                }
-            }
-        }
-        res = _usbCurrent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the remaining number of seconds before the module restarts, or zero when no
- * reboot has been scheduled.
- *
- * @return an integer corresponding to the remaining number of seconds before the module restarts, or zero when no
- *         reboot has been scheduled
- *
- * On failure, throws an exception or returns Y_REBOOTCOUNTDOWN_INVALID.
- */
-int YModule::get_rebootCountdown(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::REBOOTCOUNTDOWN_INVALID;
-                }
-            }
-        }
-        res = _rebootCountdown;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YModule::set_rebootCountdown(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("rebootCountdown", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the value previously stored in this attribute.
- * On startup and after a device reboot, the value is always reset to zero.
- *
- * @return an integer corresponding to the value previously stored in this attribute
- *
- * On failure, throws an exception or returns Y_USERVAR_INVALID.
- */
-int YModule::get_userVar(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YModule::USERVAR_INVALID;
-                }
-            }
-        }
-        res = _userVar;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Stores a 32 bit value in the device RAM. This attribute is at programmer disposal,
- * should he need to store a state variable.
- * On startup and after a device reboot, the value is always reset to zero.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::set_userVar(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("userVar", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Allows you to find a module from its serial number or from its logical name.
- *
- * This function does not require that the module is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YModule.isOnline() to test if the module is
- * indeed online at a given time. In case of ambiguity when looking for
- * a module by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string containing either the serial number or
- *         the logical name of the desired module
- *
- * @return a YModule object allowing you to drive the module
- *         or get additional information on the module.
- */
-YModule* YModule::FindModule(string func)
-{
-    YModule* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YModule*) YFunction::_FindFromCache("Module", func);
-        if (obj == NULL) {
-            obj = new YModule(func);
-            YFunction::_AddToCache("Module", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YModule::registerValueCallback(YModuleValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackModule = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YModule::_invokeValueCallback(string value)
-{
-    if (_valueCallbackModule != NULL) {
-        _valueCallbackModule(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Saves current settings in the nonvolatile memory of the module.
- * Warning: the number of allowed save operations during a module life is
- * limited (about 100000 cycles). Do not call this function within a loop.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::saveToFlash(void)
-{
-    return this->set_persistentSettings(Y_PERSISTENTSETTINGS_SAVED);
-}
-
-/**
- * Reloads the settings stored in the nonvolatile memory, as
- * when the module is powered on.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::revertFromFlash(void)
-{
-    return this->set_persistentSettings(Y_PERSISTENTSETTINGS_LOADED);
-}
-
-/**
- * Schedules a simple module reboot after the given number of seconds.
- *
- * @param secBeforeReboot : number of seconds before rebooting
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::reboot(int secBeforeReboot)
-{
-    return this->set_rebootCountdown(secBeforeReboot);
-}
-
-/**
- * Schedules a module reboot into special firmware update mode.
- *
- * @param secBeforeReboot : number of seconds before rebooting
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::triggerFirmwareUpdate(int secBeforeReboot)
-{
-    return this->set_rebootCountdown(-secBeforeReboot);
-}
-
-void YModule::_startStopDevLog(string serial,bool start)
-{
-    int i_start = 0;
-    if (start) {
-        i_start = 1;
-    } else {
-        i_start = 0;
-    }
-
-    yapiStartStopDeviceLogCallback(serial.c_str(), i_start);
-}
-
-/**
- * Registers a device log callback function. This callback will be called each time
- * that a module sends a new log message. Mostly useful to debug a Yoctopuce module.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the module object that emitted the log message, and the character string containing the log.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YModule::registerLogCallback(YModuleLogCallback callback)
-{
-    string serial;
-
-    serial = this->get_serialNumber();
-    if (serial == YAPI_INVALID_STRING) {
-        return YAPI_DEVICE_NOT_FOUND;
-    }
-    _logCallback = callback;
-    this->_startStopDevLog(serial, callback != NULL);
-    return 0;
-}
-
-YModuleLogCallback YModule::get_logCallback(void)
-{
-    return _logCallback;
-}
-
-/**
- * Register a callback function, to be called when a persistent settings in
- * a device configuration has been changed (e.g. change of unit, etc).
- *
- * @param callback : a procedure taking a YModule parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-int YModule::registerConfigChangeCallback(YModuleConfigChangeCallback callback)
-{
-    if (callback != NULL) {
-        YModule::_updateModuleCallbackList(this, true);
-    } else {
-        YModule::_updateModuleCallbackList(this, false);
-    }
-    _confChangeCallback = callback;
-    return 0;
-}
-
-int YModule::_invokeConfigChangeCallback(void)
-{
-    if (_confChangeCallback != NULL) {
-        _confChangeCallback(this);
-    }
-    return 0;
-}
-
-/**
- * Register a callback function, to be called when the localization beacon of the module
- * has been changed. The callback function should take two arguments: the YModule object of
- * which the beacon has changed, and an integer describing the new beacon state.
- *
- * @param callback : The callback function to call, or NULL to unregister a
- *         previously registered callback.
- */
-int YModule::registerBeaconCallback(YModuleBeaconCallback callback)
-{
-    if (callback != NULL) {
-        YModule::_updateModuleCallbackList(this, true);
-    } else {
-        YModule::_updateModuleCallbackList(this, false);
-    }
-    _beaconCallback = callback;
-    return 0;
-}
-
-int YModule::_invokeBeaconCallback(int beaconState)
-{
-    if (_beaconCallback != NULL) {
-        _beaconCallback(this, beaconState);
-    }
-    return 0;
-}
-
-/**
- * Triggers a configuration change callback, to check if they are supported or not.
- */
-int YModule::triggerConfigChangeCallback(void)
-{
-    this->_setAttr("persistentSettings", "2");
-    return 0;
-}
-
-/**
- * Tests whether the byn file is valid for this module. This method is useful to test if the module
- * needs to be updated.
- * It is possible to pass a directory as argument instead of a file. In this case, this method returns
- * the path of the most recent
- * appropriate .byn file. If the parameter onlynew is true, the function discards firmwares that are older or
- * equal to the installed firmware.
- *
- * @param path : the path of a byn file or a directory that contains byn files
- * @param onlynew : returns only files that are strictly newer
- *
- * @return the path of the byn file to use or a empty string if no byn files matches the requirement
- *
- * On failure, throws an exception or returns a string that start with "error:".
- */
-string YModule::checkFirmware(string path,bool onlynew)
-{
-    string serial;
-    int release = 0;
-    string tmp_res;
-    if (onlynew) {
-        release = atoi((this->get_firmwareRelease()).c_str());
-    } else {
-        release = 0;
-    }
-    //may throw an exception
-    serial = this->get_serialNumber();
-    tmp_res = YFirmwareUpdate::CheckFirmware(serial, path, release);
-    if (_ystrpos(tmp_res, "error:") == 0) {
-        this->_throw(YAPI_INVALID_ARGUMENT, tmp_res);
-    }
-    return tmp_res;
-}
-
-/**
- * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
- * handles the firmware update process.
- *
- * @param path : the path of the .byn file to use.
- * @param force : true to force the firmware update even if some prerequisites appear not to be met
- *
- * @return a YFirmwareUpdate object or NULL on error.
- */
-YFirmwareUpdate YModule::updateFirmwareEx(string path,bool force)
-{
-    string serial;
-    string settings;
-
-    serial = this->get_serialNumber();
-    settings = this->get_allSettings();
-    if ((int)(settings).size() == 0) {
-        this->_throw(YAPI_IO_ERROR, "Unable to get device settings");
-        settings = "error:Unable to get device settings";
-    }
-    return YFirmwareUpdate(serial, path, settings, force);
-}
-
-/**
- * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
- * handles the firmware update process.
- *
- * @param path : the path of the .byn file to use.
- *
- * @return a YFirmwareUpdate object or NULL on error.
- */
-YFirmwareUpdate YModule::updateFirmware(string path)
-{
-    return this->updateFirmwareEx(path, false);
-}
-
-/**
- * Returns all the settings and uploaded files of the module. Useful to backup all the
- * logical names, calibrations parameters, and uploaded files of a device.
- *
- * @return a binary buffer with all the settings.
- *
- * On failure, throws an exception or returns an binary object of size 0.
- */
-string YModule::get_allSettings(void)
-{
-    string settings;
-    string json;
-    string res;
-    string sep;
-    string name;
-    string item;
-    string t_type;
-    string id;
-    string url;
-    string file_data;
-    string file_data_bin;
-    string temp_data_bin;
-    string ext_settings;
-    vector<string> filelist;
-    vector<string> templist;
-
-    settings = this->_download("api.json");
-    if ((int)(settings).size() == 0) {
-        return settings;
-    }
-    ext_settings = ", \"extras\":[";
-    templist = this->get_functionIds("Temperature");
-    sep = "";
-    for (unsigned ii = 0; ii <  templist.size(); ii++) {
-        if (atoi((this->get_firmwareRelease()).c_str()) > 9000) {
-            url = YapiWrapper::ysprintf("api/%s/sensorType", templist[ii].c_str());
-            t_type = this->_download(url);
-            if (t_type == "RES_NTC") {
-                id = ( templist[ii]).substr( 11, (int)( templist[ii]).length() - 11);
-                temp_data_bin = this->_download(YapiWrapper::ysprintf("extra.json?page=%s",id.c_str()));
-                if ((int)(temp_data_bin).size() == 0) {
-                    return temp_data_bin;
-                }
-                item = YapiWrapper::ysprintf("%s{\"fid\":\"%s\", \"json\":%s}\n", sep.c_str(),  templist[ii].c_str(),temp_data_bin.c_str());
-                ext_settings = ext_settings + item;
-                sep = ",";
-            }
-        }
-    }
-    ext_settings = ext_settings + "],\n\"files\":[";
-    if (this->hasFunction("files")) {
-        json = this->_download("files.json?a=dir&f=");
-        if ((int)(json).size() == 0) {
-            return json;
-        }
-        filelist = this->_json_get_array(json);
-        sep = "";
-        for (unsigned ii = 0; ii <  filelist.size(); ii++) {
-            name = this->_json_get_key( filelist[ii], "name");
-            if (((int)(name).length() > 0) && !(name == "startupConf.json")) {
-                file_data_bin = this->_download(this->_escapeAttr(name));
-                file_data = YAPI::_bin2HexStr(file_data_bin);
-                item = YapiWrapper::ysprintf("%s{\"name\":\"%s\", \"data\":\"%s\"}\n", sep.c_str(), name.c_str(),file_data.c_str());
-                ext_settings = ext_settings + item;
-                sep = ",";
-            }
-        }
-    }
-    res = "{ \"api\":" + settings + ext_settings + "]}";
-    return res;
-}
-
-int YModule::loadThermistorExtra(string funcId,string jsonExtra)
-{
-    vector<string> values;
-    string url;
-    string curr;
-    string currTemp;
-    int ofs = 0;
-    int size = 0;
-    url = "api/" + funcId + ".json?command=Z";
-
-    this->_download(url);
-    // add records in growing resistance value
-    values = this->_json_get_array(jsonExtra);
-    ofs = 0;
-    size = (int)values.size();
-    while (ofs + 1 < size) {
-        curr = values[ofs];
-        currTemp = values[ofs + 1];
-        url = YapiWrapper::ysprintf("api/%s/.json?command=m%s:%s",  funcId.c_str(), curr.c_str(),currTemp.c_str());
-        this->_download(url);
-        ofs = ofs + 2;
-    }
-    return YAPI_SUCCESS;
-}
-
-int YModule::set_extraSettings(string jsonExtra)
-{
-    vector<string> extras;
-    string functionId;
-    string data;
-    extras = this->_json_get_array(jsonExtra);
-    for (unsigned ii = 0; ii <  extras.size(); ii++) {
-        functionId = this->_get_json_path( extras[ii], "fid");
-        functionId = this->_decode_json_string(functionId);
-        data = this->_get_json_path( extras[ii], "json");
-        if (this->hasFunction(functionId)) {
-            this->loadThermistorExtra(functionId, data);
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Restores all the settings and uploaded files to the module.
- * This method is useful to restore all the logical names and calibrations parameters,
- * uploaded files etc. of a device from a backup.
- * Remember to call the saveToFlash() method of the module if the
- * modifications must be kept.
- *
- * @param settings : a binary buffer with all the settings.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::set_allSettingsAndFiles(string settings)
-{
-    string down;
-    string json;
-    string json_api;
-    string json_files;
-    string json_extra;
-    json = settings;
-    json_api = this->_get_json_path(json, "api");
-    if (json_api == "") {
-        return this->set_allSettings(settings);
-    }
-    json_extra = this->_get_json_path(json, "extras");
-    if (!(json_extra == "")) {
-        this->set_extraSettings(json_extra);
-    }
-    this->set_allSettings(json_api);
-    if (this->hasFunction("files")) {
-        vector<string> files;
-        string res;
-        string name;
-        string data;
-        down = this->_download("files.json?a=format");
-        res = this->_get_json_path(down, "res");
-        res = this->_decode_json_string(res);
-        if (!(res == "ok")) {
-            _throw(YAPI_IO_ERROR,"format failed");
-            return YAPI_IO_ERROR;
-        }
-        json_files = this->_get_json_path(json, "files");
-        files = this->_json_get_array(json_files);
-        for (unsigned ii = 0; ii <  files.size(); ii++) {
-            name = this->_get_json_path( files[ii], "name");
-            name = this->_decode_json_string(name);
-            data = this->_get_json_path( files[ii], "data");
-            data = this->_decode_json_string(data);
-            this->_upload(name, YAPI::_hexStr2Bin(data));
-        }
-    }
-    // Apply settings a second time for file-dependent settings and dynamic sensor nodes
-    this->set_allSettings(json_api);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Tests if the device includes a specific function. This method takes a function identifier
- * and returns a boolean.
- *
- * @param funcId : the requested function identifier
- *
- * @return true if the device has the function identifier
- */
-bool YModule::hasFunction(string funcId)
-{
-    int count = 0;
-    int i = 0;
-    string fid;
-
-    count = this->functionCount();
-    i = 0;
-    while (i < count) {
-        fid = this->functionId(i);
-        if (fid == funcId) {
-            return true;
-        }
-        i = i + 1;
-    }
-    return false;
-}
-
-/**
- * Retrieve all hardware identifier that match the type passed in argument.
- *
- * @param funType : The type of function (Relay, LightSensor, Voltage,...)
- *
- * @return an array of strings.
- */
-vector<string> YModule::get_functionIds(string funType)
-{
-    int count = 0;
-    int i = 0;
-    string ftype;
-    vector<string> res;
-
-    count = this->functionCount();
-    i = 0;
-    while (i < count) {
-        ftype = this->functionType(i);
-        if (ftype == funType) {
-            res.push_back(this->functionId(i));
-        } else {
-            ftype = this->functionBaseType(i);
-            if (ftype == funType) {
-                res.push_back(this->functionId(i));
-            }
-        }
-        i = i + 1;
-    }
-    return res;
-}
-
-string YModule::_flattenJsonStruct(string jsoncomplex)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char smallbuff[1024];
-    char *bigbuff;
-    int buffsize = 0;
-    int fullsize = 0;
-    int res = 0;
-    string jsonflat;
-    string jsoncomplexstr;
-    fullsize = 0;
-    jsoncomplexstr = jsoncomplex;
-    res = yapiGetAllJsonKeys(jsoncomplexstr.c_str(), smallbuff, 1024, &fullsize, errmsg);
-    if (res < 0) {
-        this->_throw(YAPI_INVALID_ARGUMENT, string(errmsg));
-        jsonflat = "error:" + string(errmsg);
-        return jsonflat;
-    }
-    if (fullsize <= 1024) {
-        jsonflat = string(smallbuff, fullsize);
-    } else {
-        fullsize = fullsize * 2;
-        buffsize = fullsize;
-        bigbuff = (char *)malloc(buffsize);
-        res = yapiGetAllJsonKeys(jsoncomplexstr.c_str(), bigbuff, buffsize, &fullsize, errmsg);
-        if (res < 0) {
-            this->_throw(YAPI_INVALID_ARGUMENT, string(errmsg));
-            jsonflat = "error:" + string(errmsg);
-        } else {
-            jsonflat = string(bigbuff, fullsize);
-        }
-        free(bigbuff);
-    }
-    return jsonflat;
-}
-
-int YModule::calibVersion(string cparams)
-{
-    if (cparams == "0,") {
-        return 3;
-    }
-    if (_ystrpos(cparams, ",") >= 0) {
-        if (_ystrpos(cparams, " ") > 0) {
-            return 3;
-        } else {
-            return 1;
-        }
-    }
-    if (cparams == "" || cparams == "0") {
-        return 1;
-    }
-    if (((int)(cparams).length() < 2) || (_ystrpos(cparams, ".") >= 0)) {
-        return 0;
-    } else {
-        return 2;
-    }
-}
-
-int YModule::calibScale(string unit_name,string sensorType)
-{
-    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
-        return 1000;
-    }
-    if (unit_name == "C") {
-        if (sensorType == "") {
-            return 16;
-        }
-        if (atoi((sensorType).c_str()) < 8) {
-            return 16;
-        } else {
-            return 100;
-        }
-    }
-    if (unit_name == "m" || unit_name == "deg") {
-        return 10;
-    }
-    return 1;
-}
-
-int YModule::calibOffset(string unit_name)
-{
-    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
-        return 0;
-    }
-    return 32767;
-}
-
-string YModule::calibConvert(string param,string currentFuncValue,string unit_name,string sensorType)
-{
-    int paramVer = 0;
-    int funVer = 0;
-    int funScale = 0;
-    int funOffset = 0;
-    int paramScale = 0;
-    int paramOffset = 0;
-    vector<int> words;
-    vector<string> words_str;
-    vector<double> calibData;
-    vector<int> iCalib;
-    int calibType = 0;
-    int i = 0;
-    int maxSize = 0;
-    double ratio = 0.0;
-    int nPoints = 0;
-    double wordVal = 0.0;
-    // Initial guess for parameter encoding
-    paramVer = this->calibVersion(param);
-    funVer = this->calibVersion(currentFuncValue);
-    funScale = this->calibScale(unit_name, sensorType);
-    funOffset = this->calibOffset(unit_name);
-    paramScale = funScale;
-    paramOffset = funOffset;
-    if (funVer < 3) {
-        // Read the effective device scale if available
-        if (funVer == 2) {
-            words = YAPI::_decodeWords(currentFuncValue);
-            if ((words[0] == 1366) && (words[1] == 12500)) {
-                // Yocto-3D RefFrame used a special encoding
-                funScale = 1;
-                funOffset = 0;
-            } else {
-                funScale = words[1];
-                funOffset = words[0];
-            }
-        } else {
-            if (funVer == 1) {
-                if (currentFuncValue == "" || (atoi((currentFuncValue).c_str()) > 10)) {
-                    funScale = 0;
-                }
-            }
-        }
-    }
-    calibData.clear();
-    calibType = 0;
-    if (paramVer < 3) {
-        // Handle old 16 bit parameters formats
-        if (paramVer == 2) {
-            words = YAPI::_decodeWords(param);
-            if ((words[0] == 1366) && (words[1] == 12500)) {
-                // Yocto-3D RefFrame used a special encoding
-                paramScale = 1;
-                paramOffset = 0;
-            } else {
-                paramScale = words[1];
-                paramOffset = words[0];
-            }
-            if (((int)words.size() >= 3) && (words[2] > 0)) {
-                maxSize = 3 + 2 * ((words[2]) % (10));
-                if (maxSize > (int)words.size()) {
-                    maxSize = (int)words.size();
-                }
-                i = 3;
-                while (i < maxSize) {
-                    calibData.push_back((double) words[i]);
-                    i = i + 1;
-                }
-            }
-        } else {
-            if (paramVer == 1) {
-                words_str = _strsplit(param,',');
-                for (unsigned ii = 0; ii < words_str.size(); ii++) {
-                    words.push_back(atoi((words_str[ii]).c_str()));
-                }
-                if (param == "" || (words[0] > 10)) {
-                    paramScale = 0;
-                }
-                if (((int)words.size() > 0) && (words[0] > 0)) {
-                    maxSize = 1 + 2 * ((words[0]) % (10));
-                    if (maxSize > (int)words.size()) {
-                        maxSize = (int)words.size();
-                    }
-                    i = 1;
-                    while (i < maxSize) {
-                        calibData.push_back((double) words[i]);
-                        i = i + 1;
-                    }
-                }
-            } else {
-                if (paramVer == 0) {
-                    ratio = atof((param).c_str());
-                    if (ratio > 0) {
-                        calibData.push_back(0.0);
-                        calibData.push_back(0.0);
-                        calibData.push_back(floor(65535 / ratio+0.5));
-                        calibData.push_back(65535.0);
-                    }
-                }
-            }
-        }
-        i = 0;
-        while (i < (int)calibData.size()) {
-            if (paramScale > 0) {
-                // scalar decoding
-                calibData[i] = (calibData[i] - paramOffset) / paramScale;
-            } else {
-                // floating-point decoding
-                calibData[i] = YAPI::_decimalToDouble((int) floor(calibData[i]+0.5));
-            }
-            i = i + 1;
-        }
-    } else {
-        // Handle latest 32bit parameter format
-        iCalib = YAPI::_decodeFloats(param);
-        calibType = (int) floor(iCalib[0] / 1000.0+0.5);
-        if (calibType >= 30) {
-            calibType = calibType - 30;
-        }
-        i = 1;
-        while (i < (int)iCalib.size()) {
-            calibData.push_back(iCalib[i] / 1000.0);
-            i = i + 1;
-        }
-    }
-    if (funVer >= 3) {
-        // Encode parameters in new format
-        if ((int)calibData.size() == 0) {
-            param = "0,";
-        } else {
-            param = YapiWrapper::ysprintf("%d",30 + calibType);
-            i = 0;
-            while (i < (int)calibData.size()) {
-                if (((i) & (1)) > 0) {
-                    param = param + ":";
-                } else {
-                    param = param + " ";
-                }
-                param = param + YapiWrapper::ysprintf("%d",(int) floor(calibData[i] * 1000.0 / 1000.0+0.5));
-                i = i + 1;
-            }
-            param = param + ",";
-        }
-    } else {
-        if (funVer >= 1) {
-            // Encode parameters for older devices
-            nPoints = (((int)calibData.size()) / (2));
-            param = YapiWrapper::ysprintf("%d",nPoints);
-            i = 0;
-            while (i < 2 * nPoints) {
-                if (funScale == 0) {
-                    wordVal = YAPI::_doubleToDecimal((int) floor(calibData[i]+0.5));
-                } else {
-                    wordVal = calibData[i] * funScale + funOffset;
-                }
-                param = param + "," + YapiWrapper::ysprintf("%f",floor(wordVal+0.5));
-                i = i + 1;
-            }
-        } else {
-            // Initial V0 encoding used for old Yocto-Light
-            if ((int)calibData.size() == 4) {
-                param = YapiWrapper::ysprintf("%f",floor(1000 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]+0.5));
-            }
-        }
-    }
-    return param;
-}
-
-/**
- * Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters
- * of a module from a backup.Remember to call the saveToFlash() method of the module if the
- * modifications must be kept.
- *
- * @param settings : a binary buffer with all the settings.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::set_allSettings(string settings)
-{
-    vector<string> restoreLast;
-    string old_json_flat;
-    vector<string> old_dslist;
-    vector<string> old_jpath;
-    vector<int> old_jpath_len;
-    vector<string> old_val_arr;
-    string actualSettings;
-    vector<string> new_dslist;
-    vector<string> new_jpath;
-    vector<int> new_jpath_len;
-    vector<string> new_val_arr;
-    int cpos = 0;
-    int eqpos = 0;
-    int leng = 0;
-    int i = 0;
-    int j = 0;
-    string njpath;
-    string jpath;
-    string fun;
-    string attr;
-    string value;
-    string url;
-    string tmp;
-    string new_calib;
-    string sensorType;
-    string unit_name;
-    string newval;
-    string oldval;
-    string old_calib;
-    string each_str;
-    bool do_update = 0;
-    bool found = 0;
-    tmp = settings;
-    tmp = this->_get_json_path(tmp, "api");
-    if (!(tmp == "")) {
-        settings = tmp;
-    }
-    oldval = "";
-    newval = "";
-    old_json_flat = this->_flattenJsonStruct(settings);
-    old_dslist = this->_json_get_array(old_json_flat);
-    for (unsigned ii = 0; ii < old_dslist.size(); ii++) {
-        each_str = this->_json_get_string(old_dslist[ii]);
-        // split json path and attr
-        leng = (int)(each_str).length();
-        eqpos = _ystrpos(each_str, "=");
-        if ((eqpos < 0) || (leng == 0)) {
-            this->_throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
-            return YAPI_INVALID_ARGUMENT;
-        }
-        jpath = (each_str).substr( 0, eqpos);
-        eqpos = eqpos + 1;
-        value = (each_str).substr( eqpos, leng - eqpos);
-        old_jpath.push_back(jpath);
-        old_jpath_len.push_back((int)(jpath).length());
-        old_val_arr.push_back(value);
-    }
-
-    actualSettings = this->_download("api.json");
-    actualSettings = this->_flattenJsonStruct(actualSettings);
-    new_dslist = this->_json_get_array(actualSettings);
-    for (unsigned ii = 0; ii < new_dslist.size(); ii++) {
-        // remove quotes
-        each_str = this->_json_get_string(new_dslist[ii]);
-        // split json path and attr
-        leng = (int)(each_str).length();
-        eqpos = _ystrpos(each_str, "=");
-        if ((eqpos < 0) || (leng == 0)) {
-            this->_throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
-            return YAPI_INVALID_ARGUMENT;
-        }
-        jpath = (each_str).substr( 0, eqpos);
-        eqpos = eqpos + 1;
-        value = (each_str).substr( eqpos, leng - eqpos);
-        new_jpath.push_back(jpath);
-        new_jpath_len.push_back((int)(jpath).length());
-        new_val_arr.push_back(value);
-    }
-    i = 0;
-    while (i < (int)new_jpath.size()) {
-        njpath = new_jpath[i];
-        leng = (int)(njpath).length();
-        cpos = _ystrpos(njpath, "/");
-        if ((cpos < 0) || (leng == 0)) {
-            continue;
-        }
-        fun = (njpath).substr( 0, cpos);
-        cpos = cpos + 1;
-        attr = (njpath).substr( cpos, leng - cpos);
-        do_update = true;
-        if (fun == "services") {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "firmwareRelease")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "usbCurrent")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "upTime")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "persistentSettings")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "adminPassword")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "userPassword")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "rebootCountdown")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "advertisedValue")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "poeCurrent")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "readiness")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "ipAddress")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "subnetMask")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "router")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "linkQuality")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "ssid")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "channel")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "security")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "message")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "currentValue")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "currentRawValue")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "currentRunIndex")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "pulseTimer")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "lastTimePressed")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "lastTimeReleased")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "filesCount")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "freeSpace")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "timeUTC")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "rtcTime")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "unixTime")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "dateTime")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "rawValue")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "lastMsg")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "delayedPulseTimer")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "rxCount")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "txCount")) {
-            do_update = false;
-        }
-        if ((do_update) && (attr == "msgCount")) {
-            do_update = false;
-        }
-        if (do_update) {
-            do_update = false;
-            newval = new_val_arr[i];
-            j = 0;
-            found = false;
-            while ((j < (int)old_jpath.size()) && !(found)) {
-                if ((new_jpath_len[i] == old_jpath_len[j]) && (new_jpath[i] == old_jpath[j])) {
-                    found = true;
-                    oldval = old_val_arr[j];
-                    if (!(newval == oldval)) {
-                        do_update = true;
-                    }
-                }
-                j = j + 1;
-            }
-        }
-        if (do_update) {
-            if (attr == "calibrationParam") {
-                old_calib = "";
-                unit_name = "";
-                sensorType = "";
-                new_calib = newval;
-                j = 0;
-                found = false;
-                while ((j < (int)old_jpath.size()) && !(found)) {
-                    if ((new_jpath_len[i] == old_jpath_len[j]) && (new_jpath[i] == old_jpath[j])) {
-                        found = true;
-                        old_calib = old_val_arr[j];
-                    }
-                    j = j + 1;
-                }
-                tmp = fun + "/unit";
-                j = 0;
-                found = false;
-                while ((j < (int)new_jpath.size()) && !(found)) {
-                    if (tmp == new_jpath[j]) {
-                        found = true;
-                        unit_name = new_val_arr[j];
-                    }
-                    j = j + 1;
-                }
-                tmp = fun + "/sensorType";
-                j = 0;
-                found = false;
-                while ((j < (int)new_jpath.size()) && !(found)) {
-                    if (tmp == new_jpath[j]) {
-                        found = true;
-                        sensorType = new_val_arr[j];
-                    }
-                    j = j + 1;
-                }
-                newval = this->calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
-                url = "api/" + fun + ".json?" + attr + "=" + this->_escapeAttr(newval);
-                this->_download(url);
-            } else {
-                url = "api/" + fun + ".json?" + attr + "=" + this->_escapeAttr(oldval);
-                if (attr == "resolution") {
-                    restoreLast.push_back(url);
-                } else {
-                    this->_download(url);
-                }
-            }
-        }
-        i = i + 1;
-    }
-    for (unsigned ii = 0; ii < restoreLast.size(); ii++) {
-        this->_download(restoreLast[ii]);
-    }
-    this->clearCache();
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns the unique hardware identifier of the module.
- * The unique hardware identifier is made of the device serial
- * number followed by string ".module".
- *
- * @return a string that uniquely identifies the module
- */
-string YModule::get_hardwareId(void)
-{
-    string serial;
-
-    serial = this->get_serialNumber();
-    return serial + ".module";
-}
-
-/**
- * Downloads the specified built-in file and returns a binary buffer with its content.
- *
- * @param pathname : name of the new file to load
- *
- * @return a binary buffer with the file content
- *
- * On failure, throws an exception or returns  YAPI_INVALID_STRING.
- */
-string YModule::download(string pathname)
-{
-    return this->_download(pathname);
-}
-
-/**
- * Returns the icon of the module. The icon is a PNG image and does not
- * exceeds 1536 bytes.
- *
- * @return a binary buffer with module icon, in png format.
- *         On failure, throws an exception or returns  YAPI_INVALID_STRING.
- */
-string YModule::get_icon2d(void)
-{
-    return this->_download("icon2d.png");
-}
-
-/**
- * Returns a string with last logs of the module. This method return only
- * logs that are still in the module.
- *
- * @return a string with last logs of the module.
- *         On failure, throws an exception or returns  YAPI_INVALID_STRING.
- */
-string YModule::get_lastLogs(void)
-{
-    string content;
-
-    content = this->_download("logs.txt");
-    return content;
-}
-
-/**
- * Adds a text message to the device logs. This function is useful in
- * particular to trace the execution of HTTP callbacks. If a newline
- * is desired after the message, it must be included in the string.
- *
- * @param text : the string to append to the logs.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YModule::log(string text)
-{
-    return this->_upload("logs.txt", text);
-}
-
-/**
- * Returns a list of all the modules that are plugged into the current module.
- * This method only makes sense when called for a YoctoHub/VirtualHub.
- * Otherwise, an empty array will be returned.
- *
- * @return an array of strings containing the sub modules.
- */
-vector<string> YModule::get_subDevices(void)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char smallbuff[1024];
-    char *bigbuff;
-    int buffsize = 0;
-    int fullsize = 0;
-    int yapi_res = 0;
-    string subdevice_list;
-    vector<string> subdevices;
-    string serial;
-
-    serial = this->get_serialNumber();
-    fullsize = 0;
-    yapi_res = yapiGetSubdevices(serial.c_str(), smallbuff, 1024, &fullsize, errmsg);
-    if (yapi_res < 0) {
-        return subdevices;
-    }
-    if (fullsize <= 1024) {
-        subdevice_list = string(smallbuff, yapi_res);
-    } else {
-        buffsize = fullsize;
-        bigbuff = (char *)malloc(buffsize);
-        yapi_res = yapiGetSubdevices(serial.c_str(), bigbuff, buffsize, &fullsize, errmsg);
-        if (yapi_res < 0) {
-            free(bigbuff);
-            return subdevices;
-        } else {
-            subdevice_list = string(bigbuff, yapi_res);
-        }
-        free(bigbuff);
-    }
-    if (!(subdevice_list == "")) {
-        subdevices = _strsplit(subdevice_list,',');
-    }
-    return subdevices;
-}
-
-/**
- * Returns the serial number of the YoctoHub on which this module is connected.
- * If the module is connected by USB, or if the module is the root YoctoHub, an
- * empty string is returned.
- *
- * @return a string with the serial number of the YoctoHub or an empty string
- */
-string YModule::get_parentHub(void)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char hubserial[YOCTO_SERIAL_LEN];
-    int pathsize = 0;
-    int yapi_res = 0;
-    string serial;
-
-    serial = this->get_serialNumber();
-    // retrieve device object
-    pathsize = 0;
-    yapi_res = yapiGetDevicePathEx(serial.c_str(), hubserial, NULL, 0, &pathsize, errmsg);
-    if (yapi_res < 0) {
-        return "";
-    }
-    return string(hubserial);
-}
-
-/**
- * Returns the URL used to access the module. If the module is connected by USB, the
- * string 'usb' is returned.
- *
- * @return a string with the URL of the module.
- */
-string YModule::get_url(void)
-{
-    char errmsg[YOCTO_ERRMSG_LEN];
-    char path[1024];
-    int pathsize = 0;
-    int yapi_res = 0;
-    string serial;
-
-    serial = this->get_serialNumber();
-    // retrieve device object
-    pathsize = 0;
-    yapi_res = yapiGetDevicePathEx(serial.c_str(), NULL, path, 1024, &pathsize, errmsg);
-    if (yapi_res < 0) {
-        return "";
-    }
-    return string(path);
-}
-
-YModule *YModule::nextModule(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YModule::FindModule(hwid);
-}
-
-YModule* YModule::FirstModule(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Module", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YModule::FindModule(serial+"."+funcId);
-}
-
-//--- (end of generated code: YModule implementation)
-
-// Return a string that describes the function (class and logical name or hardware id)
-string YModule::get_friendlyName(void)
-{
-    YFUN_DESCR fundescr, moddescr;
-    YDEV_DESCR devdescr;
-    string errmsg, serial, funcId, funcName, funcValue;
-    string mod_serial, mod_funcId, mod_funcname;
-
-    yEnterCriticalSection(&_this_cs);
-    fundescr = YapiWrapper::getFunction(_className, _func, errmsg);
-    if (!YISERR(fundescr) && !YISERR(YapiWrapper::getFunctionInfo(fundescr, devdescr, serial, funcId, funcName, funcValue, errmsg))) {
-        moddescr = YapiWrapper::getFunction("Module", serial, errmsg);
-        if (!YISERR(moddescr) && !YISERR(YapiWrapper::getFunctionInfo(moddescr, devdescr, mod_serial, mod_funcId, mod_funcname, funcValue, errmsg))) {
-            if (mod_funcname != "") {
-                yLeaveCriticalSection(&_this_cs);
-                return mod_funcname;
-            }
-        }
-        yLeaveCriticalSection(&_this_cs);
-        return serial;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return Y_FRIENDLYNAME_INVALID;
-}
-
-
-void YModule::setImmutableAttributes(yDeviceSt* infos)
-{
-    // do not take CS on purpose (called for update device list)
-    _serialNumber = (string)infos->serial;
-    _productName = (string)infos->productname;
-    _productId = infos->deviceid;
-    _cacheExpiration = YAPI::GetTickCount();
-}
-
-
-// Return the properties of the nth function of our device
-YRETCODE YModule::_getFunction(int idx, string& serial, string& funcId, string& baseType, string& funcName, string& funcVal, string& errmsg)
-{
-    vector<YFUN_DESCR>* functions;
-    YDevice* dev;
-    int res;
-    YFUN_DESCR fundescr;
-    YDEV_DESCR devdescr;
-
-    // retrieve device object
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-
-    // get reference to all functions from the device
-    res = dev->getFunctions(&functions, errmsg);
-    if (YISERR(res)) return (YRETCODE)res;
-
-    // get latest function info from yellow pages
-    fundescr = functions->at(idx);
-    res = YapiWrapper::getFunctionInfoEx(fundescr, devdescr, serial, funcId, baseType, funcName, funcVal, errmsg);
-    if (YISERR(res)) return (YRETCODE)res;
-
-    return YAPI_SUCCESS;
-}
-
-// Retrieve the number of functions (beside "module") in the device
-int YModule::functionCount()
-{
-    vector<YFUN_DESCR>* functions;
-    YDevice* dev;
-    string errmsg;
-    int res;
-
-    yEnterCriticalSection(&_this_cs);
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_this_cs);
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    res = dev->getFunctions(&functions, errmsg);
-    if (YISERR(res)) {
-        yLeaveCriticalSection(&_this_cs);
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return (int)functions->size();
-}
-
-// Retrieve the Id of the nth function (beside "module") in the device
-string YModule::functionId(int functionIndex)
-{
-    string serial, funcId, funcName, basetype, funcVal, errmsg;
-    int res;
-
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = _getFunction(functionIndex, serial, funcId, basetype, funcName, funcVal, errmsg);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-    return funcId;
-}
-
-// Retrieve the logical name of the nth function (beside "module") in the device
-string YModule::functionName(int functionIndex)
-{
-    string serial, funcId, basetype, funcName, funcVal, errmsg;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = _getFunction(functionIndex, serial, funcId, basetype, funcName, funcVal, errmsg);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-
-    return funcName;
-}
-
-// Retrieve the advertised value of the nth function (beside "module") in the device
-string YModule::functionValue(int functionIndex)
-{
-    string serial, funcId, basetype, funcName, funcVal, errmsg;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = _getFunction(functionIndex, serial, funcId, basetype, funcName, funcVal, errmsg);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-
-    return funcVal;
-}
-
-
-// Retrieve the Id of the nth function (beside "module") in the device
-string YModule::functionType(int functionIndex)
-{
-    string serial, funcId, basetype, funcName, funcVal, errmsg;
-    char buffer[YOCTO_FUNCTION_LEN], *d = buffer;
-    const char* p;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = _getFunction(functionIndex, serial, funcId, basetype, funcName, funcVal, errmsg);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-    p = funcId.c_str();
-    *d++ = *p++ & 0xdf;
-    while (*p && (*p < '0' || *p > '9')) {
-        *d++ = *p++;
-    }
-    *d = 0;
-    return string(buffer);
-}
-
-// Retrieve the Id of the nth function (beside "module") in the device
-string YModule::functionBaseType(int functionIndex)
-{
-    string serial, funcId, basetype, funcName, funcVal, errmsg;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        res = _getFunction(functionIndex, serial, funcId, basetype, funcName, funcVal, errmsg);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return YAPI_INVALID_STRING;
-    }
-
-    return basetype;
-}
-
-
-//--- (generated code: YModule functions)
-//--- (end of generated code: YModule functions)
-
-
-YSensor::YSensor(const string& func): YFunction(func)
-                                      //--- (generated code: YSensor initialization)
-    ,_unit(UNIT_INVALID)
-    ,_currentValue(CURRENTVALUE_INVALID)
-    ,_lowestValue(LOWESTVALUE_INVALID)
-    ,_highestValue(HIGHESTVALUE_INVALID)
-    ,_currentRawValue(CURRENTRAWVALUE_INVALID)
-    ,_logFrequency(LOGFREQUENCY_INVALID)
-    ,_reportFrequency(REPORTFREQUENCY_INVALID)
-    ,_advMode(ADVMODE_INVALID)
-    ,_calibrationParam(CALIBRATIONPARAM_INVALID)
-    ,_resolution(RESOLUTION_INVALID)
-    ,_sensorState(SENSORSTATE_INVALID)
-    ,_valueCallbackSensor(NULL)
-    ,_timedReportCallbackSensor(NULL)
-    ,_prevTimedReport(0.0)
-    ,_iresol(0.0)
-    ,_offset(0.0)
-    ,_scale(0.0)
-    ,_decexp(0.0)
-    ,_caltyp(0)
-//--- (end of generated code: YSensor initialization)
-{
-    _className = "Sensor";
-}
-
-YSensor::~YSensor()
-{
-    //--- (generated code: YSensor cleanup)
-//--- (end of generated code: YSensor cleanup)
-}
-
-
-//--- (generated code: YSensor implementation)
-// static attributes
-const string YSensor::UNIT_INVALID = YAPI_INVALID_STRING;
-const double YSensor::CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YSensor::LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YSensor::HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YSensor::CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const string YSensor::LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
-const string YSensor::REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
-const string YSensor::CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
-const double YSensor::RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
-
-int YSensor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("unit")) {
-        _unit =  json_val->getString("unit");
-    }
-    if(json_val->has("currentValue")) {
-        _currentValue =  floor(json_val->getDouble("currentValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("lowestValue")) {
-        _lowestValue =  floor(json_val->getDouble("lowestValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("highestValue")) {
-        _highestValue =  floor(json_val->getDouble("highestValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("currentRawValue")) {
-        _currentRawValue =  floor(json_val->getDouble("currentRawValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("logFrequency")) {
-        _logFrequency =  json_val->getString("logFrequency");
-    }
-    if(json_val->has("reportFrequency")) {
-        _reportFrequency =  json_val->getString("reportFrequency");
-    }
-    if(json_val->has("advMode")) {
-        _advMode =  (Y_ADVMODE_enum)json_val->getInt("advMode");
-    }
-    if(json_val->has("calibrationParam")) {
-        _calibrationParam =  json_val->getString("calibrationParam");
-    }
-    if(json_val->has("resolution")) {
-        _resolution =  floor(json_val->getDouble("resolution") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("sensorState")) {
-        _sensorState =  json_val->getInt("sensorState");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measuring unit for the measure.
- *
- * @return a string corresponding to the measuring unit for the measure
- *
- * On failure, throws an exception or returns Y_UNIT_INVALID.
- */
-string YSensor::get_unit(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::UNIT_INVALID;
-                }
-            }
-        }
-        res = _unit;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current value of the measure, in the specified unit, as a floating point number.
- *
- * @return a floating point number corresponding to the current value of the measure, in the specified
- * unit, as a floating point number
- *
- * On failure, throws an exception or returns Y_CURRENTVALUE_INVALID.
- */
-double YSensor::get_currentValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::CURRENTVALUE_INVALID;
-                }
-            }
-        }
-        res = this->_applyCalibration(_currentRawValue);
-        if (res == YSensor::CURRENTVALUE_INVALID) {
-            res = _currentValue;
-        }
-        res = res * _iresol;
-        res = floor(res+0.5) / _iresol;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the recorded minimal value observed. Can be used to reset the value returned
- * by get_lowestValue().
- *
- * @param newval : a floating point number corresponding to the recorded minimal value observed
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_lowestValue(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("lowestValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minimal value observed for the measure since the device was started.
- * Can be reset to an arbitrary value thanks to set_lowestValue().
- *
- * @return a floating point number corresponding to the minimal value observed for the measure since
- * the device was started
- *
- * On failure, throws an exception or returns Y_LOWESTVALUE_INVALID.
- */
-double YSensor::get_lowestValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::LOWESTVALUE_INVALID;
-                }
-            }
-        }
-        res = _lowestValue * _iresol;
-        res = floor(res+0.5) / _iresol;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the recorded maximal value observed. Can be used to reset the value returned
- * by get_lowestValue().
- *
- * @param newval : a floating point number corresponding to the recorded maximal value observed
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_highestValue(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("highestValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximal value observed for the measure since the device was started.
- * Can be reset to an arbitrary value thanks to set_highestValue().
- *
- * @return a floating point number corresponding to the maximal value observed for the measure since
- * the device was started
- *
- * On failure, throws an exception or returns Y_HIGHESTVALUE_INVALID.
- */
-double YSensor::get_highestValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::HIGHESTVALUE_INVALID;
-                }
-            }
-        }
-        res = _highestValue * _iresol;
-        res = floor(res+0.5) / _iresol;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a
- * floating point number.
- *
- * @return a floating point number corresponding to the uncalibrated, unrounded raw value returned by
- * the sensor, in the specified unit, as a floating point number
- *
- * On failure, throws an exception or returns Y_CURRENTRAWVALUE_INVALID.
- */
-double YSensor::get_currentRawValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::CURRENTRAWVALUE_INVALID;
-                }
-            }
-        }
-        res = _currentRawValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the datalogger recording frequency for this function, or "OFF"
- * when measures are not stored in the data logger flash memory.
- *
- * @return a string corresponding to the datalogger recording frequency for this function, or "OFF"
- *         when measures are not stored in the data logger flash memory
- *
- * On failure, throws an exception or returns Y_LOGFREQUENCY_INVALID.
- */
-string YSensor::get_logFrequency(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::LOGFREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _logFrequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the datalogger recording frequency for this function.
- * The frequency can be specified as samples per second,
- * as sample per minute (for instance "15/m") or in samples per
- * hour (eg. "4/h"). To disable recording for this function, use
- * the value "OFF". Note that setting the  datalogger recording frequency
- * to a greater value than the sensor native sampling frequency is unless,
- * and even counterproductive: those two frequencies are not related.
- *
- * @param newval : a string corresponding to the datalogger recording frequency for this function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_logFrequency(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("logFrequency", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the timed value notification frequency, or "OFF" if timed
- * value notifications are disabled for this function.
- *
- * @return a string corresponding to the timed value notification frequency, or "OFF" if timed
- *         value notifications are disabled for this function
- *
- * On failure, throws an exception or returns Y_REPORTFREQUENCY_INVALID.
- */
-string YSensor::get_reportFrequency(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::REPORTFREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _reportFrequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the timed value notification frequency for this function.
- * The frequency can be specified as samples per second,
- * as sample per minute (for instance "15/m") or in samples per
- * hour (e.g. "4/h"). To disable timed value notifications for this
- * function, use the value "OFF". Note that setting the  timed value
- * notification frequency to a greater value than the sensor native
- * sampling frequency is unless, and even counterproductive: those two
- * frequencies are not related.
- *
- * @param newval : a string corresponding to the timed value notification frequency for this function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_reportFrequency(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("reportFrequency", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measuring mode used for the advertised value pushed to the parent hub.
- *
- * @return a value among Y_ADVMODE_IMMEDIATE, Y_ADVMODE_PERIOD_AVG, Y_ADVMODE_PERIOD_MIN and
- * Y_ADVMODE_PERIOD_MAX corresponding to the measuring mode used for the advertised value pushed to the parent hub
- *
- * On failure, throws an exception or returns Y_ADVMODE_INVALID.
- */
-Y_ADVMODE_enum YSensor::get_advMode(void)
-{
-    Y_ADVMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::ADVMODE_INVALID;
-                }
-            }
-        }
-        res = _advMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measuring mode used for the advertised value pushed to the parent hub.
- *
- * @param newval : a value among Y_ADVMODE_IMMEDIATE, Y_ADVMODE_PERIOD_AVG, Y_ADVMODE_PERIOD_MIN and
- * Y_ADVMODE_PERIOD_MAX corresponding to the measuring mode used for the advertised value pushed to the parent hub
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_advMode(Y_ADVMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("advMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YSensor::get_calibrationParam(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::CALIBRATIONPARAM_INVALID;
-                }
-            }
-        }
-        res = _calibrationParam;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YSensor::set_calibrationParam(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("calibrationParam", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision
- * when displaying value. It does not change the precision of the measure itself.
- *
- * @param newval : a floating point number corresponding to the resolution of the measured physical values
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::set_resolution(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("resolution", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the resolution of the measured values. The resolution corresponds to the numerical precision
- * of the measures, which is not always the same as the actual precision of the sensor.
- *
- * @return a floating point number corresponding to the resolution of the measured values
- *
- * On failure, throws an exception or returns Y_RESOLUTION_INVALID.
- */
-double YSensor::get_resolution(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::RESOLUTION_INVALID;
-                }
-            }
-        }
-        res = _resolution;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the sensor health state code, which is zero when there is an up-to-date measure
- * available or a positive code if the sensor is not able to provide a measure right now.
- *
- * @return an integer corresponding to the sensor health state code, which is zero when there is an
- * up-to-date measure
- *         available or a positive code if the sensor is not able to provide a measure right now
- *
- * On failure, throws an exception or returns Y_SENSORSTATE_INVALID.
- */
-int YSensor::get_sensorState(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSensor::SENSORSTATE_INVALID;
-                }
-            }
-        }
-        res = _sensorState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSensor.isOnline() to test if the sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the sensor
- *
- * @return a YSensor object allowing you to drive the sensor.
- */
-YSensor* YSensor::FindSensor(string func)
-{
-    YSensor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YSensor*) YFunction::_FindFromCache("Sensor", func);
-        if (obj == NULL) {
-            obj = new YSensor(func);
-            YFunction::_AddToCache("Sensor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YSensor::registerValueCallback(YSensorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackSensor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YSensor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackSensor != NULL) {
-        _valueCallbackSensor(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YSensor::_parserHelper(void)
-{
-    int position = 0;
-    int maxpos = 0;
-    vector<int> iCalib;
-    int iRaw = 0;
-    int iRef = 0;
-    double fRaw = 0.0;
-    double fRef = 0.0;
-    _caltyp = -1;
-    _scale = -1;
-    _calpar.clear();
-    _calraw.clear();
-    _calref.clear();
-    // Store inverted resolution, to provide better rounding
-    if (_resolution > 0) {
-        _iresol = floor(1.0 / _resolution+0.5);
-    } else {
-        _iresol = 10000;
-        _resolution = 0.0001;
-    }
-    // Old format: supported when there is no calibration
-    if (_calibrationParam == "" || _calibrationParam == "0") {
-        _caltyp = 0;
-        return 0;
-    }
-    if (_ystrpos(_calibrationParam, ",") >= 0) {
-        // Plain text format
-        iCalib = YAPI::_decodeFloats(_calibrationParam);
-        _caltyp = ((iCalib[0]) / (1000));
-        if (_caltyp > 0) {
-            if (_caltyp < YOCTO_CALIB_TYPE_OFS) {
-                // Unknown calibration type: calibrated value will be provided by the device
-                _caltyp = -1;
-                return 0;
-            }
-            _calhdl = YAPI::_getCalibrationHandler(_caltyp);
-            if (!(_calhdl != NULL)) {
-                // Unknown calibration type: calibrated value will be provided by the device
-                _caltyp = -1;
-                return 0;
-            }
-        }
-        // New 32 bits text format
-        _offset = 0;
-        _scale = 1000;
-        maxpos = (int)iCalib.size();
-        _calpar.clear();
-        position = 1;
-        while (position < maxpos) {
-            _calpar.push_back(iCalib[position]);
-            position = position + 1;
-        }
-        _calraw.clear();
-        _calref.clear();
-        position = 1;
-        while (position + 1 < maxpos) {
-            fRaw = iCalib[position];
-            fRaw = fRaw / 1000.0;
-            fRef = iCalib[position + 1];
-            fRef = fRef / 1000.0;
-            _calraw.push_back(fRaw);
-            _calref.push_back(fRef);
-            position = position + 2;
-        }
-    } else {
-        // Recorder-encoded format, including encoding
-        iCalib = YAPI::_decodeWords(_calibrationParam);
-        // In case of unknown format, calibrated value will be provided by the device
-        if ((int)iCalib.size() < 2) {
-            _caltyp = -1;
-            return 0;
-        }
-        // Save variable format (scale for scalar, or decimal exponent)
-        _offset = 0;
-        _scale = 1;
-        _decexp = 1.0;
-        position = iCalib[0];
-        while (position > 0) {
-            _decexp = _decexp * 10;
-            position = position - 1;
-        }
-        // Shortcut when there is no calibration parameter
-        if ((int)iCalib.size() == 2) {
-            _caltyp = 0;
-            return 0;
-        }
-        _caltyp = iCalib[2];
-        _calhdl = YAPI::_getCalibrationHandler(_caltyp);
-        // parse calibration points
-        if (_caltyp <= 10) {
-            maxpos = _caltyp;
-        } else {
-            if (_caltyp <= 20) {
-                maxpos = _caltyp - 10;
-            } else {
-                maxpos = 5;
-            }
-        }
-        maxpos = 3 + 2 * maxpos;
-        if (maxpos > (int)iCalib.size()) {
-            maxpos = (int)iCalib.size();
-        }
-        _calpar.clear();
-        _calraw.clear();
-        _calref.clear();
-        position = 3;
-        while (position + 1 < maxpos) {
-            iRaw = iCalib[position];
-            iRef = iCalib[position + 1];
-            _calpar.push_back(iRaw);
-            _calpar.push_back(iRef);
-            _calraw.push_back(YAPI::_decimalToDouble(iRaw));
-            _calref.push_back(YAPI::_decimalToDouble(iRef));
-            position = position + 2;
-        }
-    }
-    return 0;
-}
-
-/**
- * Checks if the sensor is currently able to provide an up-to-date measure.
- * Returns false if the device is unreachable, or if the sensor does not have
- * a current measure to transmit. No exception is raised if there is an error
- * while trying to contact the device hosting $THEFUNCTION$.
- *
- * @return true if the sensor can provide an up-to-date measure, and false otherwise
- */
-bool YSensor::isSensorReady(void)
-{
-    if (!(this->isOnline())) {
-        return false;
-    }
-    if (!(_sensorState == 0)) {
-        return false;
-    }
-    return true;
-}
-
-/**
- * Returns the YDatalogger object of the device hosting the sensor. This method returns an object of
- * class YDatalogger that can control global parameters of the data logger. The returned object
- * should not be freed.
- *
- * @return an YDataLogger object or NULL on error.
- */
-YDataLogger* YSensor::get_dataLogger(void)
-{
-    YDataLogger* logger = NULL;
-    YModule* modu = NULL;
-    string serial;
-    string hwid;
-
-    modu = this->get_module();
-    serial = modu->get_serialNumber();
-    if (serial == YAPI_INVALID_STRING) {
-        return NULL;
-    }
-    hwid = serial + ".dataLogger";
-    logger = YDataLogger::FindDataLogger(hwid);
-    return logger;
-}
-
-/**
- * Starts the data logger on the device. Note that the data logger
- * will only save the measures on this sensor if the logFrequency
- * is not set to "OFF".
- *
- * @return YAPI_SUCCESS if the call succeeds.
- */
-int YSensor::startDataLogger(void)
-{
-    string res;
-
-    res = this->_download("api/dataLogger/recording?recording=1");
-    if (!((int)(res).size()>0)) {
-        _throw(YAPI_IO_ERROR,"unable to start datalogger");
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Stops the datalogger on the device.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- */
-int YSensor::stopDataLogger(void)
-{
-    string res;
-
-    res = this->_download("api/dataLogger/recording?recording=0");
-    if (!((int)(res).size()>0)) {
-        _throw(YAPI_IO_ERROR,"unable to stop datalogger");
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Retrieves a DataSet object holding historical data for this
- * sensor, for a specified time interval. The measures will be
- * retrieved from the data logger, which must have been turned
- * on at the desired time. See the documentation of the DataSet
- * class for information on how to get an overview of the
- * recorded data, and how to load progressively a large set
- * of measures from the data logger.
- *
- * This function only works if the device uses a recent firmware,
- * as DataSet objects are not supported by firmwares older than
- * version 13000.
- *
- * @param startTime : the start of the desired measure time interval,
- *         as a Unix timestamp, i.e. the number of seconds since
- *         January 1, 1970 UTC. The special value 0 can be used
- *         to include any measure, without initial limit.
- * @param endTime : the end of the desired measure time interval,
- *         as a Unix timestamp, i.e. the number of seconds since
- *         January 1, 1970 UTC. The special value 0 can be used
- *         to include any measure, without ending limit.
- *
- * @return an instance of YDataSet, providing access to historical
- *         data. Past measures can be loaded progressively
- *         using methods from the YDataSet object.
- */
-YDataSet YSensor::get_recordedData(double startTime,double endTime)
-{
-    string funcid;
-    string funit;
-
-    funcid = this->get_functionId();
-    funit = this->get_unit();
-    return YDataSet(this,funcid,funit,startTime,endTime);
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YSensor::registerTimedReportCallback(YSensorTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackSensor = callback;
-    return 0;
-}
-
-int YSensor::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackSensor != NULL) {
-        _timedReportCallbackSensor(this, value);
-    } else {
-    }
-    return 0;
-}
-
-/**
- * Configures error correction data points, in particular to compensate for
- * a possible perturbation of the measure caused by an enclosure. It is possible
- * to configure up to five correction points. Correction points must be provided
- * in ascending order, and be in the range of the sensor. The device will automatically
- * perform a linear interpolation of the error correction between specified
- * points. Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * For more information on advanced capabilities to refine the calibration of
- * sensors, please contact support@yoctopuce.com.
- *
- * @param rawValues : array of floating point numbers, corresponding to the raw
- *         values returned by the sensor for the correction points.
- * @param refValues : array of floating point numbers, corresponding to the corrected
- *         values for the correction points.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::calibrateFromPoints(vector<double> rawValues,vector<double> refValues)
-{
-    string rest_val;
-    int res = 0;
-
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = this->_encodeCalibrationPoints(rawValues, refValues);
-        res = this->_setAttr("calibrationParam", rest_val);
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves error correction data points previously entered using the method
- * calibrateFromPoints.
- *
- * @param rawValues : array of floating point numbers, that will be filled by the
- *         function with the raw sensor values for the correction points.
- * @param refValues : array of floating point numbers, that will be filled by the
- *         function with the desired values for the correction points.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSensor::loadCalibrationPoints(vector<double>& rawValues,vector<double>& refValues)
-{
-    rawValues.clear();
-    refValues.clear();
-    // Load function parameters if not yet loaded
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_scale == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAPI_DEVICE_NOT_FOUND;
-                }
-            }
-        }
-        if (_caltyp < 0) {
-            this->_throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
-            {
-                yLeaveCriticalSection(&_this_cs);
-                return YAPI_NOT_SUPPORTED;
-            }
-        }
-        rawValues.clear();
-        refValues.clear();
-        for (unsigned ii = 0; ii < _calraw.size(); ii++) {
-            rawValues.push_back(_calraw[ii]);
-        }
-        for (unsigned ii = 0; ii < _calref.size(); ii++) {
-            refValues.push_back(_calref[ii]);
-        }
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return YAPI_SUCCESS;
-}
-
-string YSensor::_encodeCalibrationPoints(vector<double> rawValues,vector<double> refValues)
-{
-    string res;
-    int npt = 0;
-    int idx = 0;
-    npt = (int)rawValues.size();
-    if (npt != (int)refValues.size()) {
-        this->_throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
-        return YAPI_INVALID_STRING;
-    }
-    // Shortcut when building empty calibration parameters
-    if (npt == 0) {
-        return "0";
-    }
-    // Load function parameters if not yet loaded
-    if (_scale == 0) {
-        if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-            return YAPI_INVALID_STRING;
-        }
-    }
-    // Detect old firmware
-    if ((_caltyp < 0) || (_scale < 0)) {
-        this->_throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
-        return "0";
-    }
-    // 32-bit fixed-point encoding
-    res = YapiWrapper::ysprintf("%d",YOCTO_CALIB_TYPE_OFS);
-    idx = 0;
-    while (idx < npt) {
-        res = YapiWrapper::ysprintf("%s,%g,%g", res.c_str(), rawValues[idx],refValues[idx]);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-double YSensor::_applyCalibration(double rawValue)
-{
-    if (rawValue == Y_CURRENTVALUE_INVALID) {
-        return Y_CURRENTVALUE_INVALID;
-    }
-    if (_caltyp == 0) {
-        return rawValue;
-    }
-    if (_caltyp < 0) {
-        return Y_CURRENTVALUE_INVALID;
-    }
-    if (!(_calhdl != NULL)) {
-        return Y_CURRENTVALUE_INVALID;
-    }
-    return _calhdl(rawValue, _caltyp, _calpar, _calraw, _calref);
-}
-
-YMeasure YSensor::_decodeTimedReport(double timestamp,double duration,vector<int> report)
-{
-    int i = 0;
-    int byteVal = 0;
-    double poww = 0.0;
-    double minRaw = 0.0;
-    double avgRaw = 0.0;
-    double maxRaw = 0.0;
-    int sublen = 0;
-    double difRaw = 0.0;
-    double startTime = 0.0;
-    double endTime = 0.0;
-    double minVal = 0.0;
-    double avgVal = 0.0;
-    double maxVal = 0.0;
-    if (duration > 0) {
-        startTime = timestamp - duration;
-    } else {
-        startTime = _prevTimedReport;
-    }
-    endTime = timestamp;
-    _prevTimedReport = endTime;
-    if (startTime == 0) {
-        startTime = endTime;
-    }
-    // 32 bits timed report format
-    if ((int)report.size() <= 5) {
-        // sub-second report, 1-4 bytes
-        poww = 1;
-        avgRaw = 0;
-        byteVal = 0;
-        i = 1;
-        while (i < (int)report.size()) {
-            byteVal = report[i];
-            avgRaw = avgRaw + poww * byteVal;
-            poww = poww * 0x100;
-            i = i + 1;
-        }
-        if (((byteVal) & (0x80)) != 0) {
-            avgRaw = avgRaw - poww;
-        }
-        avgVal = avgRaw / 1000.0;
-        if (_caltyp != 0) {
-            if (_calhdl != NULL) {
-                avgVal = _calhdl(avgVal, _caltyp, _calpar, _calraw, _calref);
-            }
-        }
-        minVal = avgVal;
-        maxVal = avgVal;
-    } else {
-        // averaged report: avg,avg-min,max-avg
-        sublen = 1 + ((report[1]) & (3));
-        poww = 1;
-        avgRaw = 0;
-        byteVal = 0;
-        i = 2;
-        while ((sublen > 0) && (i < (int)report.size())) {
-            byteVal = report[i];
-            avgRaw = avgRaw + poww * byteVal;
-            poww = poww * 0x100;
-            i = i + 1;
-            sublen = sublen - 1;
-        }
-        if (((byteVal) & (0x80)) != 0) {
-            avgRaw = avgRaw - poww;
-        }
-        sublen = 1 + ((((report[1]) >> (2))) & (3));
-        poww = 1;
-        difRaw = 0;
-        while ((sublen > 0) && (i < (int)report.size())) {
-            byteVal = report[i];
-            difRaw = difRaw + poww * byteVal;
-            poww = poww * 0x100;
-            i = i + 1;
-            sublen = sublen - 1;
-        }
-        minRaw = avgRaw - difRaw;
-        sublen = 1 + ((((report[1]) >> (4))) & (3));
-        poww = 1;
-        difRaw = 0;
-        while ((sublen > 0) && (i < (int)report.size())) {
-            byteVal = report[i];
-            difRaw = difRaw + poww * byteVal;
-            poww = poww * 0x100;
-            i = i + 1;
-            sublen = sublen - 1;
-        }
-        maxRaw = avgRaw + difRaw;
-        avgVal = avgRaw / 1000.0;
-        minVal = minRaw / 1000.0;
-        maxVal = maxRaw / 1000.0;
-        if (_caltyp != 0) {
-            if (_calhdl != NULL) {
-                avgVal = _calhdl(avgVal, _caltyp, _calpar, _calraw, _calref);
-                minVal = _calhdl(minVal, _caltyp, _calpar, _calraw, _calref);
-                maxVal = _calhdl(maxVal, _caltyp, _calpar, _calraw, _calref);
-            }
-        }
-    }
-    return YMeasure( startTime, endTime, minVal, avgVal,maxVal);
-}
-
-double YSensor::_decodeVal(int w)
-{
-    double val = 0.0;
-    val = w;
-    if (_caltyp != 0) {
-        if (_calhdl != NULL) {
-            val = _calhdl(val, _caltyp, _calpar, _calraw, _calref);
-        }
-    }
-    return val;
-}
-
-double YSensor::_decodeAvg(int dw)
-{
-    double val = 0.0;
-    val = dw;
-    if (_caltyp != 0) {
-        if (_calhdl != NULL) {
-            val = _calhdl(val, _caltyp, _calpar, _calraw, _calref);
-        }
-    }
-    return val;
-}
-
-YSensor *YSensor::nextSensor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YSensor::FindSensor(hwid);
-}
-
-YSensor* YSensor::FirstSensor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Sensor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YSensor::FindSensor(serial+"."+funcId);
-}
-
-//--- (end of generated code: YSensor implementation)
-
-YDataSet YSensor::get_recordedData(s64 startTime, s64 endTime)
-{
-    return this->get_recordedData((double)startTime, (double)endTime);
-}
-
-YDataSet YSensor::get_recordedData(int startTime, int endTime)
-{
-    return this->get_recordedData((double)startTime, (double)endTime);
-}
-
-//--- (generated code: YSensor functions)
-//--- (end of generated code: YSensor functions)
-
-
-// DataLogger-specific method to retrieve and pre-parse recorded data
-//
-int YDataLogger::getData(unsigned runIdx, unsigned timeIdx, string& buffer, yJsonStateMachine& j)
-{
-    YDevice* dev;
-    char query[128];
-    string errmsg;
-    int res;
-
-    if (this->dataLoggerURL == "") this->dataLoggerURL = "/logger.json";
-
-    // Resolve our reference to our device, load REST API
-    res = _getDevice(dev, errmsg);
-    if (YISERR(res)) {
-        _throw((YRETCODE)res, errmsg);
-        return (YRETCODE)res;
-    }
-    if (timeIdx) {
-        // used by old datalogger only
-        sprintf(query, "GET %s?run=%u&time=%u \r\n\r\n", this->dataLoggerURL.c_str(), runIdx, timeIdx);
-    } else {
-        sprintf(query, "GET %s \r\n\r\n", this->dataLoggerURL.c_str());
-    }
-    res = dev->HTTPRequest(0, query, buffer, NULL, NULL, errmsg);
-    if (YISERR(res)) {
-        // Check if an update of the device list does not solve the issue
-        res = YAPI::UpdateDeviceList(errmsg);
-        if (YISERR(res)) {
-            _throw((YRETCODE)res, errmsg);
-            return (YRETCODE)res;
-        }
-        res = dev->HTTPRequest(0, query, buffer, NULL, NULL, errmsg);
-        if (YISERR(res)) {
-            _throw((YRETCODE)res, errmsg);
-            return (YRETCODE)res;
-        }
-    }
-
-    // Parse HTTP header
-    j.src = buffer.data();
-    j.end = j.src + buffer.size();
-    j.st = YJSON_HTTP_START;
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_CODE) {
-        _throw(YAPI_IO_ERROR, "Failed to parse HTTP header");
-        return YAPI_IO_ERROR;
-    }
-    if (string(j.token) != "200") {
-        _throw(YAPI_IO_ERROR, string("Unexpected HTTP return code: ") + j.token);
-        return YAPI_IO_ERROR;
-    }
-    if (yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_HTTP_READ_MSG) {
-        _throw(YAPI_IO_ERROR, "Unexpected HTTP header format");
-        return YAPI_IO_ERROR;
-    }
-
-    return YAPI_SUCCESS;
-}
-
-
-YDataLogger::YDataLogger(const string& func): YFunction(func)
-                                              //--- (generated code: YDataLogger initialization)
-    ,_currentRunIndex(CURRENTRUNINDEX_INVALID)
-    ,_timeUTC(TIMEUTC_INVALID)
-    ,_recording(RECORDING_INVALID)
-    ,_autoStart(AUTOSTART_INVALID)
-    ,_beaconDriven(BEACONDRIVEN_INVALID)
-    ,_usage(USAGE_INVALID)
-    ,_clearHistory(CLEARHISTORY_INVALID)
-    ,_valueCallbackDataLogger(NULL)
-//--- (end of generated code: YDataLogger initialization)
-{
-    _className = "DataLogger";
-}
-
-YDataLogger::~YDataLogger()
-{
-    //--- (generated code: YDataLogger cleanup)
-//--- (end of generated code: YDataLogger cleanup)
-}
-
-
-//--- (generated code: YDataLogger implementation)
-// static attributes
-
-int YDataLogger::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("currentRunIndex")) {
-        _currentRunIndex =  json_val->getInt("currentRunIndex");
-    }
-    if(json_val->has("timeUTC")) {
-        _timeUTC =  json_val->getLong("timeUTC");
-    }
-    if(json_val->has("recording")) {
-        _recording =  (Y_RECORDING_enum)json_val->getInt("recording");
-    }
-    if(json_val->has("autoStart")) {
-        _autoStart =  (Y_AUTOSTART_enum)json_val->getInt("autoStart");
-    }
-    if(json_val->has("beaconDriven")) {
-        _beaconDriven =  (Y_BEACONDRIVEN_enum)json_val->getInt("beaconDriven");
-    }
-    if(json_val->has("usage")) {
-        _usage =  json_val->getInt("usage");
-    }
-    if(json_val->has("clearHistory")) {
-        _clearHistory =  (Y_CLEARHISTORY_enum)json_val->getInt("clearHistory");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current run number, corresponding to the number of times the module was
- * powered on with the dataLogger enabled at some point.
- *
- * @return an integer corresponding to the current run number, corresponding to the number of times the module was
- *         powered on with the dataLogger enabled at some point
- *
- * On failure, throws an exception or returns Y_CURRENTRUNINDEX_INVALID.
- */
-int YDataLogger::get_currentRunIndex(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::CURRENTRUNINDEX_INVALID;
-                }
-            }
-        }
-        res = _currentRunIndex;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Unix timestamp for current UTC time, if known.
- *
- * @return an integer corresponding to the Unix timestamp for current UTC time, if known
- *
- * On failure, throws an exception or returns Y_TIMEUTC_INVALID.
- */
-s64 YDataLogger::get_timeUTC(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::TIMEUTC_INVALID;
-                }
-            }
-        }
-        res = _timeUTC;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current UTC time reference used for recorded data.
- *
- * @param newval : an integer corresponding to the current UTC time reference used for recorded data
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataLogger::set_timeUTC(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("timeUTC", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current activation state of the data logger.
- *
- * @return a value among Y_RECORDING_OFF, Y_RECORDING_ON and Y_RECORDING_PENDING corresponding to the
- * current activation state of the data logger
- *
- * On failure, throws an exception or returns Y_RECORDING_INVALID.
- */
-Y_RECORDING_enum YDataLogger::get_recording(void)
-{
-    Y_RECORDING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::RECORDING_INVALID;
-                }
-            }
-        }
-        res = _recording;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the activation state of the data logger to start/stop recording data.
- *
- * @param newval : a value among Y_RECORDING_OFF, Y_RECORDING_ON and Y_RECORDING_PENDING corresponding
- * to the activation state of the data logger to start/stop recording data
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataLogger::set_recording(Y_RECORDING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("recording", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the default activation state of the data logger on power up.
- *
- * @return either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the default activation state of the
- * data logger on power up
- *
- * On failure, throws an exception or returns Y_AUTOSTART_INVALID.
- */
-Y_AUTOSTART_enum YDataLogger::get_autoStart(void)
-{
-    Y_AUTOSTART_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::AUTOSTART_INVALID;
-                }
-            }
-        }
-        res = _autoStart;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the default activation state of the data logger on power up.
- * Do not forget to call the saveToFlash() method of the module to save the
- * configuration change.  Note: if the device doesn't have any time source at his disposal when
- * starting up, it will wait for ~8 seconds before automatically starting to record  with
- * an arbitrary timestamp
- *
- * @param newval : either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the default activation state
- * of the data logger on power up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataLogger::set_autoStart(Y_AUTOSTART_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("autoStart", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true if the data logger is synchronised with the localization beacon.
- *
- * @return either Y_BEACONDRIVEN_OFF or Y_BEACONDRIVEN_ON, according to true if the data logger is
- * synchronised with the localization beacon
- *
- * On failure, throws an exception or returns Y_BEACONDRIVEN_INVALID.
- */
-Y_BEACONDRIVEN_enum YDataLogger::get_beaconDriven(void)
-{
-    Y_BEACONDRIVEN_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::BEACONDRIVEN_INVALID;
-                }
-            }
-        }
-        res = _beaconDriven;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the type of synchronisation of the data logger.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : either Y_BEACONDRIVEN_OFF or Y_BEACONDRIVEN_ON, according to the type of
- * synchronisation of the data logger
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataLogger::set_beaconDriven(Y_BEACONDRIVEN_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("beaconDriven", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the percentage of datalogger memory in use.
- *
- * @return an integer corresponding to the percentage of datalogger memory in use
- *
- * On failure, throws an exception or returns Y_USAGE_INVALID.
- */
-int YDataLogger::get_usage(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::USAGE_INVALID;
-                }
-            }
-        }
-        res = _usage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_CLEARHISTORY_enum YDataLogger::get_clearHistory(void)
-{
-    Y_CLEARHISTORY_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDataLogger::CLEARHISTORY_INVALID;
-                }
-            }
-        }
-        res = _clearHistory;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YDataLogger::set_clearHistory(Y_CLEARHISTORY_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("clearHistory", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a data logger for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the data logger is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDataLogger.isOnline() to test if the data logger is
- * indeed online at a given time. In case of ambiguity when looking for
- * a data logger by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the data logger
- *
- * @return a YDataLogger object allowing you to drive the data logger.
- */
-YDataLogger* YDataLogger::FindDataLogger(string func)
-{
-    YDataLogger* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YDataLogger*) YFunction::_FindFromCache("DataLogger", func);
-        if (obj == NULL) {
-            obj = new YDataLogger(func);
-            YFunction::_AddToCache("DataLogger", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YDataLogger::registerValueCallback(YDataLoggerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackDataLogger = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YDataLogger::_invokeValueCallback(string value)
-{
-    if (_valueCallbackDataLogger != NULL) {
-        _valueCallbackDataLogger(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Clears the data logger memory and discards all recorded data streams.
- * This method also resets the current run index to zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDataLogger::forgetAllDataStreams(void)
-{
-    return this->set_clearHistory(Y_CLEARHISTORY_TRUE);
-}
-
-/**
- * Returns a list of YDataSet objects that can be used to retrieve
- * all measures stored by the data logger.
- *
- * This function only works if the device uses a recent firmware,
- * as YDataSet objects are not supported by firmwares older than
- * version 13000.
- *
- * @return a list of YDataSet object.
- *
- * On failure, throws an exception or returns an empty list.
- */
-vector<YDataSet> YDataLogger::get_dataSets(void)
-{
-    return this->parse_dataSets(this->_download("logger.json"));
-}
-
-vector<YDataSet> YDataLogger::parse_dataSets(string json)
-{
-    vector<string> dslist;
-    YDataSet* dataset = NULL;
-    vector<YDataSet> res;
-
-    dslist = this->_json_get_array(json);
-    res.clear();
-    for (unsigned ii = 0; ii < dslist.size(); ii++) {
-        dataset = new YDataSet(this);
-        dataset->_parse(dslist[ii]);
-        res.push_back(*dataset);
-    }
-    return res;
-}
-
-YDataLogger *YDataLogger::nextDataLogger(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YDataLogger::FindDataLogger(hwid);
-}
-
-YDataLogger* YDataLogger::FirstDataLogger(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("DataLogger", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YDataLogger::FindDataLogger(serial+"."+funcId);
-}
-
-//--- (end of generated code: YDataLogger implementation)
-
-//--- (generated code: YDataLogger functions)
-//--- (end of generated code: YDataLogger functions)
--- a/Sources/cpplib/yocto_api.h
+++ /dev/null
@@ -1,4187 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_api.h 33821 2018-12-21 13:57:06Z seb $
- *
- * High-level programming interface, common to all modules
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YOCTO_API_H
-#define YOCTO_API_H
-
-#include "yapi/ydef.h"
-#include "yapi/yjson.h"
-#include <string>
-#include <vector>
-#include <queue>
-#include <map>
-#include <stdexcept>
-#include <cfloat>
-#include <cmath>
-
-#if defined(WINDOWS_API)
-#if defined(GENERATE_DLL) || defined(YOCTOPUCEDLL_EXPORTS)
-#define YOCTO_CLASS_EXPORT __declspec(dllexport)
-#pragma warning(disable: 4251)
-#else
-#define YOCTO_CLASS_EXPORT
-#endif
-#else
-#define YOCTO_CLASS_EXPORT
-#endif
-
-using std::string;
-using std::vector;
-using std::queue;
-using std::map;
-
-#define YAPI_INVALID_STRING         "!INVALID!"
-#define YAPI_INVALID_INT            (0x7FFFFFFF)
-#define YAPI_INVALID_UINT           (-1)
-#define YAPI_INVALID_LONG           (0x7FFFFFFFFFFFFFFFLL)
-#define YAPI_INVALID_DOUBLE         (-DBL_MAX)
-#define YAPI_MIN_DOUBLE             (-DBL_MAX)
-#define YAPI_MAX_DOUBLE             DBL_MAX
-
-
-//--- (generated code: YFunction definitions)
-class YFunction; // forward declaration
-
-typedef void (*YFunctionValueCallback)(YFunction *func, const string& functionValue);
-#define Y_LOGICALNAME_INVALID           (YAPI_INVALID_STRING)
-#define Y_ADVERTISEDVALUE_INVALID       (YAPI_INVALID_STRING)
-//--- (end of generated code: YFunction definitions)
-
-
-
-//--- (generated code: YModule definitions)
-class YModule; // forward declaration
-
-typedef void (*YModuleLogCallback)(YModule *module, const string& logline);
-typedef void (*YModuleConfigChangeCallback)(YModule *module);
-typedef void (*YModuleValueCallback)(YModule *func, const string& functionValue);
-#ifndef _Y_PERSISTENTSETTINGS_ENUM
-#define _Y_PERSISTENTSETTINGS_ENUM
-typedef enum {
-    Y_PERSISTENTSETTINGS_LOADED = 0,
-    Y_PERSISTENTSETTINGS_SAVED = 1,
-    Y_PERSISTENTSETTINGS_MODIFIED = 2,
-    Y_PERSISTENTSETTINGS_INVALID = -1,
-} Y_PERSISTENTSETTINGS_enum;
-#endif
-#ifndef _Y_BEACON_ENUM
-#define _Y_BEACON_ENUM
-typedef enum {
-    Y_BEACON_OFF = 0,
-    Y_BEACON_ON = 1,
-    Y_BEACON_INVALID = -1,
-} Y_BEACON_enum;
-#endif
-#define Y_PRODUCTNAME_INVALID           (YAPI_INVALID_STRING)
-#define Y_SERIALNUMBER_INVALID          (YAPI_INVALID_STRING)
-#define Y_PRODUCTID_INVALID             (YAPI_INVALID_UINT)
-#define Y_PRODUCTRELEASE_INVALID        (YAPI_INVALID_UINT)
-#define Y_FIRMWARERELEASE_INVALID       (YAPI_INVALID_STRING)
-#define Y_LUMINOSITY_INVALID            (YAPI_INVALID_UINT)
-#define Y_UPTIME_INVALID                (YAPI_INVALID_LONG)
-#define Y_USBCURRENT_INVALID            (YAPI_INVALID_UINT)
-#define Y_REBOOTCOUNTDOWN_INVALID       (YAPI_INVALID_INT)
-#define Y_USERVAR_INVALID               (YAPI_INVALID_INT)
-typedef void (*YModuleBeaconCallback)(YModule *module, int beacon);
-//--- (end of generated code: YModule definitions)
-
-class YMeasure; // forward declaration
-//--- (generated code: YSensor definitions)
-class YSensor; // forward declaration
-
-typedef void (*YSensorValueCallback)(YSensor *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YSensorTimedReportCallback)(YSensor *func, YMeasure measure);
-#ifndef _Y_ADVMODE_ENUM
-#define _Y_ADVMODE_ENUM
-typedef enum {
-    Y_ADVMODE_IMMEDIATE = 0,
-    Y_ADVMODE_PERIOD_AVG = 1,
-    Y_ADVMODE_PERIOD_MIN = 2,
-    Y_ADVMODE_PERIOD_MAX = 3,
-    Y_ADVMODE_INVALID = -1,
-} Y_ADVMODE_enum;
-#endif
-#define Y_UNIT_INVALID                  (YAPI_INVALID_STRING)
-#define Y_CURRENTVALUE_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_LOWESTVALUE_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_HIGHESTVALUE_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_CURRENTRAWVALUE_INVALID       (YAPI_INVALID_DOUBLE)
-#define Y_LOGFREQUENCY_INVALID          (YAPI_INVALID_STRING)
-#define Y_REPORTFREQUENCY_INVALID       (YAPI_INVALID_STRING)
-#define Y_CALIBRATIONPARAM_INVALID      (YAPI_INVALID_STRING)
-#define Y_RESOLUTION_INVALID            (YAPI_INVALID_DOUBLE)
-#define Y_SENSORSTATE_INVALID           (YAPI_INVALID_INT)
-//--- (end of generated code: YSensor definitions)
-
-
-//--- (generated code: YDataStream definitions)
-//--- (end of generated code: YDataStream definitions)
-
-//--- (generated code: YFirmwareUpdate definitions)
-//--- (end of generated code: YFirmwareUpdate definitions)
-
-
-//--- (generated code: YMeasure definitions)
-//--- (end of generated code: YMeasure definitions)
-
-
-//--- (generated code: YDataLogger definitions)
-class YDataLogger; // forward declaration
-
-typedef void (*YDataLoggerValueCallback)(YDataLogger *func, const string& functionValue);
-#ifndef _Y_RECORDING_ENUM
-#define _Y_RECORDING_ENUM
-typedef enum {
-    Y_RECORDING_OFF = 0,
-    Y_RECORDING_ON = 1,
-    Y_RECORDING_PENDING = 2,
-    Y_RECORDING_INVALID = -1,
-} Y_RECORDING_enum;
-#endif
-#ifndef _Y_AUTOSTART_ENUM
-#define _Y_AUTOSTART_ENUM
-typedef enum {
-    Y_AUTOSTART_OFF = 0,
-    Y_AUTOSTART_ON = 1,
-    Y_AUTOSTART_INVALID = -1,
-} Y_AUTOSTART_enum;
-#endif
-#ifndef _Y_BEACONDRIVEN_ENUM
-#define _Y_BEACONDRIVEN_ENUM
-typedef enum {
-    Y_BEACONDRIVEN_OFF = 0,
-    Y_BEACONDRIVEN_ON = 1,
-    Y_BEACONDRIVEN_INVALID = -1,
-} Y_BEACONDRIVEN_enum;
-#endif
-#ifndef _Y_CLEARHISTORY_ENUM
-#define _Y_CLEARHISTORY_ENUM
-typedef enum {
-    Y_CLEARHISTORY_FALSE = 0,
-    Y_CLEARHISTORY_TRUE = 1,
-    Y_CLEARHISTORY_INVALID = -1,
-} Y_CLEARHISTORY_enum;
-#endif
-#define Y_CURRENTRUNINDEX_INVALID       (YAPI_INVALID_UINT)
-#define Y_TIMEUTC_INVALID               (YAPI_INVALID_LONG)
-#define Y_USAGE_INVALID                 (YAPI_INVALID_UINT)
-//--- (end of generated code: YDataLogger definitions)
-
-
-// yInitAPI argument
-const int Y_DETECT_NONE = 0;
-const int Y_DETECT_USB = 1;
-const int Y_DETECT_NET = 2;
-const int Y_RESEND_MISSING_PKT = 4;
-const int Y_DETECT_ALL = (Y_DETECT_USB | Y_DETECT_NET);
-
-// Forward-declaration
-class YDataSet;
-class YFunction;
-
-/// prototype of the log callback
-typedef void (*yLogFunction)(const string& msg);
-
-/// prototype of the device arrival/update/removal callback
-typedef void (*yDeviceUpdateCallback)(YModule *module);
-
-/// prototype of the Hub discoverycallback
-typedef void (*YHubDiscoveryCallback)(const string& serial, const string& url);
-
-
-
-/// prototype of the value calibration handlers
-typedef vector<double>  floatArr;
-typedef vector<int>     intArr;
-typedef double (*yCalibrationHandler)(double rawValue, int calibType, vector<int> params, vector<double> rawValues, vector<double> refValues);
-
-typedef YAPI_DEVICE     YDEV_DESCR;
-typedef YAPI_FUNCTION   YFUN_DESCR;
-#define Y_FUNCTIONDESCRIPTOR_INVALID    (-1)
-#define Y_HARDWAREID_INVALID            (YAPI_INVALID_STRING)
-#define Y_FUNCTIONID_INVALID            (YAPI_INVALID_STRING)
-#define Y_FRIENDLYNAME_INVALID          (YAPI_INVALID_STRING)
-
-#define Y_DATA_INVALID                  (-DBL_MAX)
-#define Y_DURATION_INVALID              (-1)
-
-//
-// Class used to report exceptions within Yocto-API
-// Do not instantiate directly
-//
-class YAPI_Exception : public std::runtime_error {
-public:
-    YRETCODE errorType;
-    explicit YAPI_Exception(YRETCODE errType, string errMsg) : std::runtime_error(errMsg), errorType(errType) { }
-};
-
-typedef enum {
-    YAPI_DEV_ARRIVAL,
-    YAPI_DEV_REMOVAL,
-    YAPI_DEV_CHANGE,
-    YAPI_DEV_LOG,
-    YAPI_HUB_DISCOVER
-} yapiGlobalEventType;
-
-typedef struct{
-	yapiGlobalEventType    type;
-    union{
-        YModule		*module;
-		struct {
-			char serial[YOCTO_SERIAL_LEN];
-			char url[64];
-		};
-    };
-}yapiGlobalEvent;
-
-
-
-typedef enum {
-	YAPI_FUN_UPDATE,
-	YAPI_FUN_VALUE,
-	YAPI_FUN_TIMEDREPORT,
-	YAPI_FUN_REFRESH,
-    YAPI_DEV_CONFCHANGE,
-    YAPI_DEV_BEACON
-} yapiDataEventType;
-
-typedef struct{
-	yapiDataEventType    type;
-	union{
-		struct {
-			YFunction   *fun;
-			char        value[YOCTO_PUBVAL_LEN];
-		};
-		struct {
-			YSensor    *sensor;
-			double      timestamp;
-            double      duration;
-            int         len;
-			int			report[18];
-		};
-        struct {
-            YModule    *module;
-            int         beacon;
-        };
-    };
-}yapiDataEvent;
-
-
-// internal helper function
-s64 yatoi(const char *c);
-int _ystrpos(const string& haystack, const string& needle);
-vector<string> _strsplit(const string& str, char delimiter);
-
-typedef enum {
-    STRING,
-    NUMBER,
-    ARRAY,
-    OBJECT
-} YJSONType;
-
-typedef enum {
-    JSTART,
-    JWAITFORNAME,
-    JWAITFORENDOFNAME,
-    JWAITFORCOLON,
-    JWAITFORDATA,
-    JWAITFORNEXTSTRUCTMEMBER,
-    JWAITFORNEXTARRAYITEM,
-    JWAITFORSTRINGVALUE,
-    JWAITFORSTRINGVALUE_ESC,
-    JWAITFORINTVALUE,
-    JWAITFORBOOLVALUE
-} Tjstate;
-
-class YJSONObject;
-
-class YJSONContent
-{
-    public:
-        string _data;
-        int _data_start;
-        int _data_len;
-        int _data_boundary;
-        YJSONType _type;
-        static YJSONContent* ParseJson(const string& data, int start, int stop);
-        YJSONContent(const string& data, int start, int stop, YJSONType type);
-        YJSONContent(YJSONContent *ref);
-        YJSONContent(YJSONType type);
-        virtual ~YJSONContent();
-        YJSONType getJSONType();
-        virtual int parse()=0;
-        static int SkipGarbage(const string& data, int start, int stop);
-        string FormatError(const string& errmsg, int cur_pos);
-        virtual string toJSON()=0;
-        virtual string toString()=0;
-};
-
-class YJSONArray : public YJSONContent
-{
-        vector<YJSONContent*> _arrayValue;
-    public:
-        YJSONArray(const string& data, int start, int stop);
-        YJSONArray(const string& data);
-        YJSONArray(YJSONArray *ref);
-        YJSONArray();
-        virtual ~YJSONArray();
-        int length();
-        virtual int parse();
-        YJSONObject* getYJSONObject(int i);
-        string getString(int i);
-        YJSONContent* get(int i);
-        YJSONArray* getYJSONArray(int i);
-        int getInt(int i);
-        s64 getLong(int i);
-        void put(const string& flatAttr);
-        virtual string toJSON();
-        virtual string toString();
-};
-
-class YJSONString : public YJSONContent
-{
-        string _stringValue;
-    public:
-        YJSONString(const string& data, int start, int stop);
-        YJSONString(YJSONString *ref);
-        YJSONString();
-
-        virtual ~YJSONString() { }
-
-    virtual int parse();
-        virtual string toJSON();
-        string getString();
-        virtual string toString();
-        void setContent(const string& value);
-};
-
-
-class YJSONNumber : public YJSONContent
-{
-        s64 _intValue;
-        double _doubleValue;
-        bool _isFloat;
-    public:
-        YJSONNumber(const string& data, int start, int stop);
-        YJSONNumber(YJSONNumber *ref);
-
-        virtual ~YJSONNumber()    { }
-
-    virtual int parse();
-        virtual string toJSON();
-        s64 getLong();
-        int getInt();
-        double getDouble();
-        virtual string toString();
-};
-
-
-class YJSONObject : public YJSONContent
-{
-    map<string, YJSONContent*> _parsed;
-    vector<string> _keys;
-    void convert(YJSONObject* reference, YJSONArray* newArray);
-public:
-    YJSONObject(const string& data);
-    YJSONObject(const string& data, int start, int len);
-    YJSONObject(YJSONObject *ref);
-    virtual ~YJSONObject();
-
-    virtual int parse();
-    bool has(const string& key);
-    YJSONObject* getYJSONObject(const string& key);
-    YJSONString* getYJSONString(const string& key);
-    YJSONArray* getYJSONArray(const string& key);
-    vector<string> keys();
-    YJSONNumber* getYJSONNumber(const string& key);
-    string getString(const string& key);
-    int getInt(const string& key);
-    YJSONContent* get(const string& key);
-    s64 getLong(const string& key);
-    double getDouble(const string& key);
-    virtual string toJSON();
-    virtual string toString();
-    void parseWithRef(YJSONObject* reference);
-    string getKeyFromIdx(int i);
-};
-
-
-
-
-
-//
-// YAPI Context
-
-
-//--- (generated code: YAPIContext return codes)
-//--- (end of generated code: YAPIContext return codes)
-//--- (generated code: YAPIContext definitions)
-//--- (end of generated code: YAPIContext definitions)
-
-//--- (generated code: YAPIContext declaration)
-/**
- * YAPIContext Class: Control interface for the firmware update process
- *
- *
- */
-class YOCTO_CLASS_EXPORT YAPIContext {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YAPIContext declaration)
-protected:
-    //--- (generated code: YAPIContext attributes)
-    // Attributes (function value cache)
-    u64             _defaultCacheValidity;
-    //--- (end of generated code: YAPIContext attributes)
-
-public:
-    YAPIContext();
-    ~YAPIContext();
-    //--- (generated code: YAPIContext accessors declaration)
-
-
-    /**
-     * Change the time between each forced enumeration of the YoctoHub used.
-     * By default, the library performs a complete enumeration every 10 seconds.
-     * To reduce network traffic it is possible to increase this delay.
-     * This is particularly useful when a YoctoHub is connected to a GSM network
-     * where the traffic is charged. This setting does not affect modules connected by USB,
-     * nor the operation of arrival/removal callbacks.
-     * Note: This function must be called after yInitAPI.
-     *
-     * @param deviceListValidity : number of seconds between each enumeration.
-     * @noreturn
-     */
-    virtual void        SetDeviceListValidity(int deviceListValidity);
-
-    /**
-     * Returns the time between each forced enumeration of the YoctoHub used.
-     * Note: This function must be called after yInitAPI.
-     *
-     * @return the number of seconds between each enumeration.
-     */
-    virtual int         GetDeviceListValidity(void);
-
-    /**
-     * Change the validity period of the data loaded by the library.
-     * By default, when accessing a module, all the attributes of the
-     * module functions are automatically kept in cache for the standard
-     * duration (5 ms). This method can be used to change this standard duration,
-     * for example in order to reduce network or USB traffic. This parameter
-     * does not affect value change callbacks
-     * Note: This function must be called after yInitAPI.
-     *
-     * @param cacheValidityMs : an integer corresponding to the validity attributed to the
-     *         loaded function parameters, in milliseconds.
-     * @noreturn
-     */
-    virtual void        SetCacheValidity(u64 cacheValidityMs);
-
-    /**
-     * Returns the validity period of the data loaded by the library.
-     * This method returns the cache validity of all attributes
-     * module functions.
-     * Note: This function must be called after yInitAPI .
-     *
-     * @return an integer corresponding to the validity attributed to the
-     *         loaded function parameters, in milliseconds
-     */
-    virtual u64         GetCacheValidity(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YAPIContext accessors declaration)
-};
-
-//--- (generated code: YAPIContext functions declaration)
-//--- (end of generated code: YAPIContext functions declaration)
-
-
-
-
-//
-// This class provides C++-style entry points to lowlevcel functions defined to yapi.h
-// Could be implemented by a singleton, we use static methods insead
-//
-class YOCTO_CLASS_EXPORT YAPI {
-private:
-    static  queue<yapiGlobalEvent>  _plug_events;
-    static  queue<yapiDataEvent>    _data_events;
-    static  YHubDiscoveryCallback   _HubDiscoveryCallback;
-    static  u64                 _nextEnum;
-
-    static  map<int,yCalibrationHandler> _calibHandlers;
-    static  void        _yapiLogFunctionFwd(const char *log, u32 loglen);
-    static  void        _yapiDeviceArrivalCallbackFwd(YDEV_DESCR devdesc);
-    static  void        _yapiDeviceRemovalCallbackFwd(YDEV_DESCR devdesc);
-    static  void        _yapiDeviceChangeCallbackFwd(YDEV_DESCR devdesc);
-    static  void        _yapiBeaconCallbackFwd(YDEV_DESCR devdesc, int beacon);
-    static  void        _yapiDeviceConfigChangeCallbackFwd(YDEV_DESCR devdesc);
-    static  void        _yapiDeviceLogCallbackFwd(YDEV_DESCR devdesc, const char* line);
-    static  void        _yapiFunctionTimedReportCallbackFwd(YAPI_FUNCTION fundesc, double timestamp, const u8 *bytes, u32 len, double duration);
-	static  void        _yapiHubDiscoveryCallbackFwd(const char *serial, const char *url);
-
-public:
-    static  YAPIContext _yapiContext;
-    static  void        _yapiFunctionUpdateCallbackFwd(YFUN_DESCR fundesc, const char *value);
-    static  double      _decimalToDouble(s16 val);
-    static  s16         _doubleToDecimal(double val);
-    static  yCalibrationHandler _getCalibrationHandler(int calibType);
-    static  vector<int> _decodeWords(string s);
-    static  vector<int> _decodeFloats(string sdat);
-    static  string      _bin2HexStr(const string& data);
-    static  string      _hexStr2Bin(const string& str);
-    static  string      _flattenJsonStruct(string jsonbuffer);
-    static  string      _checkFirmware(const string& serial, const string& rev, const string& path);
-
-    static  bool        ExceptionsDisabled;
-    static  const string      INVALID_STRING;
-    static  const int         INVALID_INT = YAPI_INVALID_INT;
-    static  const int         INVALID_UINT = YAPI_INVALID_UINT;
-    static  const double      INVALID_DOUBLE;
-    static  const s64         INVALID_LONG = YAPI_INVALID_LONG;
-    static  bool                _apiInitialized;
-    static  yCRITICAL_SECTION   _global_cs;
-
-    // Callback functions
-    static  yLogFunction            LogFunction;
-    static  yDeviceUpdateCallback   DeviceArrivalCallback;
-    static  yDeviceUpdateCallback   DeviceRemovalCallback;
-    static  yDeviceUpdateCallback   DeviceChangeCallback;
-
-    static const u32 DETECT_NONE        = 0;
-    static const u32 DETECT_USB         = 1;
-    static const u32 DETECT_NET         = 2;
-    static const u32 RESEND_MISSING_PKT = 4;
-    static const u32 DETECT_ALL  = (Y_DETECT_USB | Y_DETECT_NET);
-
-//--- (generated code: YFunction return codes)
-    static const int SUCCESS               = 0;       // everything worked all right
-    static const int NOT_INITIALIZED       = -1;      // call yInitAPI() first !
-    static const int INVALID_ARGUMENT      = -2;      // one of the arguments passed to the function is invalid
-    static const int NOT_SUPPORTED         = -3;      // the operation attempted is (currently) not supported
-    static const int DEVICE_NOT_FOUND      = -4;      // the requested device is not reachable
-    static const int VERSION_MISMATCH      = -5;      // the device firmware is incompatible with this API version
-    static const int DEVICE_BUSY           = -6;      // the device is busy with another task and cannot answer
-    static const int TIMEOUT               = -7;      // the device took too long to provide an answer
-    static const int IO_ERROR              = -8;      // there was an I/O problem while talking to the device
-    static const int NO_MORE_DATA          = -9;      // there is no more data to read from
-    static const int EXHAUSTED             = -10;     // you have run out of a limited resource, check the documentation
-    static const int DOUBLE_ACCES          = -11;     // you have two process that try to access to the same device
-    static const int UNAUTHORIZED          = -12;     // unauthorized access to password-protected device
-    static const int RTC_NOT_READY         = -13;     // real-time clock has not been initialized (or time was lost)
-    static const int FILE_NOT_FOUND        = -14;     // the file is not found
-//--- (end of generated code: YFunction return codes)
-
-
-    /**
-     * Returns the version identifier for the Yoctopuce library in use.
-     * The version is a string in the form "Major.Minor.Build",
-     * for instance "1.01.5535". For languages using an external
-     * DLL (for instance C#, VisualBasic or Delphi), the character string
-     * includes as well the DLL version, for instance
-     * "1.01.5535 (1.01.5439)".
-     *
-     * If you want to verify in your code that the library version is
-     * compatible with the version that you have used during development,
-     * verify that the major number is strictly equal and that the minor
-     * number is greater or equal. The build number is not relevant
-     * with respect to the library compatibility.
-     *
-     * @return a character string describing the library version.
-     */
-    static string GetAPIVersion(void);
-
-
-    /**
-     * Initializes the Yoctopuce programming library explicitly.
-     * It is not strictly needed to call yInitAPI(), as the library is
-     * automatically  initialized when calling yRegisterHub() for the
-     * first time.
-     *
-     * When Y_DETECT_NONE is used as detection mode,
-     * you must explicitly use yRegisterHub() to point the API to the
-     * VirtualHub on which your devices are connected before trying to access them.
-     *
-     * @param mode : an integer corresponding to the type of automatic
-     *         device detection to use. Possible values are
-     *         Y_DETECT_NONE, Y_DETECT_USB, Y_DETECT_NET,
-     *         and Y_DETECT_ALL.
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    InitAPI(int mode, string& errmsg);
-
-    /**
-     * Frees dynamically allocated memory blocks used by the Yoctopuce library.
-     * It is generally not required to call this function, unless you
-     * want to free all dynamically allocated memory blocks in order to
-     * track a memory leak for instance.
-     * You should not call any other library function after calling
-     * yFreeAPI(), or your program will crash.
-     */
-    static  void        FreeAPI(void);
-
-    /**
-     * Disables the use of exceptions to report runtime errors.
-     * When exceptions are disabled, every function returns a specific
-     * error value which depends on its type and which is documented in
-     * this reference manual.
-     */
-    static  void        DisableExceptions(void);
-
-    /**
-     * Re-enables the use of exceptions for runtime error handling.
-     * Be aware than when exceptions are enabled, every function that fails
-     * triggers an exception. If the exception is not caught by the user code,
-     * it  either fires the debugger or aborts (i.e. crash) the program.
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  void        EnableExceptions(void);
-
-    /**
-     * Registers a log callback function. This callback will be called each time
-     * the API have something to say. Quite useful to debug the API.
-     *
-     * @param logfun : a procedure taking a string parameter, or NULL
-     *         to unregister a previously registered  callback.
-     */
-    static  void        RegisterLogFunction(yLogFunction logfun);
-
-    /**
-     * Register a callback function, to be called each time
-     * a device is plugged. This callback will be invoked while yUpdateDeviceList
-     * is running. You will have to call this function on a regular basis.
-     *
-     * @param arrivalCallback : a procedure taking a YModule parameter, or NULL
-     *         to unregister a previously registered  callback.
-     */
-    static  void        RegisterDeviceArrivalCallback(yDeviceUpdateCallback arrivalCallback);
-
-    /**
-     * Register a callback function, to be called each time
-     * a device is unplugged. This callback will be invoked while yUpdateDeviceList
-     * is running. You will have to call this function on a regular basis.
-     *
-     * @param removalCallback : a procedure taking a YModule parameter, or NULL
-     *         to unregister a previously registered  callback.
-     */
-    static  void        RegisterDeviceRemovalCallback(yDeviceUpdateCallback removalCallback);
-
-    /**
-     * Register a callback function, to be called each time an Network Hub send
-     * an SSDP message. The callback has two string parameter, the first one
-     * contain the serial number of the hub and the second contain the URL of the
-     * network hub (this URL can be passed to RegisterHub). This callback will be invoked
-     * while yUpdateDeviceList is running. You will have to call this function on a regular basis.
-     *
-     * @param hubDiscoveryCallback : a procedure taking two string parameter, the serial
-     *         number and the hub URL. Use NULL to unregister a previously registered  callback.
-     */
-    static  void        RegisterHubDiscoveryCallback(YHubDiscoveryCallback hubDiscoveryCallback);
-
-    /**
-     * Force a hub discovery, if a callback as been registered with yRegisterHubDiscoveryCallback it
-     * will be called for each net work hub that will respond to the discovery.
-     *
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-	static  YRETCODE    TriggerHubDiscovery(string& errmsg);
-
-
-    static  void        RegisterDeviceChangeCallback(yDeviceUpdateCallback changeCallback);
-
-    // Register a new value calibration handler for a given calibration type
-    //
-    static void         RegisterCalibrationHandler(int calibrationType, yCalibrationHandler calibrationHandler);
-
-    // Standard value calibration handler (n-point linear error correction)
-    //
-    static double       LinearCalibrationHandler(double rawValue, int calibType, intArr params, floatArr rawValues, floatArr refValues);
-
-    /**
-     * Test if the hub is reachable. This method do not register the hub, it only test if the
-     * hub is usable. The url parameter follow the same convention as the RegisterHub
-     * method. This method is useful to verify the authentication parameters for a hub. It
-     * is possible to force this method to return after mstimeout milliseconds.
-     *
-     * @param url : a string containing either "usb","callback" or the
-     *         root URL of the hub to monitor
-     * @param mstimeout : the number of millisecond available to test the connection.
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure returns a negative error code.
-     */
-    static  YRETCODE    TestHub(const string& url, int mstimeout, string& errmsg);
-    /**
-     * Setup the Yoctopuce library to use modules connected on a given machine. The
-     * parameter will determine how the API will work. Use the following values:
-     *
-     * <b>usb</b>: When the usb keyword is used, the API will work with
-     * devices connected directly to the USB bus. Some programming languages such a JavaScript,
-     * PHP, and Java don't provide direct access to USB hardware, so usb will
-     * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
-     *
-     * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
-     * host with the given IP address or hostname. That host can be a regular computer
-     * running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or
-     * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
-     * computer, use the IP address 127.0.0.1.
-     *
-     * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
-     * This a special mode allowing to take control of Yoctopuce devices
-     * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
-     * need to configure your hub to call your server script on a regular basis.
-     * This mode is currently available for PHP and Node.JS only.
-     *
-     * Be aware that only one application can use direct USB access at a
-     * given time on a machine. Multiple access would cause conflicts
-     * while trying to access the USB modules. In particular, this means
-     * that you must stop the VirtualHub software before starting
-     * an application that uses direct USB access. The workaround
-     * for this limitation is to setup the library to use the VirtualHub
-     * rather than direct USB access.
-     *
-     * If access control has been activated on the hub, virtual or not, you want to
-     * reach, the URL parameter should look like:
-     *
-     * http://username:password@address:port
-     *
-     * You can call <i>RegisterHub</i> several times to connect to several machines.
-     *
-     * @param url : a string containing either "usb","callback" or the
-     *         root URL of the hub to monitor
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    RegisterHub(const string& url, string& errmsg);
-
-    /**
-     * Fault-tolerant alternative to RegisterHub(). This function has the same
-     * purpose and same arguments as RegisterHub(), but does not trigger
-     * an error when the selected hub is not available at the time of the function call.
-     * This makes it possible to register a network hub independently of the current
-     * connectivity, and to try to contact it only when a device is actively needed.
-     *
-     * @param url : a string containing either "usb","callback" or the
-     *         root URL of the hub to monitor
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    PreregisterHub(const string& url, string& errmsg);
-
-    /**
-     * Setup the Yoctopuce library to no more use modules connected on a previously
-     * registered machine with RegisterHub.
-     *
-     * @param url : a string containing either "usb" or the
-     *         root URL of the hub to monitor
-     */
-    static  void        UnregisterHub(const string& url);
-
-    /**
-     * Triggers a (re)detection of connected Yoctopuce modules.
-     * The library searches the machines or USB ports previously registered using
-     * yRegisterHub(), and invokes any user-defined callback function
-     * in case a change in the list of connected devices is detected.
-     *
-     * This function can be called as frequently as desired to refresh the device list
-     * and to make the application aware of hot-plug events. However, since device
-     * detection is quite a heavy process, UpdateDeviceList shouldn't be called more
-     * than once every two seconds.
-     *
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    UpdateDeviceList(string& errmsg);
-    /**
-     * Maintains the device-to-library communication channel.
-     * If your program includes significant loops, you may want to include
-     * a call to this function to make sure that the library takes care of
-     * the information pushed by the modules on the communication channels.
-     * This is not strictly necessary, but it may improve the reactivity
-     * of the library for the following commands.
-     *
-     * This function may signal an error in case there is a communication problem
-     * while contacting a module.
-     *
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    HandleEvents(string& errmsg);
-    /**
-     * Pauses the execution flow for a specified duration.
-     * This function implements a passive waiting loop, meaning that it does not
-     * consume CPU cycles significantly. The processor is left available for
-     * other threads and processes. During the pause, the library nevertheless
-     * reads from time to time information from the Yoctopuce modules by
-     * calling yHandleEvents(), in order to stay up-to-date.
-     *
-     * This function may signal an error in case there is a communication problem
-     * while contacting a module.
-     *
-     * @param ms_duration : an integer corresponding to the duration of the pause,
-     *         in milliseconds.
-     * @param errmsg : a string passed by reference to receive any error message.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    static  YRETCODE    Sleep(unsigned ms_duration, string& errmsg);
-    /**
-     * Returns the current value of a monotone millisecond-based time counter.
-     * This counter can be used to compute delays in relation with
-     * Yoctopuce devices, which also uses the millisecond as timebase.
-     *
-     * @return a long integer corresponding to the millisecond counter.
-     */
-    static  u64         GetTickCount(void);
-    /**
-     * Checks if a given string is valid as logical name for a module or a function.
-     * A valid logical name has a maximum of 19 characters, all among
-     * A..Z, a..z, 0..9, _, and -.
-     * If you try to configure a logical name with an incorrect string,
-     * the invalid characters are ignored.
-     *
-     * @param name : a string containing the name to check.
-     *
-     * @return true if the name is valid, false otherwise.
-     */
-    static  bool        CheckLogicalName(const string& name);
-
-    //--- (generated code: YAPIContext yapiwrapper)
-    /**
-     * Change the time between each forced enumeration of the YoctoHub used.
-     * By default, the library performs a complete enumeration every 10 seconds.
-     * To reduce network traffic it is possible to increase this delay.
-     * This is particularly useful when a YoctoHub is connected to a GSM network
-     * where the traffic is charged. This setting does not affect modules connected by USB,
-     * nor the operation of arrival/removal callbacks.
-     * Note: This function must be called after yInitAPI.
-     *
-     * @param deviceListValidity : number of seconds between each enumeration.
-     * @noreturn
-     */
-    inline static void SetDeviceListValidity(int deviceListValidity)
-    {
-        YAPI::_yapiContext.SetDeviceListValidity(deviceListValidity);
-    }
-    /**
-     * Returns the time between each forced enumeration of the YoctoHub used.
-     * Note: This function must be called after yInitAPI.
-     *
-     * @return the number of seconds between each enumeration.
-     */
-    inline static int GetDeviceListValidity(void)
-    {
-        return YAPI::_yapiContext.GetDeviceListValidity();
-    }
-    /**
-     * Change the validity period of the data loaded by the library.
-     * By default, when accessing a module, all the attributes of the
-     * module functions are automatically kept in cache for the standard
-     * duration (5 ms). This method can be used to change this standard duration,
-     * for example in order to reduce network or USB traffic. This parameter
-     * does not affect value change callbacks
-     * Note: This function must be called after yInitAPI.
-     *
-     * @param cacheValidityMs : an integer corresponding to the validity attributed to the
-     *         loaded function parameters, in milliseconds.
-     * @noreturn
-     */
-    inline static void SetCacheValidity(u64 cacheValidityMs)
-    {
-        YAPI::_yapiContext.SetCacheValidity(cacheValidityMs);
-    }
-    /**
-     * Returns the validity period of the data loaded by the library.
-     * This method returns the cache validity of all attributes
-     * module functions.
-     * Note: This function must be called after yInitAPI .
-     *
-     * @return an integer corresponding to the validity attributed to the
-     *         loaded function parameters, in milliseconds
-     */
-    inline static u64 GetCacheValidity(void)
-    {
-        return YAPI::_yapiContext.GetCacheValidity();
-    }
-//--- (end of generated code: YAPIContext yapiwrapper)
-
-
-};
-
-
-// Wrappers to yapi low-level API
-class YapiWrapper {
-public:
-    static  u16         getAPIVersion(string& version, string& date);
-    static  YDEV_DESCR  getDevice(const string& device_str, string& errmsg);
-    static  int         getAllDevices(vector<YDEV_DESCR>& buffer, string& errmsg);
-    static  YRETCODE    getDeviceInfo(YDEV_DESCR devdesc, yDeviceSt& infos, string& errmsg);
-    static  YFUN_DESCR  getFunction(const string& class_str, const string& function_str, string& errmsg);
-    static  int         getFunctionsByClass(const string& class_str, YFUN_DESCR prevfundesc, vector<YFUN_DESCR>& buffer, int maxsize, string& errmsg);
-    static  int         getFunctionsByDevice(YDEV_DESCR devdesc, YFUN_DESCR prevfundesc, vector<YFUN_DESCR>& buffer, int maxsize, string& errmsg);
-    static  YDEV_DESCR  getDeviceByFunction(YFUN_DESCR fundesc, string& errmsg);
-    static  YRETCODE    getFunctionInfo(YFUN_DESCR fundesc, YDEV_DESCR& devdescr, string& serial, string& funcId, string& funcName, string& funcVal, string& errmsg);
-    static  YRETCODE    getFunctionInfoEx(YFUN_DESCR fundesc, YDEV_DESCR& devdescr, string& serial, string& funcId, string& baseType, string& funcName, string& funcVal, string& errmsg);
-    // pure yapi mapper
-    static  YRETCODE    updateDeviceList(bool forceupdate, string& errmsg);
-    static  YRETCODE    handleEvents(string& errmsg);
-    static  string      ysprintf(const char *fmt, ...);
-};
-
-
-//--- (generated code: YFirmwareUpdate declaration)
-/**
- * YFirmwareUpdate Class: Control interface for the firmware update process
- *
- * The YFirmwareUpdate class let you control the firmware update of a Yoctopuce
- * module. This class should not be instantiate directly, instead the method
- * updateFirmware should be called to get an instance of YFirmwareUpdate.
- */
-class YOCTO_CLASS_EXPORT YFirmwareUpdate {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YFirmwareUpdate declaration)
-protected:
-    //--- (generated code: YFirmwareUpdate attributes)
-    // Attributes (function value cache)
-    string          _serial;
-    string          _settings;
-    string          _firmwarepath;
-    string          _progress_msg;
-    int             _progress_c;
-    int             _progress;
-    int             _restore_step;
-    bool            _force;
-    //--- (end of generated code: YFirmwareUpdate attributes)
-
-
-public:
-    YFirmwareUpdate(string serialNumber, string path, string settings);
-    YFirmwareUpdate(string serialNumber, string path, string settings, bool force);
-    YFirmwareUpdate();
-
-    //--- (generated code: YFirmwareUpdate accessors declaration)
-
-
-    virtual int         _processMore(int newupdate);
-
-    /**
-     * Returns a list of all the modules in "firmware update" mode. Only devices
-     * connected over USB are listed. For devices connected to a YoctoHub, you
-     * must connect yourself to the YoctoHub web interface.
-     *
-     * @return an array of strings containing the serial numbers of devices in "firmware update" mode.
-     */
-    static vector<string> GetAllBootLoaders(void);
-
-    /**
-     * Test if the byn file is valid for this module. It is possible to pass a directory instead of a file.
-     * In that case, this method returns the path of the most recent appropriate byn file. This method will
-     * ignore any firmware older than minrelease.
-     *
-     * @param serial : the serial number of the module to update
-     * @param path : the path of a byn file or a directory that contains byn files
-     * @param minrelease : a positive integer
-     *
-     * @return : the path of the byn file to use, or an empty string if no byn files matches the requirement
-     *
-     * On failure, returns a string that starts with "error:".
-     */
-    static string       CheckFirmware(string serial,string path,int minrelease);
-
-    /**
-     * Returns the progress of the firmware update, on a scale from 0 to 100. When the object is
-     * instantiated, the progress is zero. The value is updated during the firmware update process until
-     * the value of 100 is reached. The 100 value means that the firmware update was completed
-     * successfully. If an error occurs during the firmware update, a negative value is returned, and the
-     * error message can be retrieved with get_progressMessage.
-     *
-     * @return an integer in the range 0 to 100 (percentage of completion)
-     *         or a negative error code in case of failure.
-     */
-    virtual int         get_progress(void);
-
-    /**
-     * Returns the last progress message of the firmware update process. If an error occurs during the
-     * firmware update process, the error message is returned
-     *
-     * @return a string  with the latest progress message, or the error message.
-     */
-    virtual string      get_progressMessage(void);
-
-    /**
-     * Starts the firmware update process. This method starts the firmware update process in background. This method
-     * returns immediately. You can monitor the progress of the firmware update with the get_progress()
-     * and get_progressMessage() methods.
-     *
-     * @return an integer in the range 0 to 100 (percentage of completion),
-     *         or a negative error code in case of failure.
-     *
-     * On failure returns a negative error code.
-     */
-    virtual int         startUpdate(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YFirmwareUpdate accessors declaration)
-};
-
-
-
-//--- (generated code: YDataStream declaration)
-/**
- * YDataStream Class: Unformatted data sequence
- *
- * YDataStream objects represent bare recorded measure sequences,
- * exactly as found within the data logger present on Yoctopuce
- * sensors.
- *
- * In most cases, it is not necessary to use YDataStream objects
- * directly, as the YDataSet objects (returned by the
- * get_recordedData() method from sensors and the
- * get_dataSets() method from the data logger) provide
- * a more convenient interface.
- */
-class YOCTO_CLASS_EXPORT YDataStream {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YDataStream declaration)
-protected:
-    //--- (generated code: YDataStream attributes)
-    // Attributes (function value cache)
-    YFunction*      _parent;
-    int             _runNo;
-    s64             _utcStamp;
-    int             _nCols;
-    int             _nRows;
-    double          _startTime;
-    double          _duration;
-    double          _dataSamplesInterval;
-    double          _firstMeasureDuration;
-    vector<string>  _columnNames;
-    string          _functionId;
-    bool            _isClosed;
-    bool            _isAvg;
-    double          _minVal;
-    double          _avgVal;
-    double          _maxVal;
-    int             _caltyp;
-    vector<int>     _calpar;
-    vector<double>  _calraw;
-    vector<double>  _calref;
-    vector< vector<double> > _values;
-    //--- (end of generated code: YDataStream attributes)
-
-    yCalibrationHandler _calhdl;
-
-public:
-    YDataStream(YFunction *parent);
-    YDataStream(YFunction *parent, YDataSet &dataset, const vector<int>& encoded);
-
-    virtual ~YDataStream();
-
-    static const double DATA_INVALID;
-    static const int    DURATION_INVALID = -1;
-
-    //--- (generated code: YDataStream accessors declaration)
-
-
-    virtual int         _initFromDataSet(YDataSet* dataset,vector<int> encoded);
-
-    virtual int         _parseStream(string sdata);
-
-    virtual string      _get_url(void);
-
-    virtual int         loadStream(void);
-
-    virtual double      _decodeVal(int w);
-
-    virtual double      _decodeAvg(int dw,int count);
-
-    virtual bool        isClosed(void);
-
-    /**
-     * Returns the run index of the data stream. A run can be made of
-     * multiple datastreams, for different time intervals.
-     *
-     * @return an unsigned number corresponding to the run index.
-     */
-    virtual int         get_runIndex(void);
-
-    /**
-     * Returns the relative start time of the data stream, measured in seconds.
-     * For recent firmwares, the value is relative to the present time,
-     * which means the value is always negative.
-     * If the device uses a firmware older than version 13000, value is
-     * relative to the start of the time the device was powered on, and
-     * is always positive.
-     * If you need an absolute UTC timestamp, use get_realStartTimeUTC().
-     *
-     * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
-     *
-     * @return an unsigned number corresponding to the number of seconds
-     *         between the start of the run and the beginning of this data
-     *         stream.
-     */
-    virtual int         get_startTime(void);
-
-    /**
-     * Returns the start time of the data stream, relative to the Jan 1, 1970.
-     * If the UTC time was not set in the datalogger at the time of the recording
-     * of this data stream, this method returns 0.
-     *
-     * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
-     *
-     * @return an unsigned number corresponding to the number of seconds
-     *         between the Jan 1, 1970 and the beginning of this data
-     *         stream (i.e. Unix time representation of the absolute time).
-     */
-    virtual s64         get_startTimeUTC(void);
-
-    /**
-     * Returns the start time of the data stream, relative to the Jan 1, 1970.
-     * If the UTC time was not set in the datalogger at the time of the recording
-     * of this data stream, this method returns 0.
-     *
-     * @return a floating-point number  corresponding to the number of seconds
-     *         between the Jan 1, 1970 and the beginning of this data
-     *         stream (i.e. Unix time representation of the absolute time).
-     */
-    virtual double      get_realStartTimeUTC(void);
-
-    /**
-     * Returns the number of milliseconds between two consecutive
-     * rows of this data stream. By default, the data logger records one row
-     * per second, but the recording frequency can be changed for
-     * each device function
-     *
-     * @return an unsigned number corresponding to a number of milliseconds.
-     */
-    virtual int         get_dataSamplesIntervalMs(void);
-
-    virtual double      get_dataSamplesInterval(void);
-
-    virtual double      get_firstDataSamplesInterval(void);
-
-    /**
-     * Returns the number of data rows present in this stream.
-     *
-     * If the device uses a firmware older than version 13000,
-     * this method fetches the whole data stream from the device
-     * if not yet done, which can cause a little delay.
-     *
-     * @return an unsigned number corresponding to the number of rows.
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         get_rowCount(void);
-
-    /**
-     * Returns the number of data columns present in this stream.
-     * The meaning of the values present in each column can be obtained
-     * using the method get_columnNames().
-     *
-     * If the device uses a firmware older than version 13000,
-     * this method fetches the whole data stream from the device
-     * if not yet done, which can cause a little delay.
-     *
-     * @return an unsigned number corresponding to the number of columns.
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         get_columnCount(void);
-
-    /**
-     * Returns the title (or meaning) of each data column present in this stream.
-     * In most case, the title of the data column is the hardware identifier
-     * of the sensor that produced the data. For streams recorded at a lower
-     * recording rate, the dataLogger stores the min, average and max value
-     * during each measure interval into three columns with suffixes _min,
-     * _avg and _max respectively.
-     *
-     * If the device uses a firmware older than version 13000,
-     * this method fetches the whole data stream from the device
-     * if not yet done, which can cause a little delay.
-     *
-     * @return a list containing as many strings as there are columns in the
-     *         data stream.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<string> get_columnNames(void);
-
-    /**
-     * Returns the smallest measure observed within this stream.
-     * If the device uses a firmware older than version 13000,
-     * this method will always return Y_DATA_INVALID.
-     *
-     * @return a floating-point number corresponding to the smallest value,
-     *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
-     *
-     * On failure, throws an exception or returns Y_DATA_INVALID.
-     */
-    virtual double      get_minValue(void);
-
-    /**
-     * Returns the average of all measures observed within this stream.
-     * If the device uses a firmware older than version 13000,
-     * this method will always return Y_DATA_INVALID.
-     *
-     * @return a floating-point number corresponding to the average value,
-     *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
-     *
-     * On failure, throws an exception or returns Y_DATA_INVALID.
-     */
-    virtual double      get_averageValue(void);
-
-    /**
-     * Returns the largest measure observed within this stream.
-     * If the device uses a firmware older than version 13000,
-     * this method will always return Y_DATA_INVALID.
-     *
-     * @return a floating-point number corresponding to the largest value,
-     *         or Y_DATA_INVALID if the stream is not yet complete (still recording).
-     *
-     * On failure, throws an exception or returns Y_DATA_INVALID.
-     */
-    virtual double      get_maxValue(void);
-
-    virtual double      get_realDuration(void);
-
-    /**
-     * Returns the whole data set contained in the stream, as a bidimensional
-     * table of numbers.
-     * The meaning of the values present in each column can be obtained
-     * using the method get_columnNames().
-     *
-     * This method fetches the whole data stream from the device,
-     * if not yet done.
-     *
-     * @return a list containing as many elements as there are rows in the
-     *         data stream. Each row itself is a list of floating-point
-     *         numbers.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector< vector<double> > get_dataRows(void);
-
-    /**
-     * Returns a single measure from the data stream, specified by its
-     * row and column index.
-     * The meaning of the values present in each column can be obtained
-     * using the method get_columnNames().
-     *
-     * This method fetches the whole data stream from the device,
-     * if not yet done.
-     *
-     * @param row : row index
-     * @param col : column index
-     *
-     * @return a floating-point number
-     *
-     * On failure, throws an exception or returns Y_DATA_INVALID.
-     */
-    virtual double      get_data(int row,int col);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YDataStream accessors declaration)
-};
-
-//--- (generated code: YMeasure declaration)
-/**
- * YMeasure Class: Measured value
- *
- * YMeasure objects are used within the API to represent
- * a value measured at a specified time. These objects are
- * used in particular in conjunction with the YDataSet class.
- */
-class YOCTO_CLASS_EXPORT YMeasure {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YMeasure declaration)
-protected:
-    //--- (generated code: YMeasure attributes)
-    // Attributes (function value cache)
-    double          _start;
-    double          _end;
-    double          _minVal;
-    double          _avgVal;
-    double          _maxVal;
-    //--- (end of generated code: YMeasure attributes)
-
-
-    time_t              _startTime_t;
-    time_t              _stopTime_t;
-public:
-    YMeasure(double start, double end, double minVal, double avgVal, double maxVal);
-    YMeasure();
-    virtual ~YMeasure(){};
-
-    time_t*        get_startTimeUTC_asTime_t(time_t *time);
-    time_t*        get_endTimeUTC_asTime_t(time_t *time);
-
-    //--- (generated code: YMeasure accessors declaration)
-
-
-    /**
-     * Returns the start time of the measure, relative to the Jan 1, 1970 UTC
-     * (Unix timestamp). When the recording rate is higher then 1 sample
-     * per second, the timestamp may have a fractional part.
-     *
-     * @return an floating point number corresponding to the number of seconds
-     *         between the Jan 1, 1970 UTC and the beginning of this measure.
-     */
-    virtual double      get_startTimeUTC(void);
-
-    /**
-     * Returns the end time of the measure, relative to the Jan 1, 1970 UTC
-     * (Unix timestamp). When the recording rate is higher than 1 sample
-     * per second, the timestamp may have a fractional part.
-     *
-     * @return an floating point number corresponding to the number of seconds
-     *         between the Jan 1, 1970 UTC and the end of this measure.
-     */
-    virtual double      get_endTimeUTC(void);
-
-    /**
-     * Returns the smallest value observed during the time interval
-     * covered by this measure.
-     *
-     * @return a floating-point number corresponding to the smallest value observed.
-     */
-    virtual double      get_minValue(void);
-
-    /**
-     * Returns the average value observed during the time interval
-     * covered by this measure.
-     *
-     * @return a floating-point number corresponding to the average value observed.
-     */
-    virtual double      get_averageValue(void);
-
-    /**
-     * Returns the largest value observed during the time interval
-     * covered by this measure.
-     *
-     * @return a floating-point number corresponding to the largest value observed.
-     */
-    virtual double      get_maxValue(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YMeasure accessors declaration)
-};
-
-
-
-//--- (generated code: YDataSet declaration)
-/**
- * YDataSet Class: Recorded data sequence
- *
- * YDataSet objects make it possible to retrieve a set of recorded measures
- * for a given sensor and a specified time interval. They can be used
- * to load data points with a progress report. When the YDataSet object is
- * instantiated by the get_recordedData()  function, no data is
- * yet loaded from the module. It is only when the loadMore()
- * method is called over and over than data will be effectively loaded
- * from the dataLogger.
- *
- * A preview of available measures is available using the function
- * get_preview() as soon as loadMore() has been called
- * once. Measures themselves are available using function get_measures()
- * when loaded by subsequent calls to loadMore().
- *
- * This class can only be used on devices that use a recent firmware,
- * as YDataSet objects are not supported by firmwares older than version 13000.
- */
-class YOCTO_CLASS_EXPORT YDataSet {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YDataSet declaration)
-protected:
-    //--- (generated code: YDataSet attributes)
-    // Attributes (function value cache)
-    YFunction*      _parent;
-    string          _hardwareId;
-    string          _functionId;
-    string          _unit;
-    double          _startTimeMs;
-    double          _endTimeMs;
-    int             _progress;
-    vector<int>     _calib;
-    vector<YDataStream*> _streams;
-    YMeasure        _summary;
-    vector<YMeasure> _preview;
-    vector<YMeasure> _measures;
-    double          _summaryMinVal;
-    double          _summaryMaxVal;
-    double          _summaryTotalAvg;
-    double          _summaryTotalTime;
-    //--- (end of generated code: YDataSet attributes)
-
-public:
-    YDataSet(YFunction *parent, const string& functionId, const string& unit, double startTime, double endTime);
-    YDataSet(YFunction *parent);
-    YDataSet(){};
-    virtual ~YDataSet(){};
-
-    int _parse(const string& json);
-
-
-
-    //--- (generated code: YDataSet accessors declaration)
-
-
-    virtual vector<int> _get_calibration(void);
-
-    virtual int         loadSummary(string data);
-
-    virtual int         processMore(int progress,string data);
-
-    virtual vector<YDataStream*> get_privateDataStreams(void);
-
-    /**
-     * Returns the unique hardware identifier of the function who performed the measures,
-     * in the form SERIAL.FUNCTIONID. The unique hardware identifier is composed of the
-     * device serial number and of the hardware identifier of the function
-     * (for example THRMCPL1-123456.temperature1)
-     *
-     * @return a string that uniquely identifies the function (ex: THRMCPL1-123456.temperature1)
-     *
-     * On failure, throws an exception or returns  Y_HARDWAREID_INVALID.
-     */
-    virtual string      get_hardwareId(void);
-
-    /**
-     * Returns the hardware identifier of the function that performed the measure,
-     * without reference to the module. For example temperature1.
-     *
-     * @return a string that identifies the function (ex: temperature1)
-     */
-    virtual string      get_functionId(void);
-
-    /**
-     * Returns the measuring unit for the measured value.
-     *
-     * @return a string that represents a physical unit.
-     *
-     * On failure, throws an exception or returns  Y_UNIT_INVALID.
-     */
-    virtual string      get_unit(void);
-
-    /**
-     * Returns the start time of the dataset, relative to the Jan 1, 1970.
-     * When the YDataSet is created, the start time is the value passed
-     * in parameter to the get_dataSet() function. After the
-     * very first call to loadMore(), the start time is updated
-     * to reflect the timestamp of the first measure actually found in the
-     * dataLogger within the specified range.
-     *
-     * <b>DEPRECATED</b>: This method has been replaced by get_summary()
-     * which contain more precise informations on the YDataSet.
-     *
-     * @return an unsigned number corresponding to the number of seconds
-     *         between the Jan 1, 1970 and the beginning of this data
-     *         set (i.e. Unix time representation of the absolute time).
-     */
-    virtual s64         get_startTimeUTC(void);
-
-    virtual s64         imm_get_startTimeUTC(void);
-
-    /**
-     * Returns the end time of the dataset, relative to the Jan 1, 1970.
-     * When the YDataSet is created, the end time is the value passed
-     * in parameter to the get_dataSet() function. After the
-     * very first call to loadMore(), the end time is updated
-     * to reflect the timestamp of the last measure actually found in the
-     * dataLogger within the specified range.
-     *
-     * <b>DEPRECATED</b>: This method has been replaced by get_summary()
-     * which contain more precise informations on the YDataSet.
-     *
-     *
-     * @return an unsigned number corresponding to the number of seconds
-     *         between the Jan 1, 1970 and the end of this data
-     *         set (i.e. Unix time representation of the absolute time).
-     */
-    virtual s64         get_endTimeUTC(void);
-
-    virtual s64         imm_get_endTimeUTC(void);
-
-    /**
-     * Returns the progress of the downloads of the measures from the data logger,
-     * on a scale from 0 to 100. When the object is instantiated by get_dataSet,
-     * the progress is zero. Each time loadMore() is invoked, the progress
-     * is updated, to reach the value 100 only once all measures have been loaded.
-     *
-     * @return an integer in the range 0 to 100 (percentage of completion).
-     */
-    virtual int         get_progress(void);
-
-    /**
-     * Loads the the next block of measures from the dataLogger, and updates
-     * the progress indicator.
-     *
-     * @return an integer in the range 0 to 100 (percentage of completion),
-     *         or a negative error code in case of failure.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadMore(void);
-
-    /**
-     * Returns an YMeasure object which summarizes the whole
-     * DataSet. In includes the following information:
-     * - the start of a time interval
-     * - the end of a time interval
-     * - the minimal value observed during the time interval
-     * - the average value observed during the time interval
-     * - the maximal value observed during the time interval
-     *
-     * This summary is available as soon as loadMore() has
-     * been called for the first time.
-     *
-     * @return an YMeasure object
-     */
-    virtual YMeasure    get_summary(void);
-
-    /**
-     * Returns a condensed version of the measures that can
-     * retrieved in this YDataSet, as a list of YMeasure
-     * objects. Each item includes:
-     * - the start of a time interval
-     * - the end of a time interval
-     * - the minimal value observed during the time interval
-     * - the average value observed during the time interval
-     * - the maximal value observed during the time interval
-     *
-     * This preview is available as soon as loadMore() has
-     * been called for the first time.
-     *
-     * @return a table of records, where each record depicts the
-     *         measured values during a time interval
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<YMeasure> get_preview(void);
-
-    /**
-     * Returns the detailed set of measures for the time interval corresponding
-     * to a given condensed measures previously returned by get_preview().
-     * The result is provided as a list of YMeasure objects.
-     *
-     * @param measure : condensed measure from the list previously returned by
-     *         get_preview().
-     *
-     * @return a table of records, where each record depicts the
-     *         measured values during a time interval
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<YMeasure> get_measuresAt(YMeasure measure);
-
-    /**
-     * Returns all measured values currently available for this DataSet,
-     * as a list of YMeasure objects. Each item includes:
-     * - the start of the measure time interval
-     * - the end of the measure time interval
-     * - the minimal value observed during the time interval
-     * - the average value observed during the time interval
-     * - the maximal value observed during the time interval
-     *
-     * Before calling this method, you should call loadMore()
-     * to load data from the device. You may have to call loadMore()
-     * several time until all rows are loaded, but you can start
-     * looking at available data rows before the load is complete.
-     *
-     * The oldest measures are always loaded first, and the most
-     * recent measures will be loaded last. As a result, timestamps
-     * are normally sorted in ascending order within the measure table,
-     * unless there was an unexpected adjustment of the datalogger UTC
-     * clock.
-     *
-     * @return a table of records, where each record depicts the
-     *         measured value for a given time interval
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<YMeasure> get_measures(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YDataSet accessors declaration)
-};
-
-//
-// YDevice Class (used internally)
-//
-// This class is used to cache device-level information
-//
-// In order to regroup multiple function queries on the same physical device,
-// this class implements a device-wide API string cache (agnostic of API content).
-// This is in addition to the function-specific cache implemented in YFunction.
-//
-
-class YDevice;
-
-typedef void (*HTTPRequestCallback)(YDevice *device,void *context,YRETCODE returnval, const string& result,string& errmsg);
-
-class YDevice
-{
-private:
-    // Static device-based JSON string cache
-    static vector<YDevice*> _devCache;
-
-    // Device cache entries
-    YDEV_DESCR          _devdescr;
-    u64                 _cacheStamp; // used only by requestAPI method
-    YJSONObject*        _cacheJson;  // used only by requestAPI method
-    vector<YFUN_DESCR>  _functions;
-    char                _rootdevice[YOCTO_SERIAL_LEN];
-    char                *_subpath;
-    yCRITICAL_SECTION   _lock;
-    // Constructor is private, use getDevice factory method
-    YDevice(YDEV_DESCR devdesc);
-    ~YDevice();
-    YRETCODE   HTTPRequestPrepare(const string& request, string& fullrequest, char *errbuff);
-    YRETCODE   HTTPRequest_unsafe(int channel, const string& request, string& buffer, yapiRequestProgressCallback progress_cb, void *progress_ctx, string& errmsg);
-
-public:
-    static void ClearCache();
-    static YDevice *getDevice(YDEV_DESCR devdescr);
-    YRETCODE    HTTPRequestAsync(int channel, const string& request, HTTPRequestCallback callback, void *context, string& errmsg);
-    YRETCODE    HTTPRequest(int channel, const string& request, string& buffer, yapiRequestProgressCallback progress_cb, void *progress_ctx, string& errmsg);
-    YRETCODE    requestAPI(YJSONObject*& apires, string& errmsg);
-    void        clearCache(bool clearSubpath);
-    YRETCODE    getFunctions(vector<YFUN_DESCR> **functions, string& errmsg);
-    string      getHubSerial(void);
-
-};
-
-//--- (generated code: YFunction declaration)
-/**
- * YFunction Class: Common function interface
- *
- * This is the parent class for all public objects representing device functions documented in
- * the high-level programming API. This abstract class does all the real job, but without
- * knowledge of the specific function attributes.
- *
- * Instantiating a child class of YFunction does not cause any communication.
- * The instance simply keeps track of its function identifier, and will dynamically bind
- * to a matching device at the time it is really being used to read or set an attribute.
- * In order to allow true hot-plug replacement of one device by another, the binding stay
- * dynamic through the life of the object.
- *
- * The YFunction class implements a generic high-level cache for the attribute values of
- * the specified function, pre-parsed from the REST API string.
- */
-class YOCTO_CLASS_EXPORT YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YFunction declaration)
-protected:
-    // Protected attributes
-    string      _className;
-    string      _func;
-    YRETCODE    _lastErrorType;
-    string      _lastErrorMsg;
-    YFUN_DESCR  _fundescr;
-    yCRITICAL_SECTION _this_cs;
-    std::map<string,YDataStream*> _dataStreams;
-    void*                   _userData;
-    //--- (generated code: YFunction attributes)
-    // Attributes (function value cache)
-    string          _logicalName;
-    string          _advertisedValue;
-    YFunctionValueCallback _valueCallbackFunction;
-    u64             _cacheExpiration;
-    string          _serial;
-    string          _funId;
-    string          _hwId;
-
-    friend YFunction *yFindFunction(const string& func);
-    friend YFunction *yFirstFunction(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindFunction factory function to instantiate
-    YFunction(const string& func);
-    //--- (end of generated code: YFunction attributes)
-    static  std::map<string,YFunction*> _cache;
-
-
-    // Method used to retrieve our unique function descriptor (may trigger a hub scan)
-    YRETCODE    _getDescriptor(YFUN_DESCR& fundescr, string& errMsg);
-
-    // Method used to retrieve our device object (may trigger a hub scan)
-    YRETCODE    _getDevice(YDevice*& dev, string& errMsg);
-
-    // Method used to find the next instance of our function
-    YRETCODE    _nextFunction(string &hwId);
-
-    int         _parse(YJSONObject* j);
-
-    string      _escapeAttr(const string& changeval);
-    YRETCODE    _buildSetRequest(const string& changeattr, const string  *changeval, string& request, string& errmsg);
-
-    // Method used to change attributes
-    YRETCODE    _setAttr(string attrname, string newvalue);
-    YRETCODE    _load_unsafe(u64 msValidity);
-
-    static void _UpdateValueCallbackList(YFunction* func, bool add);
-    static void _UpdateTimedReportCallbackList(YFunction* func, bool add);
-
-    // function cache methods
-    static YFunction*  _FindFromCache(const string& classname, const string& func);
-    static void        _AddToCache(const string& classname, const string& func, YFunction *obj);
-
-public:
-    virtual ~YFunction();
-
-    // clear cache of all YFunction object (use only on YAPI::FreeAPI)
-    static void _ClearCache(void);
-
-    // Method used to throw exceptions or save error type/message
-    void        _throw(YRETCODE errType, string errMsg);
-
-    // Method used to send http request to the device (not the function)
-    string      _request(const string& request);
-    string      _requestEx(int tcpchan, const string& request, yapiRequestProgressCallback callback, void *context);
-    string      _download(const string& url);
-
-    // Method used to upload a file to the device
-    YRETCODE    _uploadWithProgress(const string& path, const string& content, yapiRequestProgressCallback callback, void *context);
-    YRETCODE    _upload(const string& path, const string& content);
-
-    // Method used to parse a string in JSON data (low-level)
-    string      _json_get_key(const string& json, const string& data);
-    string      _json_get_string(const string& json);
-    vector<string> _json_get_array(const string& json);
-    string      _get_json_path(const string& json, const string& path);
-    string      _decode_json_string(const string& json);
-    string      _parseString(yJsonStateMachine& j);
-    int         _parseEx(yJsonStateMachine& j);
-
-
-
-    // Method used to cache DataStream objects (new DataLogger)
-    YDataStream *_findDataStream(YDataSet& dataset, const string& def);
-    // Method used to clear cache of DataStream object (undocumented)
-    void _clearDataStreamCache();
-
-
-
-    static const YFUN_DESCR FUNCTIONDESCRIPTOR_INVALID = Y_FUNCTIONDESCRIPTOR_INVALID;
-    static const string     HARDWAREID_INVALID;
-    static const string     FUNCTIONID_INVALID;
-    static const string     FRIENDLYNAME_INVALID;
-
-
-
-    string get_hubSerial();
-
-
-    //--- (generated code: YFunction accessors declaration)
-
-    static const string LOGICALNAME_INVALID;
-    static const string ADVERTISEDVALUE_INVALID;
-
-    /**
-     * Returns the logical name of the function.
-     *
-     * @return a string corresponding to the logical name of the function
-     *
-     * On failure, throws an exception or returns Y_LOGICALNAME_INVALID.
-     */
-    string              get_logicalName(void);
-
-    inline string       logicalName(void)
-    { return this->get_logicalName(); }
-
-    /**
-     * Changes the logical name of the function. You can use yCheckLogicalName()
-     * prior to this call to make sure that your parameter is valid.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the logical name of the function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_logicalName(const string& newval);
-    inline int      setLogicalName(const string& newval)
-    { return this->set_logicalName(newval); }
-
-    /**
-     * Returns a short string representing the current state of the function.
-     *
-     * @return a string corresponding to a short string representing the current state of the function
-     *
-     * On failure, throws an exception or returns Y_ADVERTISEDVALUE_INVALID.
-     */
-    string              get_advertisedValue(void);
-
-    inline string       advertisedValue(void)
-    { return this->get_advertisedValue(); }
-
-    int             set_advertisedValue(const string& newval);
-    inline int      setAdvertisedValue(const string& newval)
-    { return this->set_advertisedValue(newval); }
-
-    /**
-     * Retrieves a function for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the function is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YFunction.isOnline() to test if the function is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a function by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the function
-     *
-     * @return a YFunction object allowing you to drive the function.
-     */
-    static YFunction*   FindFunction(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YFunctionValueCallback callback);
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Disables the propagation of every new advertised value to the parent hub.
-     * You can use this function to save bandwidth and CPU on computers with limited
-     * resources, or to prevent unwanted invocations of the HTTP callback.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         muteValueCallbacks(void);
-
-    /**
-     * Re-enables the propagation of every new advertised value to the parent hub.
-     * This function reverts the effect of a previous call to muteValueCallbacks().
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         unmuteValueCallbacks(void);
-
-    /**
-     * Returns the current value of a single function attribute, as a text string, as quickly as
-     * possible but without using the cached value.
-     *
-     * @param attrName : the name of the requested attribute
-     *
-     * @return a string with the value of the the attribute
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    virtual string      loadAttribute(string attrName);
-
-    virtual int         _parserHelper(void);
-
-
-    inline static YFunction* Find(string func)
-    { return YFunction::FindFunction(func); }
-
-    /**
-     * comment from .yc definition
-     */
-           YFunction       *nextFunction(void);
-    inline YFunction       *next(void)
-    { return this->nextFunction();}
-
-    /**
-     * comment from .yc definition
-     */
-           static YFunction* FirstFunction(void);
-    inline static YFunction* First(void)
-    { return YFunction::FirstFunction();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YFunction accessors declaration)
-
-
-
-    /**
-     * Returns a short text that describes unambiguously the instance of the function in the form
-     * TYPE(NAME)=SERIAL&#46;FUNCTIONID.
-     * More precisely,
-     * TYPE       is the type of the function,
-     * NAME       it the name used for the first access to the function,
-     * SERIAL     is the serial number of the module if the module is connected or "unresolved", and
-     * FUNCTIONID is  the hardware identifier of the function if the module is connected.
-     * For example, this method returns Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1 if the
-     * module is already connected or Relay(BadCustomeName.relay1)=unresolved if the module has
-     * not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in
-     * a debugger.
-     *
-     * @return a string that describes the function
-     *         (ex: Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1)
-     */
-    string      describe(void);
-
-    /**
-     * Returns a global identifier of the function in the format MODULE_NAME&#46;FUNCTION_NAME.
-     * The returned string uses the logical names of the module and of the function if they are defined,
-     * otherwise the serial number of the module and the hardware identifier of the function
-     * (for example: MyCustomName.relay1)
-     *
-     * @return a string that uniquely identifies the function using logical names
-     *         (ex: MyCustomName.relay1)
-     *
-     * On failure, throws an exception or returns  Y_FRIENDLYNAME_INVALID.
-     */
-     virtual string      get_friendlyName(void);
-
-    /**
-     * Returns the unique hardware identifier of the function in the form SERIAL.FUNCTIONID.
-     * The unique hardware identifier is composed of the device serial
-     * number and of the hardware identifier of the function (for example RELAYLO1-123456.relay1).
-     *
-     * @return a string that uniquely identifies the function (ex: RELAYLO1-123456.relay1)
-     *
-     * On failure, throws an exception or returns  Y_HARDWAREID_INVALID.
-     */
-    string      get_hardwareId(void);
-
-    /**
-     * Returns the hardware identifier of the function, without reference to the module. For example
-     * relay1
-     *
-     * @return a string that identifies the function (ex: relay1)
-     *
-     * On failure, throws an exception or returns  Y_FUNCTIONID_INVALID.
-     */
-    string      get_functionId(void);
-
-
-    /**
-     * Returns the numerical error code of the latest error with the function.
-     * This method is mostly useful when using the Yoctopuce library with
-     * exceptions disabled.
-     *
-     * @return a number corresponding to the code of the latest error that occurred while
-     *         using the function object
-     */
-           YRETCODE    get_errorType(void);
-    inline YRETCODE    errorType(void)
-    {return this->get_errorType();}
-    inline YRETCODE    errType(void)
-    {return this->get_errorType();}
-
-    /**
-     * Returns the error message of the latest error with the function.
-     * This method is mostly useful when using the Yoctopuce library with
-     * exceptions disabled.
-     *
-     * @return a string corresponding to the latest error message that occured while
-     *         using the function object
-     */
-           string      get_errorMessage(void);
-    inline string      errorMessage(void)
-    {return this->get_errorMessage();}
-    inline string      errMessage(void)
-    {return this->get_errorMessage();}
-
-    /**
-     * Checks if the function is currently reachable, without raising any error.
-     * If there is a cached value for the function in cache, that has not yet
-     * expired, the device is considered reachable.
-     * No exception is raised if there is an error while trying to contact the
-     * device hosting the function.
-     *
-     * @return true if the function can be reached, and false otherwise
-     */
-    bool        isOnline(void);
-
-    /**
-     * Preloads the function cache with a specified validity duration.
-     * By default, whenever accessing a device, all function attributes
-     * are kept in cache for the standard duration (5 ms). This method can be
-     * used to temporarily mark the cache as valid for a longer period, in order
-     * to reduce network traffic for instance.
-     *
-     * @param msValidity : an integer corresponding to the validity attributed to the
-     *         loaded function parameters, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    YRETCODE    load(int msValidity);
-
-    /**
-     * Invalidates the cache. Invalidates the cache of the function attributes. Forces the
-     * next call to get_xxx() or loadxxx() to use values that come from the device.
-     *
-     * @noreturn
-     */
-    void    clearCache();
-
-    /**
-     * Gets the YModule object for the device on which the function is located.
-     * If the function cannot be located on any module, the returned instance of
-     * YModule is not shown as on-line.
-     *
-     * @return an instance of YModule
-     */
-           YModule     *get_module(void);
-    inline YModule     *module(void)
-    {return this->get_module();}
-
-    /**
-     * Returns a unique identifier of type YFUN_DESCR corresponding to the function.
-     * This identifier can be used to test if two instances of YFunction reference the same
-     * physical function on the same physical device.
-     *
-     * @return an identifier of type YFUN_DESCR.
-     *
-     * If the function has never been contacted, the returned value is Y_FUNCTIONDESCRIPTOR_INVALID.
-     */
-           YFUN_DESCR     get_functionDescriptor(void);
-    inline YFUN_DESCR     functionDescriptor(void)
-    {return this->get_functionDescriptor();}
-
-    /**
-     * Returns the value of the userData attribute, as previously stored using method
-     * set_userData.
-     * This attribute is never touched directly by the API, and is at disposal of the caller to
-     * store a context.
-     *
-     * @return the object stored previously by the caller.
-     */
-           void        *get_userData(void);
-    inline void        *userData(void)
-    {return this->get_userData();}
-
-    /**
-     * Stores a user context provided as argument in the userData attribute of the function.
-     * This attribute is never touched by the API, and is at disposal of the caller to store a context.
-     *
-     * @param data : any kind of object to be stored
-     * @noreturn
-     */
-           void        set_userData(void* data);
-    inline void        setUserData(void* data)
-    { this->set_userData(data);}
-
-};
-
-//--- (generated code: YModule declaration)
-/**
- * YModule Class: Module control interface
- *
- * This interface is identical for all Yoctopuce USB modules.
- * It can be used to control the module global parameters, and
- * to enumerate the functions provided by each module.
- */
-class YOCTO_CLASS_EXPORT YModule: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YModule declaration)
-protected:
-    //--- (generated code: YModule attributes)
-    // Attributes (function value cache)
-    string          _productName;
-    string          _serialNumber;
-    int             _productId;
-    int             _productRelease;
-    string          _firmwareRelease;
-    Y_PERSISTENTSETTINGS_enum _persistentSettings;
-    int             _luminosity;
-    Y_BEACON_enum   _beacon;
-    s64             _upTime;
-    int             _usbCurrent;
-    int             _rebootCountdown;
-    int             _userVar;
-    YModuleValueCallback _valueCallbackModule;
-    YModuleLogCallback _logCallback;
-    YModuleConfigChangeCallback _confChangeCallback;
-    YModuleBeaconCallback _beaconCallback;
-
-    friend YModule *yFindModule(const string& func);
-    friend YModule *yFirstModule(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindModule factory function to instantiate
-    YModule(const string& func);
-    //--- (end of generated code: YModule attributes)
-    //--- (generated code: YModule initialization)
-    //--- (end of generated code: YModule initialization)
-
-    // Method used to retrieve details of the nth function of our device
-    YRETCODE        _getFunction(int idx, string& serial, string& funcId, string& baseType, string& funcName, string& funcVal, string& errMsg);
-
-    static void _updateModuleCallbackList(YModule* func, bool add);
-
-public:
-    virtual ~YModule();
-
-    /**
-     * Returns a global identifier of the function in the format MODULE_NAME&#46;FUNCTION_NAME.
-     * The returned string uses the logical names of the module and of the function if they are defined,
-     * otherwise the serial number of the module and the hardware identifier of the function
-     * (for example: MyCustomName.relay1)
-     *
-     * @return a string that uniquely identifies the function using logical names
-     *         (ex: MyCustomName.relay1)
-     *
-     * On failure, throws an exception or returns  Y_FRIENDLYNAME_INVALID.
-     */
-    virtual string      get_friendlyName(void);
-
-
-    /**
-     * Returns the number of functions (beside the "module" interface) available on the module.
-     *
-     * @return the number of functions on the module
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             functionCount();
-
-    /**
-     * Retrieves the hardware identifier of the <i>n</i>th function on the module.
-     *
-     * @param functionIndex : the index of the function for which the information is desired, starting at
-     * 0 for the first function.
-     *
-     * @return a string corresponding to the unambiguous hardware identifier of the requested module function
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    string          functionId(int functionIndex);
-
-    /**
-     * Retrieves the logical name of the <i>n</i>th function on the module.
-     *
-     * @param functionIndex : the index of the function for which the information is desired, starting at
-     * 0 for the first function.
-     *
-     * @return a string corresponding to the logical name of the requested module function
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    string          functionName(int functionIndex);
-
-    /**
-     * Retrieves the advertised value of the <i>n</i>th function on the module.
-     *
-     * @param functionIndex : the index of the function for which the information is desired, starting at
-     * 0 for the first function.
-     *
-     * @return a short string (up to 6 characters) corresponding to the advertised value of the requested
-     * module function
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    string          functionValue(int functionIndex);
-
-    /**
-     * Retrieves the type of the <i>n</i>th function on the module.
-     *
-     * @param functionIndex : the index of the function for which the information is desired, starting at
-     * 0 for the first function.
-     *
-     * @return a string corresponding to the type of the function
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    string          functionType(int functionIndex);
-
-
-    /**
-     * Retrieves the base type of the <i>n</i>th function on the module.
-     * For instance, the base type of all measuring functions is "Sensor".
-     *
-     * @param functionIndex : the index of the function for which the information is desired, starting at
-     * 0 for the first function.
-     *
-     * @return a string corresponding to the base type of the function
-     *
-     * On failure, throws an exception or returns an empty string.
-     */
-    string          functionBaseType(int functionIndex);
-
-
-    void            setImmutableAttributes(yDeviceSt *infos);
-
-    //--- (generated code: YModule accessors declaration)
-
-    static const string PRODUCTNAME_INVALID;
-    static const string SERIALNUMBER_INVALID;
-    static const int PRODUCTID_INVALID = YAPI_INVALID_UINT;
-    static const int PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
-    static const string FIRMWARERELEASE_INVALID;
-    static const Y_PERSISTENTSETTINGS_enum PERSISTENTSETTINGS_LOADED = Y_PERSISTENTSETTINGS_LOADED;
-    static const Y_PERSISTENTSETTINGS_enum PERSISTENTSETTINGS_SAVED = Y_PERSISTENTSETTINGS_SAVED;
-    static const Y_PERSISTENTSETTINGS_enum PERSISTENTSETTINGS_MODIFIED = Y_PERSISTENTSETTINGS_MODIFIED;
-    static const Y_PERSISTENTSETTINGS_enum PERSISTENTSETTINGS_INVALID = Y_PERSISTENTSETTINGS_INVALID;
-    static const int LUMINOSITY_INVALID = YAPI_INVALID_UINT;
-    static const Y_BEACON_enum BEACON_OFF = Y_BEACON_OFF;
-    static const Y_BEACON_enum BEACON_ON = Y_BEACON_ON;
-    static const Y_BEACON_enum BEACON_INVALID = Y_BEACON_INVALID;
-    static const s64 UPTIME_INVALID = YAPI_INVALID_LONG;
-    static const int USBCURRENT_INVALID = YAPI_INVALID_UINT;
-    static const int REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
-    static const int USERVAR_INVALID = YAPI_INVALID_INT;
-
-    /**
-     * Returns the commercial name of the module, as set by the factory.
-     *
-     * @return a string corresponding to the commercial name of the module, as set by the factory
-     *
-     * On failure, throws an exception or returns Y_PRODUCTNAME_INVALID.
-     */
-    string              get_productName(void);
-
-    inline string       productName(void)
-    { return this->get_productName(); }
-
-    /**
-     * Returns the serial number of the module, as set by the factory.
-     *
-     * @return a string corresponding to the serial number of the module, as set by the factory
-     *
-     * On failure, throws an exception or returns Y_SERIALNUMBER_INVALID.
-     */
-    string              get_serialNumber(void);
-
-    inline string       serialNumber(void)
-    { return this->get_serialNumber(); }
-
-    /**
-     * Returns the USB device identifier of the module.
-     *
-     * @return an integer corresponding to the USB device identifier of the module
-     *
-     * On failure, throws an exception or returns Y_PRODUCTID_INVALID.
-     */
-    int                 get_productId(void);
-
-    inline int          productId(void)
-    { return this->get_productId(); }
-
-    /**
-     * Returns the hardware release version of the module.
-     *
-     * @return an integer corresponding to the hardware release version of the module
-     *
-     * On failure, throws an exception or returns Y_PRODUCTRELEASE_INVALID.
-     */
-    int                 get_productRelease(void);
-
-    inline int          productRelease(void)
-    { return this->get_productRelease(); }
-
-    /**
-     * Returns the version of the firmware embedded in the module.
-     *
-     * @return a string corresponding to the version of the firmware embedded in the module
-     *
-     * On failure, throws an exception or returns Y_FIRMWARERELEASE_INVALID.
-     */
-    string              get_firmwareRelease(void);
-
-    inline string       firmwareRelease(void)
-    { return this->get_firmwareRelease(); }
-
-    /**
-     * Returns the current state of persistent module settings.
-     *
-     * @return a value among Y_PERSISTENTSETTINGS_LOADED, Y_PERSISTENTSETTINGS_SAVED and
-     * Y_PERSISTENTSETTINGS_MODIFIED corresponding to the current state of persistent module settings
-     *
-     * On failure, throws an exception or returns Y_PERSISTENTSETTINGS_INVALID.
-     */
-    Y_PERSISTENTSETTINGS_enum get_persistentSettings(void);
-
-    inline Y_PERSISTENTSETTINGS_enum persistentSettings(void)
-    { return this->get_persistentSettings(); }
-
-    int             set_persistentSettings(Y_PERSISTENTSETTINGS_enum newval);
-    inline int      setPersistentSettings(Y_PERSISTENTSETTINGS_enum newval)
-    { return this->set_persistentSettings(newval); }
-
-    /**
-     * Returns the luminosity of the  module informative LEDs (from 0 to 100).
-     *
-     * @return an integer corresponding to the luminosity of the  module informative LEDs (from 0 to 100)
-     *
-     * On failure, throws an exception or returns Y_LUMINOSITY_INVALID.
-     */
-    int                 get_luminosity(void);
-
-    inline int          luminosity(void)
-    { return this->get_luminosity(); }
-
-    /**
-     * Changes the luminosity of the module informative leds. The parameter is a
-     * value between 0 and 100.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : an integer corresponding to the luminosity of the module informative leds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_luminosity(int newval);
-    inline int      setLuminosity(int newval)
-    { return this->set_luminosity(newval); }
-
-    /**
-     * Returns the state of the localization beacon.
-     *
-     * @return either Y_BEACON_OFF or Y_BEACON_ON, according to the state of the localization beacon
-     *
-     * On failure, throws an exception or returns Y_BEACON_INVALID.
-     */
-    Y_BEACON_enum       get_beacon(void);
-
-    inline Y_BEACON_enum beacon(void)
-    { return this->get_beacon(); }
-
-    /**
-     * Turns on or off the module localization beacon.
-     *
-     * @param newval : either Y_BEACON_OFF or Y_BEACON_ON
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_beacon(Y_BEACON_enum newval);
-    inline int      setBeacon(Y_BEACON_enum newval)
-    { return this->set_beacon(newval); }
-
-    /**
-     * Returns the number of milliseconds spent since the module was powered on.
-     *
-     * @return an integer corresponding to the number of milliseconds spent since the module was powered on
-     *
-     * On failure, throws an exception or returns Y_UPTIME_INVALID.
-     */
-    s64                 get_upTime(void);
-
-    inline s64          upTime(void)
-    { return this->get_upTime(); }
-
-    /**
-     * Returns the current consumed by the module on the USB bus, in milli-amps.
-     *
-     * @return an integer corresponding to the current consumed by the module on the USB bus, in milli-amps
-     *
-     * On failure, throws an exception or returns Y_USBCURRENT_INVALID.
-     */
-    int                 get_usbCurrent(void);
-
-    inline int          usbCurrent(void)
-    { return this->get_usbCurrent(); }
-
-    /**
-     * Returns the remaining number of seconds before the module restarts, or zero when no
-     * reboot has been scheduled.
-     *
-     * @return an integer corresponding to the remaining number of seconds before the module restarts, or zero when no
-     *         reboot has been scheduled
-     *
-     * On failure, throws an exception or returns Y_REBOOTCOUNTDOWN_INVALID.
-     */
-    int                 get_rebootCountdown(void);
-
-    inline int          rebootCountdown(void)
-    { return this->get_rebootCountdown(); }
-
-    int             set_rebootCountdown(int newval);
-    inline int      setRebootCountdown(int newval)
-    { return this->set_rebootCountdown(newval); }
-
-    /**
-     * Returns the value previously stored in this attribute.
-     * On startup and after a device reboot, the value is always reset to zero.
-     *
-     * @return an integer corresponding to the value previously stored in this attribute
-     *
-     * On failure, throws an exception or returns Y_USERVAR_INVALID.
-     */
-    int                 get_userVar(void);
-
-    inline int          userVar(void)
-    { return this->get_userVar(); }
-
-    /**
-     * Stores a 32 bit value in the device RAM. This attribute is at programmer disposal,
-     * should he need to store a state variable.
-     * On startup and after a device reboot, the value is always reset to zero.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_userVar(int newval);
-    inline int      setUserVar(int newval)
-    { return this->set_userVar(newval); }
-
-    /**
-     * Allows you to find a module from its serial number or from its logical name.
-     *
-     * This function does not require that the module is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YModule.isOnline() to test if the module is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a module by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string containing either the serial number or
-     *         the logical name of the desired module
-     *
-     * @return a YModule object allowing you to drive the module
-     *         or get additional information on the module.
-     */
-    static YModule*     FindModule(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YModuleValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Saves current settings in the nonvolatile memory of the module.
-     * Warning: the number of allowed save operations during a module life is
-     * limited (about 100000 cycles). Do not call this function within a loop.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         saveToFlash(void);
-
-    /**
-     * Reloads the settings stored in the nonvolatile memory, as
-     * when the module is powered on.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         revertFromFlash(void);
-
-    /**
-     * Schedules a simple module reboot after the given number of seconds.
-     *
-     * @param secBeforeReboot : number of seconds before rebooting
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reboot(int secBeforeReboot);
-
-    /**
-     * Schedules a module reboot into special firmware update mode.
-     *
-     * @param secBeforeReboot : number of seconds before rebooting
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerFirmwareUpdate(int secBeforeReboot);
-
-    virtual void        _startStopDevLog(string serial,bool start);
-
-    /**
-     * Registers a device log callback function. This callback will be called each time
-     * that a module sends a new log message. Mostly useful to debug a Yoctopuce module.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the module object that emitted the log message, and the character string containing the log.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         registerLogCallback(YModuleLogCallback callback);
-
-    virtual YModuleLogCallback get_logCallback(void);
-
-    /**
-     * Register a callback function, to be called when a persistent settings in
-     * a device configuration has been changed (e.g. change of unit, etc).
-     *
-     * @param callback : a procedure taking a YModule parameter, or NULL
-     *         to unregister a previously registered  callback.
-     */
-    virtual int         registerConfigChangeCallback(YModuleConfigChangeCallback callback);
-
-    virtual int         _invokeConfigChangeCallback(void);
-
-    /**
-     * Register a callback function, to be called when the localization beacon of the module
-     * has been changed. The callback function should take two arguments: the YModule object of
-     * which the beacon has changed, and an integer describing the new beacon state.
-     *
-     * @param callback : The callback function to call, or NULL to unregister a
-     *         previously registered callback.
-     */
-    virtual int         registerBeaconCallback(YModuleBeaconCallback callback);
-
-    virtual int         _invokeBeaconCallback(int beaconState);
-
-    /**
-     * Triggers a configuration change callback, to check if they are supported or not.
-     */
-    virtual int         triggerConfigChangeCallback(void);
-
-    /**
-     * Tests whether the byn file is valid for this module. This method is useful to test if the module
-     * needs to be updated.
-     * It is possible to pass a directory as argument instead of a file. In this case, this method returns
-     * the path of the most recent
-     * appropriate .byn file. If the parameter onlynew is true, the function discards firmwares that are older or
-     * equal to the installed firmware.
-     *
-     * @param path : the path of a byn file or a directory that contains byn files
-     * @param onlynew : returns only files that are strictly newer
-     *
-     * @return the path of the byn file to use or a empty string if no byn files matches the requirement
-     *
-     * On failure, throws an exception or returns a string that start with "error:".
-     */
-    virtual string      checkFirmware(string path,bool onlynew);
-
-    /**
-     * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
-     * handles the firmware update process.
-     *
-     * @param path : the path of the .byn file to use.
-     * @param force : true to force the firmware update even if some prerequisites appear not to be met
-     *
-     * @return a YFirmwareUpdate object or NULL on error.
-     */
-    virtual YFirmwareUpdate updateFirmwareEx(string path,bool force);
-
-    /**
-     * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
-     * handles the firmware update process.
-     *
-     * @param path : the path of the .byn file to use.
-     *
-     * @return a YFirmwareUpdate object or NULL on error.
-     */
-    virtual YFirmwareUpdate updateFirmware(string path);
-
-    /**
-     * Returns all the settings and uploaded files of the module. Useful to backup all the
-     * logical names, calibrations parameters, and uploaded files of a device.
-     *
-     * @return a binary buffer with all the settings.
-     *
-     * On failure, throws an exception or returns an binary object of size 0.
-     */
-    virtual string      get_allSettings(void);
-
-    virtual int         loadThermistorExtra(string funcId,string jsonExtra);
-
-    virtual int         set_extraSettings(string jsonExtra);
-
-    /**
-     * Restores all the settings and uploaded files to the module.
-     * This method is useful to restore all the logical names and calibrations parameters,
-     * uploaded files etc. of a device from a backup.
-     * Remember to call the saveToFlash() method of the module if the
-     * modifications must be kept.
-     *
-     * @param settings : a binary buffer with all the settings.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_allSettingsAndFiles(string settings);
-
-    /**
-     * Tests if the device includes a specific function. This method takes a function identifier
-     * and returns a boolean.
-     *
-     * @param funcId : the requested function identifier
-     *
-     * @return true if the device has the function identifier
-     */
-    virtual bool        hasFunction(string funcId);
-
-    /**
-     * Retrieve all hardware identifier that match the type passed in argument.
-     *
-     * @param funType : The type of function (Relay, LightSensor, Voltage,...)
-     *
-     * @return an array of strings.
-     */
-    virtual vector<string> get_functionIds(string funType);
-
-    virtual string      _flattenJsonStruct(string jsoncomplex);
-
-    virtual int         calibVersion(string cparams);
-
-    virtual int         calibScale(string unit_name,string sensorType);
-
-    virtual int         calibOffset(string unit_name);
-
-    virtual string      calibConvert(string param,string currentFuncValue,string unit_name,string sensorType);
-
-    /**
-     * Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters
-     * of a module from a backup.Remember to call the saveToFlash() method of the module if the
-     * modifications must be kept.
-     *
-     * @param settings : a binary buffer with all the settings.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_allSettings(string settings);
-
-    /**
-     * Returns the unique hardware identifier of the module.
-     * The unique hardware identifier is made of the device serial
-     * number followed by string ".module".
-     *
-     * @return a string that uniquely identifies the module
-     */
-    virtual string      get_hardwareId(void);
-
-    /**
-     * Downloads the specified built-in file and returns a binary buffer with its content.
-     *
-     * @param pathname : name of the new file to load
-     *
-     * @return a binary buffer with the file content
-     *
-     * On failure, throws an exception or returns  YAPI_INVALID_STRING.
-     */
-    virtual string      download(string pathname);
-
-    /**
-     * Returns the icon of the module. The icon is a PNG image and does not
-     * exceeds 1536 bytes.
-     *
-     * @return a binary buffer with module icon, in png format.
-     *         On failure, throws an exception or returns  YAPI_INVALID_STRING.
-     */
-    virtual string      get_icon2d(void);
-
-    /**
-     * Returns a string with last logs of the module. This method return only
-     * logs that are still in the module.
-     *
-     * @return a string with last logs of the module.
-     *         On failure, throws an exception or returns  YAPI_INVALID_STRING.
-     */
-    virtual string      get_lastLogs(void);
-
-    /**
-     * Adds a text message to the device logs. This function is useful in
-     * particular to trace the execution of HTTP callbacks. If a newline
-     * is desired after the message, it must be included in the string.
-     *
-     * @param text : the string to append to the logs.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         log(string text);
-
-    /**
-     * Returns a list of all the modules that are plugged into the current module.
-     * This method only makes sense when called for a YoctoHub/VirtualHub.
-     * Otherwise, an empty array will be returned.
-     *
-     * @return an array of strings containing the sub modules.
-     */
-    virtual vector<string> get_subDevices(void);
-
-    /**
-     * Returns the serial number of the YoctoHub on which this module is connected.
-     * If the module is connected by USB, or if the module is the root YoctoHub, an
-     * empty string is returned.
-     *
-     * @return a string with the serial number of the YoctoHub or an empty string
-     */
-    virtual string      get_parentHub(void);
-
-    /**
-     * Returns the URL used to access the module. If the module is connected by USB, the
-     * string 'usb' is returned.
-     *
-     * @return a string with the URL of the module.
-     */
-    virtual string      get_url(void);
-
-
-    inline static YModule* Find(string func)
-    { return YModule::FindModule(func); }
-
-    /**
-     * Continues the module enumeration started using yFirstModule().
-     * Caution: You can't make any assumption about the returned modules order.
-     * If you want to find a specific module, use Module.findModule()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YModule object, corresponding to
-     *         the next module found, or a NULL pointer
-     *         if there are no more modules to enumerate.
-     */
-           YModule         *nextModule(void);
-    inline YModule         *next(void)
-    { return this->nextModule();}
-
-    /**
-     * Starts the enumeration of modules currently accessible.
-     * Use the method YModule.nextModule() to iterate on the
-     * next modules.
-     *
-     * @return a pointer to a YModule object, corresponding to
-     *         the first module currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YModule* FirstModule(void);
-    inline static YModule* First(void)
-    { return YModule::FirstModule();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YModule accessors declaration)
-};
-
-
-
-
-//--- (generated code: YSensor declaration)
-/**
- * YSensor Class: Sensor function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YSensor: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YSensor declaration)
-protected:
-    //--- (generated code: YSensor attributes)
-    // Attributes (function value cache)
-    string          _unit;
-    double          _currentValue;
-    double          _lowestValue;
-    double          _highestValue;
-    double          _currentRawValue;
-    string          _logFrequency;
-    string          _reportFrequency;
-    Y_ADVMODE_enum  _advMode;
-    string          _calibrationParam;
-    double          _resolution;
-    int             _sensorState;
-    YSensorValueCallback _valueCallbackSensor;
-    YSensorTimedReportCallback _timedReportCallbackSensor;
-    double          _prevTimedReport;
-    double          _iresol;
-    double          _offset;
-    double          _scale;
-    double          _decexp;
-    int             _caltyp;
-    vector<int>     _calpar;
-    vector<double>  _calraw;
-    vector<double>  _calref;
-    yCalibrationHandler _calhdl;
-
-    friend YSensor *yFindSensor(const string& func);
-    friend YSensor *yFirstSensor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindSensor factory function to instantiate
-    YSensor(const string& func);
-    //--- (end of generated code: YSensor attributes)
-
-    //--- (generated code: YSensor initialization)
-    //--- (end of generated code: YSensor initialization)
-
-public:
-    virtual ~YSensor();
-    //--- (generated code: YSensor accessors declaration)
-
-    static const string UNIT_INVALID;
-    static const double CURRENTVALUE_INVALID;
-    static const double LOWESTVALUE_INVALID;
-    static const double HIGHESTVALUE_INVALID;
-    static const double CURRENTRAWVALUE_INVALID;
-    static const string LOGFREQUENCY_INVALID;
-    static const string REPORTFREQUENCY_INVALID;
-    static const Y_ADVMODE_enum ADVMODE_IMMEDIATE = Y_ADVMODE_IMMEDIATE;
-    static const Y_ADVMODE_enum ADVMODE_PERIOD_AVG = Y_ADVMODE_PERIOD_AVG;
-    static const Y_ADVMODE_enum ADVMODE_PERIOD_MIN = Y_ADVMODE_PERIOD_MIN;
-    static const Y_ADVMODE_enum ADVMODE_PERIOD_MAX = Y_ADVMODE_PERIOD_MAX;
-    static const Y_ADVMODE_enum ADVMODE_INVALID = Y_ADVMODE_INVALID;
-    static const string CALIBRATIONPARAM_INVALID;
-    static const double RESOLUTION_INVALID;
-    static const int SENSORSTATE_INVALID = YAPI_INVALID_INT;
-
-    /**
-     * Returns the measuring unit for the measure.
-     *
-     * @return a string corresponding to the measuring unit for the measure
-     *
-     * On failure, throws an exception or returns Y_UNIT_INVALID.
-     */
-    string              get_unit(void);
-
-    inline string       unit(void)
-    { return this->get_unit(); }
-
-    /**
-     * Returns the current value of the measure, in the specified unit, as a floating point number.
-     *
-     * @return a floating point number corresponding to the current value of the measure, in the specified
-     * unit, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_CURRENTVALUE_INVALID.
-     */
-    double              get_currentValue(void);
-
-    inline double       currentValue(void)
-    { return this->get_currentValue(); }
-
-    /**
-     * Changes the recorded minimal value observed. Can be used to reset the value returned
-     * by get_lowestValue().
-     *
-     * @param newval : a floating point number corresponding to the recorded minimal value observed
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_lowestValue(double newval);
-    inline int      setLowestValue(double newval)
-    { return this->set_lowestValue(newval); }
-
-    /**
-     * Returns the minimal value observed for the measure since the device was started.
-     * Can be reset to an arbitrary value thanks to set_lowestValue().
-     *
-     * @return a floating point number corresponding to the minimal value observed for the measure since
-     * the device was started
-     *
-     * On failure, throws an exception or returns Y_LOWESTVALUE_INVALID.
-     */
-    double              get_lowestValue(void);
-
-    inline double       lowestValue(void)
-    { return this->get_lowestValue(); }
-
-    /**
-     * Changes the recorded maximal value observed. Can be used to reset the value returned
-     * by get_lowestValue().
-     *
-     * @param newval : a floating point number corresponding to the recorded maximal value observed
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_highestValue(double newval);
-    inline int      setHighestValue(double newval)
-    { return this->set_highestValue(newval); }
-
-    /**
-     * Returns the maximal value observed for the measure since the device was started.
-     * Can be reset to an arbitrary value thanks to set_highestValue().
-     *
-     * @return a floating point number corresponding to the maximal value observed for the measure since
-     * the device was started
-     *
-     * On failure, throws an exception or returns Y_HIGHESTVALUE_INVALID.
-     */
-    double              get_highestValue(void);
-
-    inline double       highestValue(void)
-    { return this->get_highestValue(); }
-
-    /**
-     * Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a
-     * floating point number.
-     *
-     * @return a floating point number corresponding to the uncalibrated, unrounded raw value returned by
-     * the sensor, in the specified unit, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_CURRENTRAWVALUE_INVALID.
-     */
-    double              get_currentRawValue(void);
-
-    inline double       currentRawValue(void)
-    { return this->get_currentRawValue(); }
-
-    /**
-     * Returns the datalogger recording frequency for this function, or "OFF"
-     * when measures are not stored in the data logger flash memory.
-     *
-     * @return a string corresponding to the datalogger recording frequency for this function, or "OFF"
-     *         when measures are not stored in the data logger flash memory
-     *
-     * On failure, throws an exception or returns Y_LOGFREQUENCY_INVALID.
-     */
-    string              get_logFrequency(void);
-
-    inline string       logFrequency(void)
-    { return this->get_logFrequency(); }
-
-    /**
-     * Changes the datalogger recording frequency for this function.
-     * The frequency can be specified as samples per second,
-     * as sample per minute (for instance "15/m") or in samples per
-     * hour (eg. "4/h"). To disable recording for this function, use
-     * the value "OFF". Note that setting the  datalogger recording frequency
-     * to a greater value than the sensor native sampling frequency is unless,
-     * and even counterproductive: those two frequencies are not related.
-     *
-     * @param newval : a string corresponding to the datalogger recording frequency for this function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_logFrequency(const string& newval);
-    inline int      setLogFrequency(const string& newval)
-    { return this->set_logFrequency(newval); }
-
-    /**
-     * Returns the timed value notification frequency, or "OFF" if timed
-     * value notifications are disabled for this function.
-     *
-     * @return a string corresponding to the timed value notification frequency, or "OFF" if timed
-     *         value notifications are disabled for this function
-     *
-     * On failure, throws an exception or returns Y_REPORTFREQUENCY_INVALID.
-     */
-    string              get_reportFrequency(void);
-
-    inline string       reportFrequency(void)
-    { return this->get_reportFrequency(); }
-
-    /**
-     * Changes the timed value notification frequency for this function.
-     * The frequency can be specified as samples per second,
-     * as sample per minute (for instance "15/m") or in samples per
-     * hour (e.g. "4/h"). To disable timed value notifications for this
-     * function, use the value "OFF". Note that setting the  timed value
-     * notification frequency to a greater value than the sensor native
-     * sampling frequency is unless, and even counterproductive: those two
-     * frequencies are not related.
-     *
-     * @param newval : a string corresponding to the timed value notification frequency for this function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_reportFrequency(const string& newval);
-    inline int      setReportFrequency(const string& newval)
-    { return this->set_reportFrequency(newval); }
-
-    /**
-     * Returns the measuring mode used for the advertised value pushed to the parent hub.
-     *
-     * @return a value among Y_ADVMODE_IMMEDIATE, Y_ADVMODE_PERIOD_AVG, Y_ADVMODE_PERIOD_MIN and
-     * Y_ADVMODE_PERIOD_MAX corresponding to the measuring mode used for the advertised value pushed to the parent hub
-     *
-     * On failure, throws an exception or returns Y_ADVMODE_INVALID.
-     */
-    Y_ADVMODE_enum      get_advMode(void);
-
-    inline Y_ADVMODE_enum advMode(void)
-    { return this->get_advMode(); }
-
-    /**
-     * Changes the measuring mode used for the advertised value pushed to the parent hub.
-     *
-     * @param newval : a value among Y_ADVMODE_IMMEDIATE, Y_ADVMODE_PERIOD_AVG, Y_ADVMODE_PERIOD_MIN and
-     * Y_ADVMODE_PERIOD_MAX corresponding to the measuring mode used for the advertised value pushed to the parent hub
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_advMode(Y_ADVMODE_enum newval);
-    inline int      setAdvMode(Y_ADVMODE_enum newval)
-    { return this->set_advMode(newval); }
-
-    string              get_calibrationParam(void);
-
-    inline string       calibrationParam(void)
-    { return this->get_calibrationParam(); }
-
-    int             set_calibrationParam(const string& newval);
-    inline int      setCalibrationParam(const string& newval)
-    { return this->set_calibrationParam(newval); }
-
-    /**
-     * Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision
-     * when displaying value. It does not change the precision of the measure itself.
-     *
-     * @param newval : a floating point number corresponding to the resolution of the measured physical values
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_resolution(double newval);
-    inline int      setResolution(double newval)
-    { return this->set_resolution(newval); }
-
-    /**
-     * Returns the resolution of the measured values. The resolution corresponds to the numerical precision
-     * of the measures, which is not always the same as the actual precision of the sensor.
-     *
-     * @return a floating point number corresponding to the resolution of the measured values
-     *
-     * On failure, throws an exception or returns Y_RESOLUTION_INVALID.
-     */
-    double              get_resolution(void);
-
-    inline double       resolution(void)
-    { return this->get_resolution(); }
-
-    /**
-     * Returns the sensor health state code, which is zero when there is an up-to-date measure
-     * available or a positive code if the sensor is not able to provide a measure right now.
-     *
-     * @return an integer corresponding to the sensor health state code, which is zero when there is an
-     * up-to-date measure
-     *         available or a positive code if the sensor is not able to provide a measure right now
-     *
-     * On failure, throws an exception or returns Y_SENSORSTATE_INVALID.
-     */
-    int                 get_sensorState(void);
-
-    inline int          sensorState(void)
-    { return this->get_sensorState(); }
-
-    /**
-     * Retrieves a sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YSensor.isOnline() to test if the sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the sensor
-     *
-     * @return a YSensor object allowing you to drive the sensor.
-     */
-    static YSensor*     FindSensor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YSensorValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         _parserHelper(void);
-
-    /**
-     * Checks if the sensor is currently able to provide an up-to-date measure.
-     * Returns false if the device is unreachable, or if the sensor does not have
-     * a current measure to transmit. No exception is raised if there is an error
-     * while trying to contact the device hosting $THEFUNCTION$.
-     *
-     * @return true if the sensor can provide an up-to-date measure, and false otherwise
-     */
-    virtual bool        isSensorReady(void);
-
-    /**
-     * Returns the YDatalogger object of the device hosting the sensor. This method returns an object of
-     * class YDatalogger that can control global parameters of the data logger. The returned object
-     * should not be freed.
-     *
-     * @return an YDataLogger object or NULL on error.
-     */
-    virtual YDataLogger* get_dataLogger(void);
-
-    /**
-     * Starts the data logger on the device. Note that the data logger
-     * will only save the measures on this sensor if the logFrequency
-     * is not set to "OFF".
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     */
-    virtual int         startDataLogger(void);
-
-    /**
-     * Stops the datalogger on the device.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     */
-    virtual int         stopDataLogger(void);
-
-    /**
-     * Retrieves a DataSet object holding historical data for this
-     * sensor, for a specified time interval. The measures will be
-     * retrieved from the data logger, which must have been turned
-     * on at the desired time. See the documentation of the DataSet
-     * class for information on how to get an overview of the
-     * recorded data, and how to load progressively a large set
-     * of measures from the data logger.
-     *
-     * This function only works if the device uses a recent firmware,
-     * as DataSet objects are not supported by firmwares older than
-     * version 13000.
-     *
-     * @param startTime : the start of the desired measure time interval,
-     *         as a Unix timestamp, i.e. the number of seconds since
-     *         January 1, 1970 UTC. The special value 0 can be used
-     *         to include any measure, without initial limit.
-     * @param endTime : the end of the desired measure time interval,
-     *         as a Unix timestamp, i.e. the number of seconds since
-     *         January 1, 1970 UTC. The special value 0 can be used
-     *         to include any measure, without ending limit.
-     *
-     * @return an instance of YDataSet, providing access to historical
-     *         data. Past measures can be loaded progressively
-     *         using methods from the YDataSet object.
-     */
-    virtual YDataSet    get_recordedData(double startTime,double endTime);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YSensorTimedReportCallback callback);
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Configures error correction data points, in particular to compensate for
-     * a possible perturbation of the measure caused by an enclosure. It is possible
-     * to configure up to five correction points. Correction points must be provided
-     * in ascending order, and be in the range of the sensor. The device will automatically
-     * perform a linear interpolation of the error correction between specified
-     * points. Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * For more information on advanced capabilities to refine the calibration of
-     * sensors, please contact support@yoctopuce.com.
-     *
-     * @param rawValues : array of floating point numbers, corresponding to the raw
-     *         values returned by the sensor for the correction points.
-     * @param refValues : array of floating point numbers, corresponding to the corrected
-     *         values for the correction points.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         calibrateFromPoints(vector<double> rawValues,vector<double> refValues);
-
-    /**
-     * Retrieves error correction data points previously entered using the method
-     * calibrateFromPoints.
-     *
-     * @param rawValues : array of floating point numbers, that will be filled by the
-     *         function with the raw sensor values for the correction points.
-     * @param refValues : array of floating point numbers, that will be filled by the
-     *         function with the desired values for the correction points.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadCalibrationPoints(vector<double>& rawValues,vector<double>& refValues);
-
-    virtual string      _encodeCalibrationPoints(vector<double> rawValues,vector<double> refValues);
-
-    virtual double      _applyCalibration(double rawValue);
-
-    virtual YMeasure    _decodeTimedReport(double timestamp,double duration,vector<int> report);
-
-    virtual double      _decodeVal(int w);
-
-    virtual double      _decodeAvg(int dw);
-
-
-    inline static YSensor* Find(string func)
-    { return YSensor::FindSensor(func); }
-
-    /**
-     * Continues the enumeration of sensors started using yFirstSensor().
-     * Caution: You can't make any assumption about the returned sensors order.
-     * If you want to find a specific a sensor, use Sensor.findSensor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YSensor object, corresponding to
-     *         a sensor currently online, or a NULL pointer
-     *         if there are no more sensors to enumerate.
-     */
-           YSensor         *nextSensor(void);
-    inline YSensor         *next(void)
-    { return this->nextSensor();}
-
-    /**
-     * Starts the enumeration of sensors currently accessible.
-     * Use the method YSensor.nextSensor() to iterate on
-     * next sensors.
-     *
-     * @return a pointer to a YSensor object, corresponding to
-     *         the first sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YSensor* FirstSensor(void);
-    inline static YSensor* First(void)
-    { return YSensor::FirstSensor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YSensor accessors declaration)
-    
-    
-    YDataSet get_recordedData(s64 startTime, s64 endTime);
-    YDataSet get_recordedData(int startTime, int endTime);
-
-
-};
-
-//--- (generated code: YSensor functions declaration)
-
-/**
- * Retrieves a sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSensor.isOnline() to test if the sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the sensor
- *
- * @return a YSensor object allowing you to drive the sensor.
- */
-inline YSensor* yFindSensor(const string& func)
-{ return YSensor::FindSensor(func);}
-/**
- * Starts the enumeration of sensors currently accessible.
- * Use the method YSensor.nextSensor() to iterate on
- * next sensors.
- *
- * @return a pointer to a YSensor object, corresponding to
- *         the first sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YSensor* yFirstSensor(void)
-{ return YSensor::FirstSensor();}
-
-//--- (end of generated code: YSensor functions declaration)
-
-
-inline string yGetAPIVersion()
-{ return YAPI::GetAPIVersion(); }
-
-
-
-/**
- * Initializes the Yoctopuce programming library explicitly.
- * It is not strictly needed to call yInitAPI(), as the library is
- * automatically  initialized when calling yRegisterHub() for the
- * first time.
- *
- * When Y_DETECT_NONE is used as detection mode,
- * you must explicitly use yRegisterHub() to point the API to the
- * VirtualHub on which your devices are connected before trying to access them.
- *
- * @param mode : an integer corresponding to the type of automatic
- *         device detection to use. Possible values are
- *         Y_DETECT_NONE, Y_DETECT_USB, Y_DETECT_NET,
- *         and Y_DETECT_ALL.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yInitAPI(int mode, string& errmsg)
-{ return YAPI::InitAPI(mode,errmsg); }
-
-/**
- * Frees dynamically allocated memory blocks used by the Yoctopuce library.
- * It is generally not required to call this function, unless you
- * want to free all dynamically allocated memory blocks in order to
- * track a memory leak for instance.
- * You should not call any other library function after calling
- * yFreeAPI(), or your program will crash.
- */
-inline void yFreeAPI()
-{ YAPI::FreeAPI(); }
-
-/**
- * Disables the use of exceptions to report runtime errors.
- * When exceptions are disabled, every function returns a specific
- * error value which depends on its type and which is documented in
- * this reference manual.
- */
-inline void yDisableExceptions(void)
-{ YAPI::DisableExceptions(); }
-
-/**
- * Re-enables the use of exceptions for runtime error handling.
- * Be aware than when exceptions are enabled, every function that fails
- * triggers an exception. If the exception is not caught by the user code,
- * it  either fires the debugger or aborts (i.e. crash) the program.
- * On failure, throws an exception or returns a negative error code.
- */
-inline void yEnableExceptions(void)
-{ YAPI::EnableExceptions(); }
-
-/**
- * Registers a log callback function. This callback will be called each time
- * the API have something to say. Quite useful to debug the API.
- *
- * @param logfun : a procedure taking a string parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-inline void yRegisterLogFunction(yLogFunction logfun)
-{ YAPI::RegisterLogFunction(logfun); }
-
-/**
- * Register a callback function, to be called each time
- * a device is plugged. This callback will be invoked while yUpdateDeviceList
- * is running. You will have to call this function on a regular basis.
- *
- * @param arrivalCallback : a procedure taking a YModule parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-inline void yRegisterDeviceArrivalCallback(yDeviceUpdateCallback arrivalCallback)
-{ YAPI::RegisterDeviceArrivalCallback(arrivalCallback); }
-
-/**
- * Register a callback function, to be called each time
- * a device is unplugged. This callback will be invoked while yUpdateDeviceList
- * is running. You will have to call this function on a regular basis.
- *
- * @param removalCallback : a procedure taking a YModule parameter, or NULL
- *         to unregister a previously registered  callback.
- */
-inline void yRegisterDeviceRemovalCallback(yDeviceUpdateCallback removalCallback)
-{ YAPI::RegisterDeviceRemovalCallback(removalCallback); }
-
-inline void yRegisterDeviceChangeCallback(yDeviceUpdateCallback removalCallback)
-{ YAPI::RegisterDeviceChangeCallback(removalCallback); }
-
-
-/**
- * Register a callback function, to be called each time an Network Hub send
- * an SSDP message. The callback has two string parameter, the first one
- * contain the serial number of the hub and the second contain the URL of the
- * network hub (this URL can be passed to RegisterHub). This callback will be invoked
- * while yUpdateDeviceList is running. You will have to call this function on a regular basis.
- *
- * @param hubDiscoveryCallback : a procedure taking two string parameter, the serial
- *         number and the hub URL. Use NULL to unregister a previously registered  callback.
- */
-inline void yRegisterHubDiscoveryCallback(YHubDiscoveryCallback hubDiscoveryCallback)
-{
-	YAPI::RegisterHubDiscoveryCallback(hubDiscoveryCallback);
-}
-
-/**
- * Force a hub discovery, if a callback as been registered with yRegisterHubDiscoveryCallback it
- * will be called for each net work hub that will respond to the discovery.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yTriggerHubDiscovery(string& errmsg)
-{
-	return YAPI::TriggerHubDiscovery(errmsg);
-}
-
-
-// Register a new value calibration handler for a given calibration type
-//
-inline void yRegisterCalibrationHandler(int calibrationType, yCalibrationHandler calibrationHandler)
-{ YAPI::RegisterCalibrationHandler(calibrationType, calibrationHandler); }
-
-/**
- * Setup the Yoctopuce library to use modules connected on a given machine. The
- * parameter will determine how the API will work. Use the following values:
- *
- * <b>usb</b>: When the usb keyword is used, the API will work with
- * devices connected directly to the USB bus. Some programming languages such a JavaScript,
- * PHP, and Java don't provide direct access to USB hardware, so usb will
- * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
- *
- * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
- * host with the given IP address or hostname. That host can be a regular computer
- * running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or
- * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
- * computer, use the IP address 127.0.0.1.
- *
- * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
- * This a special mode allowing to take control of Yoctopuce devices
- * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
- * need to configure your hub to call your server script on a regular basis.
- * This mode is currently available for PHP and Node.JS only.
- *
- * Be aware that only one application can use direct USB access at a
- * given time on a machine. Multiple access would cause conflicts
- * while trying to access the USB modules. In particular, this means
- * that you must stop the VirtualHub software before starting
- * an application that uses direct USB access. The workaround
- * for this limitation is to setup the library to use the VirtualHub
- * rather than direct USB access.
- *
- * If access control has been activated on the hub, virtual or not, you want to
- * reach, the URL parameter should look like:
- *
- * http://username:password@address:port
- *
- * You can call <i>RegisterHub</i> several times to connect to several machines.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yRegisterHub(const string& url, string& errmsg)
-{ return YAPI::RegisterHub(url,errmsg); }
-
-/**
- * Fault-tolerant alternative to RegisterHub(). This function has the same
- * purpose and same arguments as RegisterHub(), but does not trigger
- * an error when the selected hub is not available at the time of the function call.
- * This makes it possible to register a network hub independently of the current
- * connectivity, and to try to contact it only when a device is actively needed.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yPreregisterHub(const string& url, string& errmsg)
-{ return YAPI::PreregisterHub(url,errmsg); }
-
-/**
- * Setup the Yoctopuce library to no more use modules connected on a previously
- * registered machine with RegisterHub.
- *
- * @param url : a string containing either "usb" or the
- *         root URL of the hub to monitor
- */
-inline void yUnregisterHub(const string& url)
-{ YAPI::UnregisterHub(url); }
-
-/**
- * Test if the hub is reachable. This method do not register the hub, it only test if the
- * hub is usable. The url parameter follow the same convention as the RegisterHub
- * method. This method is useful to verify the authentication parameters for a hub. It
- * is possible to force this method to return after mstimeout milliseconds.
- *
- * @param url : a string containing either "usb","callback" or the
- *         root URL of the hub to monitor
- * @param mstimeout : the number of millisecond available to test the connection.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure returns a negative error code.
- */
-inline YRETCODE yTestHub(const string& url, int mstimeout, string& errmsg)
-{ return YAPI::TestHub(url, mstimeout, errmsg); }
-
-/**
- * Triggers a (re)detection of connected Yoctopuce modules.
- * The library searches the machines or USB ports previously registered using
- * yRegisterHub(), and invokes any user-defined callback function
- * in case a change in the list of connected devices is detected.
- *
- * This function can be called as frequently as desired to refresh the device list
- * and to make the application aware of hot-plug events. However, since device
- * detection is quite a heavy process, UpdateDeviceList shouldn't be called more
- * than once every two seconds.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yUpdateDeviceList(string& errmsg)
-{ return YAPI::UpdateDeviceList(errmsg); }
-
-/**
- * Maintains the device-to-library communication channel.
- * If your program includes significant loops, you may want to include
- * a call to this function to make sure that the library takes care of
- * the information pushed by the modules on the communication channels.
- * This is not strictly necessary, but it may improve the reactivity
- * of the library for the following commands.
- *
- * This function may signal an error in case there is a communication problem
- * while contacting a module.
- *
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE yHandleEvents(string& errmsg)
-{ return YAPI::HandleEvents(errmsg); }
-
-/**
- * Pauses the execution flow for a specified duration.
- * This function implements a passive waiting loop, meaning that it does not
- * consume CPU cycles significantly. The processor is left available for
- * other threads and processes. During the pause, the library nevertheless
- * reads from time to time information from the Yoctopuce modules by
- * calling yHandleEvents(), in order to stay up-to-date.
- *
- * This function may signal an error in case there is a communication problem
- * while contacting a module.
- *
- * @param ms_duration : an integer corresponding to the duration of the pause,
- *         in milliseconds.
- * @param errmsg : a string passed by reference to receive any error message.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-inline YRETCODE ySleep(unsigned ms_duration, string& errmsg)
-{ return YAPI::Sleep(ms_duration, errmsg); }
-
-/**
- * Returns the current value of a monotone millisecond-based time counter.
- * This counter can be used to compute delays in relation with
- * Yoctopuce devices, which also uses the millisecond as timebase.
- *
- * @return a long integer corresponding to the millisecond counter.
- */
-inline u64 yGetTickCount(void)
-{ return YAPI::GetTickCount(); }
-
-/**
- * Checks if a given string is valid as logical name for a module or a function.
- * A valid logical name has a maximum of 19 characters, all among
- * A..Z, a..z, 0..9, _, and -.
- * If you try to configure a logical name with an incorrect string,
- * the invalid characters are ignored.
- *
- * @param name : a string containing the name to check.
- *
- * @return true if the name is valid, false otherwise.
- */
-inline bool yCheckLogicalName(const string& name)
-{ return YAPI::CheckLogicalName(name); }
-
-//--- (generated code: YModule functions declaration)
-
-/**
- * Allows you to find a module from its serial number or from its logical name.
- *
- * This function does not require that the module is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YModule.isOnline() to test if the module is
- * indeed online at a given time. In case of ambiguity when looking for
- * a module by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string containing either the serial number or
- *         the logical name of the desired module
- *
- * @return a YModule object allowing you to drive the module
- *         or get additional information on the module.
- */
-inline YModule* yFindModule(const string& func)
-{ return YModule::FindModule(func);}
-/**
- * Starts the enumeration of modules currently accessible.
- * Use the method YModule.nextModule() to iterate on the
- * next modules.
- *
- * @return a pointer to a YModule object, corresponding to
- *         the first module currently online, or a NULL pointer
- *         if there are none.
- */
-inline YModule* yFirstModule(void)
-{ return YModule::FirstModule();}
-
-//--- (end of generated code: YModule functions declaration)
-
-
-//--- (generated code: YDataLogger declaration)
-/**
- * YDataLogger Class: DataLogger function interface
- *
- * Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured
- * data automatically, without requiring a permanent connection to a computer.
- * The DataLogger function controls the global parameters of the internal data
- * logger. Recording control (start/stop) as well as data retreival is done at
- * sensor objects level.
- */
-class YOCTO_CLASS_EXPORT YDataLogger: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YDataLogger declaration)
-    //--- (generated code: YDataLogger attributes)
-    // Attributes (function value cache)
-    int             _currentRunIndex;
-    s64             _timeUTC;
-    Y_RECORDING_enum _recording;
-    Y_AUTOSTART_enum _autoStart;
-    Y_BEACONDRIVEN_enum _beaconDriven;
-    int             _usage;
-    Y_CLEARHISTORY_enum _clearHistory;
-    YDataLoggerValueCallback _valueCallbackDataLogger;
-
-    friend YDataLogger *yFindDataLogger(const string& func);
-    friend YDataLogger *yFirstDataLogger(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindDataLogger factory function to instantiate
-    YDataLogger(const string& func);
-    //--- (end of generated code: YDataLogger attributes)
-    //--- (generated code: YDataLogger initialization)
-    //--- (end of generated code: YDataLogger initialization)
-
-    // device-specific URL to access the datalogger
-    string          dataLoggerURL;
-
-    // DataLogger-specific method to retrieve and pre-parse recorded data
-    int             getData(unsigned runIdx, unsigned timeIdx, string &buffer, yJsonStateMachine &j);
-
-public:
-    virtual ~YDataLogger();
-
-
-    //--- (generated code: YDataLogger accessors declaration)
-
-    static const int CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
-    static const s64 TIMEUTC_INVALID = YAPI_INVALID_LONG;
-    static const Y_RECORDING_enum RECORDING_OFF = Y_RECORDING_OFF;
-    static const Y_RECORDING_enum RECORDING_ON = Y_RECORDING_ON;
-    static const Y_RECORDING_enum RECORDING_PENDING = Y_RECORDING_PENDING;
-    static const Y_RECORDING_enum RECORDING_INVALID = Y_RECORDING_INVALID;
-    static const Y_AUTOSTART_enum AUTOSTART_OFF = Y_AUTOSTART_OFF;
-    static const Y_AUTOSTART_enum AUTOSTART_ON = Y_AUTOSTART_ON;
-    static const Y_AUTOSTART_enum AUTOSTART_INVALID = Y_AUTOSTART_INVALID;
-    static const Y_BEACONDRIVEN_enum BEACONDRIVEN_OFF = Y_BEACONDRIVEN_OFF;
-    static const Y_BEACONDRIVEN_enum BEACONDRIVEN_ON = Y_BEACONDRIVEN_ON;
-    static const Y_BEACONDRIVEN_enum BEACONDRIVEN_INVALID = Y_BEACONDRIVEN_INVALID;
-    static const int USAGE_INVALID = YAPI_INVALID_UINT;
-    static const Y_CLEARHISTORY_enum CLEARHISTORY_FALSE = Y_CLEARHISTORY_FALSE;
-    static const Y_CLEARHISTORY_enum CLEARHISTORY_TRUE = Y_CLEARHISTORY_TRUE;
-    static const Y_CLEARHISTORY_enum CLEARHISTORY_INVALID = Y_CLEARHISTORY_INVALID;
-
-    /**
-     * Returns the current run number, corresponding to the number of times the module was
-     * powered on with the dataLogger enabled at some point.
-     *
-     * @return an integer corresponding to the current run number, corresponding to the number of times the module was
-     *         powered on with the dataLogger enabled at some point
-     *
-     * On failure, throws an exception or returns Y_CURRENTRUNINDEX_INVALID.
-     */
-    int                 get_currentRunIndex(void);
-
-    inline int          currentRunIndex(void)
-    { return this->get_currentRunIndex(); }
-
-    /**
-     * Returns the Unix timestamp for current UTC time, if known.
-     *
-     * @return an integer corresponding to the Unix timestamp for current UTC time, if known
-     *
-     * On failure, throws an exception or returns Y_TIMEUTC_INVALID.
-     */
-    s64                 get_timeUTC(void);
-
-    inline s64          timeUTC(void)
-    { return this->get_timeUTC(); }
-
-    /**
-     * Changes the current UTC time reference used for recorded data.
-     *
-     * @param newval : an integer corresponding to the current UTC time reference used for recorded data
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_timeUTC(s64 newval);
-    inline int      setTimeUTC(s64 newval)
-    { return this->set_timeUTC(newval); }
-
-    /**
-     * Returns the current activation state of the data logger.
-     *
-     * @return a value among Y_RECORDING_OFF, Y_RECORDING_ON and Y_RECORDING_PENDING corresponding to the
-     * current activation state of the data logger
-     *
-     * On failure, throws an exception or returns Y_RECORDING_INVALID.
-     */
-    Y_RECORDING_enum    get_recording(void);
-
-    inline Y_RECORDING_enum recording(void)
-    { return this->get_recording(); }
-
-    /**
-     * Changes the activation state of the data logger to start/stop recording data.
-     *
-     * @param newval : a value among Y_RECORDING_OFF, Y_RECORDING_ON and Y_RECORDING_PENDING corresponding
-     * to the activation state of the data logger to start/stop recording data
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_recording(Y_RECORDING_enum newval);
-    inline int      setRecording(Y_RECORDING_enum newval)
-    { return this->set_recording(newval); }
-
-    /**
-     * Returns the default activation state of the data logger on power up.
-     *
-     * @return either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the default activation state of the
-     * data logger on power up
-     *
-     * On failure, throws an exception or returns Y_AUTOSTART_INVALID.
-     */
-    Y_AUTOSTART_enum    get_autoStart(void);
-
-    inline Y_AUTOSTART_enum autoStart(void)
-    { return this->get_autoStart(); }
-
-    /**
-     * Changes the default activation state of the data logger on power up.
-     * Do not forget to call the saveToFlash() method of the module to save the
-     * configuration change.  Note: if the device doesn't have any time source at his disposal when
-     * starting up, it will wait for ~8 seconds before automatically starting to record  with
-     * an arbitrary timestamp
-     *
-     * @param newval : either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the default activation state
-     * of the data logger on power up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_autoStart(Y_AUTOSTART_enum newval);
-    inline int      setAutoStart(Y_AUTOSTART_enum newval)
-    { return this->set_autoStart(newval); }
-
-    /**
-     * Returns true if the data logger is synchronised with the localization beacon.
-     *
-     * @return either Y_BEACONDRIVEN_OFF or Y_BEACONDRIVEN_ON, according to true if the data logger is
-     * synchronised with the localization beacon
-     *
-     * On failure, throws an exception or returns Y_BEACONDRIVEN_INVALID.
-     */
-    Y_BEACONDRIVEN_enum get_beaconDriven(void);
-
-    inline Y_BEACONDRIVEN_enum beaconDriven(void)
-    { return this->get_beaconDriven(); }
-
-    /**
-     * Changes the type of synchronisation of the data logger.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : either Y_BEACONDRIVEN_OFF or Y_BEACONDRIVEN_ON, according to the type of
-     * synchronisation of the data logger
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_beaconDriven(Y_BEACONDRIVEN_enum newval);
-    inline int      setBeaconDriven(Y_BEACONDRIVEN_enum newval)
-    { return this->set_beaconDriven(newval); }
-
-    /**
-     * Returns the percentage of datalogger memory in use.
-     *
-     * @return an integer corresponding to the percentage of datalogger memory in use
-     *
-     * On failure, throws an exception or returns Y_USAGE_INVALID.
-     */
-    int                 get_usage(void);
-
-    inline int          usage(void)
-    { return this->get_usage(); }
-
-    Y_CLEARHISTORY_enum get_clearHistory(void);
-
-    inline Y_CLEARHISTORY_enum clearHistory(void)
-    { return this->get_clearHistory(); }
-
-    int             set_clearHistory(Y_CLEARHISTORY_enum newval);
-    inline int      setClearHistory(Y_CLEARHISTORY_enum newval)
-    { return this->set_clearHistory(newval); }
-
-    /**
-     * Retrieves a data logger for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the data logger is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YDataLogger.isOnline() to test if the data logger is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a data logger by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the data logger
-     *
-     * @return a YDataLogger object allowing you to drive the data logger.
-     */
-    static YDataLogger* FindDataLogger(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YDataLoggerValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Clears the data logger memory and discards all recorded data streams.
-     * This method also resets the current run index to zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         forgetAllDataStreams(void);
-
-    /**
-     * Returns a list of YDataSet objects that can be used to retrieve
-     * all measures stored by the data logger.
-     *
-     * This function only works if the device uses a recent firmware,
-     * as YDataSet objects are not supported by firmwares older than
-     * version 13000.
-     *
-     * @return a list of YDataSet object.
-     *
-     * On failure, throws an exception or returns an empty list.
-     */
-    virtual vector<YDataSet> get_dataSets(void);
-
-    virtual vector<YDataSet> parse_dataSets(string json);
-
-
-    inline static YDataLogger* Find(string func)
-    { return YDataLogger::FindDataLogger(func); }
-
-    /**
-     * Continues the enumeration of data loggers started using yFirstDataLogger().
-     * Caution: You can't make any assumption about the returned data loggers order.
-     * If you want to find a specific a data logger, use DataLogger.findDataLogger()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YDataLogger object, corresponding to
-     *         a data logger currently online, or a NULL pointer
-     *         if there are no more data loggers to enumerate.
-     */
-           YDataLogger     *nextDataLogger(void);
-    inline YDataLogger     *next(void)
-    { return this->nextDataLogger();}
-
-    /**
-     * Starts the enumeration of data loggers currently accessible.
-     * Use the method YDataLogger.nextDataLogger() to iterate on
-     * next data loggers.
-     *
-     * @return a pointer to a YDataLogger object, corresponding to
-     *         the first data logger currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YDataLogger* FirstDataLogger(void);
-    inline static YDataLogger* First(void)
-    { return YDataLogger::FirstDataLogger();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YDataLogger accessors declaration)
-};
-
-
-//--- (generated code: YDataLogger functions declaration)
-
-/**
- * Retrieves a data logger for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the data logger is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDataLogger.isOnline() to test if the data logger is
- * indeed online at a given time. In case of ambiguity when looking for
- * a data logger by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the data logger
- *
- * @return a YDataLogger object allowing you to drive the data logger.
- */
-inline YDataLogger* yFindDataLogger(const string& func)
-{ return YDataLogger::FindDataLogger(func);}
-/**
- * Starts the enumeration of data loggers currently accessible.
- * Use the method YDataLogger.nextDataLogger() to iterate on
- * next data loggers.
- *
- * @return a pointer to a YDataLogger object, corresponding to
- *         the first data logger currently online, or a NULL pointer
- *         if there are none.
- */
-inline YDataLogger* yFirstDataLogger(void)
-{ return YDataLogger::FirstDataLogger();}
-
-//--- (end of generated code: YDataLogger functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_audioin.cpp
+++ /dev/null
@@ -1,408 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_audioin.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindAudioIn(), the high-level API for AudioIn functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_audioin.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "audioin"
-
-YAudioIn::YAudioIn(const string& func): YFunction(func)
-//--- (YAudioIn initialization)
-    ,_volume(VOLUME_INVALID)
-    ,_mute(MUTE_INVALID)
-    ,_volumeRange(VOLUMERANGE_INVALID)
-    ,_signal(SIGNAL_INVALID)
-    ,_noSignalFor(NOSIGNALFOR_INVALID)
-    ,_valueCallbackAudioIn(NULL)
-//--- (end of YAudioIn initialization)
-{
-    _className="AudioIn";
-}
-
-YAudioIn::~YAudioIn()
-{
-//--- (YAudioIn cleanup)
-//--- (end of YAudioIn cleanup)
-}
-//--- (YAudioIn implementation)
-// static attributes
-const string YAudioIn::VOLUMERANGE_INVALID = YAPI_INVALID_STRING;
-
-int YAudioIn::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("volume")) {
-        _volume =  json_val->getInt("volume");
-    }
-    if(json_val->has("mute")) {
-        _mute =  (Y_MUTE_enum)json_val->getInt("mute");
-    }
-    if(json_val->has("volumeRange")) {
-        _volumeRange =  json_val->getString("volumeRange");
-    }
-    if(json_val->has("signal")) {
-        _signal =  json_val->getInt("signal");
-    }
-    if(json_val->has("noSignalFor")) {
-        _noSignalFor =  json_val->getInt("noSignalFor");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns audio input gain, in per cents.
- *
- * @return an integer corresponding to audio input gain, in per cents
- *
- * On failure, throws an exception or returns Y_VOLUME_INVALID.
- */
-int YAudioIn::get_volume(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioIn::VOLUME_INVALID;
-                }
-            }
-        }
-        res = _volume;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes audio input gain, in per cents.
- *
- * @param newval : an integer corresponding to audio input gain, in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAudioIn::set_volume(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("volume", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the mute function.
- *
- * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * On failure, throws an exception or returns Y_MUTE_INVALID.
- */
-Y_MUTE_enum YAudioIn::get_mute(void)
-{
-    Y_MUTE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioIn::MUTE_INVALID;
-                }
-            }
-        }
-        res = _mute;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the mute function. Remember to call the matching module
- * saveToFlash() method to save the setting permanently.
- *
- * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAudioIn::set_mute(Y_MUTE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("mute", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the supported volume range. The low value of the
- * range corresponds to the minimal audible value. To
- * completely mute the sound, use set_mute()
- * instead of the set_volume().
- *
- * @return a string corresponding to the supported volume range
- *
- * On failure, throws an exception or returns Y_VOLUMERANGE_INVALID.
- */
-string YAudioIn::get_volumeRange(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioIn::VOLUMERANGE_INVALID;
-                }
-            }
-        }
-        res = _volumeRange;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the detected input signal level.
- *
- * @return an integer corresponding to the detected input signal level
- *
- * On failure, throws an exception or returns Y_SIGNAL_INVALID.
- */
-int YAudioIn::get_signal(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioIn::SIGNAL_INVALID;
-                }
-            }
-        }
-        res = _signal;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of seconds elapsed without detecting a signal.
- *
- * @return an integer corresponding to the number of seconds elapsed without detecting a signal
- *
- * On failure, throws an exception or returns Y_NOSIGNALFOR_INVALID.
- */
-int YAudioIn::get_noSignalFor(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioIn::NOSIGNALFOR_INVALID;
-                }
-            }
-        }
-        res = _noSignalFor;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an audio input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the audio input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAudioIn.isOnline() to test if the audio input is
- * indeed online at a given time. In case of ambiguity when looking for
- * an audio input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the audio input
- *
- * @return a YAudioIn object allowing you to drive the audio input.
- */
-YAudioIn* YAudioIn::FindAudioIn(string func)
-{
-    YAudioIn* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YAudioIn*) YFunction::_FindFromCache("AudioIn", func);
-        if (obj == NULL) {
-            obj = new YAudioIn(func);
-            YFunction::_AddToCache("AudioIn", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YAudioIn::registerValueCallback(YAudioInValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackAudioIn = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YAudioIn::_invokeValueCallback(string value)
-{
-    if (_valueCallbackAudioIn != NULL) {
-        _valueCallbackAudioIn(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YAudioIn *YAudioIn::nextAudioIn(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YAudioIn::FindAudioIn(hwid);
-}
-
-YAudioIn* YAudioIn::FirstAudioIn(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("AudioIn", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YAudioIn::FindAudioIn(serial+"."+funcId);
-}
-
-//--- (end of YAudioIn implementation)
-
-//--- (YAudioIn functions)
-//--- (end of YAudioIn functions)
--- a/Sources/cpplib/yocto_audioin.h
+++ /dev/null
@@ -1,330 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_audioin.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindAudioIn(), the high-level API for AudioIn functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_AUDIOIN_H
-#define YOCTO_AUDIOIN_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YAudioIn return codes)
-//--- (end of YAudioIn return codes)
-//--- (YAudioIn yapiwrapper)
-//--- (end of YAudioIn yapiwrapper)
-//--- (YAudioIn definitions)
-class YAudioIn; // forward declaration
-
-typedef void (*YAudioInValueCallback)(YAudioIn *func, const string& functionValue);
-#ifndef _Y_MUTE_ENUM
-#define _Y_MUTE_ENUM
-typedef enum {
-    Y_MUTE_FALSE = 0,
-    Y_MUTE_TRUE = 1,
-    Y_MUTE_INVALID = -1,
-} Y_MUTE_enum;
-#endif
-#define Y_VOLUME_INVALID                (YAPI_INVALID_UINT)
-#define Y_VOLUMERANGE_INVALID           (YAPI_INVALID_STRING)
-#define Y_SIGNAL_INVALID                (YAPI_INVALID_INT)
-#define Y_NOSIGNALFOR_INVALID           (YAPI_INVALID_INT)
-//--- (end of YAudioIn definitions)
-
-//--- (YAudioIn declaration)
-/**
- * YAudioIn Class: AudioIn function interface
- *
- * The Yoctopuce application programming interface allows you to configure the volume of the input channel.
- */
-class YOCTO_CLASS_EXPORT YAudioIn: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YAudioIn declaration)
-protected:
-    //--- (YAudioIn attributes)
-    // Attributes (function value cache)
-    int             _volume;
-    Y_MUTE_enum     _mute;
-    string          _volumeRange;
-    int             _signal;
-    int             _noSignalFor;
-    YAudioInValueCallback _valueCallbackAudioIn;
-
-    friend YAudioIn *yFindAudioIn(const string& func);
-    friend YAudioIn *yFirstAudioIn(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindAudioIn factory function to instantiate
-    YAudioIn(const string& func);
-    //--- (end of YAudioIn attributes)
-
-public:
-    virtual ~YAudioIn();
-    //--- (YAudioIn accessors declaration)
-
-    static const int VOLUME_INVALID = YAPI_INVALID_UINT;
-    static const Y_MUTE_enum MUTE_FALSE = Y_MUTE_FALSE;
-    static const Y_MUTE_enum MUTE_TRUE = Y_MUTE_TRUE;
-    static const Y_MUTE_enum MUTE_INVALID = Y_MUTE_INVALID;
-    static const string VOLUMERANGE_INVALID;
-    static const int SIGNAL_INVALID = YAPI_INVALID_INT;
-    static const int NOSIGNALFOR_INVALID = YAPI_INVALID_INT;
-
-    /**
-     * Returns audio input gain, in per cents.
-     *
-     * @return an integer corresponding to audio input gain, in per cents
-     *
-     * On failure, throws an exception or returns Y_VOLUME_INVALID.
-     */
-    int                 get_volume(void);
-
-    inline int          volume(void)
-    { return this->get_volume(); }
-
-    /**
-     * Changes audio input gain, in per cents.
-     *
-     * @param newval : an integer corresponding to audio input gain, in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_volume(int newval);
-    inline int      setVolume(int newval)
-    { return this->set_volume(newval); }
-
-    /**
-     * Returns the state of the mute function.
-     *
-     * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * On failure, throws an exception or returns Y_MUTE_INVALID.
-     */
-    Y_MUTE_enum         get_mute(void);
-
-    inline Y_MUTE_enum  mute(void)
-    { return this->get_mute(); }
-
-    /**
-     * Changes the state of the mute function. Remember to call the matching module
-     * saveToFlash() method to save the setting permanently.
-     *
-     * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_mute(Y_MUTE_enum newval);
-    inline int      setMute(Y_MUTE_enum newval)
-    { return this->set_mute(newval); }
-
-    /**
-     * Returns the supported volume range. The low value of the
-     * range corresponds to the minimal audible value. To
-     * completely mute the sound, use set_mute()
-     * instead of the set_volume().
-     *
-     * @return a string corresponding to the supported volume range
-     *
-     * On failure, throws an exception or returns Y_VOLUMERANGE_INVALID.
-     */
-    string              get_volumeRange(void);
-
-    inline string       volumeRange(void)
-    { return this->get_volumeRange(); }
-
-    /**
-     * Returns the detected input signal level.
-     *
-     * @return an integer corresponding to the detected input signal level
-     *
-     * On failure, throws an exception or returns Y_SIGNAL_INVALID.
-     */
-    int                 get_signal(void);
-
-    inline int          signal(void)
-    { return this->get_signal(); }
-
-    /**
-     * Returns the number of seconds elapsed without detecting a signal.
-     *
-     * @return an integer corresponding to the number of seconds elapsed without detecting a signal
-     *
-     * On failure, throws an exception or returns Y_NOSIGNALFOR_INVALID.
-     */
-    int                 get_noSignalFor(void);
-
-    inline int          noSignalFor(void)
-    { return this->get_noSignalFor(); }
-
-    /**
-     * Retrieves an audio input for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the audio input is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YAudioIn.isOnline() to test if the audio input is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an audio input by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the audio input
-     *
-     * @return a YAudioIn object allowing you to drive the audio input.
-     */
-    static YAudioIn*    FindAudioIn(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YAudioInValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YAudioIn* Find(string func)
-    { return YAudioIn::FindAudioIn(func); }
-
-    /**
-     * Continues the enumeration of audio inputs started using yFirstAudioIn().
-     * Caution: You can't make any assumption about the returned audio inputs order.
-     * If you want to find a specific an audio input, use AudioIn.findAudioIn()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YAudioIn object, corresponding to
-     *         an audio input currently online, or a NULL pointer
-     *         if there are no more audio inputs to enumerate.
-     */
-           YAudioIn        *nextAudioIn(void);
-    inline YAudioIn        *next(void)
-    { return this->nextAudioIn();}
-
-    /**
-     * Starts the enumeration of audio inputs currently accessible.
-     * Use the method YAudioIn.nextAudioIn() to iterate on
-     * next audio inputs.
-     *
-     * @return a pointer to a YAudioIn object, corresponding to
-     *         the first audio input currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YAudioIn* FirstAudioIn(void);
-    inline static YAudioIn* First(void)
-    { return YAudioIn::FirstAudioIn();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YAudioIn accessors declaration)
-};
-
-//--- (YAudioIn functions declaration)
-
-/**
- * Retrieves an audio input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the audio input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAudioIn.isOnline() to test if the audio input is
- * indeed online at a given time. In case of ambiguity when looking for
- * an audio input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the audio input
- *
- * @return a YAudioIn object allowing you to drive the audio input.
- */
-inline YAudioIn* yFindAudioIn(const string& func)
-{ return YAudioIn::FindAudioIn(func);}
-/**
- * Starts the enumeration of audio inputs currently accessible.
- * Use the method YAudioIn.nextAudioIn() to iterate on
- * next audio inputs.
- *
- * @return a pointer to a YAudioIn object, corresponding to
- *         the first audio input currently online, or a NULL pointer
- *         if there are none.
- */
-inline YAudioIn* yFirstAudioIn(void)
-{ return YAudioIn::FirstAudioIn();}
-
-//--- (end of YAudioIn functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_audioout.cpp
+++ /dev/null
@@ -1,408 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_audioout.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindAudioOut(), the high-level API for AudioOut functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_audioout.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "audioout"
-
-YAudioOut::YAudioOut(const string& func): YFunction(func)
-//--- (YAudioOut initialization)
-    ,_volume(VOLUME_INVALID)
-    ,_mute(MUTE_INVALID)
-    ,_volumeRange(VOLUMERANGE_INVALID)
-    ,_signal(SIGNAL_INVALID)
-    ,_noSignalFor(NOSIGNALFOR_INVALID)
-    ,_valueCallbackAudioOut(NULL)
-//--- (end of YAudioOut initialization)
-{
-    _className="AudioOut";
-}
-
-YAudioOut::~YAudioOut()
-{
-//--- (YAudioOut cleanup)
-//--- (end of YAudioOut cleanup)
-}
-//--- (YAudioOut implementation)
-// static attributes
-const string YAudioOut::VOLUMERANGE_INVALID = YAPI_INVALID_STRING;
-
-int YAudioOut::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("volume")) {
-        _volume =  json_val->getInt("volume");
-    }
-    if(json_val->has("mute")) {
-        _mute =  (Y_MUTE_enum)json_val->getInt("mute");
-    }
-    if(json_val->has("volumeRange")) {
-        _volumeRange =  json_val->getString("volumeRange");
-    }
-    if(json_val->has("signal")) {
-        _signal =  json_val->getInt("signal");
-    }
-    if(json_val->has("noSignalFor")) {
-        _noSignalFor =  json_val->getInt("noSignalFor");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns audio output volume, in per cents.
- *
- * @return an integer corresponding to audio output volume, in per cents
- *
- * On failure, throws an exception or returns Y_VOLUME_INVALID.
- */
-int YAudioOut::get_volume(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioOut::VOLUME_INVALID;
-                }
-            }
-        }
-        res = _volume;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes audio output volume, in per cents.
- *
- * @param newval : an integer corresponding to audio output volume, in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAudioOut::set_volume(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("volume", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the mute function.
- *
- * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * On failure, throws an exception or returns Y_MUTE_INVALID.
- */
-Y_MUTE_enum YAudioOut::get_mute(void)
-{
-    Y_MUTE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioOut::MUTE_INVALID;
-                }
-            }
-        }
-        res = _mute;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the mute function. Remember to call the matching module
- * saveToFlash() method to save the setting permanently.
- *
- * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YAudioOut::set_mute(Y_MUTE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("mute", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the supported volume range. The low value of the
- * range corresponds to the minimal audible value. To
- * completely mute the sound, use set_mute()
- * instead of the set_volume().
- *
- * @return a string corresponding to the supported volume range
- *
- * On failure, throws an exception or returns Y_VOLUMERANGE_INVALID.
- */
-string YAudioOut::get_volumeRange(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioOut::VOLUMERANGE_INVALID;
-                }
-            }
-        }
-        res = _volumeRange;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the detected output current level.
- *
- * @return an integer corresponding to the detected output current level
- *
- * On failure, throws an exception or returns Y_SIGNAL_INVALID.
- */
-int YAudioOut::get_signal(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioOut::SIGNAL_INVALID;
-                }
-            }
-        }
-        res = _signal;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of seconds elapsed without detecting a signal.
- *
- * @return an integer corresponding to the number of seconds elapsed without detecting a signal
- *
- * On failure, throws an exception or returns Y_NOSIGNALFOR_INVALID.
- */
-int YAudioOut::get_noSignalFor(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YAudioOut::NOSIGNALFOR_INVALID;
-                }
-            }
-        }
-        res = _noSignalFor;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an audio output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the audio output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAudioOut.isOnline() to test if the audio output is
- * indeed online at a given time. In case of ambiguity when looking for
- * an audio output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the audio output
- *
- * @return a YAudioOut object allowing you to drive the audio output.
- */
-YAudioOut* YAudioOut::FindAudioOut(string func)
-{
-    YAudioOut* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YAudioOut*) YFunction::_FindFromCache("AudioOut", func);
-        if (obj == NULL) {
-            obj = new YAudioOut(func);
-            YFunction::_AddToCache("AudioOut", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YAudioOut::registerValueCallback(YAudioOutValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackAudioOut = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YAudioOut::_invokeValueCallback(string value)
-{
-    if (_valueCallbackAudioOut != NULL) {
-        _valueCallbackAudioOut(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YAudioOut *YAudioOut::nextAudioOut(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YAudioOut::FindAudioOut(hwid);
-}
-
-YAudioOut* YAudioOut::FirstAudioOut(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("AudioOut", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YAudioOut::FindAudioOut(serial+"."+funcId);
-}
-
-//--- (end of YAudioOut implementation)
-
-//--- (YAudioOut functions)
-//--- (end of YAudioOut functions)
--- a/Sources/cpplib/yocto_audioout.h
+++ /dev/null
@@ -1,330 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_audioout.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindAudioOut(), the high-level API for AudioOut functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_AUDIOOUT_H
-#define YOCTO_AUDIOOUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YAudioOut return codes)
-//--- (end of YAudioOut return codes)
-//--- (YAudioOut yapiwrapper)
-//--- (end of YAudioOut yapiwrapper)
-//--- (YAudioOut definitions)
-class YAudioOut; // forward declaration
-
-typedef void (*YAudioOutValueCallback)(YAudioOut *func, const string& functionValue);
-#ifndef _Y_MUTE_ENUM
-#define _Y_MUTE_ENUM
-typedef enum {
-    Y_MUTE_FALSE = 0,
-    Y_MUTE_TRUE = 1,
-    Y_MUTE_INVALID = -1,
-} Y_MUTE_enum;
-#endif
-#define Y_VOLUME_INVALID                (YAPI_INVALID_UINT)
-#define Y_VOLUMERANGE_INVALID           (YAPI_INVALID_STRING)
-#define Y_SIGNAL_INVALID                (YAPI_INVALID_INT)
-#define Y_NOSIGNALFOR_INVALID           (YAPI_INVALID_INT)
-//--- (end of YAudioOut definitions)
-
-//--- (YAudioOut declaration)
-/**
- * YAudioOut Class: AudioOut function interface
- *
- * The Yoctopuce application programming interface allows you to configure the volume of the outout.
- */
-class YOCTO_CLASS_EXPORT YAudioOut: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YAudioOut declaration)
-protected:
-    //--- (YAudioOut attributes)
-    // Attributes (function value cache)
-    int             _volume;
-    Y_MUTE_enum     _mute;
-    string          _volumeRange;
-    int             _signal;
-    int             _noSignalFor;
-    YAudioOutValueCallback _valueCallbackAudioOut;
-
-    friend YAudioOut *yFindAudioOut(const string& func);
-    friend YAudioOut *yFirstAudioOut(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindAudioOut factory function to instantiate
-    YAudioOut(const string& func);
-    //--- (end of YAudioOut attributes)
-
-public:
-    virtual ~YAudioOut();
-    //--- (YAudioOut accessors declaration)
-
-    static const int VOLUME_INVALID = YAPI_INVALID_UINT;
-    static const Y_MUTE_enum MUTE_FALSE = Y_MUTE_FALSE;
-    static const Y_MUTE_enum MUTE_TRUE = Y_MUTE_TRUE;
-    static const Y_MUTE_enum MUTE_INVALID = Y_MUTE_INVALID;
-    static const string VOLUMERANGE_INVALID;
-    static const int SIGNAL_INVALID = YAPI_INVALID_INT;
-    static const int NOSIGNALFOR_INVALID = YAPI_INVALID_INT;
-
-    /**
-     * Returns audio output volume, in per cents.
-     *
-     * @return an integer corresponding to audio output volume, in per cents
-     *
-     * On failure, throws an exception or returns Y_VOLUME_INVALID.
-     */
-    int                 get_volume(void);
-
-    inline int          volume(void)
-    { return this->get_volume(); }
-
-    /**
-     * Changes audio output volume, in per cents.
-     *
-     * @param newval : an integer corresponding to audio output volume, in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_volume(int newval);
-    inline int      setVolume(int newval)
-    { return this->set_volume(newval); }
-
-    /**
-     * Returns the state of the mute function.
-     *
-     * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * On failure, throws an exception or returns Y_MUTE_INVALID.
-     */
-    Y_MUTE_enum         get_mute(void);
-
-    inline Y_MUTE_enum  mute(void)
-    { return this->get_mute(); }
-
-    /**
-     * Changes the state of the mute function. Remember to call the matching module
-     * saveToFlash() method to save the setting permanently.
-     *
-     * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_mute(Y_MUTE_enum newval);
-    inline int      setMute(Y_MUTE_enum newval)
-    { return this->set_mute(newval); }
-
-    /**
-     * Returns the supported volume range. The low value of the
-     * range corresponds to the minimal audible value. To
-     * completely mute the sound, use set_mute()
-     * instead of the set_volume().
-     *
-     * @return a string corresponding to the supported volume range
-     *
-     * On failure, throws an exception or returns Y_VOLUMERANGE_INVALID.
-     */
-    string              get_volumeRange(void);
-
-    inline string       volumeRange(void)
-    { return this->get_volumeRange(); }
-
-    /**
-     * Returns the detected output current level.
-     *
-     * @return an integer corresponding to the detected output current level
-     *
-     * On failure, throws an exception or returns Y_SIGNAL_INVALID.
-     */
-    int                 get_signal(void);
-
-    inline int          signal(void)
-    { return this->get_signal(); }
-
-    /**
-     * Returns the number of seconds elapsed without detecting a signal.
-     *
-     * @return an integer corresponding to the number of seconds elapsed without detecting a signal
-     *
-     * On failure, throws an exception or returns Y_NOSIGNALFOR_INVALID.
-     */
-    int                 get_noSignalFor(void);
-
-    inline int          noSignalFor(void)
-    { return this->get_noSignalFor(); }
-
-    /**
-     * Retrieves an audio output for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the audio output is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YAudioOut.isOnline() to test if the audio output is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an audio output by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the audio output
-     *
-     * @return a YAudioOut object allowing you to drive the audio output.
-     */
-    static YAudioOut*   FindAudioOut(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YAudioOutValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YAudioOut* Find(string func)
-    { return YAudioOut::FindAudioOut(func); }
-
-    /**
-     * Continues the enumeration of audio outputs started using yFirstAudioOut().
-     * Caution: You can't make any assumption about the returned audio outputs order.
-     * If you want to find a specific an audio output, use AudioOut.findAudioOut()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YAudioOut object, corresponding to
-     *         an audio output currently online, or a NULL pointer
-     *         if there are no more audio outputs to enumerate.
-     */
-           YAudioOut       *nextAudioOut(void);
-    inline YAudioOut       *next(void)
-    { return this->nextAudioOut();}
-
-    /**
-     * Starts the enumeration of audio outputs currently accessible.
-     * Use the method YAudioOut.nextAudioOut() to iterate on
-     * next audio outputs.
-     *
-     * @return a pointer to a YAudioOut object, corresponding to
-     *         the first audio output currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YAudioOut* FirstAudioOut(void);
-    inline static YAudioOut* First(void)
-    { return YAudioOut::FirstAudioOut();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YAudioOut accessors declaration)
-};
-
-//--- (YAudioOut functions declaration)
-
-/**
- * Retrieves an audio output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the audio output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YAudioOut.isOnline() to test if the audio output is
- * indeed online at a given time. In case of ambiguity when looking for
- * an audio output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the audio output
- *
- * @return a YAudioOut object allowing you to drive the audio output.
- */
-inline YAudioOut* yFindAudioOut(const string& func)
-{ return YAudioOut::FindAudioOut(func);}
-/**
- * Starts the enumeration of audio outputs currently accessible.
- * Use the method YAudioOut.nextAudioOut() to iterate on
- * next audio outputs.
- *
- * @return a pointer to a YAudioOut object, corresponding to
- *         the first audio output currently online, or a NULL pointer
- *         if there are none.
- */
-inline YAudioOut* yFirstAudioOut(void)
-{ return YAudioOut::FirstAudioOut();}
-
-//--- (end of YAudioOut functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_bluetoothlink.cpp
+++ /dev/null
@@ -1,691 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_bluetoothlink.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindBluetoothLink(), the high-level API for BluetoothLink functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_bluetoothlink.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "bluetoothlink"
-
-YBluetoothLink::YBluetoothLink(const string& func): YFunction(func)
-//--- (YBluetoothLink initialization)
-    ,_ownAddress(OWNADDRESS_INVALID)
-    ,_pairingPin(PAIRINGPIN_INVALID)
-    ,_remoteAddress(REMOTEADDRESS_INVALID)
-    ,_remoteName(REMOTENAME_INVALID)
-    ,_mute(MUTE_INVALID)
-    ,_preAmplifier(PREAMPLIFIER_INVALID)
-    ,_volume(VOLUME_INVALID)
-    ,_linkState(LINKSTATE_INVALID)
-    ,_linkQuality(LINKQUALITY_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackBluetoothLink(NULL)
-//--- (end of YBluetoothLink initialization)
-{
-    _className="BluetoothLink";
-}
-
-YBluetoothLink::~YBluetoothLink()
-{
-//--- (YBluetoothLink cleanup)
-//--- (end of YBluetoothLink cleanup)
-}
-//--- (YBluetoothLink implementation)
-// static attributes
-const string YBluetoothLink::OWNADDRESS_INVALID = YAPI_INVALID_STRING;
-const string YBluetoothLink::PAIRINGPIN_INVALID = YAPI_INVALID_STRING;
-const string YBluetoothLink::REMOTEADDRESS_INVALID = YAPI_INVALID_STRING;
-const string YBluetoothLink::REMOTENAME_INVALID = YAPI_INVALID_STRING;
-const string YBluetoothLink::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YBluetoothLink::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("ownAddress")) {
-        _ownAddress =  json_val->getString("ownAddress");
-    }
-    if(json_val->has("pairingPin")) {
-        _pairingPin =  json_val->getString("pairingPin");
-    }
-    if(json_val->has("remoteAddress")) {
-        _remoteAddress =  json_val->getString("remoteAddress");
-    }
-    if(json_val->has("remoteName")) {
-        _remoteName =  json_val->getString("remoteName");
-    }
-    if(json_val->has("mute")) {
-        _mute =  (Y_MUTE_enum)json_val->getInt("mute");
-    }
-    if(json_val->has("preAmplifier")) {
-        _preAmplifier =  json_val->getInt("preAmplifier");
-    }
-    if(json_val->has("volume")) {
-        _volume =  json_val->getInt("volume");
-    }
-    if(json_val->has("linkState")) {
-        _linkState =  (Y_LINKSTATE_enum)json_val->getInt("linkState");
-    }
-    if(json_val->has("linkQuality")) {
-        _linkQuality =  json_val->getInt("linkQuality");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.
- *
- * @return a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on
- * the bluetooth network
- *
- * On failure, throws an exception or returns Y_OWNADDRESS_INVALID.
- */
-string YBluetoothLink::get_ownAddress(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::OWNADDRESS_INVALID;
-                }
-            }
-        }
-        res = _ownAddress;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns an opaque string if a PIN code has been configured in the device to access
- * the SIM card, or an empty string if none has been configured or if the code provided
- * was rejected by the SIM card.
- *
- * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
- *         the SIM card, or an empty string if none has been configured or if the code provided
- *         was rejected by the SIM card
- *
- * On failure, throws an exception or returns Y_PAIRINGPIN_INVALID.
- */
-string YBluetoothLink::get_pairingPin(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::PAIRINGPIN_INVALID;
-                }
-            }
-        }
-        res = _pairingPin;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PIN code used by the module for bluetooth pairing.
- * Remember to call the saveToFlash() method of the module to save the
- * new value in the device flash.
- *
- * @param newval : a string corresponding to the PIN code used by the module for bluetooth pairing
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::set_pairingPin(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("pairingPin", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the MAC-48 address of the remote device to connect to.
- *
- * @return a string corresponding to the MAC-48 address of the remote device to connect to
- *
- * On failure, throws an exception or returns Y_REMOTEADDRESS_INVALID.
- */
-string YBluetoothLink::get_remoteAddress(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::REMOTEADDRESS_INVALID;
-                }
-            }
-        }
-        res = _remoteAddress;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the MAC-48 address defining which remote device to connect to.
- *
- * @param newval : a string corresponding to the MAC-48 address defining which remote device to connect to
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::set_remoteAddress(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("remoteAddress", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the bluetooth name the remote device, if found on the bluetooth network.
- *
- * @return a string corresponding to the bluetooth name the remote device, if found on the bluetooth network
- *
- * On failure, throws an exception or returns Y_REMOTENAME_INVALID.
- */
-string YBluetoothLink::get_remoteName(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::REMOTENAME_INVALID;
-                }
-            }
-        }
-        res = _remoteName;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the mute function.
- *
- * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * On failure, throws an exception or returns Y_MUTE_INVALID.
- */
-Y_MUTE_enum YBluetoothLink::get_mute(void)
-{
-    Y_MUTE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::MUTE_INVALID;
-                }
-            }
-        }
-        res = _mute;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the mute function. Remember to call the matching module
- * saveToFlash() method to save the setting permanently.
- *
- * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::set_mute(Y_MUTE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("mute", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the audio pre-amplifier volume, in per cents.
- *
- * @return an integer corresponding to the audio pre-amplifier volume, in per cents
- *
- * On failure, throws an exception or returns Y_PREAMPLIFIER_INVALID.
- */
-int YBluetoothLink::get_preAmplifier(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::PREAMPLIFIER_INVALID;
-                }
-            }
-        }
-        res = _preAmplifier;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the audio pre-amplifier volume, in per cents.
- *
- * @param newval : an integer corresponding to the audio pre-amplifier volume, in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::set_preAmplifier(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("preAmplifier", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the connected headset volume, in per cents.
- *
- * @return an integer corresponding to the connected headset volume, in per cents
- *
- * On failure, throws an exception or returns Y_VOLUME_INVALID.
- */
-int YBluetoothLink::get_volume(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::VOLUME_INVALID;
-                }
-            }
-        }
-        res = _volume;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the connected headset volume, in per cents.
- *
- * @param newval : an integer corresponding to the connected headset volume, in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::set_volume(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("volume", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the bluetooth link state.
- *
- * @return a value among Y_LINKSTATE_DOWN, Y_LINKSTATE_FREE, Y_LINKSTATE_SEARCH, Y_LINKSTATE_EXISTS,
- * Y_LINKSTATE_LINKED and Y_LINKSTATE_PLAY corresponding to the bluetooth link state
- *
- * On failure, throws an exception or returns Y_LINKSTATE_INVALID.
- */
-Y_LINKSTATE_enum YBluetoothLink::get_linkState(void)
-{
-    Y_LINKSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::LINKSTATE_INVALID;
-                }
-            }
-        }
-        res = _linkState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.
- *
- * @return an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if
- * no connection is established
- *
- * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
- */
-int YBluetoothLink::get_linkQuality(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::LINKQUALITY_INVALID;
-                }
-            }
-        }
-        res = _linkQuality;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YBluetoothLink::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBluetoothLink::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YBluetoothLink::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a cellular interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the cellular interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YBluetoothLink.isOnline() to test if the cellular interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a cellular interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the cellular interface
- *
- * @return a YBluetoothLink object allowing you to drive the cellular interface.
- */
-YBluetoothLink* YBluetoothLink::FindBluetoothLink(string func)
-{
-    YBluetoothLink* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YBluetoothLink*) YFunction::_FindFromCache("BluetoothLink", func);
-        if (obj == NULL) {
-            obj = new YBluetoothLink(func);
-            YFunction::_AddToCache("BluetoothLink", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YBluetoothLink::registerValueCallback(YBluetoothLinkValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackBluetoothLink = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YBluetoothLink::_invokeValueCallback(string value)
-{
-    if (_valueCallbackBluetoothLink != NULL) {
-        _valueCallbackBluetoothLink(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Attempt to connect to the previously selected remote device.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::connect(void)
-{
-    return this->set_command("C");
-}
-
-/**
- * Disconnect from the previously selected remote device.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBluetoothLink::disconnect(void)
-{
-    return this->set_command("D");
-}
-
-YBluetoothLink *YBluetoothLink::nextBluetoothLink(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YBluetoothLink::FindBluetoothLink(hwid);
-}
-
-YBluetoothLink* YBluetoothLink::FirstBluetoothLink(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("BluetoothLink", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YBluetoothLink::FindBluetoothLink(serial+"."+funcId);
-}
-
-//--- (end of YBluetoothLink implementation)
-
-//--- (YBluetoothLink functions)
-//--- (end of YBluetoothLink functions)
--- a/Sources/cpplib/yocto_bluetoothlink.h
+++ /dev/null
@@ -1,483 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_bluetoothlink.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindBluetoothLink(), the high-level API for BluetoothLink functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_BLUETOOTHLINK_H
-#define YOCTO_BLUETOOTHLINK_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YBluetoothLink return codes)
-//--- (end of YBluetoothLink return codes)
-//--- (YBluetoothLink yapiwrapper)
-//--- (end of YBluetoothLink yapiwrapper)
-//--- (YBluetoothLink definitions)
-class YBluetoothLink; // forward declaration
-
-typedef void (*YBluetoothLinkValueCallback)(YBluetoothLink *func, const string& functionValue);
-#ifndef _Y_MUTE_ENUM
-#define _Y_MUTE_ENUM
-typedef enum {
-    Y_MUTE_FALSE = 0,
-    Y_MUTE_TRUE = 1,
-    Y_MUTE_INVALID = -1,
-} Y_MUTE_enum;
-#endif
-#ifndef _Y_LINKSTATE_ENUM
-#define _Y_LINKSTATE_ENUM
-typedef enum {
-    Y_LINKSTATE_DOWN = 0,
-    Y_LINKSTATE_FREE = 1,
-    Y_LINKSTATE_SEARCH = 2,
-    Y_LINKSTATE_EXISTS = 3,
-    Y_LINKSTATE_LINKED = 4,
-    Y_LINKSTATE_PLAY = 5,
-    Y_LINKSTATE_INVALID = -1,
-} Y_LINKSTATE_enum;
-#endif
-#define Y_OWNADDRESS_INVALID            (YAPI_INVALID_STRING)
-#define Y_PAIRINGPIN_INVALID            (YAPI_INVALID_STRING)
-#define Y_REMOTEADDRESS_INVALID         (YAPI_INVALID_STRING)
-#define Y_REMOTENAME_INVALID            (YAPI_INVALID_STRING)
-#define Y_PREAMPLIFIER_INVALID          (YAPI_INVALID_UINT)
-#define Y_VOLUME_INVALID                (YAPI_INVALID_UINT)
-#define Y_LINKQUALITY_INVALID           (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YBluetoothLink definitions)
-
-//--- (YBluetoothLink declaration)
-/**
- * YBluetoothLink Class: BluetoothLink function interface
- *
- * BluetoothLink function provides control over bluetooth link
- * and status for devices that are bluetooth-enabled.
- */
-class YOCTO_CLASS_EXPORT YBluetoothLink: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YBluetoothLink declaration)
-protected:
-    //--- (YBluetoothLink attributes)
-    // Attributes (function value cache)
-    string          _ownAddress;
-    string          _pairingPin;
-    string          _remoteAddress;
-    string          _remoteName;
-    Y_MUTE_enum     _mute;
-    int             _preAmplifier;
-    int             _volume;
-    Y_LINKSTATE_enum _linkState;
-    int             _linkQuality;
-    string          _command;
-    YBluetoothLinkValueCallback _valueCallbackBluetoothLink;
-
-    friend YBluetoothLink *yFindBluetoothLink(const string& func);
-    friend YBluetoothLink *yFirstBluetoothLink(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindBluetoothLink factory function to instantiate
-    YBluetoothLink(const string& func);
-    //--- (end of YBluetoothLink attributes)
-
-public:
-    virtual ~YBluetoothLink();
-    //--- (YBluetoothLink accessors declaration)
-
-    static const string OWNADDRESS_INVALID;
-    static const string PAIRINGPIN_INVALID;
-    static const string REMOTEADDRESS_INVALID;
-    static const string REMOTENAME_INVALID;
-    static const Y_MUTE_enum MUTE_FALSE = Y_MUTE_FALSE;
-    static const Y_MUTE_enum MUTE_TRUE = Y_MUTE_TRUE;
-    static const Y_MUTE_enum MUTE_INVALID = Y_MUTE_INVALID;
-    static const int PREAMPLIFIER_INVALID = YAPI_INVALID_UINT;
-    static const int VOLUME_INVALID = YAPI_INVALID_UINT;
-    static const Y_LINKSTATE_enum LINKSTATE_DOWN = Y_LINKSTATE_DOWN;
-    static const Y_LINKSTATE_enum LINKSTATE_FREE = Y_LINKSTATE_FREE;
-    static const Y_LINKSTATE_enum LINKSTATE_SEARCH = Y_LINKSTATE_SEARCH;
-    static const Y_LINKSTATE_enum LINKSTATE_EXISTS = Y_LINKSTATE_EXISTS;
-    static const Y_LINKSTATE_enum LINKSTATE_LINKED = Y_LINKSTATE_LINKED;
-    static const Y_LINKSTATE_enum LINKSTATE_PLAY = Y_LINKSTATE_PLAY;
-    static const Y_LINKSTATE_enum LINKSTATE_INVALID = Y_LINKSTATE_INVALID;
-    static const int LINKQUALITY_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.
-     *
-     * @return a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on
-     * the bluetooth network
-     *
-     * On failure, throws an exception or returns Y_OWNADDRESS_INVALID.
-     */
-    string              get_ownAddress(void);
-
-    inline string       ownAddress(void)
-    { return this->get_ownAddress(); }
-
-    /**
-     * Returns an opaque string if a PIN code has been configured in the device to access
-     * the SIM card, or an empty string if none has been configured or if the code provided
-     * was rejected by the SIM card.
-     *
-     * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
-     *         the SIM card, or an empty string if none has been configured or if the code provided
-     *         was rejected by the SIM card
-     *
-     * On failure, throws an exception or returns Y_PAIRINGPIN_INVALID.
-     */
-    string              get_pairingPin(void);
-
-    inline string       pairingPin(void)
-    { return this->get_pairingPin(); }
-
-    /**
-     * Changes the PIN code used by the module for bluetooth pairing.
-     * Remember to call the saveToFlash() method of the module to save the
-     * new value in the device flash.
-     *
-     * @param newval : a string corresponding to the PIN code used by the module for bluetooth pairing
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pairingPin(const string& newval);
-    inline int      setPairingPin(const string& newval)
-    { return this->set_pairingPin(newval); }
-
-    /**
-     * Returns the MAC-48 address of the remote device to connect to.
-     *
-     * @return a string corresponding to the MAC-48 address of the remote device to connect to
-     *
-     * On failure, throws an exception or returns Y_REMOTEADDRESS_INVALID.
-     */
-    string              get_remoteAddress(void);
-
-    inline string       remoteAddress(void)
-    { return this->get_remoteAddress(); }
-
-    /**
-     * Changes the MAC-48 address defining which remote device to connect to.
-     *
-     * @param newval : a string corresponding to the MAC-48 address defining which remote device to connect to
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_remoteAddress(const string& newval);
-    inline int      setRemoteAddress(const string& newval)
-    { return this->set_remoteAddress(newval); }
-
-    /**
-     * Returns the bluetooth name the remote device, if found on the bluetooth network.
-     *
-     * @return a string corresponding to the bluetooth name the remote device, if found on the bluetooth network
-     *
-     * On failure, throws an exception or returns Y_REMOTENAME_INVALID.
-     */
-    string              get_remoteName(void);
-
-    inline string       remoteName(void)
-    { return this->get_remoteName(); }
-
-    /**
-     * Returns the state of the mute function.
-     *
-     * @return either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * On failure, throws an exception or returns Y_MUTE_INVALID.
-     */
-    Y_MUTE_enum         get_mute(void);
-
-    inline Y_MUTE_enum  mute(void)
-    { return this->get_mute(); }
-
-    /**
-     * Changes the state of the mute function. Remember to call the matching module
-     * saveToFlash() method to save the setting permanently.
-     *
-     * @param newval : either Y_MUTE_FALSE or Y_MUTE_TRUE, according to the state of the mute function
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_mute(Y_MUTE_enum newval);
-    inline int      setMute(Y_MUTE_enum newval)
-    { return this->set_mute(newval); }
-
-    /**
-     * Returns the audio pre-amplifier volume, in per cents.
-     *
-     * @return an integer corresponding to the audio pre-amplifier volume, in per cents
-     *
-     * On failure, throws an exception or returns Y_PREAMPLIFIER_INVALID.
-     */
-    int                 get_preAmplifier(void);
-
-    inline int          preAmplifier(void)
-    { return this->get_preAmplifier(); }
-
-    /**
-     * Changes the audio pre-amplifier volume, in per cents.
-     *
-     * @param newval : an integer corresponding to the audio pre-amplifier volume, in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_preAmplifier(int newval);
-    inline int      setPreAmplifier(int newval)
-    { return this->set_preAmplifier(newval); }
-
-    /**
-     * Returns the connected headset volume, in per cents.
-     *
-     * @return an integer corresponding to the connected headset volume, in per cents
-     *
-     * On failure, throws an exception or returns Y_VOLUME_INVALID.
-     */
-    int                 get_volume(void);
-
-    inline int          volume(void)
-    { return this->get_volume(); }
-
-    /**
-     * Changes the connected headset volume, in per cents.
-     *
-     * @param newval : an integer corresponding to the connected headset volume, in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_volume(int newval);
-    inline int      setVolume(int newval)
-    { return this->set_volume(newval); }
-
-    /**
-     * Returns the bluetooth link state.
-     *
-     * @return a value among Y_LINKSTATE_DOWN, Y_LINKSTATE_FREE, Y_LINKSTATE_SEARCH, Y_LINKSTATE_EXISTS,
-     * Y_LINKSTATE_LINKED and Y_LINKSTATE_PLAY corresponding to the bluetooth link state
-     *
-     * On failure, throws an exception or returns Y_LINKSTATE_INVALID.
-     */
-    Y_LINKSTATE_enum    get_linkState(void);
-
-    inline Y_LINKSTATE_enum linkState(void)
-    { return this->get_linkState(); }
-
-    /**
-     * Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.
-     *
-     * @return an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if
-     * no connection is established
-     *
-     * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
-     */
-    int                 get_linkQuality(void);
-
-    inline int          linkQuality(void)
-    { return this->get_linkQuality(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a cellular interface for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the cellular interface is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YBluetoothLink.isOnline() to test if the cellular interface is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a cellular interface by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the cellular interface
-     *
-     * @return a YBluetoothLink object allowing you to drive the cellular interface.
-     */
-    static YBluetoothLink* FindBluetoothLink(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YBluetoothLinkValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Attempt to connect to the previously selected remote device.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         connect(void);
-
-    /**
-     * Disconnect from the previously selected remote device.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         disconnect(void);
-
-
-    inline static YBluetoothLink* Find(string func)
-    { return YBluetoothLink::FindBluetoothLink(func); }
-
-    /**
-     * Continues the enumeration of cellular interfaces started using yFirstBluetoothLink().
-     * Caution: You can't make any assumption about the returned cellular interfaces order.
-     * If you want to find a specific a cellular interface, use BluetoothLink.findBluetoothLink()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YBluetoothLink object, corresponding to
-     *         a cellular interface currently online, or a NULL pointer
-     *         if there are no more cellular interfaces to enumerate.
-     */
-           YBluetoothLink  *nextBluetoothLink(void);
-    inline YBluetoothLink  *next(void)
-    { return this->nextBluetoothLink();}
-
-    /**
-     * Starts the enumeration of cellular interfaces currently accessible.
-     * Use the method YBluetoothLink.nextBluetoothLink() to iterate on
-     * next cellular interfaces.
-     *
-     * @return a pointer to a YBluetoothLink object, corresponding to
-     *         the first cellular interface currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YBluetoothLink* FirstBluetoothLink(void);
-    inline static YBluetoothLink* First(void)
-    { return YBluetoothLink::FirstBluetoothLink();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YBluetoothLink accessors declaration)
-};
-
-//--- (YBluetoothLink functions declaration)
-
-/**
- * Retrieves a cellular interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the cellular interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YBluetoothLink.isOnline() to test if the cellular interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a cellular interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the cellular interface
- *
- * @return a YBluetoothLink object allowing you to drive the cellular interface.
- */
-inline YBluetoothLink* yFindBluetoothLink(const string& func)
-{ return YBluetoothLink::FindBluetoothLink(func);}
-/**
- * Starts the enumeration of cellular interfaces currently accessible.
- * Use the method YBluetoothLink.nextBluetoothLink() to iterate on
- * next cellular interfaces.
- *
- * @return a pointer to a YBluetoothLink object, corresponding to
- *         the first cellular interface currently online, or a NULL pointer
- *         if there are none.
- */
-inline YBluetoothLink* yFirstBluetoothLink(void)
-{ return YBluetoothLink::FirstBluetoothLink();}
-
-//--- (end of YBluetoothLink functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_buzzer.cpp
+++ /dev/null
@@ -1,782 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_buzzer.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindBuzzer(), the high-level API for Buzzer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_buzzer.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "buzzer"
-
-YBuzzer::YBuzzer(const string& func): YFunction(func)
-//--- (YBuzzer initialization)
-    ,_frequency(FREQUENCY_INVALID)
-    ,_volume(VOLUME_INVALID)
-    ,_playSeqSize(PLAYSEQSIZE_INVALID)
-    ,_playSeqMaxSize(PLAYSEQMAXSIZE_INVALID)
-    ,_playSeqSignature(PLAYSEQSIGNATURE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackBuzzer(NULL)
-//--- (end of YBuzzer initialization)
-{
-    _className="Buzzer";
-}
-
-YBuzzer::~YBuzzer()
-{
-//--- (YBuzzer cleanup)
-//--- (end of YBuzzer cleanup)
-}
-//--- (YBuzzer implementation)
-// static attributes
-const double YBuzzer::FREQUENCY_INVALID = YAPI_INVALID_DOUBLE;
-const string YBuzzer::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YBuzzer::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("frequency")) {
-        _frequency =  floor(json_val->getDouble("frequency") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("volume")) {
-        _volume =  json_val->getInt("volume");
-    }
-    if(json_val->has("playSeqSize")) {
-        _playSeqSize =  json_val->getInt("playSeqSize");
-    }
-    if(json_val->has("playSeqMaxSize")) {
-        _playSeqMaxSize =  json_val->getInt("playSeqMaxSize");
-    }
-    if(json_val->has("playSeqSignature")) {
-        _playSeqSignature =  json_val->getInt("playSeqSignature");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.
- *
- * @param newval : a floating point number corresponding to the frequency of the signal sent to the buzzer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::set_frequency(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("frequency", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the  frequency of the signal sent to the buzzer/speaker.
- *
- * @return a floating point number corresponding to the  frequency of the signal sent to the buzzer/speaker
- *
- * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
- */
-double YBuzzer::get_frequency(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::FREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _frequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the volume of the signal sent to the buzzer/speaker.
- *
- * @return an integer corresponding to the volume of the signal sent to the buzzer/speaker
- *
- * On failure, throws an exception or returns Y_VOLUME_INVALID.
- */
-int YBuzzer::get_volume(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::VOLUME_INVALID;
-                }
-            }
-        }
-        res = _volume;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the volume of the signal sent to the buzzer/speaker.
- *
- * @param newval : an integer corresponding to the volume of the signal sent to the buzzer/speaker
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::set_volume(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("volume", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current length of the playing sequence.
- *
- * @return an integer corresponding to the current length of the playing sequence
- *
- * On failure, throws an exception or returns Y_PLAYSEQSIZE_INVALID.
- */
-int YBuzzer::get_playSeqSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::PLAYSEQSIZE_INVALID;
-                }
-            }
-        }
-        res = _playSeqSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum length of the playing sequence.
- *
- * @return an integer corresponding to the maximum length of the playing sequence
- *
- * On failure, throws an exception or returns Y_PLAYSEQMAXSIZE_INVALID.
- */
-int YBuzzer::get_playSeqMaxSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::PLAYSEQMAXSIZE_INVALID;
-                }
-            }
-        }
-        res = _playSeqMaxSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the playing sequence signature. As playing
- * sequences cannot be read from the device, this can be used
- * to detect if a specific playing sequence is already
- * programmed.
- *
- * @return an integer corresponding to the playing sequence signature
- *
- * On failure, throws an exception or returns Y_PLAYSEQSIGNATURE_INVALID.
- */
-int YBuzzer::get_playSeqSignature(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::PLAYSEQSIGNATURE_INVALID;
-                }
-            }
-        }
-        res = _playSeqSignature;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YBuzzer::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YBuzzer::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YBuzzer::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a buzzer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the buzzer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YBuzzer.isOnline() to test if the buzzer is
- * indeed online at a given time. In case of ambiguity when looking for
- * a buzzer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the buzzer
- *
- * @return a YBuzzer object allowing you to drive the buzzer.
- */
-YBuzzer* YBuzzer::FindBuzzer(string func)
-{
-    YBuzzer* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YBuzzer*) YFunction::_FindFromCache("Buzzer", func);
-        if (obj == NULL) {
-            obj = new YBuzzer(func);
-            YFunction::_AddToCache("Buzzer", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YBuzzer::registerValueCallback(YBuzzerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackBuzzer = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YBuzzer::_invokeValueCallback(string value)
-{
-    if (_valueCallbackBuzzer != NULL) {
-        _valueCallbackBuzzer(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YBuzzer::sendCommand(string command)
-{
-    return this->set_command(command);
-}
-
-/**
- * Adds a new frequency transition to the playing sequence.
- *
- * @param freq    : desired frequency when the transition is completed, in Hz
- * @param msDelay : duration of the frequency transition, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::addFreqMoveToPlaySeq(int freq,int msDelay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("A%d,%d",freq,msDelay));
-}
-
-/**
- * Adds a pulse to the playing sequence.
- *
- * @param freq : pulse frequency, in Hz
- * @param msDuration : pulse duration, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::addPulseToPlaySeq(int freq,int msDuration)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("B%d,%d",freq,msDuration));
-}
-
-/**
- * Adds a new volume transition to the playing sequence. Frequency stays untouched:
- * if frequency is at zero, the transition has no effect.
- *
- * @param volume    : desired volume when the transition is completed, as a percentage.
- * @param msDuration : duration of the volume transition, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::addVolMoveToPlaySeq(int volume,int msDuration)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("C%d,%d",volume,msDuration));
-}
-
-/**
- * Adds notes to the playing sequence. Notes are provided as text words, separated by
- * spaces. The pitch is specified using the usual letter from A to G. The duration is
- * specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc.
- * Some modifiers are supported: # and b to alter a note pitch,
- * ' and , to move to the upper/lower octave, . to enlarge
- * the note duration.
- *
- * @param notes : notes to be played, as a text string.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::addNotesToPlaySeq(string notes)
-{
-    int tempo = 0;
-    int prevPitch = 0;
-    int prevDuration = 0;
-    int prevFreq = 0;
-    int note = 0;
-    int num = 0;
-    int typ = 0;
-    string ascNotes;
-    int notesLen = 0;
-    int i = 0;
-    int ch = 0;
-    int dNote = 0;
-    int pitch = 0;
-    int freq = 0;
-    int ms = 0;
-    int ms16 = 0;
-    int rest = 0;
-    tempo = 100;
-    prevPitch = 3;
-    prevDuration = 4;
-    prevFreq = 110;
-    note = -99;
-    num = 0;
-    typ = 3;
-    ascNotes = notes;
-    notesLen = (int)(ascNotes).size();
-    i = 0;
-    while (i < notesLen) {
-        ch = ((u8)ascNotes[i]);
-        // A (note))
-        if (ch == 65) {
-            note = 0;
-        }
-        // B (note)
-        if (ch == 66) {
-            note = 2;
-        }
-        // C (note)
-        if (ch == 67) {
-            note = 3;
-        }
-        // D (note)
-        if (ch == 68) {
-            note = 5;
-        }
-        // E (note)
-        if (ch == 69) {
-            note = 7;
-        }
-        // F (note)
-        if (ch == 70) {
-            note = 8;
-        }
-        // G (note)
-        if (ch == 71) {
-            note = 10;
-        }
-        // '#' (sharp modifier)
-        if (ch == 35) {
-            note = note + 1;
-        }
-        // 'b' (flat modifier)
-        if (ch == 98) {
-            note = note - 1;
-        }
-        // ' (octave up)
-        if (ch == 39) {
-            prevPitch = prevPitch + 12;
-        }
-        // , (octave down)
-        if (ch == 44) {
-            prevPitch = prevPitch - 12;
-        }
-        // R (rest)
-        if (ch == 82) {
-            typ = 0;
-        }
-        // ! (staccato modifier)
-        if (ch == 33) {
-            typ = 1;
-        }
-        // ^ (short modifier)
-        if (ch == 94) {
-            typ = 2;
-        }
-        // _ (legato modifier)
-        if (ch == 95) {
-            typ = 4;
-        }
-        // - (glissando modifier)
-        if (ch == 45) {
-            typ = 5;
-        }
-        // % (tempo change)
-        if ((ch == 37) && (num > 0)) {
-            tempo = num;
-            num = 0;
-        }
-        if ((ch >= 48) && (ch <= 57)) {
-            // 0-9 (number)
-            num = (num * 10) + (ch - 48);
-        }
-        if (ch == 46) {
-            // . (duration modifier)
-            num = ((num * 2) / (3));
-        }
-        if (((ch == 32) || (i+1 == notesLen)) && ((note > -99) || (typ != 3))) {
-            if (num == 0) {
-                num = prevDuration;
-            } else {
-                prevDuration = num;
-            }
-            ms = (int) floor(320000.0 / (tempo * num)+0.5);
-            if (typ == 0) {
-                this->addPulseToPlaySeq(0, ms);
-            } else {
-                dNote = note - (((prevPitch) % (12)));
-                if (dNote > 6) {
-                    dNote = dNote - 12;
-                }
-                if (dNote <= -6) {
-                    dNote = dNote + 12;
-                }
-                pitch = prevPitch + dNote;
-                freq = (int) floor(440 * exp(pitch * 0.05776226504666)+0.5);
-                ms16 = ((ms) >> (4));
-                rest = 0;
-                if (typ == 3) {
-                    rest = 2 * ms16;
-                }
-                if (typ == 2) {
-                    rest = 8 * ms16;
-                }
-                if (typ == 1) {
-                    rest = 12 * ms16;
-                }
-                if (typ == 5) {
-                    this->addPulseToPlaySeq(prevFreq, ms16);
-                    this->addFreqMoveToPlaySeq(freq, 8 * ms16);
-                    this->addPulseToPlaySeq(freq, ms - 9 * ms16);
-                } else {
-                    this->addPulseToPlaySeq(freq, ms - rest);
-                    if (rest > 0) {
-                        this->addPulseToPlaySeq(0, rest);
-                    }
-                }
-                prevFreq = freq;
-                prevPitch = pitch;
-            }
-            note = -99;
-            num = 0;
-            typ = 3;
-        }
-        i = i + 1;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Starts the preprogrammed playing sequence. The sequence
- * runs in loop until it is stopped by stopPlaySeq or an explicit
- * change. To play the sequence only once, use oncePlaySeq().
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::startPlaySeq(void)
-{
-    return this->sendCommand("S");
-}
-
-/**
- * Stops the preprogrammed playing sequence and sets the frequency to zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::stopPlaySeq(void)
-{
-    return this->sendCommand("X");
-}
-
-/**
- * Resets the preprogrammed playing sequence and sets the frequency to zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::resetPlaySeq(void)
-{
-    return this->sendCommand("Z");
-}
-
-/**
- * Starts the preprogrammed playing sequence and run it once only.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::oncePlaySeq(void)
-{
-    return this->sendCommand("s");
-}
-
-/**
- * Activates the buzzer for a short duration.
- *
- * @param frequency : pulse frequency, in hertz
- * @param duration : pulse duration in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::pulse(int frequency,int duration)
-{
-    return this->set_command(YapiWrapper::ysprintf("P%d,%d",frequency,duration));
-}
-
-/**
- * Makes the buzzer frequency change over a period of time.
- *
- * @param frequency : frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.
- * @param duration :  pulse duration in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::freqMove(int frequency,int duration)
-{
-    return this->set_command(YapiWrapper::ysprintf("F%d,%d",frequency,duration));
-}
-
-/**
- * Makes the buzzer volume change over a period of time, frequency  stays untouched.
- *
- * @param volume : volume to reach in %
- * @param duration : change duration in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::volumeMove(int volume,int duration)
-{
-    return this->set_command(YapiWrapper::ysprintf("V%d,%d",volume,duration));
-}
-
-/**
- * Immediately play a note sequence. Notes are provided as text words, separated by
- * spaces. The pitch is specified using the usual letter from A to G. The duration is
- * specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc.
- * Some modifiers are supported: # and b to alter a note pitch,
- * ' and , to move to the upper/lower octave, . to enlarge
- * the note duration.
- *
- * @param notes : notes to be played, as a text string.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YBuzzer::playNotes(string notes)
-{
-    this->resetPlaySeq();
-    this->addNotesToPlaySeq(notes);
-    return this->oncePlaySeq();
-}
-
-YBuzzer *YBuzzer::nextBuzzer(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YBuzzer::FindBuzzer(hwid);
-}
-
-YBuzzer* YBuzzer::FirstBuzzer(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Buzzer", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YBuzzer::FindBuzzer(serial+"."+funcId);
-}
-
-//--- (end of YBuzzer implementation)
-
-//--- (YBuzzer functions)
-//--- (end of YBuzzer functions)
--- a/Sources/cpplib/yocto_buzzer.h
+++ /dev/null
@@ -1,470 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_buzzer.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindBuzzer(), the high-level API for Buzzer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_BUZZER_H
-#define YOCTO_BUZZER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YBuzzer return codes)
-//--- (end of YBuzzer return codes)
-//--- (YBuzzer yapiwrapper)
-//--- (end of YBuzzer yapiwrapper)
-//--- (YBuzzer definitions)
-class YBuzzer; // forward declaration
-
-typedef void (*YBuzzerValueCallback)(YBuzzer *func, const string& functionValue);
-#define Y_FREQUENCY_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_VOLUME_INVALID                (YAPI_INVALID_UINT)
-#define Y_PLAYSEQSIZE_INVALID           (YAPI_INVALID_UINT)
-#define Y_PLAYSEQMAXSIZE_INVALID        (YAPI_INVALID_UINT)
-#define Y_PLAYSEQSIGNATURE_INVALID      (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YBuzzer definitions)
-
-//--- (YBuzzer declaration)
-/**
- * YBuzzer Class: Buzzer function interface
- *
- * The Yoctopuce application programming interface allows you to
- * choose the frequency and volume at which the buzzer must sound.
- * You can also pre-program a play sequence.
- */
-class YOCTO_CLASS_EXPORT YBuzzer: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YBuzzer declaration)
-protected:
-    //--- (YBuzzer attributes)
-    // Attributes (function value cache)
-    double          _frequency;
-    int             _volume;
-    int             _playSeqSize;
-    int             _playSeqMaxSize;
-    int             _playSeqSignature;
-    string          _command;
-    YBuzzerValueCallback _valueCallbackBuzzer;
-
-    friend YBuzzer *yFindBuzzer(const string& func);
-    friend YBuzzer *yFirstBuzzer(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindBuzzer factory function to instantiate
-    YBuzzer(const string& func);
-    //--- (end of YBuzzer attributes)
-
-public:
-    virtual ~YBuzzer();
-    //--- (YBuzzer accessors declaration)
-
-    static const double FREQUENCY_INVALID;
-    static const int VOLUME_INVALID = YAPI_INVALID_UINT;
-    static const int PLAYSEQSIZE_INVALID = YAPI_INVALID_UINT;
-    static const int PLAYSEQMAXSIZE_INVALID = YAPI_INVALID_UINT;
-    static const int PLAYSEQSIGNATURE_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.
-     *
-     * @param newval : a floating point number corresponding to the frequency of the signal sent to the buzzer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_frequency(double newval);
-    inline int      setFrequency(double newval)
-    { return this->set_frequency(newval); }
-
-    /**
-     * Returns the  frequency of the signal sent to the buzzer/speaker.
-     *
-     * @return a floating point number corresponding to the  frequency of the signal sent to the buzzer/speaker
-     *
-     * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
-     */
-    double              get_frequency(void);
-
-    inline double       frequency(void)
-    { return this->get_frequency(); }
-
-    /**
-     * Returns the volume of the signal sent to the buzzer/speaker.
-     *
-     * @return an integer corresponding to the volume of the signal sent to the buzzer/speaker
-     *
-     * On failure, throws an exception or returns Y_VOLUME_INVALID.
-     */
-    int                 get_volume(void);
-
-    inline int          volume(void)
-    { return this->get_volume(); }
-
-    /**
-     * Changes the volume of the signal sent to the buzzer/speaker.
-     *
-     * @param newval : an integer corresponding to the volume of the signal sent to the buzzer/speaker
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_volume(int newval);
-    inline int      setVolume(int newval)
-    { return this->set_volume(newval); }
-
-    /**
-     * Returns the current length of the playing sequence.
-     *
-     * @return an integer corresponding to the current length of the playing sequence
-     *
-     * On failure, throws an exception or returns Y_PLAYSEQSIZE_INVALID.
-     */
-    int                 get_playSeqSize(void);
-
-    inline int          playSeqSize(void)
-    { return this->get_playSeqSize(); }
-
-    /**
-     * Returns the maximum length of the playing sequence.
-     *
-     * @return an integer corresponding to the maximum length of the playing sequence
-     *
-     * On failure, throws an exception or returns Y_PLAYSEQMAXSIZE_INVALID.
-     */
-    int                 get_playSeqMaxSize(void);
-
-    inline int          playSeqMaxSize(void)
-    { return this->get_playSeqMaxSize(); }
-
-    /**
-     * Returns the playing sequence signature. As playing
-     * sequences cannot be read from the device, this can be used
-     * to detect if a specific playing sequence is already
-     * programmed.
-     *
-     * @return an integer corresponding to the playing sequence signature
-     *
-     * On failure, throws an exception or returns Y_PLAYSEQSIGNATURE_INVALID.
-     */
-    int                 get_playSeqSignature(void);
-
-    inline int          playSeqSignature(void)
-    { return this->get_playSeqSignature(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a buzzer for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the buzzer is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YBuzzer.isOnline() to test if the buzzer is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a buzzer by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the buzzer
-     *
-     * @return a YBuzzer object allowing you to drive the buzzer.
-     */
-    static YBuzzer*     FindBuzzer(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YBuzzerValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string command);
-
-    /**
-     * Adds a new frequency transition to the playing sequence.
-     *
-     * @param freq    : desired frequency when the transition is completed, in Hz
-     * @param msDelay : duration of the frequency transition, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addFreqMoveToPlaySeq(int freq,int msDelay);
-
-    /**
-     * Adds a pulse to the playing sequence.
-     *
-     * @param freq : pulse frequency, in Hz
-     * @param msDuration : pulse duration, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addPulseToPlaySeq(int freq,int msDuration);
-
-    /**
-     * Adds a new volume transition to the playing sequence. Frequency stays untouched:
-     * if frequency is at zero, the transition has no effect.
-     *
-     * @param volume    : desired volume when the transition is completed, as a percentage.
-     * @param msDuration : duration of the volume transition, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addVolMoveToPlaySeq(int volume,int msDuration);
-
-    /**
-     * Adds notes to the playing sequence. Notes are provided as text words, separated by
-     * spaces. The pitch is specified using the usual letter from A to G. The duration is
-     * specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc.
-     * Some modifiers are supported: # and b to alter a note pitch,
-     * ' and , to move to the upper/lower octave, . to enlarge
-     * the note duration.
-     *
-     * @param notes : notes to be played, as a text string.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addNotesToPlaySeq(string notes);
-
-    /**
-     * Starts the preprogrammed playing sequence. The sequence
-     * runs in loop until it is stopped by stopPlaySeq or an explicit
-     * change. To play the sequence only once, use oncePlaySeq().
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         startPlaySeq(void);
-
-    /**
-     * Stops the preprogrammed playing sequence and sets the frequency to zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         stopPlaySeq(void);
-
-    /**
-     * Resets the preprogrammed playing sequence and sets the frequency to zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetPlaySeq(void);
-
-    /**
-     * Starts the preprogrammed playing sequence and run it once only.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         oncePlaySeq(void);
-
-    /**
-     * Activates the buzzer for a short duration.
-     *
-     * @param frequency : pulse frequency, in hertz
-     * @param duration : pulse duration in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pulse(int frequency,int duration);
-
-    /**
-     * Makes the buzzer frequency change over a period of time.
-     *
-     * @param frequency : frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.
-     * @param duration :  pulse duration in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         freqMove(int frequency,int duration);
-
-    /**
-     * Makes the buzzer volume change over a period of time, frequency  stays untouched.
-     *
-     * @param volume : volume to reach in %
-     * @param duration : change duration in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         volumeMove(int volume,int duration);
-
-    /**
-     * Immediately play a note sequence. Notes are provided as text words, separated by
-     * spaces. The pitch is specified using the usual letter from A to G. The duration is
-     * specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc.
-     * Some modifiers are supported: # and b to alter a note pitch,
-     * ' and , to move to the upper/lower octave, . to enlarge
-     * the note duration.
-     *
-     * @param notes : notes to be played, as a text string.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         playNotes(string notes);
-
-
-    inline static YBuzzer* Find(string func)
-    { return YBuzzer::FindBuzzer(func); }
-
-    /**
-     * Continues the enumeration of buzzers started using yFirstBuzzer().
-     * Caution: You can't make any assumption about the returned buzzers order.
-     * If you want to find a specific a buzzer, use Buzzer.findBuzzer()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YBuzzer object, corresponding to
-     *         a buzzer currently online, or a NULL pointer
-     *         if there are no more buzzers to enumerate.
-     */
-           YBuzzer         *nextBuzzer(void);
-    inline YBuzzer         *next(void)
-    { return this->nextBuzzer();}
-
-    /**
-     * Starts the enumeration of buzzers currently accessible.
-     * Use the method YBuzzer.nextBuzzer() to iterate on
-     * next buzzers.
-     *
-     * @return a pointer to a YBuzzer object, corresponding to
-     *         the first buzzer currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YBuzzer* FirstBuzzer(void);
-    inline static YBuzzer* First(void)
-    { return YBuzzer::FirstBuzzer();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YBuzzer accessors declaration)
-};
-
-//--- (YBuzzer functions declaration)
-
-/**
- * Retrieves a buzzer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the buzzer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YBuzzer.isOnline() to test if the buzzer is
- * indeed online at a given time. In case of ambiguity when looking for
- * a buzzer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the buzzer
- *
- * @return a YBuzzer object allowing you to drive the buzzer.
- */
-inline YBuzzer* yFindBuzzer(const string& func)
-{ return YBuzzer::FindBuzzer(func);}
-/**
- * Starts the enumeration of buzzers currently accessible.
- * Use the method YBuzzer.nextBuzzer() to iterate on
- * next buzzers.
- *
- * @return a pointer to a YBuzzer object, corresponding to
- *         the first buzzer currently online, or a NULL pointer
- *         if there are none.
- */
-inline YBuzzer* yFirstBuzzer(void)
-{ return YBuzzer::FirstBuzzer();}
-
-//--- (end of YBuzzer functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_carbondioxide.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_carbondioxide.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindCarbonDioxide(), the high-level API for CarbonDioxide functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_carbondioxide.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "carbondioxide"
-
-YCarbonDioxide::YCarbonDioxide(const string& func): YSensor(func)
-//--- (YCarbonDioxide initialization)
-    ,_abcPeriod(ABCPERIOD_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackCarbonDioxide(NULL)
-    ,_timedReportCallbackCarbonDioxide(NULL)
-//--- (end of YCarbonDioxide initialization)
-{
-    _className="CarbonDioxide";
-}
-
-YCarbonDioxide::~YCarbonDioxide()
-{
-//--- (YCarbonDioxide cleanup)
-//--- (end of YCarbonDioxide cleanup)
-}
-//--- (YCarbonDioxide implementation)
-// static attributes
-const string YCarbonDioxide::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YCarbonDioxide::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("abcPeriod")) {
-        _abcPeriod =  json_val->getInt("abcPeriod");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the Automatic Baseline Calibration period, in hours. A negative value
- * means that automatic baseline calibration is disabled.
- *
- * @return an integer corresponding to the Automatic Baseline Calibration period, in hours
- *
- * On failure, throws an exception or returns Y_ABCPERIOD_INVALID.
- */
-int YCarbonDioxide::get_abcPeriod(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCarbonDioxide::ABCPERIOD_INVALID;
-                }
-            }
-        }
-        res = _abcPeriod;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes Automatic Baseline Calibration period, in hours. If you need
- * to disable automatic baseline calibration (for instance when using the
- * sensor in an environment that is constantly above 400 ppm CO2), set the
- * period to -1. Remember to call the saveToFlash() method of the
- * module if the modification must be kept.
- *
- * @param newval : an integer corresponding to Automatic Baseline Calibration period, in hours
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCarbonDioxide::set_abcPeriod(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("abcPeriod", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YCarbonDioxide::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCarbonDioxide::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YCarbonDioxide::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a CO2 sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the CO2 sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCarbonDioxide.isOnline() to test if the CO2 sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a CO2 sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the CO2 sensor
- *
- * @return a YCarbonDioxide object allowing you to drive the CO2 sensor.
- */
-YCarbonDioxide* YCarbonDioxide::FindCarbonDioxide(string func)
-{
-    YCarbonDioxide* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YCarbonDioxide*) YFunction::_FindFromCache("CarbonDioxide", func);
-        if (obj == NULL) {
-            obj = new YCarbonDioxide(func);
-            YFunction::_AddToCache("CarbonDioxide", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YCarbonDioxide::registerValueCallback(YCarbonDioxideValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackCarbonDioxide = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YCarbonDioxide::_invokeValueCallback(string value)
-{
-    if (_valueCallbackCarbonDioxide != NULL) {
-        _valueCallbackCarbonDioxide(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YCarbonDioxide::registerTimedReportCallback(YCarbonDioxideTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackCarbonDioxide = callback;
-    return 0;
-}
-
-int YCarbonDioxide::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackCarbonDioxide != NULL) {
-        _timedReportCallbackCarbonDioxide(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Triggers a baseline calibration at standard CO2 ambiant level (400ppm).
- * It is normally not necessary to manually calibrate the sensor, because
- * the built-in automatic baseline calibration procedure will automatically
- * fix any long-term drift based on the lowest level of CO2 observed over the
- * automatic calibration period. However, if you disable automatic baseline
- * calibration, you may want to manually trigger a calibration from time to
- * time. Before starting a baseline calibration, make sure to put the sensor
- * in a standard environment (e.g. outside in fresh air) at around 400 ppm.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCarbonDioxide::triggerBaselineCalibration(void)
-{
-    return this->set_command("BC");
-}
-
-int YCarbonDioxide::triggetBaselineCalibration(void)
-{
-    return this->triggerBaselineCalibration();
-}
-
-/**
- * Triggers a zero calibration of the sensor on carbon dioxide-free air.
- * It is normally not necessary to manually calibrate the sensor, because
- * the built-in automatic baseline calibration procedure will automatically
- * fix any long-term drift based on the lowest level of CO2 observed over the
- * automatic calibration period. However, if you disable automatic baseline
- * calibration, you may want to manually trigger a calibration from time to
- * time. Before starting a zero calibration, you should circulate carbon
- * dioxide-free air within the sensor for a minute or two, using a small pipe
- * connected to the sensor. Please contact support@yoctopuce.com for more details
- * on the zero calibration procedure.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCarbonDioxide::triggerZeroCalibration(void)
-{
-    return this->set_command("ZC");
-}
-
-int YCarbonDioxide::triggetZeroCalibration(void)
-{
-    return this->triggerZeroCalibration();
-}
-
-YCarbonDioxide *YCarbonDioxide::nextCarbonDioxide(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YCarbonDioxide::FindCarbonDioxide(hwid);
-}
-
-YCarbonDioxide* YCarbonDioxide::FirstCarbonDioxide(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("CarbonDioxide", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YCarbonDioxide::FindCarbonDioxide(serial+"."+funcId);
-}
-
-//--- (end of YCarbonDioxide implementation)
-
-//--- (YCarbonDioxide functions)
-//--- (end of YCarbonDioxide functions)
--- a/Sources/cpplib/yocto_carbondioxide.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_carbondioxide.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindCarbonDioxide(), the high-level API for CarbonDioxide functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_CARBONDIOXIDE_H
-#define YOCTO_CARBONDIOXIDE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YCarbonDioxide return codes)
-//--- (end of YCarbonDioxide return codes)
-//--- (YCarbonDioxide yapiwrapper)
-//--- (end of YCarbonDioxide yapiwrapper)
-//--- (YCarbonDioxide definitions)
-class YCarbonDioxide; // forward declaration
-
-typedef void (*YCarbonDioxideValueCallback)(YCarbonDioxide *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YCarbonDioxideTimedReportCallback)(YCarbonDioxide *func, YMeasure measure);
-#define Y_ABCPERIOD_INVALID             (YAPI_INVALID_INT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YCarbonDioxide definitions)
-
-//--- (YCarbonDioxide declaration)
-/**
- * YCarbonDioxide Class: CarbonDioxide function interface
- *
- * The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions,  to access the autonomous datalogger.
- * This class adds the ability to perform manual calibration if required.
- */
-class YOCTO_CLASS_EXPORT YCarbonDioxide: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YCarbonDioxide declaration)
-protected:
-    //--- (YCarbonDioxide attributes)
-    // Attributes (function value cache)
-    int             _abcPeriod;
-    string          _command;
-    YCarbonDioxideValueCallback _valueCallbackCarbonDioxide;
-    YCarbonDioxideTimedReportCallback _timedReportCallbackCarbonDioxide;
-
-    friend YCarbonDioxide *yFindCarbonDioxide(const string& func);
-    friend YCarbonDioxide *yFirstCarbonDioxide(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindCarbonDioxide factory function to instantiate
-    YCarbonDioxide(const string& func);
-    //--- (end of YCarbonDioxide attributes)
-
-public:
-    virtual ~YCarbonDioxide();
-    //--- (YCarbonDioxide accessors declaration)
-
-    static const int ABCPERIOD_INVALID = YAPI_INVALID_INT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the Automatic Baseline Calibration period, in hours. A negative value
-     * means that automatic baseline calibration is disabled.
-     *
-     * @return an integer corresponding to the Automatic Baseline Calibration period, in hours
-     *
-     * On failure, throws an exception or returns Y_ABCPERIOD_INVALID.
-     */
-    int                 get_abcPeriod(void);
-
-    inline int          abcPeriod(void)
-    { return this->get_abcPeriod(); }
-
-    /**
-     * Changes Automatic Baseline Calibration period, in hours. If you need
-     * to disable automatic baseline calibration (for instance when using the
-     * sensor in an environment that is constantly above 400 ppm CO2), set the
-     * period to -1. Remember to call the saveToFlash() method of the
-     * module if the modification must be kept.
-     *
-     * @param newval : an integer corresponding to Automatic Baseline Calibration period, in hours
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_abcPeriod(int newval);
-    inline int      setAbcPeriod(int newval)
-    { return this->set_abcPeriod(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a CO2 sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the CO2 sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YCarbonDioxide.isOnline() to test if the CO2 sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a CO2 sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the CO2 sensor
-     *
-     * @return a YCarbonDioxide object allowing you to drive the CO2 sensor.
-     */
-    static YCarbonDioxide* FindCarbonDioxide(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YCarbonDioxideValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YCarbonDioxideTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Triggers a baseline calibration at standard CO2 ambiant level (400ppm).
-     * It is normally not necessary to manually calibrate the sensor, because
-     * the built-in automatic baseline calibration procedure will automatically
-     * fix any long-term drift based on the lowest level of CO2 observed over the
-     * automatic calibration period. However, if you disable automatic baseline
-     * calibration, you may want to manually trigger a calibration from time to
-     * time. Before starting a baseline calibration, make sure to put the sensor
-     * in a standard environment (e.g. outside in fresh air) at around 400 ppm.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerBaselineCalibration(void);
-
-    virtual int         triggetBaselineCalibration(void);
-
-    /**
-     * Triggers a zero calibration of the sensor on carbon dioxide-free air.
-     * It is normally not necessary to manually calibrate the sensor, because
-     * the built-in automatic baseline calibration procedure will automatically
-     * fix any long-term drift based on the lowest level of CO2 observed over the
-     * automatic calibration period. However, if you disable automatic baseline
-     * calibration, you may want to manually trigger a calibration from time to
-     * time. Before starting a zero calibration, you should circulate carbon
-     * dioxide-free air within the sensor for a minute or two, using a small pipe
-     * connected to the sensor. Please contact support@yoctopuce.com for more details
-     * on the zero calibration procedure.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerZeroCalibration(void);
-
-    virtual int         triggetZeroCalibration(void);
-
-
-    inline static YCarbonDioxide* Find(string func)
-    { return YCarbonDioxide::FindCarbonDioxide(func); }
-
-    /**
-     * Continues the enumeration of CO2 sensors started using yFirstCarbonDioxide().
-     * Caution: You can't make any assumption about the returned CO2 sensors order.
-     * If you want to find a specific a CO2 sensor, use CarbonDioxide.findCarbonDioxide()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YCarbonDioxide object, corresponding to
-     *         a CO2 sensor currently online, or a NULL pointer
-     *         if there are no more CO2 sensors to enumerate.
-     */
-           YCarbonDioxide  *nextCarbonDioxide(void);
-    inline YCarbonDioxide  *next(void)
-    { return this->nextCarbonDioxide();}
-
-    /**
-     * Starts the enumeration of CO2 sensors currently accessible.
-     * Use the method YCarbonDioxide.nextCarbonDioxide() to iterate on
-     * next CO2 sensors.
-     *
-     * @return a pointer to a YCarbonDioxide object, corresponding to
-     *         the first CO2 sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YCarbonDioxide* FirstCarbonDioxide(void);
-    inline static YCarbonDioxide* First(void)
-    { return YCarbonDioxide::FirstCarbonDioxide();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YCarbonDioxide accessors declaration)
-};
-
-//--- (YCarbonDioxide functions declaration)
-
-/**
- * Retrieves a CO2 sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the CO2 sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCarbonDioxide.isOnline() to test if the CO2 sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a CO2 sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the CO2 sensor
- *
- * @return a YCarbonDioxide object allowing you to drive the CO2 sensor.
- */
-inline YCarbonDioxide* yFindCarbonDioxide(const string& func)
-{ return YCarbonDioxide::FindCarbonDioxide(func);}
-/**
- * Starts the enumeration of CO2 sensors currently accessible.
- * Use the method YCarbonDioxide.nextCarbonDioxide() to iterate on
- * next CO2 sensors.
- *
- * @return a pointer to a YCarbonDioxide object, corresponding to
- *         the first CO2 sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YCarbonDioxide* yFirstCarbonDioxide(void)
-{ return YCarbonDioxide::FirstCarbonDioxide();}
-
-//--- (end of YCarbonDioxide functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_cellular.cpp
+++ /dev/null
@@ -1,1302 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_cellular.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- * Implements yFindCellular(), the high-level API for Cellular functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_cellular.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "cellular"
-
-
-
-YCellRecord::YCellRecord(int mcc,int mnc,int lac,int cellId,int dbm,int tad,const string &oper):
-//--- (generated code: YCellRecord initialization)
-    _mcc(0)
-    ,_mnc(0)
-    ,_lac(0)
-    ,_cid(0)
-    ,_dbm(0)
-    ,_tad(0)
-//--- (end of generated code: YCellRecord initialization)
-{
-    _oper = oper;
-    _mcc = mcc;
-    _mnc = mnc;
-    _lac = lac;
-    _cid = cellId;
-    _dbm = dbm;
-    _tad = tad;
-
-}
-
-//--- (generated code: YCellRecord implementation)
-// static attributes
-
-
-string YCellRecord::get_cellOperator(void)
-{
-    return _oper;
-}
-
-int YCellRecord::get_mobileCountryCode(void)
-{
-    return _mcc;
-}
-
-int YCellRecord::get_mobileNetworkCode(void)
-{
-    return _mnc;
-}
-
-int YCellRecord::get_locationAreaCode(void)
-{
-    return _lac;
-}
-
-int YCellRecord::get_cellId(void)
-{
-    return _cid;
-}
-
-int YCellRecord::get_signalStrength(void)
-{
-    return _dbm;
-}
-
-int YCellRecord::get_timingAdvance(void)
-{
-    return _tad;
-}
-//--- (end of generated code: YCellRecord implementation)
-
-
-YCellular::YCellular(const string& func): YFunction(func)
-//--- (generated code: YCellular initialization)
-    ,_linkQuality(LINKQUALITY_INVALID)
-    ,_cellOperator(CELLOPERATOR_INVALID)
-    ,_cellIdentifier(CELLIDENTIFIER_INVALID)
-    ,_cellType(CELLTYPE_INVALID)
-    ,_imsi(IMSI_INVALID)
-    ,_message(MESSAGE_INVALID)
-    ,_pin(PIN_INVALID)
-    ,_lockedOperator(LOCKEDOPERATOR_INVALID)
-    ,_airplaneMode(AIRPLANEMODE_INVALID)
-    ,_enableData(ENABLEDATA_INVALID)
-    ,_apn(APN_INVALID)
-    ,_apnSecret(APNSECRET_INVALID)
-    ,_pingInterval(PINGINTERVAL_INVALID)
-    ,_dataSent(DATASENT_INVALID)
-    ,_dataReceived(DATARECEIVED_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackCellular(NULL)
-//--- (end of generated code: YCellular initialization)
-{
-    _className="Cellular";
-}
-
-YCellular::~YCellular()
-{
-//--- (generated code: YCellular cleanup)
-//--- (end of generated code: YCellular cleanup)
-}
-//--- (generated code: YCellular implementation)
-// static attributes
-const string YCellular::CELLOPERATOR_INVALID = YAPI_INVALID_STRING;
-const string YCellular::CELLIDENTIFIER_INVALID = YAPI_INVALID_STRING;
-const string YCellular::IMSI_INVALID = YAPI_INVALID_STRING;
-const string YCellular::MESSAGE_INVALID = YAPI_INVALID_STRING;
-const string YCellular::PIN_INVALID = YAPI_INVALID_STRING;
-const string YCellular::LOCKEDOPERATOR_INVALID = YAPI_INVALID_STRING;
-const string YCellular::APN_INVALID = YAPI_INVALID_STRING;
-const string YCellular::APNSECRET_INVALID = YAPI_INVALID_STRING;
-const string YCellular::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YCellular::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("linkQuality")) {
-        _linkQuality =  json_val->getInt("linkQuality");
-    }
-    if(json_val->has("cellOperator")) {
-        _cellOperator =  json_val->getString("cellOperator");
-    }
-    if(json_val->has("cellIdentifier")) {
-        _cellIdentifier =  json_val->getString("cellIdentifier");
-    }
-    if(json_val->has("cellType")) {
-        _cellType =  (Y_CELLTYPE_enum)json_val->getInt("cellType");
-    }
-    if(json_val->has("imsi")) {
-        _imsi =  json_val->getString("imsi");
-    }
-    if(json_val->has("message")) {
-        _message =  json_val->getString("message");
-    }
-    if(json_val->has("pin")) {
-        _pin =  json_val->getString("pin");
-    }
-    if(json_val->has("lockedOperator")) {
-        _lockedOperator =  json_val->getString("lockedOperator");
-    }
-    if(json_val->has("airplaneMode")) {
-        _airplaneMode =  (Y_AIRPLANEMODE_enum)json_val->getInt("airplaneMode");
-    }
-    if(json_val->has("enableData")) {
-        _enableData =  (Y_ENABLEDATA_enum)json_val->getInt("enableData");
-    }
-    if(json_val->has("apn")) {
-        _apn =  json_val->getString("apn");
-    }
-    if(json_val->has("apnSecret")) {
-        _apnSecret =  json_val->getString("apnSecret");
-    }
-    if(json_val->has("pingInterval")) {
-        _pingInterval =  json_val->getInt("pingInterval");
-    }
-    if(json_val->has("dataSent")) {
-        _dataSent =  json_val->getInt("dataSent");
-    }
-    if(json_val->has("dataReceived")) {
-        _dataReceived =  json_val->getInt("dataReceived");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the link quality, expressed in percent.
- *
- * @return an integer corresponding to the link quality, expressed in percent
- *
- * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
- */
-int YCellular::get_linkQuality(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::LINKQUALITY_INVALID;
-                }
-            }
-        }
-        res = _linkQuality;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the name of the cell operator currently in use.
- *
- * @return a string corresponding to the name of the cell operator currently in use
- *
- * On failure, throws an exception or returns Y_CELLOPERATOR_INVALID.
- */
-string YCellular::get_cellOperator(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::CELLOPERATOR_INVALID;
-                }
-            }
-        }
-        res = _cellOperator;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.
- *
- * @return a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC,
- * LAC and Cell ID
- *
- * On failure, throws an exception or returns Y_CELLIDENTIFIER_INVALID.
- */
-string YCellular::get_cellIdentifier(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::CELLIDENTIFIER_INVALID;
-                }
-            }
-        }
-        res = _cellIdentifier;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Active cellular connection type.
- *
- * @return a value among Y_CELLTYPE_GPRS, Y_CELLTYPE_EGPRS, Y_CELLTYPE_WCDMA, Y_CELLTYPE_HSDPA,
- * Y_CELLTYPE_NONE and Y_CELLTYPE_CDMA
- *
- * On failure, throws an exception or returns Y_CELLTYPE_INVALID.
- */
-Y_CELLTYPE_enum YCellular::get_cellType(void)
-{
-    Y_CELLTYPE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::CELLTYPE_INVALID;
-                }
-            }
-        }
-        res = _cellType;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns an opaque string if a PIN code has been configured in the device to access
- * the SIM card, or an empty string if none has been configured or if the code provided
- * was rejected by the SIM card.
- *
- * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
- *         the SIM card, or an empty string if none has been configured or if the code provided
- *         was rejected by the SIM card
- *
- * On failure, throws an exception or returns Y_IMSI_INVALID.
- */
-string YCellular::get_imsi(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::IMSI_INVALID;
-                }
-            }
-        }
-        res = _imsi;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the latest status message from the wireless interface.
- *
- * @return a string corresponding to the latest status message from the wireless interface
- *
- * On failure, throws an exception or returns Y_MESSAGE_INVALID.
- */
-string YCellular::get_message(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::MESSAGE_INVALID;
-                }
-            }
-        }
-        res = _message;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns an opaque string if a PIN code has been configured in the device to access
- * the SIM card, or an empty string if none has been configured or if the code provided
- * was rejected by the SIM card.
- *
- * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
- *         the SIM card, or an empty string if none has been configured or if the code provided
- *         was rejected by the SIM card
- *
- * On failure, throws an exception or returns Y_PIN_INVALID.
- */
-string YCellular::get_pin(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::PIN_INVALID;
-                }
-            }
-        }
-        res = _pin;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PIN code used by the module to access the SIM card.
- * This function does not change the code on the SIM card itself, but only changes
- * the parameter used by the device to try to get access to it. If the SIM code
- * does not work immediately on first try, it will be automatically forgotten
- * and the message will be set to "Enter SIM PIN". The method should then be
- * invoked again with right correct PIN code. After three failed attempts in a row,
- * the message is changed to "Enter SIM PUK" and the SIM card PUK code must be
- * provided using method sendPUK.
- *
- * Remember to call the saveToFlash() method of the module to save the
- * new value in the device flash.
- *
- * @param newval : a string corresponding to the PIN code used by the module to access the SIM card
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_pin(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("pin", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the name of the only cell operator to use if automatic choice is disabled,
- * or an empty string if the SIM card will automatically choose among available
- * cell operators.
- *
- * @return a string corresponding to the name of the only cell operator to use if automatic choice is disabled,
- *         or an empty string if the SIM card will automatically choose among available
- *         cell operators
- *
- * On failure, throws an exception or returns Y_LOCKEDOPERATOR_INVALID.
- */
-string YCellular::get_lockedOperator(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::LOCKEDOPERATOR_INVALID;
-                }
-            }
-        }
-        res = _lockedOperator;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the name of the cell operator to be used. If the name is an empty
- * string, the choice will be made automatically based on the SIM card. Otherwise,
- * the selected operator is the only one that will be used.
- *
- * @param newval : a string corresponding to the name of the cell operator to be used
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_lockedOperator(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("lockedOperator", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true if the airplane mode is active (radio turned off).
- *
- * @return either Y_AIRPLANEMODE_OFF or Y_AIRPLANEMODE_ON, according to true if the airplane mode is
- * active (radio turned off)
- *
- * On failure, throws an exception or returns Y_AIRPLANEMODE_INVALID.
- */
-Y_AIRPLANEMODE_enum YCellular::get_airplaneMode(void)
-{
-    Y_AIRPLANEMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::AIRPLANEMODE_INVALID;
-                }
-            }
-        }
-        res = _airplaneMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the activation state of airplane mode (radio turned off).
- *
- * @param newval : either Y_AIRPLANEMODE_OFF or Y_AIRPLANEMODE_ON, according to the activation state
- * of airplane mode (radio turned off)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_airplaneMode(Y_AIRPLANEMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("airplaneMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the condition for enabling IP data services (GPRS).
- * When data services are disabled, SMS are the only mean of communication.
- *
- * @return a value among Y_ENABLEDATA_HOMENETWORK, Y_ENABLEDATA_ROAMING, Y_ENABLEDATA_NEVER and
- * Y_ENABLEDATA_NEUTRALITY corresponding to the condition for enabling IP data services (GPRS)
- *
- * On failure, throws an exception or returns Y_ENABLEDATA_INVALID.
- */
-Y_ENABLEDATA_enum YCellular::get_enableData(void)
-{
-    Y_ENABLEDATA_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::ENABLEDATA_INVALID;
-                }
-            }
-        }
-        res = _enableData;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the condition for enabling IP data services (GPRS).
- * The service can be either fully deactivated, or limited to the SIM home network,
- * or enabled for all partner networks (roaming). Caution: enabling data services
- * on roaming networks may cause prohibitive communication costs !
- *
- * When data services are disabled, SMS are the only mean of communication.
- *
- * @param newval : a value among Y_ENABLEDATA_HOMENETWORK, Y_ENABLEDATA_ROAMING, Y_ENABLEDATA_NEVER
- * and Y_ENABLEDATA_NEUTRALITY corresponding to the condition for enabling IP data services (GPRS)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_enableData(Y_ENABLEDATA_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("enableData", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Access Point Name (APN) to be used, if needed.
- * When left blank, the APN suggested by the cell operator will be used.
- *
- * @return a string corresponding to the Access Point Name (APN) to be used, if needed
- *
- * On failure, throws an exception or returns Y_APN_INVALID.
- */
-string YCellular::get_apn(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::APN_INVALID;
-                }
-            }
-        }
-        res = _apn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Access Point Name (APN) to be used, if needed.
- * When left blank, the APN suggested by the cell operator will be used.
- *
- * @param newval : a string
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_apn(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("apn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns an opaque string if APN authentication parameters have been configured
- * in the device, or an empty string otherwise.
- * To configure these parameters, use set_apnAuth().
- *
- * @return a string corresponding to an opaque string if APN authentication parameters have been configured
- *         in the device, or an empty string otherwise
- *
- * On failure, throws an exception or returns Y_APNSECRET_INVALID.
- */
-string YCellular::get_apnSecret(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::APNSECRET_INVALID;
-                }
-            }
-        }
-        res = _apnSecret;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YCellular::set_apnSecret(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("apnSecret", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the automated connectivity check interval, in seconds.
- *
- * @return an integer corresponding to the automated connectivity check interval, in seconds
- *
- * On failure, throws an exception or returns Y_PINGINTERVAL_INVALID.
- */
-int YCellular::get_pingInterval(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::PINGINTERVAL_INVALID;
-                }
-            }
-        }
-        res = _pingInterval;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the automated connectivity check interval, in seconds.
- *
- * @param newval : an integer corresponding to the automated connectivity check interval, in seconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_pingInterval(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("pingInterval", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of bytes sent so far.
- *
- * @return an integer corresponding to the number of bytes sent so far
- *
- * On failure, throws an exception or returns Y_DATASENT_INVALID.
- */
-int YCellular::get_dataSent(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::DATASENT_INVALID;
-                }
-            }
-        }
-        res = _dataSent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the value of the outgoing data counter.
- *
- * @param newval : an integer corresponding to the value of the outgoing data counter
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_dataSent(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("dataSent", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of bytes received so far.
- *
- * @return an integer corresponding to the number of bytes received so far
- *
- * On failure, throws an exception or returns Y_DATARECEIVED_INVALID.
- */
-int YCellular::get_dataReceived(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::DATARECEIVED_INVALID;
-                }
-            }
-        }
-        res = _dataReceived;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the value of the incoming data counter.
- *
- * @param newval : an integer corresponding to the value of the incoming data counter
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_dataReceived(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("dataReceived", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YCellular::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCellular::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YCellular::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a cellular interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the cellular interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCellular.isOnline() to test if the cellular interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a cellular interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the cellular interface
- *
- * @return a YCellular object allowing you to drive the cellular interface.
- */
-YCellular* YCellular::FindCellular(string func)
-{
-    YCellular* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YCellular*) YFunction::_FindFromCache("Cellular", func);
-        if (obj == NULL) {
-            obj = new YCellular(func);
-            YFunction::_AddToCache("Cellular", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YCellular::registerValueCallback(YCellularValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackCellular = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YCellular::_invokeValueCallback(string value)
-{
-    if (_valueCallbackCellular != NULL) {
-        _valueCallbackCellular(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and
- * setup a new PIN into the SIM card. Only ten consecutive tentatives are permitted:
- * after that, the SIM card will be blocked permanently without any mean of recovery
- * to use it again. Note that after calling this method, you have usually to invoke
- * method set_pin() to tell the YoctoHub which PIN to use in the future.
- *
- * @param puk : the SIM PUK code
- * @param newPin : new PIN code to configure into the SIM card
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::sendPUK(string puk,string newPin)
-{
-    string gsmMsg;
-    gsmMsg = this->get_message();
-    if (!((gsmMsg).substr(0, 13) == "Enter SIM PUK")) {
-        _throw(YAPI_INVALID_ARGUMENT,"PUK not expected at this time");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (newPin == "") {
-        return this->set_command(YapiWrapper::ysprintf("AT+CPIN=%s,0000;+CLCK=SC,0,0000",puk.c_str()));
-    }
-    return this->set_command(YapiWrapper::ysprintf("AT+CPIN=%s,%s",puk.c_str(),newPin.c_str()));
-}
-
-/**
- * Configure authentication parameters to connect to the APN. Both
- * PAP and CHAP authentication are supported.
- *
- * @param username : APN username
- * @param password : APN password
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::set_apnAuth(string username,string password)
-{
-    return this->set_apnSecret(YapiWrapper::ysprintf("%s,%s",username.c_str(),password.c_str()));
-}
-
-/**
- * Clear the transmitted data counters.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCellular::clearDataCounters(void)
-{
-    int retcode = 0;
-
-    retcode = this->set_dataReceived(0);
-    if (retcode != YAPI_SUCCESS) {
-        return retcode;
-    }
-    retcode = this->set_dataSent(0);
-    return retcode;
-}
-
-/**
- * Sends an AT command to the GSM module and returns the command output.
- * The command will only execute when the GSM module is in standard
- * command state, and should leave it in the exact same state.
- * Use this function with great care !
- *
- * @param cmd : the AT command to execute, like for instance: "+CCLK?".
- *
- * @return a string with the result of the commands. Empty lines are
- *         automatically removed from the output.
- */
-string YCellular::_AT(string cmd)
-{
-    int chrPos = 0;
-    int cmdLen = 0;
-    int waitMore = 0;
-    string res;
-    string buff;
-    int bufflen = 0;
-    string buffstr;
-    int buffstrlen = 0;
-    int idx = 0;
-    int suffixlen = 0;
-    // quote dangerous characters used in AT commands
-    cmdLen = (int)(cmd).length();
-    chrPos = _ystrpos(cmd, "#");
-    while (chrPos >= 0) {
-        cmd = YapiWrapper::ysprintf("%s%c23%s", (cmd).substr( 0, chrPos).c_str(), 37,(cmd).substr( chrPos+1, cmdLen-chrPos-1).c_str());
-        cmdLen = cmdLen + 2;
-        chrPos = _ystrpos(cmd, "#");
-    }
-    chrPos = _ystrpos(cmd, "+");
-    while (chrPos >= 0) {
-        cmd = YapiWrapper::ysprintf("%s%c2B%s", (cmd).substr( 0, chrPos).c_str(), 37,(cmd).substr( chrPos+1, cmdLen-chrPos-1).c_str());
-        cmdLen = cmdLen + 2;
-        chrPos = _ystrpos(cmd, "+");
-    }
-    chrPos = _ystrpos(cmd, "=");
-    while (chrPos >= 0) {
-        cmd = YapiWrapper::ysprintf("%s%c3D%s", (cmd).substr( 0, chrPos).c_str(), 37,(cmd).substr( chrPos+1, cmdLen-chrPos-1).c_str());
-        cmdLen = cmdLen + 2;
-        chrPos = _ystrpos(cmd, "=");
-    }
-    cmd = YapiWrapper::ysprintf("at.txt?cmd=%s",cmd.c_str());
-    res = YapiWrapper::ysprintf("");
-    // max 2 minutes (each iteration may take up to 5 seconds if waiting)
-    waitMore = 24;
-    while (waitMore > 0) {
-        buff = this->_download(cmd);
-        bufflen = (int)(buff).size();
-        buffstr = buff;
-        buffstrlen = (int)(buffstr).length();
-        idx = bufflen - 1;
-        while ((idx > 0) && (((u8)buff[idx]) != 64) && (((u8)buff[idx]) != 10) && (((u8)buff[idx]) != 13)) {
-            idx = idx - 1;
-        }
-        if (((u8)buff[idx]) == 64) {
-            // continuation detected
-            suffixlen = bufflen - idx;
-            cmd = YapiWrapper::ysprintf("at.txt?cmd=%s",(buffstr).substr( buffstrlen - suffixlen, suffixlen).c_str());
-            buffstr = (buffstr).substr( 0, buffstrlen - suffixlen);
-            waitMore = waitMore - 1;
-        } else {
-            // request complete
-            waitMore = 0;
-        }
-        res = YapiWrapper::ysprintf("%s%s", res.c_str(),buffstr.c_str());
-    }
-    return res;
-}
-
-/**
- * Returns the list detected cell operators in the neighborhood.
- * This function will typically take between 30 seconds to 1 minute to
- * return. Note that any SIM card can usually only connect to specific
- * operators. All networks returned by this function might therefore
- * not be available for connection.
- *
- * @return a list of string (cell operator names).
- */
-vector<string> YCellular::get_availableOperators(void)
-{
-    string cops;
-    int idx = 0;
-    int slen = 0;
-    vector<string> res;
-
-    cops = this->_AT("+COPS=?");
-    slen = (int)(cops).length();
-    res.clear();
-    idx = _ystrpos(cops, "(");
-    while (idx >= 0) {
-        slen = slen - (idx+1);
-        cops = (cops).substr( idx+1, slen);
-        idx = _ystrpos(cops, "\"");
-        if (idx > 0) {
-            slen = slen - (idx+1);
-            cops = (cops).substr( idx+1, slen);
-            idx = _ystrpos(cops, "\"");
-            if (idx > 0) {
-                res.push_back((cops).substr( 0, idx));
-            }
-        }
-        idx = _ystrpos(cops, "(");
-    }
-    return res;
-}
-
-/**
- * Returns a list of nearby cellular antennas, as required for quick
- * geolocation of the device. The first cell listed is the serving
- * cell, and the next ones are the neighbor cells reported by the
- * serving cell.
- *
- * @return a list of YCellRecords.
- */
-vector<YCellRecord> YCellular::quickCellSurvey(void)
-{
-    string moni;
-    vector<string> recs;
-    int llen = 0;
-    string mccs;
-    int mcc = 0;
-    string mncs;
-    int mnc = 0;
-    int lac = 0;
-    int cellId = 0;
-    string dbms;
-    int dbm = 0;
-    string tads;
-    int tad = 0;
-    string oper;
-    vector<YCellRecord> res;
-
-    moni = this->_AT("+CCED=0;#MONI=7;#MONI");
-    mccs = (moni).substr(7, 3);
-    if ((mccs).substr(0, 1) == "0") {
-        mccs = (mccs).substr(1, 2);
-    }
-    if ((mccs).substr(0, 1) == "0") {
-        mccs = (mccs).substr(1, 1);
-    }
-    mcc = atoi((mccs).c_str());
-    mncs = (moni).substr(11, 3);
-    if ((mncs).substr(2, 1) == ",") {
-        mncs = (mncs).substr(0, 2);
-    }
-    if ((mncs).substr(0, 1) == "0") {
-        mncs = (mncs).substr(1, (int)(mncs).length()-1);
-    }
-    mnc = atoi((mncs).c_str());
-    recs = _strsplit(moni,'#');
-    // process each line in turn
-    res.clear();
-    for (unsigned ii = 0; ii < recs.size(); ii++) {
-        llen = (int)(recs[ii]).length() - 2;
-        if (llen >= 44) {
-            if ((recs[ii]).substr(41, 3) == "dbm") {
-                lac = (int)strtoul((recs[ii]).substr(16, 4).c_str(), NULL, 16);
-                cellId = (int)strtoul((recs[ii]).substr(23, 4).c_str(), NULL, 16);
-                dbms = (recs[ii]).substr(37, 4);
-                if ((dbms).substr(0, 1) == " ") {
-                    dbms = (dbms).substr(1, 3);
-                }
-                dbm = atoi((dbms).c_str());
-                if (llen > 66) {
-                    tads = (recs[ii]).substr(54, 2);
-                    if ((tads).substr(0, 1) == " ") {
-                        tads = (tads).substr(1, 3);
-                    }
-                    tad = atoi((tads).c_str());
-                    oper = (recs[ii]).substr(66, llen-66);
-                } else {
-                    tad = -1;
-                    oper = "";
-                }
-                if (lac < 65535) {
-                    res.push_back(YCellRecord(mcc,mnc,lac,cellId,dbm,tad,oper));
-                }
-            }
-        }
-    }
-    return res;
-}
-
-YCellular *YCellular::nextCellular(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YCellular::FindCellular(hwid);
-}
-
-YCellular* YCellular::FirstCellular(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Cellular", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YCellular::FindCellular(serial+"."+funcId);
-}
-
-//--- (end of generated code: YCellular implementation)
-
-//--- (generated code: YCellular functions)
-//--- (end of generated code: YCellular functions)
--- a/Sources/cpplib/yocto_cellular.h
+++ /dev/null
@@ -1,769 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_cellular.h 33710 2018-12-14 14:18:53Z seb $
- *
- * Declares yFindCellular(), the high-level API for Cellular functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_CELLULAR_H
-#define YOCTO_CELLULAR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (generated code: YCellular return codes)
-//--- (end of generated code: YCellular return codes)
-//--- (generated code: YCellular definitions)
-class YCellular; // forward declaration
-
-typedef void (*YCellularValueCallback)(YCellular *func, const string& functionValue);
-#ifndef _Y_CELLTYPE_ENUM
-#define _Y_CELLTYPE_ENUM
-typedef enum {
-    Y_CELLTYPE_GPRS = 0,
-    Y_CELLTYPE_EGPRS = 1,
-    Y_CELLTYPE_WCDMA = 2,
-    Y_CELLTYPE_HSDPA = 3,
-    Y_CELLTYPE_NONE = 4,
-    Y_CELLTYPE_CDMA = 5,
-    Y_CELLTYPE_INVALID = -1,
-} Y_CELLTYPE_enum;
-#endif
-#ifndef _Y_AIRPLANEMODE_ENUM
-#define _Y_AIRPLANEMODE_ENUM
-typedef enum {
-    Y_AIRPLANEMODE_OFF = 0,
-    Y_AIRPLANEMODE_ON = 1,
-    Y_AIRPLANEMODE_INVALID = -1,
-} Y_AIRPLANEMODE_enum;
-#endif
-#ifndef _Y_ENABLEDATA_ENUM
-#define _Y_ENABLEDATA_ENUM
-typedef enum {
-    Y_ENABLEDATA_HOMENETWORK = 0,
-    Y_ENABLEDATA_ROAMING = 1,
-    Y_ENABLEDATA_NEVER = 2,
-    Y_ENABLEDATA_NEUTRALITY = 3,
-    Y_ENABLEDATA_INVALID = -1,
-} Y_ENABLEDATA_enum;
-#endif
-#define Y_LINKQUALITY_INVALID           (YAPI_INVALID_UINT)
-#define Y_CELLOPERATOR_INVALID          (YAPI_INVALID_STRING)
-#define Y_CELLIDENTIFIER_INVALID        (YAPI_INVALID_STRING)
-#define Y_IMSI_INVALID                  (YAPI_INVALID_STRING)
-#define Y_MESSAGE_INVALID               (YAPI_INVALID_STRING)
-#define Y_PIN_INVALID                   (YAPI_INVALID_STRING)
-#define Y_LOCKEDOPERATOR_INVALID        (YAPI_INVALID_STRING)
-#define Y_APN_INVALID                   (YAPI_INVALID_STRING)
-#define Y_APNSECRET_INVALID             (YAPI_INVALID_STRING)
-#define Y_PINGINTERVAL_INVALID          (YAPI_INVALID_UINT)
-#define Y_DATASENT_INVALID              (YAPI_INVALID_UINT)
-#define Y_DATARECEIVED_INVALID          (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of generated code: YCellular definitions)
-
-//--- (generated code: YCellRecord definitions)
-//--- (end of generated code: YCellRecord definitions)
-
-//--- (generated code: YCellRecord declaration)
-/**
- * YCellRecord Class: Description of a cellular antenna
- *
- *
- */
-class YOCTO_CLASS_EXPORT YCellRecord {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YCellRecord declaration)
-    //--- (generated code: YCellRecord attributes)
-    // Attributes (function value cache)
-    string          _oper;
-    int             _mcc;
-    int             _mnc;
-    int             _lac;
-    int             _cid;
-    int             _dbm;
-    int             _tad;
-    //--- (end of generated code: YCellRecord attributes)
-    //--- (generated code: YCellRecord constructor)
-
-    //--- (end of generated code: YCellRecord constructor)
-    //--- (generated code: YCellRecord initialization)
-    //--- (end of generated code: YCellRecord initialization)
-
-public:
-    YCellRecord(int mcc,int mnc,int lac,int cellId,int dbm,int tad,const string &oper);
-    virtual ~YCellRecord(){};
-    //--- (generated code: YCellRecord accessors declaration)
-
-
-    virtual string      get_cellOperator(void);
-
-    virtual int         get_mobileCountryCode(void);
-
-    virtual int         get_mobileNetworkCode(void);
-
-    virtual int         get_locationAreaCode(void);
-
-    virtual int         get_cellId(void);
-
-    virtual int         get_signalStrength(void);
-
-    virtual int         get_timingAdvance(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YCellRecord accessors declaration)
-};
-
-
-//--- (generated code: YCellular declaration)
-/**
- * YCellular Class: Cellular function interface
- *
- * YCellular functions provides control over cellular network parameters
- * and status for devices that are GSM-enabled.
- */
-class YOCTO_CLASS_EXPORT YCellular: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YCellular declaration)
-protected:
-    //--- (generated code: YCellular attributes)
-    // Attributes (function value cache)
-    int             _linkQuality;
-    string          _cellOperator;
-    string          _cellIdentifier;
-    Y_CELLTYPE_enum _cellType;
-    string          _imsi;
-    string          _message;
-    string          _pin;
-    string          _lockedOperator;
-    Y_AIRPLANEMODE_enum _airplaneMode;
-    Y_ENABLEDATA_enum _enableData;
-    string          _apn;
-    string          _apnSecret;
-    int             _pingInterval;
-    int             _dataSent;
-    int             _dataReceived;
-    string          _command;
-    YCellularValueCallback _valueCallbackCellular;
-
-    friend YCellular *yFindCellular(const string& func);
-    friend YCellular *yFirstCellular(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindCellular factory function to instantiate
-    YCellular(const string& func);
-    //--- (end of generated code: YCellular attributes)
-
-public:
-    ~YCellular();
-    //--- (generated code: YCellular accessors declaration)
-
-    static const int LINKQUALITY_INVALID = YAPI_INVALID_UINT;
-    static const string CELLOPERATOR_INVALID;
-    static const string CELLIDENTIFIER_INVALID;
-    static const Y_CELLTYPE_enum CELLTYPE_GPRS = Y_CELLTYPE_GPRS;
-    static const Y_CELLTYPE_enum CELLTYPE_EGPRS = Y_CELLTYPE_EGPRS;
-    static const Y_CELLTYPE_enum CELLTYPE_WCDMA = Y_CELLTYPE_WCDMA;
-    static const Y_CELLTYPE_enum CELLTYPE_HSDPA = Y_CELLTYPE_HSDPA;
-    static const Y_CELLTYPE_enum CELLTYPE_NONE = Y_CELLTYPE_NONE;
-    static const Y_CELLTYPE_enum CELLTYPE_CDMA = Y_CELLTYPE_CDMA;
-    static const Y_CELLTYPE_enum CELLTYPE_INVALID = Y_CELLTYPE_INVALID;
-    static const string IMSI_INVALID;
-    static const string MESSAGE_INVALID;
-    static const string PIN_INVALID;
-    static const string LOCKEDOPERATOR_INVALID;
-    static const Y_AIRPLANEMODE_enum AIRPLANEMODE_OFF = Y_AIRPLANEMODE_OFF;
-    static const Y_AIRPLANEMODE_enum AIRPLANEMODE_ON = Y_AIRPLANEMODE_ON;
-    static const Y_AIRPLANEMODE_enum AIRPLANEMODE_INVALID = Y_AIRPLANEMODE_INVALID;
-    static const Y_ENABLEDATA_enum ENABLEDATA_HOMENETWORK = Y_ENABLEDATA_HOMENETWORK;
-    static const Y_ENABLEDATA_enum ENABLEDATA_ROAMING = Y_ENABLEDATA_ROAMING;
-    static const Y_ENABLEDATA_enum ENABLEDATA_NEVER = Y_ENABLEDATA_NEVER;
-    static const Y_ENABLEDATA_enum ENABLEDATA_NEUTRALITY = Y_ENABLEDATA_NEUTRALITY;
-    static const Y_ENABLEDATA_enum ENABLEDATA_INVALID = Y_ENABLEDATA_INVALID;
-    static const string APN_INVALID;
-    static const string APNSECRET_INVALID;
-    static const int PINGINTERVAL_INVALID = YAPI_INVALID_UINT;
-    static const int DATASENT_INVALID = YAPI_INVALID_UINT;
-    static const int DATARECEIVED_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the link quality, expressed in percent.
-     *
-     * @return an integer corresponding to the link quality, expressed in percent
-     *
-     * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
-     */
-    int                 get_linkQuality(void);
-
-    inline int          linkQuality(void)
-    { return this->get_linkQuality(); }
-
-    /**
-     * Returns the name of the cell operator currently in use.
-     *
-     * @return a string corresponding to the name of the cell operator currently in use
-     *
-     * On failure, throws an exception or returns Y_CELLOPERATOR_INVALID.
-     */
-    string              get_cellOperator(void);
-
-    inline string       cellOperator(void)
-    { return this->get_cellOperator(); }
-
-    /**
-     * Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.
-     *
-     * @return a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC,
-     * LAC and Cell ID
-     *
-     * On failure, throws an exception or returns Y_CELLIDENTIFIER_INVALID.
-     */
-    string              get_cellIdentifier(void);
-
-    inline string       cellIdentifier(void)
-    { return this->get_cellIdentifier(); }
-
-    /**
-     * Active cellular connection type.
-     *
-     * @return a value among Y_CELLTYPE_GPRS, Y_CELLTYPE_EGPRS, Y_CELLTYPE_WCDMA, Y_CELLTYPE_HSDPA,
-     * Y_CELLTYPE_NONE and Y_CELLTYPE_CDMA
-     *
-     * On failure, throws an exception or returns Y_CELLTYPE_INVALID.
-     */
-    Y_CELLTYPE_enum     get_cellType(void);
-
-    inline Y_CELLTYPE_enum cellType(void)
-    { return this->get_cellType(); }
-
-    /**
-     * Returns an opaque string if a PIN code has been configured in the device to access
-     * the SIM card, or an empty string if none has been configured or if the code provided
-     * was rejected by the SIM card.
-     *
-     * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
-     *         the SIM card, or an empty string if none has been configured or if the code provided
-     *         was rejected by the SIM card
-     *
-     * On failure, throws an exception or returns Y_IMSI_INVALID.
-     */
-    string              get_imsi(void);
-
-    inline string       imsi(void)
-    { return this->get_imsi(); }
-
-    /**
-     * Returns the latest status message from the wireless interface.
-     *
-     * @return a string corresponding to the latest status message from the wireless interface
-     *
-     * On failure, throws an exception or returns Y_MESSAGE_INVALID.
-     */
-    string              get_message(void);
-
-    inline string       message(void)
-    { return this->get_message(); }
-
-    /**
-     * Returns an opaque string if a PIN code has been configured in the device to access
-     * the SIM card, or an empty string if none has been configured or if the code provided
-     * was rejected by the SIM card.
-     *
-     * @return a string corresponding to an opaque string if a PIN code has been configured in the device to access
-     *         the SIM card, or an empty string if none has been configured or if the code provided
-     *         was rejected by the SIM card
-     *
-     * On failure, throws an exception or returns Y_PIN_INVALID.
-     */
-    string              get_pin(void);
-
-    inline string       pin(void)
-    { return this->get_pin(); }
-
-    /**
-     * Changes the PIN code used by the module to access the SIM card.
-     * This function does not change the code on the SIM card itself, but only changes
-     * the parameter used by the device to try to get access to it. If the SIM code
-     * does not work immediately on first try, it will be automatically forgotten
-     * and the message will be set to "Enter SIM PIN". The method should then be
-     * invoked again with right correct PIN code. After three failed attempts in a row,
-     * the message is changed to "Enter SIM PUK" and the SIM card PUK code must be
-     * provided using method sendPUK.
-     *
-     * Remember to call the saveToFlash() method of the module to save the
-     * new value in the device flash.
-     *
-     * @param newval : a string corresponding to the PIN code used by the module to access the SIM card
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pin(const string& newval);
-    inline int      setPin(const string& newval)
-    { return this->set_pin(newval); }
-
-    /**
-     * Returns the name of the only cell operator to use if automatic choice is disabled,
-     * or an empty string if the SIM card will automatically choose among available
-     * cell operators.
-     *
-     * @return a string corresponding to the name of the only cell operator to use if automatic choice is disabled,
-     *         or an empty string if the SIM card will automatically choose among available
-     *         cell operators
-     *
-     * On failure, throws an exception or returns Y_LOCKEDOPERATOR_INVALID.
-     */
-    string              get_lockedOperator(void);
-
-    inline string       lockedOperator(void)
-    { return this->get_lockedOperator(); }
-
-    /**
-     * Changes the name of the cell operator to be used. If the name is an empty
-     * string, the choice will be made automatically based on the SIM card. Otherwise,
-     * the selected operator is the only one that will be used.
-     *
-     * @param newval : a string corresponding to the name of the cell operator to be used
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_lockedOperator(const string& newval);
-    inline int      setLockedOperator(const string& newval)
-    { return this->set_lockedOperator(newval); }
-
-    /**
-     * Returns true if the airplane mode is active (radio turned off).
-     *
-     * @return either Y_AIRPLANEMODE_OFF or Y_AIRPLANEMODE_ON, according to true if the airplane mode is
-     * active (radio turned off)
-     *
-     * On failure, throws an exception or returns Y_AIRPLANEMODE_INVALID.
-     */
-    Y_AIRPLANEMODE_enum get_airplaneMode(void);
-
-    inline Y_AIRPLANEMODE_enum airplaneMode(void)
-    { return this->get_airplaneMode(); }
-
-    /**
-     * Changes the activation state of airplane mode (radio turned off).
-     *
-     * @param newval : either Y_AIRPLANEMODE_OFF or Y_AIRPLANEMODE_ON, according to the activation state
-     * of airplane mode (radio turned off)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_airplaneMode(Y_AIRPLANEMODE_enum newval);
-    inline int      setAirplaneMode(Y_AIRPLANEMODE_enum newval)
-    { return this->set_airplaneMode(newval); }
-
-    /**
-     * Returns the condition for enabling IP data services (GPRS).
-     * When data services are disabled, SMS are the only mean of communication.
-     *
-     * @return a value among Y_ENABLEDATA_HOMENETWORK, Y_ENABLEDATA_ROAMING, Y_ENABLEDATA_NEVER and
-     * Y_ENABLEDATA_NEUTRALITY corresponding to the condition for enabling IP data services (GPRS)
-     *
-     * On failure, throws an exception or returns Y_ENABLEDATA_INVALID.
-     */
-    Y_ENABLEDATA_enum   get_enableData(void);
-
-    inline Y_ENABLEDATA_enum enableData(void)
-    { return this->get_enableData(); }
-
-    /**
-     * Changes the condition for enabling IP data services (GPRS).
-     * The service can be either fully deactivated, or limited to the SIM home network,
-     * or enabled for all partner networks (roaming). Caution: enabling data services
-     * on roaming networks may cause prohibitive communication costs !
-     *
-     * When data services are disabled, SMS are the only mean of communication.
-     *
-     * @param newval : a value among Y_ENABLEDATA_HOMENETWORK, Y_ENABLEDATA_ROAMING, Y_ENABLEDATA_NEVER
-     * and Y_ENABLEDATA_NEUTRALITY corresponding to the condition for enabling IP data services (GPRS)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enableData(Y_ENABLEDATA_enum newval);
-    inline int      setEnableData(Y_ENABLEDATA_enum newval)
-    { return this->set_enableData(newval); }
-
-    /**
-     * Returns the Access Point Name (APN) to be used, if needed.
-     * When left blank, the APN suggested by the cell operator will be used.
-     *
-     * @return a string corresponding to the Access Point Name (APN) to be used, if needed
-     *
-     * On failure, throws an exception or returns Y_APN_INVALID.
-     */
-    string              get_apn(void);
-
-    inline string       apn(void)
-    { return this->get_apn(); }
-
-    /**
-     * Returns the Access Point Name (APN) to be used, if needed.
-     * When left blank, the APN suggested by the cell operator will be used.
-     *
-     * @param newval : a string
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_apn(const string& newval);
-    inline int      setApn(const string& newval)
-    { return this->set_apn(newval); }
-
-    /**
-     * Returns an opaque string if APN authentication parameters have been configured
-     * in the device, or an empty string otherwise.
-     * To configure these parameters, use set_apnAuth().
-     *
-     * @return a string corresponding to an opaque string if APN authentication parameters have been configured
-     *         in the device, or an empty string otherwise
-     *
-     * On failure, throws an exception or returns Y_APNSECRET_INVALID.
-     */
-    string              get_apnSecret(void);
-
-    inline string       apnSecret(void)
-    { return this->get_apnSecret(); }
-
-    int             set_apnSecret(const string& newval);
-    inline int      setApnSecret(const string& newval)
-    { return this->set_apnSecret(newval); }
-
-    /**
-     * Returns the automated connectivity check interval, in seconds.
-     *
-     * @return an integer corresponding to the automated connectivity check interval, in seconds
-     *
-     * On failure, throws an exception or returns Y_PINGINTERVAL_INVALID.
-     */
-    int                 get_pingInterval(void);
-
-    inline int          pingInterval(void)
-    { return this->get_pingInterval(); }
-
-    /**
-     * Changes the automated connectivity check interval, in seconds.
-     *
-     * @param newval : an integer corresponding to the automated connectivity check interval, in seconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pingInterval(int newval);
-    inline int      setPingInterval(int newval)
-    { return this->set_pingInterval(newval); }
-
-    /**
-     * Returns the number of bytes sent so far.
-     *
-     * @return an integer corresponding to the number of bytes sent so far
-     *
-     * On failure, throws an exception or returns Y_DATASENT_INVALID.
-     */
-    int                 get_dataSent(void);
-
-    inline int          dataSent(void)
-    { return this->get_dataSent(); }
-
-    /**
-     * Changes the value of the outgoing data counter.
-     *
-     * @param newval : an integer corresponding to the value of the outgoing data counter
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_dataSent(int newval);
-    inline int      setDataSent(int newval)
-    { return this->set_dataSent(newval); }
-
-    /**
-     * Returns the number of bytes received so far.
-     *
-     * @return an integer corresponding to the number of bytes received so far
-     *
-     * On failure, throws an exception or returns Y_DATARECEIVED_INVALID.
-     */
-    int                 get_dataReceived(void);
-
-    inline int          dataReceived(void)
-    { return this->get_dataReceived(); }
-
-    /**
-     * Changes the value of the incoming data counter.
-     *
-     * @param newval : an integer corresponding to the value of the incoming data counter
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_dataReceived(int newval);
-    inline int      setDataReceived(int newval)
-    { return this->set_dataReceived(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a cellular interface for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the cellular interface is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YCellular.isOnline() to test if the cellular interface is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a cellular interface by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the cellular interface
-     *
-     * @return a YCellular object allowing you to drive the cellular interface.
-     */
-    static YCellular*   FindCellular(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YCellularValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and
-     * setup a new PIN into the SIM card. Only ten consecutive tentatives are permitted:
-     * after that, the SIM card will be blocked permanently without any mean of recovery
-     * to use it again. Note that after calling this method, you have usually to invoke
-     * method set_pin() to tell the YoctoHub which PIN to use in the future.
-     *
-     * @param puk : the SIM PUK code
-     * @param newPin : new PIN code to configure into the SIM card
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sendPUK(string puk,string newPin);
-
-    /**
-     * Configure authentication parameters to connect to the APN. Both
-     * PAP and CHAP authentication are supported.
-     *
-     * @param username : APN username
-     * @param password : APN password
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_apnAuth(string username,string password);
-
-    /**
-     * Clear the transmitted data counters.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         clearDataCounters(void);
-
-    /**
-     * Sends an AT command to the GSM module and returns the command output.
-     * The command will only execute when the GSM module is in standard
-     * command state, and should leave it in the exact same state.
-     * Use this function with great care !
-     *
-     * @param cmd : the AT command to execute, like for instance: "+CCLK?".
-     *
-     * @return a string with the result of the commands. Empty lines are
-     *         automatically removed from the output.
-     */
-    virtual string      _AT(string cmd);
-
-    /**
-     * Returns the list detected cell operators in the neighborhood.
-     * This function will typically take between 30 seconds to 1 minute to
-     * return. Note that any SIM card can usually only connect to specific
-     * operators. All networks returned by this function might therefore
-     * not be available for connection.
-     *
-     * @return a list of string (cell operator names).
-     */
-    virtual vector<string> get_availableOperators(void);
-
-    /**
-     * Returns a list of nearby cellular antennas, as required for quick
-     * geolocation of the device. The first cell listed is the serving
-     * cell, and the next ones are the neighbor cells reported by the
-     * serving cell.
-     *
-     * @return a list of YCellRecords.
-     */
-    virtual vector<YCellRecord> quickCellSurvey(void);
-
-
-    inline static YCellular* Find(string func)
-    { return YCellular::FindCellular(func); }
-
-    /**
-     * Continues the enumeration of cellular interfaces started using yFirstCellular().
-     * Caution: You can't make any assumption about the returned cellular interfaces order.
-     * If you want to find a specific a cellular interface, use Cellular.findCellular()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YCellular object, corresponding to
-     *         a cellular interface currently online, or a NULL pointer
-     *         if there are no more cellular interfaces to enumerate.
-     */
-           YCellular       *nextCellular(void);
-    inline YCellular       *next(void)
-    { return this->nextCellular();}
-
-    /**
-     * Starts the enumeration of cellular interfaces currently accessible.
-     * Use the method YCellular.nextCellular() to iterate on
-     * next cellular interfaces.
-     *
-     * @return a pointer to a YCellular object, corresponding to
-     *         the first cellular interface currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YCellular* FirstCellular(void);
-    inline static YCellular* First(void)
-    { return YCellular::FirstCellular();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YCellular accessors declaration)
-};
-
-//--- (generated code: YCellular functions declaration)
-
-/**
- * Retrieves a cellular interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the cellular interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCellular.isOnline() to test if the cellular interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a cellular interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the cellular interface
- *
- * @return a YCellular object allowing you to drive the cellular interface.
- */
-inline YCellular* yFindCellular(const string& func)
-{ return YCellular::FindCellular(func);}
-/**
- * Starts the enumeration of cellular interfaces currently accessible.
- * Use the method YCellular.nextCellular() to iterate on
- * next cellular interfaces.
- *
- * @return a pointer to a YCellular object, corresponding to
- *         the first cellular interface currently online, or a NULL pointer
- *         if there are none.
- */
-inline YCellular* yFirstCellular(void)
-{ return YCellular::FirstCellular();}
-
-//--- (end of generated code: YCellular functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_colorled.cpp
+++ /dev/null
@@ -1,716 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_colorled.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindColorLed(), the high-level API for ColorLed functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_colorled.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "colorled"
-
-YColorLed::YColorLed(const string& func): YFunction(func)
-//--- (YColorLed initialization)
-    ,_rgbColor(RGBCOLOR_INVALID)
-    ,_hslColor(HSLCOLOR_INVALID)
-    ,_rgbMove(RGBMOVE_INVALID)
-    ,_hslMove(HSLMOVE_INVALID)
-    ,_rgbColorAtPowerOn(RGBCOLORATPOWERON_INVALID)
-    ,_blinkSeqSize(BLINKSEQSIZE_INVALID)
-    ,_blinkSeqMaxSize(BLINKSEQMAXSIZE_INVALID)
-    ,_blinkSeqSignature(BLINKSEQSIGNATURE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackColorLed(NULL)
-//--- (end of YColorLed initialization)
-{
-    _className="ColorLed";
-}
-
-YColorLed::~YColorLed()
-{
-//--- (YColorLed cleanup)
-//--- (end of YColorLed cleanup)
-}
-//--- (YColorLed implementation)
-// static attributes
-const YMove YColorLed::RGBMOVE_INVALID = YMove();
-const YMove YColorLed::HSLMOVE_INVALID = YMove();
-const string YColorLed::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YColorLed::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("rgbColor")) {
-        _rgbColor =  json_val->getInt("rgbColor");
-    }
-    if(json_val->has("hslColor")) {
-        _hslColor =  json_val->getInt("hslColor");
-    }
-    if(json_val->has("rgbMove")) {
-        YJSONObject* subjson = json_val->getYJSONObject("rgbMove");
-        if (subjson->has("moving")) {
-            _rgbMove.moving = subjson->getInt("moving");
-        }
-        if (subjson->has("target")) {
-            _rgbMove.target = subjson->getInt("target");
-        }
-        if (subjson->has("ms")) {
-            _rgbMove.ms = subjson->getInt("ms");
-        }
-    }
-    if(json_val->has("hslMove")) {
-        YJSONObject* subjson = json_val->getYJSONObject("hslMove");
-        if (subjson->has("moving")) {
-            _hslMove.moving = subjson->getInt("moving");
-        }
-        if (subjson->has("target")) {
-            _hslMove.target = subjson->getInt("target");
-        }
-        if (subjson->has("ms")) {
-            _hslMove.ms = subjson->getInt("ms");
-        }
-    }
-    if(json_val->has("rgbColorAtPowerOn")) {
-        _rgbColorAtPowerOn =  json_val->getInt("rgbColorAtPowerOn");
-    }
-    if(json_val->has("blinkSeqSize")) {
-        _blinkSeqSize =  json_val->getInt("blinkSeqSize");
-    }
-    if(json_val->has("blinkSeqMaxSize")) {
-        _blinkSeqMaxSize =  json_val->getInt("blinkSeqMaxSize");
-    }
-    if(json_val->has("blinkSeqSignature")) {
-        _blinkSeqSignature =  json_val->getInt("blinkSeqSignature");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current RGB color of the LED.
- *
- * @return an integer corresponding to the current RGB color of the LED
- *
- * On failure, throws an exception or returns Y_RGBCOLOR_INVALID.
- */
-int YColorLed::get_rgbColor(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::RGBCOLOR_INVALID;
-                }
-            }
-        }
-        res = _rgbColor;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.
- *
- * @param newval : an integer corresponding to the current color of the LED, using an RGB color
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::set_rgbColor(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf,"0x%06x",newval); rest_val = string(buf);
-        res = _setAttr("rgbColor", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current HSL color of the LED.
- *
- * @return an integer corresponding to the current HSL color of the LED
- *
- * On failure, throws an exception or returns Y_HSLCOLOR_INVALID.
- */
-int YColorLed::get_hslColor(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::HSLCOLOR_INVALID;
-                }
-            }
-        }
-        res = _hslColor;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current color of the LED, using a color HSL. Encoding is done as follows: 0xHHSSLL.
- *
- * @param newval : an integer corresponding to the current color of the LED, using a color HSL
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::set_hslColor(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf,"0x%06x",newval); rest_val = string(buf);
-        res = _setAttr("hslColor", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-YMove YColorLed::get_rgbMove(void)
-{
-    YMove res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::RGBMOVE_INVALID;
-                }
-            }
-        }
-        res = _rgbMove;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YColorLed::set_rgbMove(YMove newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buff[64]; sprintf(buff,"%d:%d",newval.target,newval.ms); rest_val = string(buff);
-        res = _setAttr("rgbMove", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Performs a smooth transition in the RGB color space between the current color and a target color.
- *
- * @param rgb_target  : desired RGB color at the end of the transition
- * @param ms_duration : duration of the transition, in millisecond
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::rgbMove(int rgb_target,int ms_duration)
-{
-    string rest_val;
-    char buff[64]; sprintf(buff,"%d:%d",rgb_target,ms_duration); rest_val = string(buff);
-    return _setAttr("rgbMove", rest_val);
-}
-
-YMove YColorLed::get_hslMove(void)
-{
-    YMove res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::HSLMOVE_INVALID;
-                }
-            }
-        }
-        res = _hslMove;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YColorLed::set_hslMove(YMove newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buff[64]; sprintf(buff,"%d:%d",newval.target,newval.ms); rest_val = string(buff);
-        res = _setAttr("hslMove", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Performs a smooth transition in the HSL color space between the current color and a target color.
- *
- * @param hsl_target  : desired HSL color at the end of the transition
- * @param ms_duration : duration of the transition, in millisecond
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::hslMove(int hsl_target,int ms_duration)
-{
-    string rest_val;
-    char buff[64]; sprintf(buff,"%d:%d",hsl_target,ms_duration); rest_val = string(buff);
-    return _setAttr("hslMove", rest_val);
-}
-
-/**
- * Returns the configured color to be displayed when the module is turned on.
- *
- * @return an integer corresponding to the configured color to be displayed when the module is turned on
- *
- * On failure, throws an exception or returns Y_RGBCOLORATPOWERON_INVALID.
- */
-int YColorLed::get_rgbColorAtPowerOn(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::RGBCOLORATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _rgbColorAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the color that the LED will display by default when the module is turned on.
- *
- * @param newval : an integer corresponding to the color that the LED will display by default when the
- * module is turned on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::set_rgbColorAtPowerOn(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf,"0x%06x",newval); rest_val = string(buf);
-        res = _setAttr("rgbColorAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current length of the blinking sequence.
- *
- * @return an integer corresponding to the current length of the blinking sequence
- *
- * On failure, throws an exception or returns Y_BLINKSEQSIZE_INVALID.
- */
-int YColorLed::get_blinkSeqSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::BLINKSEQSIZE_INVALID;
-                }
-            }
-        }
-        res = _blinkSeqSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum length of the blinking sequence.
- *
- * @return an integer corresponding to the maximum length of the blinking sequence
- *
- * On failure, throws an exception or returns Y_BLINKSEQMAXSIZE_INVALID.
- */
-int YColorLed::get_blinkSeqMaxSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::BLINKSEQMAXSIZE_INVALID;
-                }
-            }
-        }
-        res = _blinkSeqMaxSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Return the blinking sequence signature. Since blinking
- * sequences cannot be read from the device, this can be used
- * to detect if a specific blinking sequence is already
- * programmed.
- *
- * @return an integer
- *
- * On failure, throws an exception or returns Y_BLINKSEQSIGNATURE_INVALID.
- */
-int YColorLed::get_blinkSeqSignature(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::BLINKSEQSIGNATURE_INVALID;
-                }
-            }
-        }
-        res = _blinkSeqSignature;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YColorLed::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLed::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YColorLed::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves an RGB LED for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the RGB LED is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YColorLed.isOnline() to test if the RGB LED is
- * indeed online at a given time. In case of ambiguity when looking for
- * an RGB LED by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the RGB LED
- *
- * @return a YColorLed object allowing you to drive the RGB LED.
- */
-YColorLed* YColorLed::FindColorLed(string func)
-{
-    YColorLed* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YColorLed*) YFunction::_FindFromCache("ColorLed", func);
-        if (obj == NULL) {
-            obj = new YColorLed(func);
-            YFunction::_AddToCache("ColorLed", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YColorLed::registerValueCallback(YColorLedValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackColorLed = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YColorLed::_invokeValueCallback(string value)
-{
-    if (_valueCallbackColorLed != NULL) {
-        _valueCallbackColorLed(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YColorLed::sendCommand(string command)
-{
-    return this->set_command(command);
-}
-
-/**
- * Add a new transition to the blinking sequence, the move will
- * be performed in the HSL space.
- *
- * @param HSLcolor : desired HSL color when the transition is completed
- * @param msDelay : duration of the color transition, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::addHslMoveToBlinkSeq(int HSLcolor,int msDelay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("H%d,%d",HSLcolor,msDelay));
-}
-
-/**
- * Adds a new transition to the blinking sequence, the move is
- * performed in the RGB space.
- *
- * @param RGBcolor : desired RGB color when the transition is completed
- * @param msDelay : duration of the color transition, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::addRgbMoveToBlinkSeq(int RGBcolor,int msDelay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("R%d,%d",RGBcolor,msDelay));
-}
-
-/**
- * Starts the preprogrammed blinking sequence. The sequence is
- * run in a loop until it is stopped by stopBlinkSeq or an explicit
- * change.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::startBlinkSeq(void)
-{
-    return this->sendCommand("S");
-}
-
-/**
- * Stops the preprogrammed blinking sequence.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::stopBlinkSeq(void)
-{
-    return this->sendCommand("X");
-}
-
-/**
- * Resets the preprogrammed blinking sequence.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YColorLed::resetBlinkSeq(void)
-{
-    return this->sendCommand("Z");
-}
-
-YColorLed *YColorLed::nextColorLed(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YColorLed::FindColorLed(hwid);
-}
-
-YColorLed* YColorLed::FirstColorLed(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("ColorLed", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YColorLed::FindColorLed(serial+"."+funcId);
-}
-
-//--- (end of YColorLed implementation)
-
-//--- (YColorLed functions)
-//--- (end of YColorLed functions)
--- a/Sources/cpplib/yocto_colorled.h
+++ /dev/null
@@ -1,481 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_colorled.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindColorLed(), the high-level API for ColorLed functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_COLORLED_H
-#define YOCTO_COLORLED_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YColorLed return codes)
-//--- (end of YColorLed return codes)
-//--- (YColorLed yapiwrapper)
-//--- (end of YColorLed yapiwrapper)
-//--- (YColorLed definitions)
-class YColorLed; // forward declaration
-
-typedef void (*YColorLedValueCallback)(YColorLed *func, const string& functionValue);
-#ifndef _CLASS_YMOVE
-#define _CLASS_YMOVE
-class YOCTO_CLASS_EXPORT YMove {
-public:
-    int             target;
-    int             ms;
-    int             moving;
-
-    YMove()
-        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
-    {}
-
-    bool operator==(const YMove& o) const {
-         return (target == o.target) && (ms == o.ms) && (moving == o.moving);
-    }
-};
-#endif
-#define Y_RGBCOLOR_INVALID              (YAPI_INVALID_UINT)
-#define Y_HSLCOLOR_INVALID              (YAPI_INVALID_UINT)
-#define Y_RGBCOLORATPOWERON_INVALID     (YAPI_INVALID_UINT)
-#define Y_BLINKSEQSIZE_INVALID          (YAPI_INVALID_UINT)
-#define Y_BLINKSEQMAXSIZE_INVALID       (YAPI_INVALID_UINT)
-#define Y_BLINKSEQSIGNATURE_INVALID     (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YColorLed definitions)
-
-//--- (YColorLed declaration)
-/**
- * YColorLed Class: ColorLed function interface
- *
- * The Yoctopuce application programming interface
- * allows you to drive a color LED using RGB coordinates as well as HSL coordinates.
- * The module performs all conversions form RGB to HSL automatically. It is then
- * self-evident to turn on a LED with a given hue and to progressively vary its
- * saturation or lightness. If needed, you can find more information on the
- * difference between RGB and HSL in the section following this one.
- */
-class YOCTO_CLASS_EXPORT YColorLed: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YColorLed declaration)
-protected:
-    //--- (YColorLed attributes)
-    // Attributes (function value cache)
-    int             _rgbColor;
-    int             _hslColor;
-    YMove           _rgbMove;
-    YMove           _hslMove;
-    int             _rgbColorAtPowerOn;
-    int             _blinkSeqSize;
-    int             _blinkSeqMaxSize;
-    int             _blinkSeqSignature;
-    string          _command;
-    YColorLedValueCallback _valueCallbackColorLed;
-
-    friend YColorLed *yFindColorLed(const string& func);
-    friend YColorLed *yFirstColorLed(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindColorLed factory function to instantiate
-    YColorLed(const string& func);
-    //--- (end of YColorLed attributes)
-
-public:
-    virtual ~YColorLed();
-    //--- (YColorLed accessors declaration)
-
-    static const int RGBCOLOR_INVALID = YAPI_INVALID_UINT;
-    static const int HSLCOLOR_INVALID = YAPI_INVALID_UINT;
-    static const YMove RGBMOVE_INVALID;
-    static const YMove HSLMOVE_INVALID;
-    static const int RGBCOLORATPOWERON_INVALID = YAPI_INVALID_UINT;
-    static const int BLINKSEQSIZE_INVALID = YAPI_INVALID_UINT;
-    static const int BLINKSEQMAXSIZE_INVALID = YAPI_INVALID_UINT;
-    static const int BLINKSEQSIGNATURE_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the current RGB color of the LED.
-     *
-     * @return an integer corresponding to the current RGB color of the LED
-     *
-     * On failure, throws an exception or returns Y_RGBCOLOR_INVALID.
-     */
-    int                 get_rgbColor(void);
-
-    inline int          rgbColor(void)
-    { return this->get_rgbColor(); }
-
-    /**
-     * Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.
-     *
-     * @param newval : an integer corresponding to the current color of the LED, using an RGB color
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_rgbColor(int newval);
-    inline int      setRgbColor(int newval)
-    { return this->set_rgbColor(newval); }
-
-    /**
-     * Returns the current HSL color of the LED.
-     *
-     * @return an integer corresponding to the current HSL color of the LED
-     *
-     * On failure, throws an exception or returns Y_HSLCOLOR_INVALID.
-     */
-    int                 get_hslColor(void);
-
-    inline int          hslColor(void)
-    { return this->get_hslColor(); }
-
-    /**
-     * Changes the current color of the LED, using a color HSL. Encoding is done as follows: 0xHHSSLL.
-     *
-     * @param newval : an integer corresponding to the current color of the LED, using a color HSL
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_hslColor(int newval);
-    inline int      setHslColor(int newval)
-    { return this->set_hslColor(newval); }
-
-    YMove               get_rgbMove(void);
-
-    inline YMove        rgbMove(void)
-    { return this->get_rgbMove(); }
-
-    int             set_rgbMove(YMove newval);
-    inline int      setRgbMove(YMove newval)
-    { return this->set_rgbMove(newval); }
-
-    /**
-     * Performs a smooth transition in the RGB color space between the current color and a target color.
-     *
-     * @param rgb_target  : desired RGB color at the end of the transition
-     * @param ms_duration : duration of the transition, in millisecond
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             rgbMove(int rgb_target,int ms_duration);
-
-    YMove               get_hslMove(void);
-
-    inline YMove        hslMove(void)
-    { return this->get_hslMove(); }
-
-    int             set_hslMove(YMove newval);
-    inline int      setHslMove(YMove newval)
-    { return this->set_hslMove(newval); }
-
-    /**
-     * Performs a smooth transition in the HSL color space between the current color and a target color.
-     *
-     * @param hsl_target  : desired HSL color at the end of the transition
-     * @param ms_duration : duration of the transition, in millisecond
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             hslMove(int hsl_target,int ms_duration);
-
-    /**
-     * Returns the configured color to be displayed when the module is turned on.
-     *
-     * @return an integer corresponding to the configured color to be displayed when the module is turned on
-     *
-     * On failure, throws an exception or returns Y_RGBCOLORATPOWERON_INVALID.
-     */
-    int                 get_rgbColorAtPowerOn(void);
-
-    inline int          rgbColorAtPowerOn(void)
-    { return this->get_rgbColorAtPowerOn(); }
-
-    /**
-     * Changes the color that the LED will display by default when the module is turned on.
-     *
-     * @param newval : an integer corresponding to the color that the LED will display by default when the
-     * module is turned on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_rgbColorAtPowerOn(int newval);
-    inline int      setRgbColorAtPowerOn(int newval)
-    { return this->set_rgbColorAtPowerOn(newval); }
-
-    /**
-     * Returns the current length of the blinking sequence.
-     *
-     * @return an integer corresponding to the current length of the blinking sequence
-     *
-     * On failure, throws an exception or returns Y_BLINKSEQSIZE_INVALID.
-     */
-    int                 get_blinkSeqSize(void);
-
-    inline int          blinkSeqSize(void)
-    { return this->get_blinkSeqSize(); }
-
-    /**
-     * Returns the maximum length of the blinking sequence.
-     *
-     * @return an integer corresponding to the maximum length of the blinking sequence
-     *
-     * On failure, throws an exception or returns Y_BLINKSEQMAXSIZE_INVALID.
-     */
-    int                 get_blinkSeqMaxSize(void);
-
-    inline int          blinkSeqMaxSize(void)
-    { return this->get_blinkSeqMaxSize(); }
-
-    /**
-     * Return the blinking sequence signature. Since blinking
-     * sequences cannot be read from the device, this can be used
-     * to detect if a specific blinking sequence is already
-     * programmed.
-     *
-     * @return an integer
-     *
-     * On failure, throws an exception or returns Y_BLINKSEQSIGNATURE_INVALID.
-     */
-    int                 get_blinkSeqSignature(void);
-
-    inline int          blinkSeqSignature(void)
-    { return this->get_blinkSeqSignature(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves an RGB LED for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the RGB LED is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YColorLed.isOnline() to test if the RGB LED is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * an RGB LED by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the RGB LED
-     *
-     * @return a YColorLed object allowing you to drive the RGB LED.
-     */
-    static YColorLed*   FindColorLed(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YColorLedValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string command);
-
-    /**
-     * Add a new transition to the blinking sequence, the move will
-     * be performed in the HSL space.
-     *
-     * @param HSLcolor : desired HSL color when the transition is completed
-     * @param msDelay : duration of the color transition, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addHslMoveToBlinkSeq(int HSLcolor,int msDelay);
-
-    /**
-     * Adds a new transition to the blinking sequence, the move is
-     * performed in the RGB space.
-     *
-     * @param RGBcolor : desired RGB color when the transition is completed
-     * @param msDelay : duration of the color transition, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addRgbMoveToBlinkSeq(int RGBcolor,int msDelay);
-
-    /**
-     * Starts the preprogrammed blinking sequence. The sequence is
-     * run in a loop until it is stopped by stopBlinkSeq or an explicit
-     * change.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         startBlinkSeq(void);
-
-    /**
-     * Stops the preprogrammed blinking sequence.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         stopBlinkSeq(void);
-
-    /**
-     * Resets the preprogrammed blinking sequence.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetBlinkSeq(void);
-
-
-    inline static YColorLed* Find(string func)
-    { return YColorLed::FindColorLed(func); }
-
-    /**
-     * Continues the enumeration of RGB LEDs started using yFirstColorLed().
-     * Caution: You can't make any assumption about the returned RGB LEDs order.
-     * If you want to find a specific an RGB LED, use ColorLed.findColorLed()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YColorLed object, corresponding to
-     *         an RGB LED currently online, or a NULL pointer
-     *         if there are no more RGB LEDs to enumerate.
-     */
-           YColorLed       *nextColorLed(void);
-    inline YColorLed       *next(void)
-    { return this->nextColorLed();}
-
-    /**
-     * Starts the enumeration of RGB LEDs currently accessible.
-     * Use the method YColorLed.nextColorLed() to iterate on
-     * next RGB LEDs.
-     *
-     * @return a pointer to a YColorLed object, corresponding to
-     *         the first RGB LED currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YColorLed* FirstColorLed(void);
-    inline static YColorLed* First(void)
-    { return YColorLed::FirstColorLed();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YColorLed accessors declaration)
-};
-
-//--- (YColorLed functions declaration)
-
-/**
- * Retrieves an RGB LED for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the RGB LED is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YColorLed.isOnline() to test if the RGB LED is
- * indeed online at a given time. In case of ambiguity when looking for
- * an RGB LED by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the RGB LED
- *
- * @return a YColorLed object allowing you to drive the RGB LED.
- */
-inline YColorLed* yFindColorLed(const string& func)
-{ return YColorLed::FindColorLed(func);}
-/**
- * Starts the enumeration of RGB LEDs currently accessible.
- * Use the method YColorLed.nextColorLed() to iterate on
- * next RGB LEDs.
- *
- * @return a pointer to a YColorLed object, corresponding to
- *         the first RGB LED currently online, or a NULL pointer
- *         if there are none.
- */
-inline YColorLed* yFirstColorLed(void)
-{ return YColorLed::FirstColorLed();}
-
-//--- (end of YColorLed functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_colorledcluster.cpp
+++ /dev/null
@@ -1,1364 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_colorledcluster.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindColorLedCluster(), the high-level API for ColorLedCluster functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_colorledcluster.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "colorledcluster"
-
-YColorLedCluster::YColorLedCluster(const string& func): YFunction(func)
-//--- (YColorLedCluster initialization)
-    ,_activeLedCount(ACTIVELEDCOUNT_INVALID)
-    ,_ledType(LEDTYPE_INVALID)
-    ,_maxLedCount(MAXLEDCOUNT_INVALID)
-    ,_blinkSeqMaxCount(BLINKSEQMAXCOUNT_INVALID)
-    ,_blinkSeqMaxSize(BLINKSEQMAXSIZE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackColorLedCluster(NULL)
-//--- (end of YColorLedCluster initialization)
-{
-    _className="ColorLedCluster";
-}
-
-YColorLedCluster::~YColorLedCluster()
-{
-//--- (YColorLedCluster cleanup)
-//--- (end of YColorLedCluster cleanup)
-}
-//--- (YColorLedCluster implementation)
-// static attributes
-const string YColorLedCluster::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YColorLedCluster::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("activeLedCount")) {
-        _activeLedCount =  json_val->getInt("activeLedCount");
-    }
-    if(json_val->has("ledType")) {
-        _ledType =  (Y_LEDTYPE_enum)json_val->getInt("ledType");
-    }
-    if(json_val->has("maxLedCount")) {
-        _maxLedCount =  json_val->getInt("maxLedCount");
-    }
-    if(json_val->has("blinkSeqMaxCount")) {
-        _blinkSeqMaxCount =  json_val->getInt("blinkSeqMaxCount");
-    }
-    if(json_val->has("blinkSeqMaxSize")) {
-        _blinkSeqMaxSize =  json_val->getInt("blinkSeqMaxSize");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the number of LEDs currently handled by the device.
- *
- * @return an integer corresponding to the number of LEDs currently handled by the device
- *
- * On failure, throws an exception or returns Y_ACTIVELEDCOUNT_INVALID.
- */
-int YColorLedCluster::get_activeLedCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::ACTIVELEDCOUNT_INVALID;
-                }
-            }
-        }
-        res = _activeLedCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of LEDs currently handled by the device.
- *
- * @param newval : an integer corresponding to the number of LEDs currently handled by the device
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_activeLedCount(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("activeLedCount", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the RGB LED type currently handled by the device.
- *
- * @return either Y_LEDTYPE_RGB or Y_LEDTYPE_RGBW, according to the RGB LED type currently handled by the device
- *
- * On failure, throws an exception or returns Y_LEDTYPE_INVALID.
- */
-Y_LEDTYPE_enum YColorLedCluster::get_ledType(void)
-{
-    Y_LEDTYPE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::LEDTYPE_INVALID;
-                }
-            }
-        }
-        res = _ledType;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the RGB LED type currently handled by the device.
- *
- * @param newval : either Y_LEDTYPE_RGB or Y_LEDTYPE_RGBW, according to the RGB LED type currently
- * handled by the device
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_ledType(Y_LEDTYPE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("ledType", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum number of LEDs that the device can handle.
- *
- * @return an integer corresponding to the maximum number of LEDs that the device can handle
- *
- * On failure, throws an exception or returns Y_MAXLEDCOUNT_INVALID.
- */
-int YColorLedCluster::get_maxLedCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::MAXLEDCOUNT_INVALID;
-                }
-            }
-        }
-        res = _maxLedCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum number of sequences that the device can handle.
- *
- * @return an integer corresponding to the maximum number of sequences that the device can handle
- *
- * On failure, throws an exception or returns Y_BLINKSEQMAXCOUNT_INVALID.
- */
-int YColorLedCluster::get_blinkSeqMaxCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::BLINKSEQMAXCOUNT_INVALID;
-                }
-            }
-        }
-        res = _blinkSeqMaxCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum length of sequences.
- *
- * @return an integer corresponding to the maximum length of sequences
- *
- * On failure, throws an exception or returns Y_BLINKSEQMAXSIZE_INVALID.
- */
-int YColorLedCluster::get_blinkSeqMaxSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::BLINKSEQMAXSIZE_INVALID;
-                }
-            }
-        }
-        res = _blinkSeqMaxSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YColorLedCluster::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YColorLedCluster::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YColorLedCluster::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a RGB LED cluster for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the RGB LED cluster is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YColorLedCluster.isOnline() to test if the RGB LED cluster is
- * indeed online at a given time. In case of ambiguity when looking for
- * a RGB LED cluster by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the RGB LED cluster
- *
- * @return a YColorLedCluster object allowing you to drive the RGB LED cluster.
- */
-YColorLedCluster* YColorLedCluster::FindColorLedCluster(string func)
-{
-    YColorLedCluster* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YColorLedCluster*) YFunction::_FindFromCache("ColorLedCluster", func);
-        if (obj == NULL) {
-            obj = new YColorLedCluster(func);
-            YFunction::_AddToCache("ColorLedCluster", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YColorLedCluster::registerValueCallback(YColorLedClusterValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackColorLedCluster = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YColorLedCluster::_invokeValueCallback(string value)
-{
-    if (_valueCallbackColorLedCluster != NULL) {
-        _valueCallbackColorLedCluster(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YColorLedCluster::sendCommand(string command)
-{
-    return this->set_command(command);
-}
-
-/**
- * Changes the current color of consecutive LEDs in the cluster, using a RGB color. Encoding is done
- * as follows: 0xRRGGBB.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param rgbValue :  new color.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_rgbColor(int ledIndex,int count,int rgbValue)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("SR%d,%d,%x",ledIndex,count,rgbValue));
-}
-
-/**
- * Changes the  color at device startup of consecutive LEDs in the cluster, using a RGB color.
- * Encoding is done as follows: 0xRRGGBB.
- * Don't forget to call saveLedsConfigAtPowerOn() to make sure the modification is saved in the device
- * flash memory.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param rgbValue :  new color.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_rgbColorAtPowerOn(int ledIndex,int count,int rgbValue)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("SC%d,%d,%x",ledIndex,count,rgbValue));
-}
-
-/**
- * Changes the  color at device startup of consecutive LEDs in the cluster, using a HSL color.
- * Encoding is done as follows: 0xHHSSLL.
- * Don't forget to call saveLedsConfigAtPowerOn() to make sure the modification is saved in the device
- * flash memory.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param hslValue :  new color.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_hslColorAtPowerOn(int ledIndex,int count,int hslValue)
-{
-    int rgbValue = 0;
-    rgbValue = this->hsl2rgb(hslValue);
-    return this->sendCommand(YapiWrapper::ysprintf("SC%d,%d,%x",ledIndex,count,rgbValue));
-}
-
-/**
- * Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done
- * as follows: 0xHHSSLL.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param hslValue :  new color.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_hslColor(int ledIndex,int count,int hslValue)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("SH%d,%d,%x",ledIndex,count,hslValue));
-}
-
-/**
- * Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and
- * autonomous manner. The transition is performed in the RGB space.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param rgbValue :  new color (0xRRGGBB).
- * @param delay    :  transition duration in ms
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::rgb_move(int ledIndex,int count,int rgbValue,int delay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("MR%d,%d,%x,%d",ledIndex,count,rgbValue,delay));
-}
-
-/**
- * Allows you to modify the current color of a group of adjacent LEDs  to another color, in a seamless and
- * autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular
- * value (0..360°). There are always two paths to perform the transition: by increasing
- * or by decreasing the hue. The module selects the shortest transition.
- * If the difference is exactly 180°, the module selects the transition which increases
- * the hue.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param hslValue :  new color (0xHHSSLL).
- * @param delay    :  transition duration in ms
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::hsl_move(int ledIndex,int count,int hslValue,int delay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("MH%d,%d,%x,%d",ledIndex,count,hslValue,delay));
-}
-
-/**
- * Adds an RGB transition to a sequence. A sequence is a transition list, which can
- * be executed in loop by a group of LEDs.  Sequences are persistent and are saved
- * in the device flash memory as soon as the saveBlinkSeq() method is called.
- *
- * @param seqIndex :  sequence index.
- * @param rgbValue :  target color (0xRRGGBB)
- * @param delay    :  transition duration in ms
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::addRgbMoveToBlinkSeq(int seqIndex,int rgbValue,int delay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AR%d,%x,%d",seqIndex,rgbValue,delay));
-}
-
-/**
- * Adds an HSL transition to a sequence. A sequence is a transition list, which can
- * be executed in loop by an group of LEDs.  Sequences are persistent and are saved
- * in the device flash memory as soon as the saveBlinkSeq() method is called.
- *
- * @param seqIndex : sequence index.
- * @param hslValue : target color (0xHHSSLL)
- * @param delay    : transition duration in ms
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::addHslMoveToBlinkSeq(int seqIndex,int hslValue,int delay)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AH%d,%x,%d",seqIndex,hslValue,delay));
-}
-
-/**
- * Adds a mirror ending to a sequence. When the sequence will reach the end of the last
- * transition, its running speed will automatically be reversed so that the sequence plays
- * in the reverse direction, like in a mirror. After the first transition of the sequence
- * is played at the end of the reverse execution, the sequence starts again in
- * the initial direction.
- *
- * @param seqIndex : sequence index.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::addMirrorToBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AC%d,0,0",seqIndex));
-}
-
-/**
- * Adds to a sequence a jump to another sequence. When a pixel will reach this jump,
- * it will be automatically relinked to the new sequence, and will run it starting
- * from the beginning.
- *
- * @param seqIndex : sequence index.
- * @param linkSeqIndex : index of the sequence to chain.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::addJumpToBlinkSeq(int seqIndex,int linkSeqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AC%d,100,%d,1000",seqIndex,linkSeqIndex));
-}
-
-/**
- * Adds a to a sequence a hard stop code. When a pixel will reach this stop code,
- * instead of restarting the sequence in a loop it will automatically be unlinked
- * from the sequence.
- *
- * @param seqIndex : sequence index.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::addUnlinkToBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AC%d,100,-1,1000",seqIndex));
-}
-
-/**
- * Links adjacent LEDs to a specific sequence. These LEDs start to execute
- * the sequence as soon as  startBlinkSeq is called. It is possible to add an offset
- * in the execution: that way we  can have several groups of LED executing the same
- * sequence, with a  temporal offset. A LED cannot be linked to more than one sequence.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param seqIndex :  sequence index.
- * @param offset   :  execution offset in ms.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::linkLedToBlinkSeq(int ledIndex,int count,int seqIndex,int offset)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("LS%d,%d,%d,%d",ledIndex,count,seqIndex,offset));
-}
-
-/**
- * Links adjacent LEDs to a specific sequence at device power-on. Don't forget to configure
- * the sequence auto start flag as well and call saveLedsConfigAtPowerOn(). It is possible to add an offset
- * in the execution: that way we  can have several groups of LEDs executing the same
- * sequence, with a  temporal offset. A LED cannot be linked to more than one sequence.
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param seqIndex :  sequence index.
- * @param offset   :  execution offset in ms.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::linkLedToBlinkSeqAtPowerOn(int ledIndex,int count,int seqIndex,int offset)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("LO%d,%d,%d,%d",ledIndex,count,seqIndex,offset));
-}
-
-/**
- * Links adjacent LEDs to a specific sequence. These LED start to execute
- * the sequence as soon as  startBlinkSeq is called. This function automatically
- * introduces a shift between LEDs so that the specified number of sequence periods
- * appears on the group of LEDs (wave effect).
- *
- * @param ledIndex :  index of the first affected LED.
- * @param count    :  affected LED count.
- * @param seqIndex :  sequence index.
- * @param periods  :  number of periods to show on LEDs.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::linkLedToPeriodicBlinkSeq(int ledIndex,int count,int seqIndex,int periods)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("LP%d,%d,%d,%d",ledIndex,count,seqIndex,periods));
-}
-
-/**
- * Unlinks adjacent LEDs from a  sequence.
- *
- * @param ledIndex  :  index of the first affected LED.
- * @param count     :  affected LED count.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::unlinkLedFromBlinkSeq(int ledIndex,int count)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("US%d,%d",ledIndex,count));
-}
-
-/**
- * Starts a sequence execution: every LED linked to that sequence starts to
- * run it in a loop. Note that a sequence with a zero duration can't be started.
- *
- * @param seqIndex :  index of the sequence to start.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::startBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("SS%d",seqIndex));
-}
-
-/**
- * Stops a sequence execution. If started again, the execution
- * restarts from the beginning.
- *
- * @param seqIndex :  index of the sequence to stop.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::stopBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("XS%d",seqIndex));
-}
-
-/**
- * Stops a sequence execution and resets its contents. LEDs linked to this
- * sequence are not automatically updated anymore.
- *
- * @param seqIndex :  index of the sequence to reset
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::resetBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("ZS%d",seqIndex));
-}
-
-/**
- * Configures a sequence to make it start automatically at device
- * startup. Note that a sequence with a zero duration can't be started.
- * Don't forget to call saveBlinkSeq() to make sure the
- * modification is saved in the device flash memory.
- *
- * @param seqIndex :  index of the sequence to reset.
- * @param autostart : 0 to keep the sequence turned off and 1 to start it automatically.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_blinkSeqStateAtPowerOn(int seqIndex,int autostart)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("AS%d,%d",seqIndex,autostart));
-}
-
-/**
- * Changes the execution speed of a sequence. The natural execution speed is 1000 per
- * thousand. If you configure a slower speed, you can play the sequence in slow-motion.
- * If you set a negative speed, you can play the sequence in reverse direction.
- *
- * @param seqIndex :  index of the sequence to start.
- * @param speed :     sequence running speed (-1000...1000).
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_blinkSeqSpeed(int seqIndex,int speed)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("CS%d,%d",seqIndex,speed));
-}
-
-/**
- * Saves the LEDs power-on configuration. This includes the start-up color or
- * sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the
- * method saveBlinkSeq() must also be called to save the sequence definition.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::saveLedsConfigAtPowerOn(void)
-{
-    return this->sendCommand("WL");
-}
-
-int YColorLedCluster::saveLedsState(void)
-{
-    return this->sendCommand("WL");
-}
-
-/**
- * Saves the definition of a sequence. Warning: only sequence steps and flags are saved.
- * to save the LEDs startup bindings, the method saveLedsConfigAtPowerOn()
- * must be called.
- *
- * @param seqIndex :  index of the sequence to start.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::saveBlinkSeq(int seqIndex)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("WS%d",seqIndex));
-}
-
-/**
- * Sends a binary buffer to the LED RGB buffer, as is.
- * First three bytes are RGB components for LED specified as parameter, the
- * next three bytes for the next LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param buff : the binary buffer to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_rgbColorBuffer(int ledIndex,string buff)
-{
-    return this->_upload(YapiWrapper::ysprintf("rgb:0:%d",ledIndex), buff);
-}
-
-/**
- * Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.
- * The first number represents the RGB value of the LED specified as parameter, the second
- * number represents the RGB value of the next LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param rgbList : a list of 24bit RGB codes, in the form 0xRRGGBB
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_rgbColorArray(int ledIndex,vector<int> rgbList)
-{
-    int listlen = 0;
-    string buff;
-    int idx = 0;
-    int rgb = 0;
-    int res = 0;
-    listlen = (int)rgbList.size();
-    buff = string(3*listlen, (char)0);
-    idx = 0;
-    while (idx < listlen) {
-        rgb = rgbList[idx];
-        buff[3*idx] = (char)(((((rgb) >> (16))) & (255)));
-        buff[3*idx+1] = (char)(((((rgb) >> (8))) & (255)));
-        buff[3*idx+2] = (char)(((rgb) & (255)));
-        idx = idx + 1;
-    }
-
-    res = this->_upload(YapiWrapper::ysprintf("rgb:0:%d",ledIndex), buff);
-    return res;
-}
-
-/**
- * Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB
- * color codes. The first color code represents the target RGB value of the first LED,
- * the next color code represents the target value of the next LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param rgbList : a list of target 24bit RGB codes, in the form 0xRRGGBB
- * @param delay   : transition duration in ms
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::rgbArrayOfs_move(int ledIndex,vector<int> rgbList,int delay)
-{
-    int listlen = 0;
-    string buff;
-    int idx = 0;
-    int rgb = 0;
-    int res = 0;
-    listlen = (int)rgbList.size();
-    buff = string(3*listlen, (char)0);
-    idx = 0;
-    while (idx < listlen) {
-        rgb = rgbList[idx];
-        buff[3*idx] = (char)(((((rgb) >> (16))) & (255)));
-        buff[3*idx+1] = (char)(((((rgb) >> (8))) & (255)));
-        buff[3*idx+2] = (char)(((rgb) & (255)));
-        idx = idx + 1;
-    }
-
-    res = this->_upload(YapiWrapper::ysprintf("rgb:%d:%d",delay,ledIndex), buff);
-    return res;
-}
-
-/**
- * Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB
- * color codes. The first color code represents the target RGB value of the first LED,
- * the next color code represents the target value of the next LED, etc.
- *
- * @param rgbList : a list of target 24bit RGB codes, in the form 0xRRGGBB
- * @param delay   : transition duration in ms
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::rgbArray_move(vector<int> rgbList,int delay)
-{
-    int res = 0;
-
-    res = this->rgbArrayOfs_move(0,rgbList,delay);
-    return res;
-}
-
-/**
- * Sends a binary buffer to the LED HSL buffer, as is.
- * First three bytes are HSL components for the LED specified as parameter, the
- * next three bytes for the second LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param buff : the binary buffer to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_hslColorBuffer(int ledIndex,string buff)
-{
-    return this->_upload(YapiWrapper::ysprintf("hsl:0:%d",ledIndex), buff);
-}
-
-/**
- * Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.
- * The first number represents the HSL value of the LED specified as parameter, the second number represents
- * the HSL value of the second LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param hslList : a list of 24bit HSL codes, in the form 0xHHSSLL
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::set_hslColorArray(int ledIndex,vector<int> hslList)
-{
-    int listlen = 0;
-    string buff;
-    int idx = 0;
-    int hsl = 0;
-    int res = 0;
-    listlen = (int)hslList.size();
-    buff = string(3*listlen, (char)0);
-    idx = 0;
-    while (idx < listlen) {
-        hsl = hslList[idx];
-        buff[3*idx] = (char)(((((hsl) >> (16))) & (255)));
-        buff[3*idx+1] = (char)(((((hsl) >> (8))) & (255)));
-        buff[3*idx+2] = (char)(((hsl) & (255)));
-        idx = idx + 1;
-    }
-
-    res = this->_upload(YapiWrapper::ysprintf("hsl:0:%d",ledIndex), buff);
-    return res;
-}
-
-/**
- * Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL
- * color codes. The first color code represents the target HSL value of the first LED,
- * the second color code represents the target value of the second LED, etc.
- *
- * @param hslList : a list of target 24bit HSL codes, in the form 0xHHSSLL
- * @param delay   : transition duration in ms
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::hslArray_move(vector<int> hslList,int delay)
-{
-    int res = 0;
-
-    res = this->hslArrayOfs_move(0,hslList, delay);
-    return res;
-}
-
-/**
- * Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL
- * color codes. The first color code represents the target HSL value of the first LED,
- * the second color code represents the target value of the second LED, etc.
- *
- * @param ledIndex : index of the first LED which should be updated
- * @param hslList : a list of target 24bit HSL codes, in the form 0xHHSSLL
- * @param delay   : transition duration in ms
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YColorLedCluster::hslArrayOfs_move(int ledIndex,vector<int> hslList,int delay)
-{
-    int listlen = 0;
-    string buff;
-    int idx = 0;
-    int hsl = 0;
-    int res = 0;
-    listlen = (int)hslList.size();
-    buff = string(3*listlen, (char)0);
-    idx = 0;
-    while (idx < listlen) {
-        hsl = hslList[idx];
-        buff[3*idx] = (char)(((((hsl) >> (16))) & (255)));
-        buff[3*idx+1] = (char)(((((hsl) >> (8))) & (255)));
-        buff[3*idx+2] = (char)(((hsl) & (255)));
-        idx = idx + 1;
-    }
-
-    res = this->_upload(YapiWrapper::ysprintf("hsl:%d:%d",delay,ledIndex), buff);
-    return res;
-}
-
-/**
- * Returns a binary buffer with content from the LED RGB buffer, as is.
- * First three bytes are RGB components for the first LED in the interval,
- * the next three bytes for the second LED in the interval, etc.
- *
- * @param ledIndex : index of the first LED which should be returned
- * @param count    : number of LEDs which should be returned
- *
- * @return a binary buffer with RGB components of selected LEDs.
- *
- * On failure, throws an exception or returns an empty binary buffer.
- */
-string YColorLedCluster::get_rgbColorBuffer(int ledIndex,int count)
-{
-    return this->_download(YapiWrapper::ysprintf("rgb.bin?typ=0&pos=%d&len=%d",3*ledIndex,3*count));
-}
-
-/**
- * Returns a list on 24bit RGB color values with the current colors displayed on
- * the RGB LEDs. The first number represents the RGB value of the first LED,
- * the second number represents the RGB value of the second LED, etc.
- *
- * @param ledIndex : index of the first LED which should be returned
- * @param count    : number of LEDs which should be returned
- *
- * @return a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_rgbColorArray(int ledIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int r = 0;
-    int g = 0;
-    int b = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=0&pos=%d&len=%d",3*ledIndex,3*count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        r = ((u8)buff[3*idx]);
-        g = ((u8)buff[3*idx+1]);
-        b = ((u8)buff[3*idx+2]);
-        res.push_back(r*65536+g*256+b);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list on 24bit RGB color values with the RGB LEDs startup colors.
- * The first number represents the startup RGB value of the first LED,
- * the second number represents the RGB value of the second LED, etc.
- *
- * @param ledIndex : index of the first LED  which should be returned
- * @param count    : number of LEDs which should be returned
- *
- * @return a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_rgbColorArrayAtPowerOn(int ledIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int r = 0;
-    int g = 0;
-    int b = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=4&pos=%d&len=%d",3*ledIndex,3*count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        r = ((u8)buff[3*idx]);
-        g = ((u8)buff[3*idx+1]);
-        b = ((u8)buff[3*idx+2]);
-        res.push_back(r*65536+g*256+b);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list on sequence index for each RGB LED. The first number represents the
- * sequence index for the the first LED, the second number represents the sequence
- * index for the second LED, etc.
- *
- * @param ledIndex : index of the first LED which should be returned
- * @param count    : number of LEDs which should be returned
- *
- * @return a list of integers with sequence index
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_linkedSeqArray(int ledIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int seq = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=1&pos=%d&len=%d",ledIndex,count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        seq = ((u8)buff[idx]);
-        res.push_back(seq);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list on 32 bit signatures for specified blinking sequences.
- * Since blinking sequences cannot be read from the device, this can be used
- * to detect if a specific blinking sequence is already programmed.
- *
- * @param seqIndex : index of the first blinking sequence which should be returned
- * @param count    : number of blinking sequences which should be returned
- *
- * @return a list of 32 bit integer signatures
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_blinkSeqSignatures(int seqIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int hh = 0;
-    int hl = 0;
-    int lh = 0;
-    int ll = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=2&pos=%d&len=%d",4*seqIndex,4*count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        hh = ((u8)buff[4*idx]);
-        hl = ((u8)buff[4*idx+1]);
-        lh = ((u8)buff[4*idx+2]);
-        ll = ((u8)buff[4*idx+3]);
-        res.push_back(((hh) << (24))+((hl) << (16))+((lh) << (8))+ll);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list of integers with the current speed for specified blinking sequences.
- *
- * @param seqIndex : index of the first sequence speed which should be returned
- * @param count    : number of sequence speeds which should be returned
- *
- * @return a list of integers, 0 for sequences turned off and 1 for sequences running
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_blinkSeqStateSpeed(int seqIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int lh = 0;
-    int ll = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=6&pos=%d&len=%d",seqIndex,count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        lh = ((u8)buff[2*idx]);
-        ll = ((u8)buff[2*idx+1]);
-        res.push_back(((lh) << (8))+ll);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list of integers with the "auto-start at power on" flag state for specified blinking sequences.
- *
- * @param seqIndex : index of the first blinking sequence which should be returned
- * @param count    : number of blinking sequences which should be returned
- *
- * @return a list of integers, 0 for sequences turned off and 1 for sequences running
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_blinkSeqStateAtPowerOn(int seqIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int started = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=5&pos=%d&len=%d",seqIndex,count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        started = ((u8)buff[idx]);
-        res.push_back(started);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Returns a list of integers with the started state for specified blinking sequences.
- *
- * @param seqIndex : index of the first blinking sequence which should be returned
- * @param count    : number of blinking sequences which should be returned
- *
- * @return a list of integers, 0 for sequences turned off and 1 for sequences running
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YColorLedCluster::get_blinkSeqState(int seqIndex,int count)
-{
-    string buff;
-    vector<int> res;
-    int idx = 0;
-    int started = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rgb.bin?typ=3&pos=%d&len=%d",seqIndex,count));
-    res.clear();
-    idx = 0;
-    while (idx < count) {
-        started = ((u8)buff[idx]);
-        res.push_back(started);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-int YColorLedCluster::hsl2rgbInt(int temp1,int temp2,int temp3)
-{
-    if (temp3 >= 170) {
-        return (((temp1 + 127)) / (255));
-    }
-    if (temp3 > 42) {
-        if (temp3 <= 127) {
-            return (((temp2 + 127)) / (255));
-        }
-        temp3 = 170 - temp3;
-    }
-    return (((temp1*255 + (temp2-temp1) * (6 * temp3) + 32512)) / (65025));
-}
-
-int YColorLedCluster::hsl2rgb(int hslValue)
-{
-    int R = 0;
-    int G = 0;
-    int B = 0;
-    int H = 0;
-    int S = 0;
-    int L = 0;
-    int temp1 = 0;
-    int temp2 = 0;
-    int temp3 = 0;
-    int res = 0;
-    L = ((hslValue) & (0xff));
-    S = ((((hslValue) >> (8))) & (0xff));
-    H = ((((hslValue) >> (16))) & (0xff));
-    if (S==0) {
-        res = ((L) << (16))+((L) << (8))+L;
-        return res;
-    }
-    if (L<=127) {
-        temp2 = L * (255 + S);
-    } else {
-        temp2 = (L+S) * 255 - L*S;
-    }
-    temp1 = 510 * L - temp2;
-    // R
-    temp3 = (H + 85);
-    if (temp3 > 255) {
-        temp3 = temp3-255;
-    }
-    R = this->hsl2rgbInt(temp1, temp2, temp3);
-    // G
-    temp3 = H;
-    if (temp3 > 255) {
-        temp3 = temp3-255;
-    }
-    G = this->hsl2rgbInt(temp1, temp2, temp3);
-    // B
-    if (H >= 85) {
-        temp3 = H - 85 ;
-    } else {
-        temp3 = H + 170;
-    }
-    B = this->hsl2rgbInt(temp1, temp2, temp3);
-    // just in case
-    if (R>255) {
-        R=255;
-    }
-    if (G>255) {
-        G=255;
-    }
-    if (B>255) {
-        B=255;
-    }
-    res = ((R) << (16))+((G) << (8))+B;
-    return res;
-}
-
-YColorLedCluster *YColorLedCluster::nextColorLedCluster(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YColorLedCluster::FindColorLedCluster(hwid);
-}
-
-YColorLedCluster* YColorLedCluster::FirstColorLedCluster(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("ColorLedCluster", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YColorLedCluster::FindColorLedCluster(serial+"."+funcId);
-}
-
-//--- (end of YColorLedCluster implementation)
-
-//--- (YColorLedCluster functions)
-//--- (end of YColorLedCluster functions)
--- a/Sources/cpplib/yocto_colorledcluster.h
+++ /dev/null
@@ -1,892 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_colorledcluster.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindColorLedCluster(), the high-level API for ColorLedCluster functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_COLORLEDCLUSTER_H
-#define YOCTO_COLORLEDCLUSTER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YColorLedCluster return codes)
-//--- (end of YColorLedCluster return codes)
-//--- (YColorLedCluster yapiwrapper)
-//--- (end of YColorLedCluster yapiwrapper)
-//--- (YColorLedCluster definitions)
-class YColorLedCluster; // forward declaration
-
-typedef void (*YColorLedClusterValueCallback)(YColorLedCluster *func, const string& functionValue);
-#ifndef _Y_LEDTYPE_ENUM
-#define _Y_LEDTYPE_ENUM
-typedef enum {
-    Y_LEDTYPE_RGB = 0,
-    Y_LEDTYPE_RGBW = 1,
-    Y_LEDTYPE_INVALID = -1,
-} Y_LEDTYPE_enum;
-#endif
-#define Y_ACTIVELEDCOUNT_INVALID        (YAPI_INVALID_UINT)
-#define Y_MAXLEDCOUNT_INVALID           (YAPI_INVALID_UINT)
-#define Y_BLINKSEQMAXCOUNT_INVALID      (YAPI_INVALID_UINT)
-#define Y_BLINKSEQMAXSIZE_INVALID       (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YColorLedCluster definitions)
-
-//--- (YColorLedCluster declaration)
-/**
- * YColorLedCluster Class: ColorLedCluster function interface
- *
- * The Yoctopuce application programming interface
- * allows you to drive a color LED cluster. Unlike the ColorLed class, the ColorLedCluster
- * allows to handle several LEDs at one. Color changes can be done   using RGB coordinates as well as
- * HSL coordinates.
- * The module performs all conversions form RGB to HSL automatically. It is then
- * self-evident to turn on a LED with a given hue and to progressively vary its
- * saturation or lightness. If needed, you can find more information on the
- * difference between RGB and HSL in the section following this one.
- */
-class YOCTO_CLASS_EXPORT YColorLedCluster: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YColorLedCluster declaration)
-protected:
-    //--- (YColorLedCluster attributes)
-    // Attributes (function value cache)
-    int             _activeLedCount;
-    Y_LEDTYPE_enum  _ledType;
-    int             _maxLedCount;
-    int             _blinkSeqMaxCount;
-    int             _blinkSeqMaxSize;
-    string          _command;
-    YColorLedClusterValueCallback _valueCallbackColorLedCluster;
-
-    friend YColorLedCluster *yFindColorLedCluster(const string& func);
-    friend YColorLedCluster *yFirstColorLedCluster(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindColorLedCluster factory function to instantiate
-    YColorLedCluster(const string& func);
-    //--- (end of YColorLedCluster attributes)
-
-public:
-    virtual ~YColorLedCluster();
-    //--- (YColorLedCluster accessors declaration)
-
-    static const int ACTIVELEDCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const Y_LEDTYPE_enum LEDTYPE_RGB = Y_LEDTYPE_RGB;
-    static const Y_LEDTYPE_enum LEDTYPE_RGBW = Y_LEDTYPE_RGBW;
-    static const Y_LEDTYPE_enum LEDTYPE_INVALID = Y_LEDTYPE_INVALID;
-    static const int MAXLEDCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int BLINKSEQMAXCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int BLINKSEQMAXSIZE_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the number of LEDs currently handled by the device.
-     *
-     * @return an integer corresponding to the number of LEDs currently handled by the device
-     *
-     * On failure, throws an exception or returns Y_ACTIVELEDCOUNT_INVALID.
-     */
-    int                 get_activeLedCount(void);
-
-    inline int          activeLedCount(void)
-    { return this->get_activeLedCount(); }
-
-    /**
-     * Changes the number of LEDs currently handled by the device.
-     *
-     * @param newval : an integer corresponding to the number of LEDs currently handled by the device
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_activeLedCount(int newval);
-    inline int      setActiveLedCount(int newval)
-    { return this->set_activeLedCount(newval); }
-
-    /**
-     * Returns the RGB LED type currently handled by the device.
-     *
-     * @return either Y_LEDTYPE_RGB or Y_LEDTYPE_RGBW, according to the RGB LED type currently handled by the device
-     *
-     * On failure, throws an exception or returns Y_LEDTYPE_INVALID.
-     */
-    Y_LEDTYPE_enum      get_ledType(void);
-
-    inline Y_LEDTYPE_enum ledType(void)
-    { return this->get_ledType(); }
-
-    /**
-     * Changes the RGB LED type currently handled by the device.
-     *
-     * @param newval : either Y_LEDTYPE_RGB or Y_LEDTYPE_RGBW, according to the RGB LED type currently
-     * handled by the device
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_ledType(Y_LEDTYPE_enum newval);
-    inline int      setLedType(Y_LEDTYPE_enum newval)
-    { return this->set_ledType(newval); }
-
-    /**
-     * Returns the maximum number of LEDs that the device can handle.
-     *
-     * @return an integer corresponding to the maximum number of LEDs that the device can handle
-     *
-     * On failure, throws an exception or returns Y_MAXLEDCOUNT_INVALID.
-     */
-    int                 get_maxLedCount(void);
-
-    inline int          maxLedCount(void)
-    { return this->get_maxLedCount(); }
-
-    /**
-     * Returns the maximum number of sequences that the device can handle.
-     *
-     * @return an integer corresponding to the maximum number of sequences that the device can handle
-     *
-     * On failure, throws an exception or returns Y_BLINKSEQMAXCOUNT_INVALID.
-     */
-    int                 get_blinkSeqMaxCount(void);
-
-    inline int          blinkSeqMaxCount(void)
-    { return this->get_blinkSeqMaxCount(); }
-
-    /**
-     * Returns the maximum length of sequences.
-     *
-     * @return an integer corresponding to the maximum length of sequences
-     *
-     * On failure, throws an exception or returns Y_BLINKSEQMAXSIZE_INVALID.
-     */
-    int                 get_blinkSeqMaxSize(void);
-
-    inline int          blinkSeqMaxSize(void)
-    { return this->get_blinkSeqMaxSize(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a RGB LED cluster for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the RGB LED cluster is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YColorLedCluster.isOnline() to test if the RGB LED cluster is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a RGB LED cluster by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the RGB LED cluster
-     *
-     * @return a YColorLedCluster object allowing you to drive the RGB LED cluster.
-     */
-    static YColorLedCluster* FindColorLedCluster(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YColorLedClusterValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string command);
-
-    /**
-     * Changes the current color of consecutive LEDs in the cluster, using a RGB color. Encoding is done
-     * as follows: 0xRRGGBB.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param rgbValue :  new color.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_rgbColor(int ledIndex,int count,int rgbValue);
-
-    /**
-     * Changes the  color at device startup of consecutive LEDs in the cluster, using a RGB color.
-     * Encoding is done as follows: 0xRRGGBB.
-     * Don't forget to call saveLedsConfigAtPowerOn() to make sure the modification is saved in the device
-     * flash memory.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param rgbValue :  new color.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_rgbColorAtPowerOn(int ledIndex,int count,int rgbValue);
-
-    /**
-     * Changes the  color at device startup of consecutive LEDs in the cluster, using a HSL color.
-     * Encoding is done as follows: 0xHHSSLL.
-     * Don't forget to call saveLedsConfigAtPowerOn() to make sure the modification is saved in the device
-     * flash memory.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param hslValue :  new color.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_hslColorAtPowerOn(int ledIndex,int count,int hslValue);
-
-    /**
-     * Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done
-     * as follows: 0xHHSSLL.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param hslValue :  new color.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_hslColor(int ledIndex,int count,int hslValue);
-
-    /**
-     * Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and
-     * autonomous manner. The transition is performed in the RGB space.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param rgbValue :  new color (0xRRGGBB).
-     * @param delay    :  transition duration in ms
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         rgb_move(int ledIndex,int count,int rgbValue,int delay);
-
-    /**
-     * Allows you to modify the current color of a group of adjacent LEDs  to another color, in a seamless and
-     * autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular
-     * value (0..360°). There are always two paths to perform the transition: by increasing
-     * or by decreasing the hue. The module selects the shortest transition.
-     * If the difference is exactly 180°, the module selects the transition which increases
-     * the hue.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param hslValue :  new color (0xHHSSLL).
-     * @param delay    :  transition duration in ms
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         hsl_move(int ledIndex,int count,int hslValue,int delay);
-
-    /**
-     * Adds an RGB transition to a sequence. A sequence is a transition list, which can
-     * be executed in loop by a group of LEDs.  Sequences are persistent and are saved
-     * in the device flash memory as soon as the saveBlinkSeq() method is called.
-     *
-     * @param seqIndex :  sequence index.
-     * @param rgbValue :  target color (0xRRGGBB)
-     * @param delay    :  transition duration in ms
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addRgbMoveToBlinkSeq(int seqIndex,int rgbValue,int delay);
-
-    /**
-     * Adds an HSL transition to a sequence. A sequence is a transition list, which can
-     * be executed in loop by an group of LEDs.  Sequences are persistent and are saved
-     * in the device flash memory as soon as the saveBlinkSeq() method is called.
-     *
-     * @param seqIndex : sequence index.
-     * @param hslValue : target color (0xHHSSLL)
-     * @param delay    : transition duration in ms
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addHslMoveToBlinkSeq(int seqIndex,int hslValue,int delay);
-
-    /**
-     * Adds a mirror ending to a sequence. When the sequence will reach the end of the last
-     * transition, its running speed will automatically be reversed so that the sequence plays
-     * in the reverse direction, like in a mirror. After the first transition of the sequence
-     * is played at the end of the reverse execution, the sequence starts again in
-     * the initial direction.
-     *
-     * @param seqIndex : sequence index.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addMirrorToBlinkSeq(int seqIndex);
-
-    /**
-     * Adds to a sequence a jump to another sequence. When a pixel will reach this jump,
-     * it will be automatically relinked to the new sequence, and will run it starting
-     * from the beginning.
-     *
-     * @param seqIndex : sequence index.
-     * @param linkSeqIndex : index of the sequence to chain.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addJumpToBlinkSeq(int seqIndex,int linkSeqIndex);
-
-    /**
-     * Adds a to a sequence a hard stop code. When a pixel will reach this stop code,
-     * instead of restarting the sequence in a loop it will automatically be unlinked
-     * from the sequence.
-     *
-     * @param seqIndex : sequence index.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         addUnlinkToBlinkSeq(int seqIndex);
-
-    /**
-     * Links adjacent LEDs to a specific sequence. These LEDs start to execute
-     * the sequence as soon as  startBlinkSeq is called. It is possible to add an offset
-     * in the execution: that way we  can have several groups of LED executing the same
-     * sequence, with a  temporal offset. A LED cannot be linked to more than one sequence.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param seqIndex :  sequence index.
-     * @param offset   :  execution offset in ms.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         linkLedToBlinkSeq(int ledIndex,int count,int seqIndex,int offset);
-
-    /**
-     * Links adjacent LEDs to a specific sequence at device power-on. Don't forget to configure
-     * the sequence auto start flag as well and call saveLedsConfigAtPowerOn(). It is possible to add an offset
-     * in the execution: that way we  can have several groups of LEDs executing the same
-     * sequence, with a  temporal offset. A LED cannot be linked to more than one sequence.
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param seqIndex :  sequence index.
-     * @param offset   :  execution offset in ms.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         linkLedToBlinkSeqAtPowerOn(int ledIndex,int count,int seqIndex,int offset);
-
-    /**
-     * Links adjacent LEDs to a specific sequence. These LED start to execute
-     * the sequence as soon as  startBlinkSeq is called. This function automatically
-     * introduces a shift between LEDs so that the specified number of sequence periods
-     * appears on the group of LEDs (wave effect).
-     *
-     * @param ledIndex :  index of the first affected LED.
-     * @param count    :  affected LED count.
-     * @param seqIndex :  sequence index.
-     * @param periods  :  number of periods to show on LEDs.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         linkLedToPeriodicBlinkSeq(int ledIndex,int count,int seqIndex,int periods);
-
-    /**
-     * Unlinks adjacent LEDs from a  sequence.
-     *
-     * @param ledIndex  :  index of the first affected LED.
-     * @param count     :  affected LED count.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         unlinkLedFromBlinkSeq(int ledIndex,int count);
-
-    /**
-     * Starts a sequence execution: every LED linked to that sequence starts to
-     * run it in a loop. Note that a sequence with a zero duration can't be started.
-     *
-     * @param seqIndex :  index of the sequence to start.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         startBlinkSeq(int seqIndex);
-
-    /**
-     * Stops a sequence execution. If started again, the execution
-     * restarts from the beginning.
-     *
-     * @param seqIndex :  index of the sequence to stop.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         stopBlinkSeq(int seqIndex);
-
-    /**
-     * Stops a sequence execution and resets its contents. LEDs linked to this
-     * sequence are not automatically updated anymore.
-     *
-     * @param seqIndex :  index of the sequence to reset
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetBlinkSeq(int seqIndex);
-
-    /**
-     * Configures a sequence to make it start automatically at device
-     * startup. Note that a sequence with a zero duration can't be started.
-     * Don't forget to call saveBlinkSeq() to make sure the
-     * modification is saved in the device flash memory.
-     *
-     * @param seqIndex :  index of the sequence to reset.
-     * @param autostart : 0 to keep the sequence turned off and 1 to start it automatically.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_blinkSeqStateAtPowerOn(int seqIndex,int autostart);
-
-    /**
-     * Changes the execution speed of a sequence. The natural execution speed is 1000 per
-     * thousand. If you configure a slower speed, you can play the sequence in slow-motion.
-     * If you set a negative speed, you can play the sequence in reverse direction.
-     *
-     * @param seqIndex :  index of the sequence to start.
-     * @param speed :     sequence running speed (-1000...1000).
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_blinkSeqSpeed(int seqIndex,int speed);
-
-    /**
-     * Saves the LEDs power-on configuration. This includes the start-up color or
-     * sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the
-     * method saveBlinkSeq() must also be called to save the sequence definition.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         saveLedsConfigAtPowerOn(void);
-
-    virtual int         saveLedsState(void);
-
-    /**
-     * Saves the definition of a sequence. Warning: only sequence steps and flags are saved.
-     * to save the LEDs startup bindings, the method saveLedsConfigAtPowerOn()
-     * must be called.
-     *
-     * @param seqIndex :  index of the sequence to start.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         saveBlinkSeq(int seqIndex);
-
-    /**
-     * Sends a binary buffer to the LED RGB buffer, as is.
-     * First three bytes are RGB components for LED specified as parameter, the
-     * next three bytes for the next LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param buff : the binary buffer to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_rgbColorBuffer(int ledIndex,string buff);
-
-    /**
-     * Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.
-     * The first number represents the RGB value of the LED specified as parameter, the second
-     * number represents the RGB value of the next LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param rgbList : a list of 24bit RGB codes, in the form 0xRRGGBB
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_rgbColorArray(int ledIndex,vector<int> rgbList);
-
-    /**
-     * Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB
-     * color codes. The first color code represents the target RGB value of the first LED,
-     * the next color code represents the target value of the next LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param rgbList : a list of target 24bit RGB codes, in the form 0xRRGGBB
-     * @param delay   : transition duration in ms
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         rgbArrayOfs_move(int ledIndex,vector<int> rgbList,int delay);
-
-    /**
-     * Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB
-     * color codes. The first color code represents the target RGB value of the first LED,
-     * the next color code represents the target value of the next LED, etc.
-     *
-     * @param rgbList : a list of target 24bit RGB codes, in the form 0xRRGGBB
-     * @param delay   : transition duration in ms
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         rgbArray_move(vector<int> rgbList,int delay);
-
-    /**
-     * Sends a binary buffer to the LED HSL buffer, as is.
-     * First three bytes are HSL components for the LED specified as parameter, the
-     * next three bytes for the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param buff : the binary buffer to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_hslColorBuffer(int ledIndex,string buff);
-
-    /**
-     * Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.
-     * The first number represents the HSL value of the LED specified as parameter, the second number represents
-     * the HSL value of the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param hslList : a list of 24bit HSL codes, in the form 0xHHSSLL
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_hslColorArray(int ledIndex,vector<int> hslList);
-
-    /**
-     * Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL
-     * color codes. The first color code represents the target HSL value of the first LED,
-     * the second color code represents the target value of the second LED, etc.
-     *
-     * @param hslList : a list of target 24bit HSL codes, in the form 0xHHSSLL
-     * @param delay   : transition duration in ms
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         hslArray_move(vector<int> hslList,int delay);
-
-    /**
-     * Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL
-     * color codes. The first color code represents the target HSL value of the first LED,
-     * the second color code represents the target value of the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be updated
-     * @param hslList : a list of target 24bit HSL codes, in the form 0xHHSSLL
-     * @param delay   : transition duration in ms
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         hslArrayOfs_move(int ledIndex,vector<int> hslList,int delay);
-
-    /**
-     * Returns a binary buffer with content from the LED RGB buffer, as is.
-     * First three bytes are RGB components for the first LED in the interval,
-     * the next three bytes for the second LED in the interval, etc.
-     *
-     * @param ledIndex : index of the first LED which should be returned
-     * @param count    : number of LEDs which should be returned
-     *
-     * @return a binary buffer with RGB components of selected LEDs.
-     *
-     * On failure, throws an exception or returns an empty binary buffer.
-     */
-    virtual string      get_rgbColorBuffer(int ledIndex,int count);
-
-    /**
-     * Returns a list on 24bit RGB color values with the current colors displayed on
-     * the RGB LEDs. The first number represents the RGB value of the first LED,
-     * the second number represents the RGB value of the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be returned
-     * @param count    : number of LEDs which should be returned
-     *
-     * @return a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_rgbColorArray(int ledIndex,int count);
-
-    /**
-     * Returns a list on 24bit RGB color values with the RGB LEDs startup colors.
-     * The first number represents the startup RGB value of the first LED,
-     * the second number represents the RGB value of the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED  which should be returned
-     * @param count    : number of LEDs which should be returned
-     *
-     * @return a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_rgbColorArrayAtPowerOn(int ledIndex,int count);
-
-    /**
-     * Returns a list on sequence index for each RGB LED. The first number represents the
-     * sequence index for the the first LED, the second number represents the sequence
-     * index for the second LED, etc.
-     *
-     * @param ledIndex : index of the first LED which should be returned
-     * @param count    : number of LEDs which should be returned
-     *
-     * @return a list of integers with sequence index
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_linkedSeqArray(int ledIndex,int count);
-
-    /**
-     * Returns a list on 32 bit signatures for specified blinking sequences.
-     * Since blinking sequences cannot be read from the device, this can be used
-     * to detect if a specific blinking sequence is already programmed.
-     *
-     * @param seqIndex : index of the first blinking sequence which should be returned
-     * @param count    : number of blinking sequences which should be returned
-     *
-     * @return a list of 32 bit integer signatures
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_blinkSeqSignatures(int seqIndex,int count);
-
-    /**
-     * Returns a list of integers with the current speed for specified blinking sequences.
-     *
-     * @param seqIndex : index of the first sequence speed which should be returned
-     * @param count    : number of sequence speeds which should be returned
-     *
-     * @return a list of integers, 0 for sequences turned off and 1 for sequences running
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_blinkSeqStateSpeed(int seqIndex,int count);
-
-    /**
-     * Returns a list of integers with the "auto-start at power on" flag state for specified blinking sequences.
-     *
-     * @param seqIndex : index of the first blinking sequence which should be returned
-     * @param count    : number of blinking sequences which should be returned
-     *
-     * @return a list of integers, 0 for sequences turned off and 1 for sequences running
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_blinkSeqStateAtPowerOn(int seqIndex,int count);
-
-    /**
-     * Returns a list of integers with the started state for specified blinking sequences.
-     *
-     * @param seqIndex : index of the first blinking sequence which should be returned
-     * @param count    : number of blinking sequences which should be returned
-     *
-     * @return a list of integers, 0 for sequences turned off and 1 for sequences running
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> get_blinkSeqState(int seqIndex,int count);
-
-    virtual int         hsl2rgbInt(int temp1,int temp2,int temp3);
-
-    virtual int         hsl2rgb(int hslValue);
-
-
-    inline static YColorLedCluster* Find(string func)
-    { return YColorLedCluster::FindColorLedCluster(func); }
-
-    /**
-     * Continues the enumeration of RGB LED clusters started using yFirstColorLedCluster().
-     * Caution: You can't make any assumption about the returned RGB LED clusters order.
-     * If you want to find a specific a RGB LED cluster, use ColorLedCluster.findColorLedCluster()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YColorLedCluster object, corresponding to
-     *         a RGB LED cluster currently online, or a NULL pointer
-     *         if there are no more RGB LED clusters to enumerate.
-     */
-           YColorLedCluster *nextColorLedCluster(void);
-    inline YColorLedCluster *next(void)
-    { return this->nextColorLedCluster();}
-
-    /**
-     * Starts the enumeration of RGB LED clusters currently accessible.
-     * Use the method YColorLedCluster.nextColorLedCluster() to iterate on
-     * next RGB LED clusters.
-     *
-     * @return a pointer to a YColorLedCluster object, corresponding to
-     *         the first RGB LED cluster currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YColorLedCluster* FirstColorLedCluster(void);
-    inline static YColorLedCluster* First(void)
-    { return YColorLedCluster::FirstColorLedCluster();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YColorLedCluster accessors declaration)
-};
-
-//--- (YColorLedCluster functions declaration)
-
-/**
- * Retrieves a RGB LED cluster for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the RGB LED cluster is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YColorLedCluster.isOnline() to test if the RGB LED cluster is
- * indeed online at a given time. In case of ambiguity when looking for
- * a RGB LED cluster by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the RGB LED cluster
- *
- * @return a YColorLedCluster object allowing you to drive the RGB LED cluster.
- */
-inline YColorLedCluster* yFindColorLedCluster(const string& func)
-{ return YColorLedCluster::FindColorLedCluster(func);}
-/**
- * Starts the enumeration of RGB LED clusters currently accessible.
- * Use the method YColorLedCluster.nextColorLedCluster() to iterate on
- * next RGB LED clusters.
- *
- * @return a pointer to a YColorLedCluster object, corresponding to
- *         the first RGB LED cluster currently online, or a NULL pointer
- *         if there are none.
- */
-inline YColorLedCluster* yFirstColorLedCluster(void)
-{ return YColorLedCluster::FirstColorLedCluster();}
-
-//--- (end of YColorLedCluster functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_compass.cpp
+++ /dev/null
@@ -1,342 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_compass.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindCompass(), the high-level API for Compass functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_compass.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "compass"
-
-YCompass::YCompass(const string& func): YSensor(func)
-//--- (YCompass initialization)
-    ,_bandwidth(BANDWIDTH_INVALID)
-    ,_axis(AXIS_INVALID)
-    ,_magneticHeading(MAGNETICHEADING_INVALID)
-    ,_valueCallbackCompass(NULL)
-    ,_timedReportCallbackCompass(NULL)
-//--- (end of YCompass initialization)
-{
-    _className="Compass";
-}
-
-YCompass::~YCompass()
-{
-//--- (YCompass cleanup)
-//--- (end of YCompass cleanup)
-}
-//--- (YCompass implementation)
-// static attributes
-const double YCompass::MAGNETICHEADING_INVALID = YAPI_INVALID_DOUBLE;
-
-int YCompass::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("bandwidth")) {
-        _bandwidth =  json_val->getInt("bandwidth");
-    }
-    if(json_val->has("axis")) {
-        _axis =  (Y_AXIS_enum) json_val->getInt("axis");
-    }
-    if(json_val->has("magneticHeading")) {
-        _magneticHeading =  floor(json_val->getDouble("magneticHeading") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
- *
- * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
- */
-int YCompass::get_bandwidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCompass::BANDWIDTH_INVALID;
-                }
-            }
-        }
-        res = _bandwidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
- * frequency is lower, the device performs averaging.
- *
- * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCompass::set_bandwidth(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("bandwidth", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_AXIS_enum YCompass::get_axis(void)
-{
-    Y_AXIS_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCompass::AXIS_INVALID;
-                }
-            }
-        }
-        res = _axis;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the magnetic heading, regardless of the configured bearing.
- *
- * @return a floating point number corresponding to the magnetic heading, regardless of the configured bearing
- *
- * On failure, throws an exception or returns Y_MAGNETICHEADING_INVALID.
- */
-double YCompass::get_magneticHeading(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCompass::MAGNETICHEADING_INVALID;
-                }
-            }
-        }
-        res = _magneticHeading;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a compass for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the compass is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCompass.isOnline() to test if the compass is
- * indeed online at a given time. In case of ambiguity when looking for
- * a compass by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the compass
- *
- * @return a YCompass object allowing you to drive the compass.
- */
-YCompass* YCompass::FindCompass(string func)
-{
-    YCompass* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YCompass*) YFunction::_FindFromCache("Compass", func);
-        if (obj == NULL) {
-            obj = new YCompass(func);
-            YFunction::_AddToCache("Compass", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YCompass::registerValueCallback(YCompassValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackCompass = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YCompass::_invokeValueCallback(string value)
-{
-    if (_valueCallbackCompass != NULL) {
-        _valueCallbackCompass(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YCompass::registerTimedReportCallback(YCompassTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackCompass = callback;
-    return 0;
-}
-
-int YCompass::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackCompass != NULL) {
-        _timedReportCallbackCompass(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YCompass *YCompass::nextCompass(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YCompass::FindCompass(hwid);
-}
-
-YCompass* YCompass::FirstCompass(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Compass", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YCompass::FindCompass(serial+"."+funcId);
-}
-
-//--- (end of YCompass implementation)
-
-//--- (YCompass functions)
-//--- (end of YCompass functions)
--- a/Sources/cpplib/yocto_compass.h
+++ /dev/null
@@ -1,306 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_compass.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindCompass(), the high-level API for Compass functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_COMPASS_H
-#define YOCTO_COMPASS_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YCompass return codes)
-//--- (end of YCompass return codes)
-//--- (YCompass yapiwrapper)
-//--- (end of YCompass yapiwrapper)
-//--- (YCompass definitions)
-class YCompass; // forward declaration
-
-typedef void (*YCompassValueCallback)(YCompass *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YCompassTimedReportCallback)(YCompass *func, YMeasure measure);
-#ifndef _Y_AXIS_ENUM
-#define _Y_AXIS_ENUM
-typedef enum {
-    Y_AXIS_X = 0,
-    Y_AXIS_Y = 1,
-    Y_AXIS_Z = 2,
-    Y_AXIS_INVALID = -1,
-} Y_AXIS_enum;
-#endif
-#define Y_BANDWIDTH_INVALID             (YAPI_INVALID_INT)
-#define Y_MAGNETICHEADING_INVALID       (YAPI_INVALID_DOUBLE)
-//--- (end of YCompass definitions)
-
-//--- (YCompass declaration)
-/**
- * YCompass Class: Compass function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YCompass: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YCompass declaration)
-protected:
-    //--- (YCompass attributes)
-    // Attributes (function value cache)
-    int             _bandwidth;
-    Y_AXIS_enum     _axis;
-    double          _magneticHeading;
-    YCompassValueCallback _valueCallbackCompass;
-    YCompassTimedReportCallback _timedReportCallbackCompass;
-
-    friend YCompass *yFindCompass(const string& func);
-    friend YCompass *yFirstCompass(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindCompass factory function to instantiate
-    YCompass(const string& func);
-    //--- (end of YCompass attributes)
-
-public:
-    virtual ~YCompass();
-    //--- (YCompass accessors declaration)
-
-    static const int BANDWIDTH_INVALID = YAPI_INVALID_INT;
-    static const Y_AXIS_enum AXIS_X = Y_AXIS_X;
-    static const Y_AXIS_enum AXIS_Y = Y_AXIS_Y;
-    static const Y_AXIS_enum AXIS_Z = Y_AXIS_Z;
-    static const Y_AXIS_enum AXIS_INVALID = Y_AXIS_INVALID;
-    static const double MAGNETICHEADING_INVALID;
-
-    /**
-     * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
-     *
-     * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
-     */
-    int                 get_bandwidth(void);
-
-    inline int          bandwidth(void)
-    { return this->get_bandwidth(); }
-
-    /**
-     * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
-     * frequency is lower, the device performs averaging.
-     *
-     * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bandwidth(int newval);
-    inline int      setBandwidth(int newval)
-    { return this->set_bandwidth(newval); }
-
-    Y_AXIS_enum         get_axis(void);
-
-    inline Y_AXIS_enum  axis(void)
-    { return this->get_axis(); }
-
-    /**
-     * Returns the magnetic heading, regardless of the configured bearing.
-     *
-     * @return a floating point number corresponding to the magnetic heading, regardless of the configured bearing
-     *
-     * On failure, throws an exception or returns Y_MAGNETICHEADING_INVALID.
-     */
-    double              get_magneticHeading(void);
-
-    inline double       magneticHeading(void)
-    { return this->get_magneticHeading(); }
-
-    /**
-     * Retrieves a compass for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the compass is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YCompass.isOnline() to test if the compass is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a compass by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the compass
-     *
-     * @return a YCompass object allowing you to drive the compass.
-     */
-    static YCompass*    FindCompass(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YCompassValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YCompassTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YCompass* Find(string func)
-    { return YCompass::FindCompass(func); }
-
-    /**
-     * Continues the enumeration of compasses started using yFirstCompass().
-     * Caution: You can't make any assumption about the returned compasses order.
-     * If you want to find a specific a compass, use Compass.findCompass()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YCompass object, corresponding to
-     *         a compass currently online, or a NULL pointer
-     *         if there are no more compasses to enumerate.
-     */
-           YCompass        *nextCompass(void);
-    inline YCompass        *next(void)
-    { return this->nextCompass();}
-
-    /**
-     * Starts the enumeration of compasses currently accessible.
-     * Use the method YCompass.nextCompass() to iterate on
-     * next compasses.
-     *
-     * @return a pointer to a YCompass object, corresponding to
-     *         the first compass currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YCompass* FirstCompass(void);
-    inline static YCompass* First(void)
-    { return YCompass::FirstCompass();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YCompass accessors declaration)
-};
-
-//--- (YCompass functions declaration)
-
-/**
- * Retrieves a compass for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the compass is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCompass.isOnline() to test if the compass is
- * indeed online at a given time. In case of ambiguity when looking for
- * a compass by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the compass
- *
- * @return a YCompass object allowing you to drive the compass.
- */
-inline YCompass* yFindCompass(const string& func)
-{ return YCompass::FindCompass(func);}
-/**
- * Starts the enumeration of compasses currently accessible.
- * Use the method YCompass.nextCompass() to iterate on
- * next compasses.
- *
- * @return a pointer to a YCompass object, corresponding to
- *         the first compass currently online, or a NULL pointer
- *         if there are none.
- */
-inline YCompass* yFirstCompass(void)
-{ return YCompass::FirstCompass();}
-
-//--- (end of YCompass functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_current.cpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_current.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindCurrent(), the high-level API for Current functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_current.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "current"
-
-YCurrent::YCurrent(const string& func): YSensor(func)
-//--- (YCurrent initialization)
-    ,_enabled(ENABLED_INVALID)
-    ,_valueCallbackCurrent(NULL)
-    ,_timedReportCallbackCurrent(NULL)
-//--- (end of YCurrent initialization)
-{
-    _className="Current";
-}
-
-YCurrent::~YCurrent()
-{
-//--- (YCurrent cleanup)
-//--- (end of YCurrent cleanup)
-}
-//--- (YCurrent implementation)
-// static attributes
-
-int YCurrent::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-Y_ENABLED_enum YCurrent::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCurrent::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YCurrent::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a current sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the current sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCurrent.isOnline() to test if the current sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a current sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the current sensor
- *
- * @return a YCurrent object allowing you to drive the current sensor.
- */
-YCurrent* YCurrent::FindCurrent(string func)
-{
-    YCurrent* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YCurrent*) YFunction::_FindFromCache("Current", func);
-        if (obj == NULL) {
-            obj = new YCurrent(func);
-            YFunction::_AddToCache("Current", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YCurrent::registerValueCallback(YCurrentValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackCurrent = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YCurrent::_invokeValueCallback(string value)
-{
-    if (_valueCallbackCurrent != NULL) {
-        _valueCallbackCurrent(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YCurrent::registerTimedReportCallback(YCurrentTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackCurrent = callback;
-    return 0;
-}
-
-int YCurrent::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackCurrent != NULL) {
-        _timedReportCallbackCurrent(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YCurrent *YCurrent::nextCurrent(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YCurrent::FindCurrent(hwid);
-}
-
-YCurrent* YCurrent::FirstCurrent(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Current", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YCurrent::FindCurrent(serial+"."+funcId);
-}
-
-//--- (end of YCurrent implementation)
-
-//--- (YCurrent functions)
-//--- (end of YCurrent functions)
--- a/Sources/cpplib/yocto_current.h
+++ /dev/null
@@ -1,258 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_current.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindCurrent(), the high-level API for Current functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_CURRENT_H
-#define YOCTO_CURRENT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YCurrent return codes)
-//--- (end of YCurrent return codes)
-//--- (YCurrent yapiwrapper)
-//--- (end of YCurrent yapiwrapper)
-//--- (YCurrent definitions)
-class YCurrent; // forward declaration
-
-typedef void (*YCurrentValueCallback)(YCurrent *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YCurrentTimedReportCallback)(YCurrent *func, YMeasure measure);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-//--- (end of YCurrent definitions)
-
-//--- (YCurrent declaration)
-/**
- * YCurrent Class: Current function interface
- *
- * The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YCurrent: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YCurrent declaration)
-protected:
-    //--- (YCurrent attributes)
-    // Attributes (function value cache)
-    Y_ENABLED_enum  _enabled;
-    YCurrentValueCallback _valueCallbackCurrent;
-    YCurrentTimedReportCallback _timedReportCallbackCurrent;
-
-    friend YCurrent *yFindCurrent(const string& func);
-    friend YCurrent *yFirstCurrent(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindCurrent factory function to instantiate
-    YCurrent(const string& func);
-    //--- (end of YCurrent attributes)
-
-public:
-    virtual ~YCurrent();
-    //--- (YCurrent accessors declaration)
-
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Retrieves a current sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the current sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YCurrent.isOnline() to test if the current sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a current sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the current sensor
-     *
-     * @return a YCurrent object allowing you to drive the current sensor.
-     */
-    static YCurrent*    FindCurrent(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YCurrentValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YCurrentTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YCurrent* Find(string func)
-    { return YCurrent::FindCurrent(func); }
-
-    /**
-     * Continues the enumeration of current sensors started using yFirstCurrent().
-     * Caution: You can't make any assumption about the returned current sensors order.
-     * If you want to find a specific a current sensor, use Current.findCurrent()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YCurrent object, corresponding to
-     *         a current sensor currently online, or a NULL pointer
-     *         if there are no more current sensors to enumerate.
-     */
-           YCurrent        *nextCurrent(void);
-    inline YCurrent        *next(void)
-    { return this->nextCurrent();}
-
-    /**
-     * Starts the enumeration of current sensors currently accessible.
-     * Use the method YCurrent.nextCurrent() to iterate on
-     * next current sensors.
-     *
-     * @return a pointer to a YCurrent object, corresponding to
-     *         the first current sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YCurrent* FirstCurrent(void);
-    inline static YCurrent* First(void)
-    { return YCurrent::FirstCurrent();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YCurrent accessors declaration)
-};
-
-//--- (YCurrent functions declaration)
-
-/**
- * Retrieves a current sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the current sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCurrent.isOnline() to test if the current sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a current sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the current sensor
- *
- * @return a YCurrent object allowing you to drive the current sensor.
- */
-inline YCurrent* yFindCurrent(const string& func)
-{ return YCurrent::FindCurrent(func);}
-/**
- * Starts the enumeration of current sensors currently accessible.
- * Use the method YCurrent.nextCurrent() to iterate on
- * next current sensors.
- *
- * @return a pointer to a YCurrent object, corresponding to
- *         the first current sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YCurrent* yFirstCurrent(void)
-{ return YCurrent::FirstCurrent();}
-
-//--- (end of YCurrent functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_currentloopoutput.cpp
+++ /dev/null
@@ -1,412 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_currentloopoutput.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindCurrentLoopOutput(), the high-level API for CurrentLoopOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_currentloopoutput.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "currentloopoutput"
-
-YCurrentLoopOutput::YCurrentLoopOutput(const string& func): YFunction(func)
-//--- (YCurrentLoopOutput initialization)
-    ,_current(CURRENT_INVALID)
-    ,_currentTransition(CURRENTTRANSITION_INVALID)
-    ,_currentAtStartUp(CURRENTATSTARTUP_INVALID)
-    ,_loopPower(LOOPPOWER_INVALID)
-    ,_valueCallbackCurrentLoopOutput(NULL)
-//--- (end of YCurrentLoopOutput initialization)
-{
-    _className="CurrentLoopOutput";
-}
-
-YCurrentLoopOutput::~YCurrentLoopOutput()
-{
-//--- (YCurrentLoopOutput cleanup)
-//--- (end of YCurrentLoopOutput cleanup)
-}
-//--- (YCurrentLoopOutput implementation)
-// static attributes
-const double YCurrentLoopOutput::CURRENT_INVALID = YAPI_INVALID_DOUBLE;
-const string YCurrentLoopOutput::CURRENTTRANSITION_INVALID = YAPI_INVALID_STRING;
-const double YCurrentLoopOutput::CURRENTATSTARTUP_INVALID = YAPI_INVALID_DOUBLE;
-
-int YCurrentLoopOutput::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("current")) {
-        _current =  floor(json_val->getDouble("current") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("currentTransition")) {
-        _currentTransition =  json_val->getString("currentTransition");
-    }
-    if(json_val->has("currentAtStartUp")) {
-        _currentAtStartUp =  floor(json_val->getDouble("currentAtStartUp") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("loopPower")) {
-        _loopPower =  (Y_LOOPPOWER_enum)json_val->getInt("loopPower");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the current loop, the valid range is from 3 to 21mA. If the loop is
- * not properly powered, the  target current is not reached and
- * loopPower is set to LOWPWR.
- *
- * @param newval : a floating point number corresponding to the current loop, the valid range is from 3 to 21mA
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCurrentLoopOutput::set_current(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("current", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the loop current set point in mA.
- *
- * @return a floating point number corresponding to the loop current set point in mA
- *
- * On failure, throws an exception or returns Y_CURRENT_INVALID.
- */
-double YCurrentLoopOutput::get_current(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCurrentLoopOutput::CURRENT_INVALID;
-                }
-            }
-        }
-        res = _current;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YCurrentLoopOutput::get_currentTransition(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCurrentLoopOutput::CURRENTTRANSITION_INVALID;
-                }
-            }
-        }
-        res = _currentTransition;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YCurrentLoopOutput::set_currentTransition(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("currentTransition", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the loop current at device start up. Remember to call the matching
- * module saveToFlash() method, otherwise this call has no effect.
- *
- * @param newval : a floating point number corresponding to the loop current at device start up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YCurrentLoopOutput::set_currentAtStartUp(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentAtStartUp", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current in the loop at device startup, in mA.
- *
- * @return a floating point number corresponding to the current in the loop at device startup, in mA
- *
- * On failure, throws an exception or returns Y_CURRENTATSTARTUP_INVALID.
- */
-double YCurrentLoopOutput::get_currentAtStartUp(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCurrentLoopOutput::CURRENTATSTARTUP_INVALID;
-                }
-            }
-        }
-        res = _currentAtStartUp;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the loop powerstate.  POWEROK: the loop
- * is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not
- * powered enough to maintain the current required (insufficient voltage).
- *
- * @return a value among Y_LOOPPOWER_NOPWR, Y_LOOPPOWER_LOWPWR and Y_LOOPPOWER_POWEROK corresponding
- * to the loop powerstate
- *
- * On failure, throws an exception or returns Y_LOOPPOWER_INVALID.
- */
-Y_LOOPPOWER_enum YCurrentLoopOutput::get_loopPower(void)
-{
-    Y_LOOPPOWER_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YCurrentLoopOutput::LOOPPOWER_INVALID;
-                }
-            }
-        }
-        res = _loopPower;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a 4-20mA output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the 4-20mA output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCurrentLoopOutput.isOnline() to test if the 4-20mA output is
- * indeed online at a given time. In case of ambiguity when looking for
- * a 4-20mA output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the 4-20mA output
- *
- * @return a YCurrentLoopOutput object allowing you to drive the 4-20mA output.
- */
-YCurrentLoopOutput* YCurrentLoopOutput::FindCurrentLoopOutput(string func)
-{
-    YCurrentLoopOutput* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YCurrentLoopOutput*) YFunction::_FindFromCache("CurrentLoopOutput", func);
-        if (obj == NULL) {
-            obj = new YCurrentLoopOutput(func);
-            YFunction::_AddToCache("CurrentLoopOutput", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YCurrentLoopOutput::registerValueCallback(YCurrentLoopOutputValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackCurrentLoopOutput = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YCurrentLoopOutput::_invokeValueCallback(string value)
-{
-    if (_valueCallbackCurrentLoopOutput != NULL) {
-        _valueCallbackCurrentLoopOutput(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Performs a smooth transition of current flowing in the loop. Any current explicit
- * change cancels any ongoing transition process.
- *
- * @param mA_target   : new current value at the end of the transition
- *         (floating-point number, representing the end current in mA)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- */
-int YCurrentLoopOutput::currentMove(double mA_target,int ms_duration)
-{
-    string newval;
-    if (mA_target < 3.0) {
-        mA_target  = 3.0;
-    }
-    if (mA_target > 21.0) {
-        mA_target = 21.0;
-    }
-    newval = YapiWrapper::ysprintf("%d:%d", (int) floor(mA_target*65536+0.5),ms_duration);
-
-    return this->set_currentTransition(newval);
-}
-
-YCurrentLoopOutput *YCurrentLoopOutput::nextCurrentLoopOutput(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YCurrentLoopOutput::FindCurrentLoopOutput(hwid);
-}
-
-YCurrentLoopOutput* YCurrentLoopOutput::FirstCurrentLoopOutput(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("CurrentLoopOutput", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YCurrentLoopOutput::FindCurrentLoopOutput(serial+"."+funcId);
-}
-
-//--- (end of YCurrentLoopOutput implementation)
-
-//--- (YCurrentLoopOutput functions)
-//--- (end of YCurrentLoopOutput functions)
--- a/Sources/cpplib/yocto_currentloopoutput.h
+++ /dev/null
@@ -1,329 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_currentloopoutput.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindCurrentLoopOutput(), the high-level API for CurrentLoopOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_CURRENTLOOPOUTPUT_H
-#define YOCTO_CURRENTLOOPOUTPUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YCurrentLoopOutput return codes)
-//--- (end of YCurrentLoopOutput return codes)
-//--- (YCurrentLoopOutput yapiwrapper)
-//--- (end of YCurrentLoopOutput yapiwrapper)
-//--- (YCurrentLoopOutput definitions)
-class YCurrentLoopOutput; // forward declaration
-
-typedef void (*YCurrentLoopOutputValueCallback)(YCurrentLoopOutput *func, const string& functionValue);
-#ifndef _Y_LOOPPOWER_ENUM
-#define _Y_LOOPPOWER_ENUM
-typedef enum {
-    Y_LOOPPOWER_NOPWR = 0,
-    Y_LOOPPOWER_LOWPWR = 1,
-    Y_LOOPPOWER_POWEROK = 2,
-    Y_LOOPPOWER_INVALID = -1,
-} Y_LOOPPOWER_enum;
-#endif
-#define Y_CURRENT_INVALID               (YAPI_INVALID_DOUBLE)
-#define Y_CURRENTTRANSITION_INVALID     (YAPI_INVALID_STRING)
-#define Y_CURRENTATSTARTUP_INVALID      (YAPI_INVALID_DOUBLE)
-//--- (end of YCurrentLoopOutput definitions)
-
-//--- (YCurrentLoopOutput declaration)
-/**
- * YCurrentLoopOutput Class: CurrentLoopOutput function interface
- *
- * The Yoctopuce application programming interface allows you to change the value of the 4-20mA
- * output as well as to know the current loop state.
- */
-class YOCTO_CLASS_EXPORT YCurrentLoopOutput: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YCurrentLoopOutput declaration)
-protected:
-    //--- (YCurrentLoopOutput attributes)
-    // Attributes (function value cache)
-    double          _current;
-    string          _currentTransition;
-    double          _currentAtStartUp;
-    Y_LOOPPOWER_enum _loopPower;
-    YCurrentLoopOutputValueCallback _valueCallbackCurrentLoopOutput;
-
-    friend YCurrentLoopOutput *yFindCurrentLoopOutput(const string& func);
-    friend YCurrentLoopOutput *yFirstCurrentLoopOutput(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindCurrentLoopOutput factory function to instantiate
-    YCurrentLoopOutput(const string& func);
-    //--- (end of YCurrentLoopOutput attributes)
-
-public:
-    virtual ~YCurrentLoopOutput();
-    //--- (YCurrentLoopOutput accessors declaration)
-
-    static const double CURRENT_INVALID;
-    static const string CURRENTTRANSITION_INVALID;
-    static const double CURRENTATSTARTUP_INVALID;
-    static const Y_LOOPPOWER_enum LOOPPOWER_NOPWR = Y_LOOPPOWER_NOPWR;
-    static const Y_LOOPPOWER_enum LOOPPOWER_LOWPWR = Y_LOOPPOWER_LOWPWR;
-    static const Y_LOOPPOWER_enum LOOPPOWER_POWEROK = Y_LOOPPOWER_POWEROK;
-    static const Y_LOOPPOWER_enum LOOPPOWER_INVALID = Y_LOOPPOWER_INVALID;
-
-    /**
-     * Changes the current loop, the valid range is from 3 to 21mA. If the loop is
-     * not properly powered, the  target current is not reached and
-     * loopPower is set to LOWPWR.
-     *
-     * @param newval : a floating point number corresponding to the current loop, the valid range is from 3 to 21mA
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_current(double newval);
-    inline int      setCurrent(double newval)
-    { return this->set_current(newval); }
-
-    /**
-     * Returns the loop current set point in mA.
-     *
-     * @return a floating point number corresponding to the loop current set point in mA
-     *
-     * On failure, throws an exception or returns Y_CURRENT_INVALID.
-     */
-    double              get_current(void);
-
-    inline double       current(void)
-    { return this->get_current(); }
-
-    string              get_currentTransition(void);
-
-    inline string       currentTransition(void)
-    { return this->get_currentTransition(); }
-
-    int             set_currentTransition(const string& newval);
-    inline int      setCurrentTransition(const string& newval)
-    { return this->set_currentTransition(newval); }
-
-    /**
-     * Changes the loop current at device start up. Remember to call the matching
-     * module saveToFlash() method, otherwise this call has no effect.
-     *
-     * @param newval : a floating point number corresponding to the loop current at device start up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentAtStartUp(double newval);
-    inline int      setCurrentAtStartUp(double newval)
-    { return this->set_currentAtStartUp(newval); }
-
-    /**
-     * Returns the current in the loop at device startup, in mA.
-     *
-     * @return a floating point number corresponding to the current in the loop at device startup, in mA
-     *
-     * On failure, throws an exception or returns Y_CURRENTATSTARTUP_INVALID.
-     */
-    double              get_currentAtStartUp(void);
-
-    inline double       currentAtStartUp(void)
-    { return this->get_currentAtStartUp(); }
-
-    /**
-     * Returns the loop powerstate.  POWEROK: the loop
-     * is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not
-     * powered enough to maintain the current required (insufficient voltage).
-     *
-     * @return a value among Y_LOOPPOWER_NOPWR, Y_LOOPPOWER_LOWPWR and Y_LOOPPOWER_POWEROK corresponding
-     * to the loop powerstate
-     *
-     * On failure, throws an exception or returns Y_LOOPPOWER_INVALID.
-     */
-    Y_LOOPPOWER_enum    get_loopPower(void);
-
-    inline Y_LOOPPOWER_enum loopPower(void)
-    { return this->get_loopPower(); }
-
-    /**
-     * Retrieves a 4-20mA output for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the 4-20mA output is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YCurrentLoopOutput.isOnline() to test if the 4-20mA output is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a 4-20mA output by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the 4-20mA output
-     *
-     * @return a YCurrentLoopOutput object allowing you to drive the 4-20mA output.
-     */
-    static YCurrentLoopOutput* FindCurrentLoopOutput(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YCurrentLoopOutputValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Performs a smooth transition of current flowing in the loop. Any current explicit
-     * change cancels any ongoing transition process.
-     *
-     * @param mA_target   : new current value at the end of the transition
-     *         (floating-point number, representing the end current in mA)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     */
-    virtual int         currentMove(double mA_target,int ms_duration);
-
-
-    inline static YCurrentLoopOutput* Find(string func)
-    { return YCurrentLoopOutput::FindCurrentLoopOutput(func); }
-
-    /**
-     * Continues the enumeration of 4-20mA outputs started using yFirstCurrentLoopOutput().
-     * Caution: You can't make any assumption about the returned 4-20mA outputs order.
-     * If you want to find a specific a 4-20mA output, use CurrentLoopOutput.findCurrentLoopOutput()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YCurrentLoopOutput object, corresponding to
-     *         a 4-20mA output currently online, or a NULL pointer
-     *         if there are no more 4-20mA outputs to enumerate.
-     */
-           YCurrentLoopOutput *nextCurrentLoopOutput(void);
-    inline YCurrentLoopOutput *next(void)
-    { return this->nextCurrentLoopOutput();}
-
-    /**
-     * Starts the enumeration of 4-20mA outputs currently accessible.
-     * Use the method YCurrentLoopOutput.nextCurrentLoopOutput() to iterate on
-     * next 4-20mA outputs.
-     *
-     * @return a pointer to a YCurrentLoopOutput object, corresponding to
-     *         the first 4-20mA output currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YCurrentLoopOutput* FirstCurrentLoopOutput(void);
-    inline static YCurrentLoopOutput* First(void)
-    { return YCurrentLoopOutput::FirstCurrentLoopOutput();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YCurrentLoopOutput accessors declaration)
-};
-
-//--- (YCurrentLoopOutput functions declaration)
-
-/**
- * Retrieves a 4-20mA output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the 4-20mA output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YCurrentLoopOutput.isOnline() to test if the 4-20mA output is
- * indeed online at a given time. In case of ambiguity when looking for
- * a 4-20mA output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the 4-20mA output
- *
- * @return a YCurrentLoopOutput object allowing you to drive the 4-20mA output.
- */
-inline YCurrentLoopOutput* yFindCurrentLoopOutput(const string& func)
-{ return YCurrentLoopOutput::FindCurrentLoopOutput(func);}
-/**
- * Starts the enumeration of 4-20mA outputs currently accessible.
- * Use the method YCurrentLoopOutput.nextCurrentLoopOutput() to iterate on
- * next 4-20mA outputs.
- *
- * @return a pointer to a YCurrentLoopOutput object, corresponding to
- *         the first 4-20mA output currently online, or a NULL pointer
- *         if there are none.
- */
-inline YCurrentLoopOutput* yFirstCurrentLoopOutput(void)
-{ return YCurrentLoopOutput::FirstCurrentLoopOutput();}
-
-//--- (end of YCurrentLoopOutput functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_daisychain.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_daisychain.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindDaisyChain(), the high-level API for DaisyChain functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_daisychain.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "daisychain"
-
-YDaisyChain::YDaisyChain(const string& func): YFunction(func)
-//--- (YDaisyChain initialization)
-    ,_daisyState(DAISYSTATE_INVALID)
-    ,_childCount(CHILDCOUNT_INVALID)
-    ,_requiredChildCount(REQUIREDCHILDCOUNT_INVALID)
-    ,_valueCallbackDaisyChain(NULL)
-//--- (end of YDaisyChain initialization)
-{
-    _className="DaisyChain";
-}
-
-YDaisyChain::~YDaisyChain()
-{
-//--- (YDaisyChain cleanup)
-//--- (end of YDaisyChain cleanup)
-}
-//--- (YDaisyChain implementation)
-// static attributes
-
-int YDaisyChain::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("daisyState")) {
-        _daisyState =  (Y_DAISYSTATE_enum)json_val->getInt("daisyState");
-    }
-    if(json_val->has("childCount")) {
-        _childCount =  json_val->getInt("childCount");
-    }
-    if(json_val->has("requiredChildCount")) {
-        _requiredChildCount =  json_val->getInt("requiredChildCount");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the state of the daisy-link between modules.
- *
- * @return a value among Y_DAISYSTATE_READY, Y_DAISYSTATE_IS_CHILD, Y_DAISYSTATE_FIRMWARE_MISMATCH,
- * Y_DAISYSTATE_CHILD_MISSING and Y_DAISYSTATE_CHILD_LOST corresponding to the state of the daisy-link
- * between modules
- *
- * On failure, throws an exception or returns Y_DAISYSTATE_INVALID.
- */
-Y_DAISYSTATE_enum YDaisyChain::get_daisyState(void)
-{
-    Y_DAISYSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDaisyChain::DAISYSTATE_INVALID;
-                }
-            }
-        }
-        res = _daisyState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of child nodes currently detected.
- *
- * @return an integer corresponding to the number of child nodes currently detected
- *
- * On failure, throws an exception or returns Y_CHILDCOUNT_INVALID.
- */
-int YDaisyChain::get_childCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDaisyChain::CHILDCOUNT_INVALID;
-                }
-            }
-        }
-        res = _childCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of child nodes expected in normal conditions.
- *
- * @return an integer corresponding to the number of child nodes expected in normal conditions
- *
- * On failure, throws an exception or returns Y_REQUIREDCHILDCOUNT_INVALID.
- */
-int YDaisyChain::get_requiredChildCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDaisyChain::REQUIREDCHILDCOUNT_INVALID;
-                }
-            }
-        }
-        res = _requiredChildCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of child nodes expected in normal conditions.
- * If the value is zero, no check is performed. If it is non-zero, the number
- * child nodes is checked on startup and the status will change to error if
- * the count does not match.
- *
- * @param newval : an integer corresponding to the number of child nodes expected in normal conditions
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDaisyChain::set_requiredChildCount(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("requiredChildCount", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a module chain for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the module chain is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDaisyChain.isOnline() to test if the module chain is
- * indeed online at a given time. In case of ambiguity when looking for
- * a module chain by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the module chain
- *
- * @return a YDaisyChain object allowing you to drive the module chain.
- */
-YDaisyChain* YDaisyChain::FindDaisyChain(string func)
-{
-    YDaisyChain* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YDaisyChain*) YFunction::_FindFromCache("DaisyChain", func);
-        if (obj == NULL) {
-            obj = new YDaisyChain(func);
-            YFunction::_AddToCache("DaisyChain", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YDaisyChain::registerValueCallback(YDaisyChainValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackDaisyChain = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YDaisyChain::_invokeValueCallback(string value)
-{
-    if (_valueCallbackDaisyChain != NULL) {
-        _valueCallbackDaisyChain(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YDaisyChain *YDaisyChain::nextDaisyChain(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YDaisyChain::FindDaisyChain(hwid);
-}
-
-YDaisyChain* YDaisyChain::FirstDaisyChain(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("DaisyChain", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YDaisyChain::FindDaisyChain(serial+"."+funcId);
-}
-
-//--- (end of YDaisyChain implementation)
-
-//--- (YDaisyChain functions)
-//--- (end of YDaisyChain functions)
--- a/Sources/cpplib/yocto_daisychain.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_daisychain.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindDaisyChain(), the high-level API for DaisyChain functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_DAISYCHAIN_H
-#define YOCTO_DAISYCHAIN_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YDaisyChain return codes)
-//--- (end of YDaisyChain return codes)
-//--- (YDaisyChain yapiwrapper)
-//--- (end of YDaisyChain yapiwrapper)
-//--- (YDaisyChain definitions)
-class YDaisyChain; // forward declaration
-
-typedef void (*YDaisyChainValueCallback)(YDaisyChain *func, const string& functionValue);
-#ifndef _Y_DAISYSTATE_ENUM
-#define _Y_DAISYSTATE_ENUM
-typedef enum {
-    Y_DAISYSTATE_READY = 0,
-    Y_DAISYSTATE_IS_CHILD = 1,
-    Y_DAISYSTATE_FIRMWARE_MISMATCH = 2,
-    Y_DAISYSTATE_CHILD_MISSING = 3,
-    Y_DAISYSTATE_CHILD_LOST = 4,
-    Y_DAISYSTATE_INVALID = -1,
-} Y_DAISYSTATE_enum;
-#endif
-#define Y_CHILDCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_REQUIREDCHILDCOUNT_INVALID    (YAPI_INVALID_UINT)
-//--- (end of YDaisyChain definitions)
-
-//--- (YDaisyChain declaration)
-/**
- * YDaisyChain Class: DaisyChain function interface
- *
- * The YDaisyChain interface can be used to verify that devices that
- * are daisy-chained directly from device to device, without a hub,
- * are detected properly.
- */
-class YOCTO_CLASS_EXPORT YDaisyChain: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YDaisyChain declaration)
-protected:
-    //--- (YDaisyChain attributes)
-    // Attributes (function value cache)
-    Y_DAISYSTATE_enum _daisyState;
-    int             _childCount;
-    int             _requiredChildCount;
-    YDaisyChainValueCallback _valueCallbackDaisyChain;
-
-    friend YDaisyChain *yFindDaisyChain(const string& func);
-    friend YDaisyChain *yFirstDaisyChain(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindDaisyChain factory function to instantiate
-    YDaisyChain(const string& func);
-    //--- (end of YDaisyChain attributes)
-
-public:
-    virtual ~YDaisyChain();
-    //--- (YDaisyChain accessors declaration)
-
-    static const Y_DAISYSTATE_enum DAISYSTATE_READY = Y_DAISYSTATE_READY;
-    static const Y_DAISYSTATE_enum DAISYSTATE_IS_CHILD = Y_DAISYSTATE_IS_CHILD;
-    static const Y_DAISYSTATE_enum DAISYSTATE_FIRMWARE_MISMATCH = Y_DAISYSTATE_FIRMWARE_MISMATCH;
-    static const Y_DAISYSTATE_enum DAISYSTATE_CHILD_MISSING = Y_DAISYSTATE_CHILD_MISSING;
-    static const Y_DAISYSTATE_enum DAISYSTATE_CHILD_LOST = Y_DAISYSTATE_CHILD_LOST;
-    static const Y_DAISYSTATE_enum DAISYSTATE_INVALID = Y_DAISYSTATE_INVALID;
-    static const int CHILDCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int REQUIREDCHILDCOUNT_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the state of the daisy-link between modules.
-     *
-     * @return a value among Y_DAISYSTATE_READY, Y_DAISYSTATE_IS_CHILD, Y_DAISYSTATE_FIRMWARE_MISMATCH,
-     * Y_DAISYSTATE_CHILD_MISSING and Y_DAISYSTATE_CHILD_LOST corresponding to the state of the daisy-link
-     * between modules
-     *
-     * On failure, throws an exception or returns Y_DAISYSTATE_INVALID.
-     */
-    Y_DAISYSTATE_enum   get_daisyState(void);
-
-    inline Y_DAISYSTATE_enum daisyState(void)
-    { return this->get_daisyState(); }
-
-    /**
-     * Returns the number of child nodes currently detected.
-     *
-     * @return an integer corresponding to the number of child nodes currently detected
-     *
-     * On failure, throws an exception or returns Y_CHILDCOUNT_INVALID.
-     */
-    int                 get_childCount(void);
-
-    inline int          childCount(void)
-    { return this->get_childCount(); }
-
-    /**
-     * Returns the number of child nodes expected in normal conditions.
-     *
-     * @return an integer corresponding to the number of child nodes expected in normal conditions
-     *
-     * On failure, throws an exception or returns Y_REQUIREDCHILDCOUNT_INVALID.
-     */
-    int                 get_requiredChildCount(void);
-
-    inline int          requiredChildCount(void)
-    { return this->get_requiredChildCount(); }
-
-    /**
-     * Changes the number of child nodes expected in normal conditions.
-     * If the value is zero, no check is performed. If it is non-zero, the number
-     * child nodes is checked on startup and the status will change to error if
-     * the count does not match.
-     *
-     * @param newval : an integer corresponding to the number of child nodes expected in normal conditions
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_requiredChildCount(int newval);
-    inline int      setRequiredChildCount(int newval)
-    { return this->set_requiredChildCount(newval); }
-
-    /**
-     * Retrieves a module chain for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the module chain is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YDaisyChain.isOnline() to test if the module chain is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a module chain by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the module chain
-     *
-     * @return a YDaisyChain object allowing you to drive the module chain.
-     */
-    static YDaisyChain* FindDaisyChain(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YDaisyChainValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YDaisyChain* Find(string func)
-    { return YDaisyChain::FindDaisyChain(func); }
-
-    /**
-     * Continues the enumeration of module chains started using yFirstDaisyChain().
-     * Caution: You can't make any assumption about the returned module chains order.
-     * If you want to find a specific a module chain, use DaisyChain.findDaisyChain()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YDaisyChain object, corresponding to
-     *         a module chain currently online, or a NULL pointer
-     *         if there are no more module chains to enumerate.
-     */
-           YDaisyChain     *nextDaisyChain(void);
-    inline YDaisyChain     *next(void)
-    { return this->nextDaisyChain();}
-
-    /**
-     * Starts the enumeration of module chains currently accessible.
-     * Use the method YDaisyChain.nextDaisyChain() to iterate on
-     * next module chains.
-     *
-     * @return a pointer to a YDaisyChain object, corresponding to
-     *         the first module chain currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YDaisyChain* FirstDaisyChain(void);
-    inline static YDaisyChain* First(void)
-    { return YDaisyChain::FirstDaisyChain();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YDaisyChain accessors declaration)
-};
-
-//--- (YDaisyChain functions declaration)
-
-/**
- * Retrieves a module chain for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the module chain is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDaisyChain.isOnline() to test if the module chain is
- * indeed online at a given time. In case of ambiguity when looking for
- * a module chain by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the module chain
- *
- * @return a YDaisyChain object allowing you to drive the module chain.
- */
-inline YDaisyChain* yFindDaisyChain(const string& func)
-{ return YDaisyChain::FindDaisyChain(func);}
-/**
- * Starts the enumeration of module chains currently accessible.
- * Use the method YDaisyChain.nextDaisyChain() to iterate on
- * next module chains.
- *
- * @return a pointer to a YDaisyChain object, corresponding to
- *         the first module chain currently online, or a NULL pointer
- *         if there are none.
- */
-inline YDaisyChain* yFirstDaisyChain(void)
-{ return YDaisyChain::FirstDaisyChain();}
-
-//--- (end of YDaisyChain functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_datalogger.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_datalogger.cpp 28133 2017-07-25 10:40:37Z seb $
- *
- * Implements yFindDataLogger(), the high-level API for DataLogger functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_datalogger.h"
-#define  __FILE_ID__  "datalogger"
-
-// DataLogger class has been moved to yocto_api.h
-
-#ifdef WINDOWS_API
-// dummy function to prevent compilation warnings
-void getRidOfLNK4221(){}
-#endif
--- a/Sources/cpplib/yocto_datalogger.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_datalogger.h 28128 2017-07-25 08:45:33Z seb $
- *
- * Declares yFindDataLogger(), the high-level API for DataLogger functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_DATALOGGER_H
-#define YOCTO_DATALOGGER_H
-
-#include "yocto_api.h"
-// DataLogger class definition has been moved to yocto_api.h
-
-#endif
--- a/Sources/cpplib/yocto_digitalio.cpp
+++ /dev/null
@@ -1,841 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_digitalio.cpp 33722 2018-12-14 15:04:43Z seb $
- *
- *  Implements yFindDigitalIO(), the high-level API for DigitalIO functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_digitalio.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "digitalio"
-
-YDigitalIO::YDigitalIO(const string& func): YFunction(func)
-//--- (YDigitalIO initialization)
-    ,_portState(PORTSTATE_INVALID)
-    ,_portDirection(PORTDIRECTION_INVALID)
-    ,_portOpenDrain(PORTOPENDRAIN_INVALID)
-    ,_portPolarity(PORTPOLARITY_INVALID)
-    ,_portDiags(PORTDIAGS_INVALID)
-    ,_portSize(PORTSIZE_INVALID)
-    ,_outputVoltage(OUTPUTVOLTAGE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackDigitalIO(NULL)
-//--- (end of YDigitalIO initialization)
-{
-    _className="DigitalIO";
-}
-
-YDigitalIO::~YDigitalIO()
-{
-//--- (YDigitalIO cleanup)
-//--- (end of YDigitalIO cleanup)
-}
-//--- (YDigitalIO implementation)
-// static attributes
-const string YDigitalIO::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YDigitalIO::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("portState")) {
-        _portState =  json_val->getInt("portState");
-    }
-    if(json_val->has("portDirection")) {
-        _portDirection =  json_val->getInt("portDirection");
-    }
-    if(json_val->has("portOpenDrain")) {
-        _portOpenDrain =  json_val->getInt("portOpenDrain");
-    }
-    if(json_val->has("portPolarity")) {
-        _portPolarity =  json_val->getInt("portPolarity");
-    }
-    if(json_val->has("portDiags")) {
-        _portDiags =  json_val->getInt("portDiags");
-    }
-    if(json_val->has("portSize")) {
-        _portSize =  json_val->getInt("portSize");
-    }
-    if(json_val->has("outputVoltage")) {
-        _outputVoltage =  (Y_OUTPUTVOLTAGE_enum)json_val->getInt("outputVoltage");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the digital IO port state as an integer with each bit
- * representing a channel
- * value 0 = 0b00000000 -> all channels are OFF
- * value 1 = 0b00000001 -> channel #0 is ON
- * value 2 = 0b00000010 -> channel #1 is ON
- * value 3 = 0b00000011 -> channels #0 and #1 are ON
- * value 4 = 0b00000100 -> channel #2 is ON
- * and so on...
- *
- * @return an integer corresponding to the digital IO port state as an integer with each bit
- *         representing a channel
- *         value 0 = 0b00000000 -> all channels are OFF
- *         value 1 = 0b00000001 -> channel #0 is ON
- *         value 2 = 0b00000010 -> channel #1 is ON
- *         value 3 = 0b00000011 -> channels #0 and #1 are ON
- *         value 4 = 0b00000100 -> channel #2 is ON
- *         and so on.
- *
- * On failure, throws an exception or returns Y_PORTSTATE_INVALID.
- */
-int YDigitalIO::get_portState(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTSTATE_INVALID;
-                }
-            }
-        }
-        res = _portState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of all digital IO port's channels at once,
- * the parameter is an integer with  each bit representing a channel.
- * Bit 0 matches channel #0. So:
- * To set all channels to  0 -> 0b00000000 -> parameter = 0
- * To set channel #0 to 1 -> 0b00000001 -> parameter =  1
- * To set channel #1 to  1 -> 0b00000010 -> parameter = 2
- * To set channel #0 and #1 -> 0b00000011 -> parameter =  3
- * To set channel #2 to 1 -> 0b00000100 -> parameter =  4
- * an so on....
- * Only channels configured as output, thanks to portDirection,
- * are affected.
- *
- * @param newval : an integer corresponding to the state of all digital IO port's channels at once,
- *         the parameter is an integer with  each bit representing a channel
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_portState(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("portState", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.
- *
- * @return an integer corresponding to the IO direction of all bits (i.e
- *
- * On failure, throws an exception or returns Y_PORTDIRECTION_INVALID.
- */
-int YDigitalIO::get_portDirection(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTDIRECTION_INVALID;
-                }
-            }
-        }
-        res = _portDirection;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.
- * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
- *
- * @param newval : an integer corresponding to the IO direction of all bits (i.e
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_portDirection(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("portDirection", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the electrical interface for each bit of the port. For each bit set to 0  the matching I/O
- * works in the regular,
- * intuitive way, for each bit set to 1, the I/O works in reverse mode.
- *
- * @return an integer corresponding to the electrical interface for each bit of the port
- *
- * On failure, throws an exception or returns Y_PORTOPENDRAIN_INVALID.
- */
-int YDigitalIO::get_portOpenDrain(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTOPENDRAIN_INVALID;
-                }
-            }
-        }
-        res = _portOpenDrain;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes
- * it an open-drain (open-collector) input/output. Remember to call the
- * saveToFlash() method  to make sure the setting is kept after a reboot.
- *
- * @param newval : an integer corresponding to the electrical interface for each bit of the port
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_portOpenDrain(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("portOpenDrain", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the polarity of all the bits of the port.  For each bit set to 0, the matching I/O works the regular,
- * intuitive way; for each bit set to 1, the I/O works in reverse mode.
- *
- * @return an integer corresponding to the polarity of all the bits of the port
- *
- * On failure, throws an exception or returns Y_PORTPOLARITY_INVALID.
- */
-int YDigitalIO::get_portPolarity(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTPOLARITY_INVALID;
-                }
-            }
-        }
-        res = _portPolarity;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular,
- * intuitive way; for each bit set to 1, the I/O works in reverse mode.
- * Remember to call the saveToFlash() method  to make sure the setting will be kept after a reboot.
- *
- * @param newval : an integer corresponding to the polarity of all the bits of the port: For each bit
- * set to 0, the matching I/O works the regular,
- *         intuitive way; for each bit set to 1, the I/O works in reverse mode
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_portPolarity(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("portPolarity", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only). Bit 0 indicates a shortcut on
- * output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent).
- * During normal use, all diagnostic bits should stay clear.
- *
- * @return an integer corresponding to the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only)
- *
- * On failure, throws an exception or returns Y_PORTDIAGS_INVALID.
- */
-int YDigitalIO::get_portDiags(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTDIAGS_INVALID;
-                }
-            }
-        }
-        res = _portDiags;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of bits (i.e. channels)implemented in the I/O port.
- *
- * @return an integer corresponding to the number of bits (i.e
- *
- * On failure, throws an exception or returns Y_PORTSIZE_INVALID.
- */
-int YDigitalIO::get_portSize(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::PORTSIZE_INVALID;
-                }
-            }
-        }
-        res = _portSize;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the voltage source used to drive output bits.
- *
- * @return a value among Y_OUTPUTVOLTAGE_USB_5V, Y_OUTPUTVOLTAGE_USB_3V and Y_OUTPUTVOLTAGE_EXT_V
- * corresponding to the voltage source used to drive output bits
- *
- * On failure, throws an exception or returns Y_OUTPUTVOLTAGE_INVALID.
- */
-Y_OUTPUTVOLTAGE_enum YDigitalIO::get_outputVoltage(void)
-{
-    Y_OUTPUTVOLTAGE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::OUTPUTVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _outputVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage source used to drive output bits.
- * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
- *
- * @param newval : a value among Y_OUTPUTVOLTAGE_USB_5V, Y_OUTPUTVOLTAGE_USB_3V and
- * Y_OUTPUTVOLTAGE_EXT_V corresponding to the voltage source used to drive output bits
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_outputVoltage(Y_OUTPUTVOLTAGE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("outputVoltage", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YDigitalIO::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDigitalIO::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YDigitalIO::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a digital IO port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the digital IO port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDigitalIO.isOnline() to test if the digital IO port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a digital IO port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the digital IO port
- *
- * @return a YDigitalIO object allowing you to drive the digital IO port.
- */
-YDigitalIO* YDigitalIO::FindDigitalIO(string func)
-{
-    YDigitalIO* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YDigitalIO*) YFunction::_FindFromCache("DigitalIO", func);
-        if (obj == NULL) {
-            obj = new YDigitalIO(func);
-            YFunction::_AddToCache("DigitalIO", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YDigitalIO::registerValueCallback(YDigitalIOValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackDigitalIO = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YDigitalIO::_invokeValueCallback(string value)
-{
-    if (_valueCallbackDigitalIO != NULL) {
-        _valueCallbackDigitalIO(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Sets a single bit (i.e. channel) of the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0
- * @param bitstate : the state of the bit (1 or 0)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_bitState(int bitno,int bitstate)
-{
-    if (!(bitstate >= 0)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid bit state");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(bitstate <= 1)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid bit state");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return this->set_command(YapiWrapper::ysprintf("%c%d",82+bitstate,bitno));
-}
-
-/**
- * Returns the state of a single bit (i.e. channel)  of the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0
- *
- * @return the bit state (0 or 1)
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::get_bitState(int bitno)
-{
-    int portVal = 0;
-    portVal = this->get_portState();
-    return ((((portVal) >> (bitno))) & (1));
-}
-
-/**
- * Reverts a single bit (i.e. channel) of the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::toggle_bitState(int bitno)
-{
-    return this->set_command(YapiWrapper::ysprintf("T%d",bitno));
-}
-
-/**
- * Changes  the direction of a single bit (i.e. channel) from the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0
- * @param bitdirection : direction to set, 0 makes the bit an input, 1 makes it an output.
- *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_bitDirection(int bitno,int bitdirection)
-{
-    if (!(bitdirection >= 0)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid direction");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(bitdirection <= 1)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid direction");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return this->set_command(YapiWrapper::ysprintf("%c%d",73+6*bitdirection,bitno));
-}
-
-/**
- * Returns the direction of a single bit (i.e. channel) from the I/O port (0 means the bit is an
- * input, 1  an output).
- *
- * @param bitno : the bit number; lowest bit has index 0
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::get_bitDirection(int bitno)
-{
-    int portDir = 0;
-    portDir = this->get_portDirection();
-    return ((((portDir) >> (bitno))) & (1));
-}
-
-/**
- * Changes the polarity of a single bit from the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0.
- * @param bitpolarity : polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O  works
- * in reverse mode.
- *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_bitPolarity(int bitno,int bitpolarity)
-{
-    if (!(bitpolarity >= 0)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid bit polarity");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(bitpolarity <= 1)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid bit polarity");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return this->set_command(YapiWrapper::ysprintf("%c%d",110+4*bitpolarity,bitno));
-}
-
-/**
- * Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1
- * means the I/O  works in reverse mode).
- *
- * @param bitno : the bit number; lowest bit has index 0
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::get_bitPolarity(int bitno)
-{
-    int portPol = 0;
-    portPol = this->get_portPolarity();
-    return ((((portPol) >> (bitno))) & (1));
-}
-
-/**
- * Changes  the electrical interface of a single bit from the I/O port.
- *
- * @param bitno : the bit number; lowest bit has index 0
- * @param opendrain : 0 makes a bit a regular input/output, 1 makes
- *         it an open-drain (open-collector) input/output. Remember to call the
- *         saveToFlash() method to make sure the setting is kept after a reboot.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::set_bitOpenDrain(int bitno,int opendrain)
-{
-    if (!(opendrain >= 0)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid state");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(opendrain <= 1)) {
-        _throw(YAPI_INVALID_ARGUMENT,"invalid state");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    return this->set_command(YapiWrapper::ysprintf("%c%d",100-32*opendrain,bitno));
-}
-
-/**
- * Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an
- * input, 1  an output).
- *
- * @param bitno : the bit number; lowest bit has index 0
- *
- * @return   0 means the a bit is a regular input/output, 1 means the bit is an open-drain
- *         (open-collector) input/output.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::get_bitOpenDrain(int bitno)
-{
-    int portOpenDrain = 0;
-    portOpenDrain = this->get_portOpenDrain();
-    return ((((portOpenDrain) >> (bitno))) & (1));
-}
-
-/**
- * Triggers a pulse on a single bit for a specified duration. The specified bit
- * will be turned to 1, and then back to 0 after the given duration.
- *
- * @param bitno : the bit number; lowest bit has index 0
- * @param ms_duration : desired pulse duration in milliseconds. Be aware that the device time
- *         resolution is not guaranteed up to the millisecond.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::pulse(int bitno,int ms_duration)
-{
-    return this->set_command(YapiWrapper::ysprintf("Z%d,0,%d", bitno,ms_duration));
-}
-
-/**
- * Schedules a pulse on a single bit for a specified duration. The specified bit
- * will be turned to 1, and then back to 0 after the given duration.
- *
- * @param bitno : the bit number; lowest bit has index 0
- * @param ms_delay : waiting time before the pulse, in milliseconds
- * @param ms_duration : desired pulse duration in milliseconds. Be aware that the device time
- *         resolution is not guaranteed up to the millisecond.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDigitalIO::delayedPulse(int bitno,int ms_delay,int ms_duration)
-{
-    return this->set_command(YapiWrapper::ysprintf("Z%d,%d,%d",bitno,ms_delay,ms_duration));
-}
-
-YDigitalIO *YDigitalIO::nextDigitalIO(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YDigitalIO::FindDigitalIO(hwid);
-}
-
-YDigitalIO* YDigitalIO::FirstDigitalIO(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("DigitalIO", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YDigitalIO::FindDigitalIO(serial+"."+funcId);
-}
-
-//--- (end of YDigitalIO implementation)
-
-//--- (YDigitalIO functions)
-//--- (end of YDigitalIO functions)
--- a/Sources/cpplib/yocto_digitalio.h
+++ /dev/null
@@ -1,596 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_digitalio.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindDigitalIO(), the high-level API for DigitalIO functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_DIGITALIO_H
-#define YOCTO_DIGITALIO_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YDigitalIO return codes)
-//--- (end of YDigitalIO return codes)
-//--- (YDigitalIO yapiwrapper)
-//--- (end of YDigitalIO yapiwrapper)
-//--- (YDigitalIO definitions)
-class YDigitalIO; // forward declaration
-
-typedef void (*YDigitalIOValueCallback)(YDigitalIO *func, const string& functionValue);
-#ifndef _Y_OUTPUTVOLTAGE_ENUM
-#define _Y_OUTPUTVOLTAGE_ENUM
-typedef enum {
-    Y_OUTPUTVOLTAGE_USB_5V = 0,
-    Y_OUTPUTVOLTAGE_USB_3V = 1,
-    Y_OUTPUTVOLTAGE_EXT_V = 2,
-    Y_OUTPUTVOLTAGE_INVALID = -1,
-} Y_OUTPUTVOLTAGE_enum;
-#endif
-#define Y_PORTSTATE_INVALID             (YAPI_INVALID_UINT)
-#define Y_PORTDIRECTION_INVALID         (YAPI_INVALID_UINT)
-#define Y_PORTOPENDRAIN_INVALID         (YAPI_INVALID_UINT)
-#define Y_PORTPOLARITY_INVALID          (YAPI_INVALID_UINT)
-#define Y_PORTDIAGS_INVALID             (YAPI_INVALID_UINT)
-#define Y_PORTSIZE_INVALID              (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YDigitalIO definitions)
-
-//--- (YDigitalIO declaration)
-/**
- * YDigitalIO Class: Digital IO function interface
- *
- * The Yoctopuce application programming interface allows you to switch the state of each
- * channel of the I/O port. You can switch all channels at once, or one by one. Most functions
- * use a binary representation for channels where bit 0 matches channel #0 , bit 1 matches channel
- * #1 and so on.... If you are not familiar with numbers binary representation, you will find more
- * information here: en.wikipedia.org/wiki/Binary_number#Representation . The library
- * can also automatically generate short pulses of a determined duration. Electrical behavior
- * of each I/O can be modified (open drain and reverse polarity).
- */
-class YOCTO_CLASS_EXPORT YDigitalIO: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YDigitalIO declaration)
-protected:
-    //--- (YDigitalIO attributes)
-    // Attributes (function value cache)
-    int             _portState;
-    int             _portDirection;
-    int             _portOpenDrain;
-    int             _portPolarity;
-    int             _portDiags;
-    int             _portSize;
-    Y_OUTPUTVOLTAGE_enum _outputVoltage;
-    string          _command;
-    YDigitalIOValueCallback _valueCallbackDigitalIO;
-
-    friend YDigitalIO *yFindDigitalIO(const string& func);
-    friend YDigitalIO *yFirstDigitalIO(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindDigitalIO factory function to instantiate
-    YDigitalIO(const string& func);
-    //--- (end of YDigitalIO attributes)
-
-public:
-    virtual ~YDigitalIO();
-    //--- (YDigitalIO accessors declaration)
-
-    static const int PORTSTATE_INVALID = YAPI_INVALID_UINT;
-    static const int PORTDIRECTION_INVALID = YAPI_INVALID_UINT;
-    static const int PORTOPENDRAIN_INVALID = YAPI_INVALID_UINT;
-    static const int PORTPOLARITY_INVALID = YAPI_INVALID_UINT;
-    static const int PORTDIAGS_INVALID = YAPI_INVALID_UINT;
-    static const int PORTSIZE_INVALID = YAPI_INVALID_UINT;
-    static const Y_OUTPUTVOLTAGE_enum OUTPUTVOLTAGE_USB_5V = Y_OUTPUTVOLTAGE_USB_5V;
-    static const Y_OUTPUTVOLTAGE_enum OUTPUTVOLTAGE_USB_3V = Y_OUTPUTVOLTAGE_USB_3V;
-    static const Y_OUTPUTVOLTAGE_enum OUTPUTVOLTAGE_EXT_V = Y_OUTPUTVOLTAGE_EXT_V;
-    static const Y_OUTPUTVOLTAGE_enum OUTPUTVOLTAGE_INVALID = Y_OUTPUTVOLTAGE_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the digital IO port state as an integer with each bit
-     * representing a channel
-     * value 0 = 0b00000000 -> all channels are OFF
-     * value 1 = 0b00000001 -> channel #0 is ON
-     * value 2 = 0b00000010 -> channel #1 is ON
-     * value 3 = 0b00000011 -> channels #0 and #1 are ON
-     * value 4 = 0b00000100 -> channel #2 is ON
-     * and so on...
-     *
-     * @return an integer corresponding to the digital IO port state as an integer with each bit
-     *         representing a channel
-     *         value 0 = 0b00000000 -> all channels are OFF
-     *         value 1 = 0b00000001 -> channel #0 is ON
-     *         value 2 = 0b00000010 -> channel #1 is ON
-     *         value 3 = 0b00000011 -> channels #0 and #1 are ON
-     *         value 4 = 0b00000100 -> channel #2 is ON
-     *         and so on.
-     *
-     * On failure, throws an exception or returns Y_PORTSTATE_INVALID.
-     */
-    int                 get_portState(void);
-
-    inline int          portState(void)
-    { return this->get_portState(); }
-
-    /**
-     * Changes the state of all digital IO port's channels at once,
-     * the parameter is an integer with  each bit representing a channel.
-     * Bit 0 matches channel #0. So:
-     * To set all channels to  0 -> 0b00000000 -> parameter = 0
-     * To set channel #0 to 1 -> 0b00000001 -> parameter =  1
-     * To set channel #1 to  1 -> 0b00000010 -> parameter = 2
-     * To set channel #0 and #1 -> 0b00000011 -> parameter =  3
-     * To set channel #2 to 1 -> 0b00000100 -> parameter =  4
-     * an so on....
-     * Only channels configured as output, thanks to portDirection,
-     * are affected.
-     *
-     * @param newval : an integer corresponding to the state of all digital IO port's channels at once,
-     *         the parameter is an integer with  each bit representing a channel
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_portState(int newval);
-    inline int      setPortState(int newval)
-    { return this->set_portState(newval); }
-
-    /**
-     * Returns the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.
-     *
-     * @return an integer corresponding to the IO direction of all bits (i.e
-     *
-     * On failure, throws an exception or returns Y_PORTDIRECTION_INVALID.
-     */
-    int                 get_portDirection(void);
-
-    inline int          portDirection(void)
-    { return this->get_portDirection(); }
-
-    /**
-     * Changes the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.
-     * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
-     *
-     * @param newval : an integer corresponding to the IO direction of all bits (i.e
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_portDirection(int newval);
-    inline int      setPortDirection(int newval)
-    { return this->set_portDirection(newval); }
-
-    /**
-     * Returns the electrical interface for each bit of the port. For each bit set to 0  the matching I/O
-     * works in the regular,
-     * intuitive way, for each bit set to 1, the I/O works in reverse mode.
-     *
-     * @return an integer corresponding to the electrical interface for each bit of the port
-     *
-     * On failure, throws an exception or returns Y_PORTOPENDRAIN_INVALID.
-     */
-    int                 get_portOpenDrain(void);
-
-    inline int          portOpenDrain(void)
-    { return this->get_portOpenDrain(); }
-
-    /**
-     * Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes
-     * it an open-drain (open-collector) input/output. Remember to call the
-     * saveToFlash() method  to make sure the setting is kept after a reboot.
-     *
-     * @param newval : an integer corresponding to the electrical interface for each bit of the port
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_portOpenDrain(int newval);
-    inline int      setPortOpenDrain(int newval)
-    { return this->set_portOpenDrain(newval); }
-
-    /**
-     * Returns the polarity of all the bits of the port.  For each bit set to 0, the matching I/O works the regular,
-     * intuitive way; for each bit set to 1, the I/O works in reverse mode.
-     *
-     * @return an integer corresponding to the polarity of all the bits of the port
-     *
-     * On failure, throws an exception or returns Y_PORTPOLARITY_INVALID.
-     */
-    int                 get_portPolarity(void);
-
-    inline int          portPolarity(void)
-    { return this->get_portPolarity(); }
-
-    /**
-     * Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular,
-     * intuitive way; for each bit set to 1, the I/O works in reverse mode.
-     * Remember to call the saveToFlash() method  to make sure the setting will be kept after a reboot.
-     *
-     * @param newval : an integer corresponding to the polarity of all the bits of the port: For each bit
-     * set to 0, the matching I/O works the regular,
-     *         intuitive way; for each bit set to 1, the I/O works in reverse mode
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_portPolarity(int newval);
-    inline int      setPortPolarity(int newval)
-    { return this->set_portPolarity(newval); }
-
-    /**
-     * Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only). Bit 0 indicates a shortcut on
-     * output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent).
-     * During normal use, all diagnostic bits should stay clear.
-     *
-     * @return an integer corresponding to the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only)
-     *
-     * On failure, throws an exception or returns Y_PORTDIAGS_INVALID.
-     */
-    int                 get_portDiags(void);
-
-    inline int          portDiags(void)
-    { return this->get_portDiags(); }
-
-    /**
-     * Returns the number of bits (i.e. channels)implemented in the I/O port.
-     *
-     * @return an integer corresponding to the number of bits (i.e
-     *
-     * On failure, throws an exception or returns Y_PORTSIZE_INVALID.
-     */
-    int                 get_portSize(void);
-
-    inline int          portSize(void)
-    { return this->get_portSize(); }
-
-    /**
-     * Returns the voltage source used to drive output bits.
-     *
-     * @return a value among Y_OUTPUTVOLTAGE_USB_5V, Y_OUTPUTVOLTAGE_USB_3V and Y_OUTPUTVOLTAGE_EXT_V
-     * corresponding to the voltage source used to drive output bits
-     *
-     * On failure, throws an exception or returns Y_OUTPUTVOLTAGE_INVALID.
-     */
-    Y_OUTPUTVOLTAGE_enum get_outputVoltage(void);
-
-    inline Y_OUTPUTVOLTAGE_enum outputVoltage(void)
-    { return this->get_outputVoltage(); }
-
-    /**
-     * Changes the voltage source used to drive output bits.
-     * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
-     *
-     * @param newval : a value among Y_OUTPUTVOLTAGE_USB_5V, Y_OUTPUTVOLTAGE_USB_3V and
-     * Y_OUTPUTVOLTAGE_EXT_V corresponding to the voltage source used to drive output bits
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_outputVoltage(Y_OUTPUTVOLTAGE_enum newval);
-    inline int      setOutputVoltage(Y_OUTPUTVOLTAGE_enum newval)
-    { return this->set_outputVoltage(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a digital IO port for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the digital IO port is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YDigitalIO.isOnline() to test if the digital IO port is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a digital IO port by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the digital IO port
-     *
-     * @return a YDigitalIO object allowing you to drive the digital IO port.
-     */
-    static YDigitalIO*  FindDigitalIO(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YDigitalIOValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Sets a single bit (i.e. channel) of the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     * @param bitstate : the state of the bit (1 or 0)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_bitState(int bitno,int bitstate);
-
-    /**
-     * Returns the state of a single bit (i.e. channel)  of the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     *
-     * @return the bit state (0 or 1)
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         get_bitState(int bitno);
-
-    /**
-     * Reverts a single bit (i.e. channel) of the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         toggle_bitState(int bitno);
-
-    /**
-     * Changes  the direction of a single bit (i.e. channel) from the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     * @param bitdirection : direction to set, 0 makes the bit an input, 1 makes it an output.
-     *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_bitDirection(int bitno,int bitdirection);
-
-    /**
-     * Returns the direction of a single bit (i.e. channel) from the I/O port (0 means the bit is an
-     * input, 1  an output).
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         get_bitDirection(int bitno);
-
-    /**
-     * Changes the polarity of a single bit from the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0.
-     * @param bitpolarity : polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O  works
-     * in reverse mode.
-     *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_bitPolarity(int bitno,int bitpolarity);
-
-    /**
-     * Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1
-     * means the I/O  works in reverse mode).
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         get_bitPolarity(int bitno);
-
-    /**
-     * Changes  the electrical interface of a single bit from the I/O port.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     * @param opendrain : 0 makes a bit a regular input/output, 1 makes
-     *         it an open-drain (open-collector) input/output. Remember to call the
-     *         saveToFlash() method to make sure the setting is kept after a reboot.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_bitOpenDrain(int bitno,int opendrain);
-
-    /**
-     * Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an
-     * input, 1  an output).
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     *
-     * @return   0 means the a bit is a regular input/output, 1 means the bit is an open-drain
-     *         (open-collector) input/output.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         get_bitOpenDrain(int bitno);
-
-    /**
-     * Triggers a pulse on a single bit for a specified duration. The specified bit
-     * will be turned to 1, and then back to 0 after the given duration.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     * @param ms_duration : desired pulse duration in milliseconds. Be aware that the device time
-     *         resolution is not guaranteed up to the millisecond.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pulse(int bitno,int ms_duration);
-
-    /**
-     * Schedules a pulse on a single bit for a specified duration. The specified bit
-     * will be turned to 1, and then back to 0 after the given duration.
-     *
-     * @param bitno : the bit number; lowest bit has index 0
-     * @param ms_delay : waiting time before the pulse, in milliseconds
-     * @param ms_duration : desired pulse duration in milliseconds. Be aware that the device time
-     *         resolution is not guaranteed up to the millisecond.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         delayedPulse(int bitno,int ms_delay,int ms_duration);
-
-
-    inline static YDigitalIO* Find(string func)
-    { return YDigitalIO::FindDigitalIO(func); }
-
-    /**
-     * Continues the enumeration of digital IO ports started using yFirstDigitalIO().
-     * Caution: You can't make any assumption about the returned digital IO ports order.
-     * If you want to find a specific a digital IO port, use DigitalIO.findDigitalIO()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YDigitalIO object, corresponding to
-     *         a digital IO port currently online, or a NULL pointer
-     *         if there are no more digital IO ports to enumerate.
-     */
-           YDigitalIO      *nextDigitalIO(void);
-    inline YDigitalIO      *next(void)
-    { return this->nextDigitalIO();}
-
-    /**
-     * Starts the enumeration of digital IO ports currently accessible.
-     * Use the method YDigitalIO.nextDigitalIO() to iterate on
-     * next digital IO ports.
-     *
-     * @return a pointer to a YDigitalIO object, corresponding to
-     *         the first digital IO port currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YDigitalIO* FirstDigitalIO(void);
-    inline static YDigitalIO* First(void)
-    { return YDigitalIO::FirstDigitalIO();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YDigitalIO accessors declaration)
-};
-
-//--- (YDigitalIO functions declaration)
-
-/**
- * Retrieves a digital IO port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the digital IO port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDigitalIO.isOnline() to test if the digital IO port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a digital IO port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the digital IO port
- *
- * @return a YDigitalIO object allowing you to drive the digital IO port.
- */
-inline YDigitalIO* yFindDigitalIO(const string& func)
-{ return YDigitalIO::FindDigitalIO(func);}
-/**
- * Starts the enumeration of digital IO ports currently accessible.
- * Use the method YDigitalIO.nextDigitalIO() to iterate on
- * next digital IO ports.
- *
- * @return a pointer to a YDigitalIO object, corresponding to
- *         the first digital IO port currently online, or a NULL pointer
- *         if there are none.
- */
-inline YDigitalIO* yFirstDigitalIO(void)
-{ return YDigitalIO::FirstDigitalIO();}
-
-//--- (end of YDigitalIO functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_display.cpp
+++ /dev/null
@@ -1,1458 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_display.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- * Implements yFindDisplay(), the high-level API for Display functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_display.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "display"
-
-
-YDisplayLayer::YDisplayLayer(YDisplay *parent, int id):
-//--- (generated code: YDisplayLayer initialization)
-//--- (end of generated code: YDisplayLayer initialization)
-_display(parent),_id(id),_cmdbuff(""),_hidden(false)
-{}
-
-
-int YDisplayLayer::flush_now(void)
-{
-    int res = YAPI_SUCCESS;
-    if(_cmdbuff.length() > 0) {
-        res = _display->sendCommand(_cmdbuff);
-        _cmdbuff="";
-    }
-    return res;
-}
-
-
-// internal function to send a command for this layer
-int YDisplayLayer::command_push(string cmd)
-{
-    int res = YAPI_SUCCESS;
-
-    if(_cmdbuff.length() + cmd.length() >= 100) {
-        // force flush before, to prevent overflow
-        res = flush_now();
-    }
-    if(_cmdbuff.length() == 0) {
-        // always prepend layer ID first
-        _cmdbuff.append(YapiWrapper::ysprintf("%d",_id));
-    }
-    _cmdbuff.append(cmd);
-    return res;
-}
-
-// internal function to send a command for this layer
-int YDisplayLayer::command_flush(string cmd)
-{
-    int  res = command_push(cmd);
-    if(_hidden) {
-        return res;
-    }
-    return flush_now();
-}
-
-int YDisplayLayer::drawBitmap(int x,int y,int w,const std::vector<unsigned char>& data,int bgcol)
-{
-	int size = (int)data.size();
-	char *arr = new char[size];
-	for (int i=0;i<size;i++) arr[i] = data[i];
-	string strval = string(arr,size);
-	return this->drawBitmap(x,y,w,strval,bgcol);
-}
-
-
-//--- (generated code: YDisplayLayer implementation)
-// static attributes
-
-
-/**
- * Reverts the layer to its initial state (fully transparent, default settings).
- * Reinitializes the drawing pointer to the upper left position,
- * and selects the most visible pen color. If you only want to erase the layer
- * content, use the method clear() instead.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::reset(void)
-{
-    _hidden = false;
-    return this->command_flush("X");
-}
-
-/**
- * Erases the whole content of the layer (makes it fully transparent).
- * This method does not change any other attribute of the layer.
- * To reinitialize the layer attributes to defaults settings, use the method
- * reset() instead.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::clear(void)
-{
-    return this->command_flush("x");
-}
-
-/**
- * Selects the pen color for all subsequent drawing functions,
- * including text drawing. The pen color is provided as an RGB value.
- * For grayscale or monochrome displays, the value is
- * automatically converted to the proper range.
- *
- * @param color : the desired pen color, as a 24-bit RGB value
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::selectColorPen(int color)
-{
-    return this->command_push(YapiWrapper::ysprintf("c%06x",color));
-}
-
-/**
- * Selects the pen gray level for all subsequent drawing functions,
- * including text drawing. The gray level is provided as a number between
- * 0 (black) and 255 (white, or whichever the lightest color is).
- * For monochrome displays (without gray levels), any value
- * lower than 128 is rendered as black, and any value equal
- * or above to 128 is non-black.
- *
- * @param graylevel : the desired gray level, from 0 to 255
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::selectGrayPen(int graylevel)
-{
-    return this->command_push(YapiWrapper::ysprintf("g%d",graylevel));
-}
-
-/**
- * Selects an eraser instead of a pen for all subsequent drawing functions,
- * except for bitmap copy functions. Any point drawn using the eraser
- * becomes transparent (as when the layer is empty), showing the other
- * layers beneath it.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::selectEraser(void)
-{
-    return this->command_push("e");
-}
-
-/**
- * Enables or disables anti-aliasing for drawing oblique lines and circles.
- * Anti-aliasing provides a smoother aspect when looked from far enough,
- * but it can add fuzziness when the display is looked from very close.
- * At the end of the day, it is your personal choice.
- * Anti-aliasing is enabled by default on grayscale and color displays,
- * but you can disable it if you prefer. This setting has no effect
- * on monochrome displays.
- *
- * @param mode : true to enable anti-aliasing, false to
- *         disable it.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::setAntialiasingMode(bool mode)
-{
-    return this->command_push(YapiWrapper::ysprintf("a%d",mode));
-}
-
-/**
- * Draws a single pixel at the specified position.
- *
- * @param x : the distance from left of layer, in pixels
- * @param y : the distance from top of layer, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawPixel(int x,int y)
-{
-    return this->command_flush(YapiWrapper::ysprintf("P%d,%d",x,y));
-}
-
-/**
- * Draws an empty rectangle at a specified position.
- *
- * @param x1 : the distance from left of layer to the left border of the rectangle, in pixels
- * @param y1 : the distance from top of layer to the top border of the rectangle, in pixels
- * @param x2 : the distance from left of layer to the right border of the rectangle, in pixels
- * @param y2 : the distance from top of layer to the bottom border of the rectangle, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawRect(int x1,int y1,int x2,int y2)
-{
-    return this->command_flush(YapiWrapper::ysprintf("R%d,%d,%d,%d",x1,y1,x2,y2));
-}
-
-/**
- * Draws a filled rectangular bar at a specified position.
- *
- * @param x1 : the distance from left of layer to the left border of the rectangle, in pixels
- * @param y1 : the distance from top of layer to the top border of the rectangle, in pixels
- * @param x2 : the distance from left of layer to the right border of the rectangle, in pixels
- * @param y2 : the distance from top of layer to the bottom border of the rectangle, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawBar(int x1,int y1,int x2,int y2)
-{
-    return this->command_flush(YapiWrapper::ysprintf("B%d,%d,%d,%d",x1,y1,x2,y2));
-}
-
-/**
- * Draws an empty circle at a specified position.
- *
- * @param x : the distance from left of layer to the center of the circle, in pixels
- * @param y : the distance from top of layer to the center of the circle, in pixels
- * @param r : the radius of the circle, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawCircle(int x,int y,int r)
-{
-    return this->command_flush(YapiWrapper::ysprintf("C%d,%d,%d",x,y,r));
-}
-
-/**
- * Draws a filled disc at a given position.
- *
- * @param x : the distance from left of layer to the center of the disc, in pixels
- * @param y : the distance from top of layer to the center of the disc, in pixels
- * @param r : the radius of the disc, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawDisc(int x,int y,int r)
-{
-    return this->command_flush(YapiWrapper::ysprintf("D%d,%d,%d",x,y,r));
-}
-
-/**
- * Selects a font to use for the next text drawing functions, by providing the name of the
- * font file. You can use a built-in font as well as a font file that you have previously
- * uploaded to the device built-in memory. If you experience problems selecting a font
- * file, check the device logs for any error message such as missing font file or bad font
- * file format.
- *
- * @param fontname : the font file name
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::selectFont(string fontname)
-{
-    return this->command_push(YapiWrapper::ysprintf("&%s%c",fontname.c_str(),27));
-}
-
-/**
- * Draws a text string at the specified position. The point of the text that is aligned
- * to the specified pixel position is called the anchor point, and can be chosen among
- * several options. Text is rendered from left to right, without implicit wrapping.
- *
- * @param x : the distance from left of layer to the text anchor point, in pixels
- * @param y : the distance from top of layer to the text anchor point, in pixels
- * @param anchor : the text anchor point, chosen among the Y_ALIGN enumeration:
- *         Y_ALIGN_TOP_LEFT,    Y_ALIGN_CENTER_LEFT,    Y_ALIGN_BASELINE_LEFT,    Y_ALIGN_BOTTOM_LEFT,
- *         Y_ALIGN_TOP_CENTER,  Y_ALIGN_CENTER,         Y_ALIGN_BASELINE_CENTER,  Y_ALIGN_BOTTOM_CENTER,
- *         Y_ALIGN_TOP_DECIMAL, Y_ALIGN_CENTER_DECIMAL, Y_ALIGN_BASELINE_DECIMAL, Y_ALIGN_BOTTOM_DECIMAL,
- *         Y_ALIGN_TOP_RIGHT,   Y_ALIGN_CENTER_RIGHT,   Y_ALIGN_BASELINE_RIGHT,   Y_ALIGN_BOTTOM_RIGHT.
- * @param text : the text string to draw
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawText(int x,int y,Y_ALIGN anchor,string text)
-{
-    return this->command_flush(YapiWrapper::ysprintf("T%d,%d,%d,%s%c",x,y,anchor,text.c_str(),27));
-}
-
-/**
- * Draws a GIF image at the specified position. The GIF image must have been previously
- * uploaded to the device built-in memory. If you experience problems using an image
- * file, check the device logs for any error message such as missing image file or bad
- * image file format.
- *
- * @param x : the distance from left of layer to the left of the image, in pixels
- * @param y : the distance from top of layer to the top of the image, in pixels
- * @param imagename : the GIF file name
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawImage(int x,int y,string imagename)
-{
-    return this->command_flush(YapiWrapper::ysprintf("*%d,%d,%s%c",x,y,imagename.c_str(),27));
-}
-
-/**
- * Draws a bitmap at the specified position. The bitmap is provided as a binary object,
- * where each pixel maps to a bit, from left to right and from top to bottom.
- * The most significant bit of each byte maps to the leftmost pixel, and the least
- * significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the
- * layer selected pen color. Bits set to 0 are drawn using the specified background
- * gray level, unless -1 is specified, in which case they are not drawn at all
- * (as if transparent).
- *
- * @param x : the distance from left of layer to the left of the bitmap, in pixels
- * @param y : the distance from top of layer to the top of the bitmap, in pixels
- * @param w : the width of the bitmap, in pixels
- * @param bitmap : a binary object
- * @param bgcol : the background gray level to use for zero bits (0 = black,
- *         255 = white), or -1 to leave the pixels unchanged
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::drawBitmap(int x,int y,int w,string bitmap,int bgcol)
-{
-    string destname;
-    destname = YapiWrapper::ysprintf("layer%d:%d,%d@%d,%d",_id,w,bgcol,x,y);
-    return _display->upload(destname,bitmap);
-}
-
-/**
- * Moves the drawing pointer of this layer to the specified position.
- *
- * @param x : the distance from left of layer, in pixels
- * @param y : the distance from top of layer, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::moveTo(int x,int y)
-{
-    return this->command_push(YapiWrapper::ysprintf("@%d,%d",x,y));
-}
-
-/**
- * Draws a line from current drawing pointer position to the specified position.
- * The specified destination pixel is included in the line. The pointer position
- * is then moved to the end point of the line.
- *
- * @param x : the distance from left of layer to the end point of the line, in pixels
- * @param y : the distance from top of layer to the end point of the line, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::lineTo(int x,int y)
-{
-    return this->command_flush(YapiWrapper::ysprintf("-%d,%d",x,y));
-}
-
-/**
- * Outputs a message in the console area, and advances the console pointer accordingly.
- * The console pointer position is automatically moved to the beginning
- * of the next line when a newline character is met, or when the right margin
- * is hit. When the new text to display extends below the lower margin, the
- * console area is automatically scrolled up.
- *
- * @param text : the message to display
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::consoleOut(string text)
-{
-    return this->command_flush(YapiWrapper::ysprintf("!%s%c",text.c_str(),27));
-}
-
-/**
- * Sets up display margins for the consoleOut function.
- *
- * @param x1 : the distance from left of layer to the left margin, in pixels
- * @param y1 : the distance from top of layer to the top margin, in pixels
- * @param x2 : the distance from left of layer to the right margin, in pixels
- * @param y2 : the distance from top of layer to the bottom margin, in pixels
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::setConsoleMargins(int x1,int y1,int x2,int y2)
-{
-    return this->command_push(YapiWrapper::ysprintf("m%d,%d,%d,%d",x1,y1,x2,y2));
-}
-
-/**
- * Sets up the background color used by the clearConsole function and by
- * the console scrolling feature.
- *
- * @param bgcol : the background gray level to use when scrolling (0 = black,
- *         255 = white), or -1 for transparent
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::setConsoleBackground(int bgcol)
-{
-    return this->command_push(YapiWrapper::ysprintf("b%d",bgcol));
-}
-
-/**
- * Sets up the wrapping behavior used by the consoleOut function.
- *
- * @param wordwrap : true to wrap only between words,
- *         false to wrap on the last column anyway.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::setConsoleWordWrap(bool wordwrap)
-{
-    return this->command_push(YapiWrapper::ysprintf("w%d",wordwrap));
-}
-
-/**
- * Blanks the console area within console margins, and resets the console pointer
- * to the upper left corner of the console.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::clearConsole(void)
-{
-    return this->command_flush("^");
-}
-
-/**
- * Sets the position of the layer relative to the display upper left corner.
- * When smooth scrolling is used, the display offset of the layer is
- * automatically updated during the next milliseconds to animate the move of the layer.
- *
- * @param x : the distance from left of display to the upper left corner of the layer
- * @param y : the distance from top of display to the upper left corner of the layer
- * @param scrollTime : number of milliseconds to use for smooth scrolling, or
- *         0 if the scrolling should be immediate.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::setLayerPosition(int x,int y,int scrollTime)
-{
-    return this->command_flush(YapiWrapper::ysprintf("#%d,%d,%d",x,y,scrollTime));
-}
-
-/**
- * Hides the layer. The state of the layer is preserved but the layer is not displayed
- * on the screen until the next call to unhide(). Hiding the layer can positively
- * affect the drawing speed, since it postpones the rendering until all operations are
- * completed (double-buffering).
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::hide(void)
-{
-    this->command_push("h");
-    _hidden = true;
-    return this->flush_now();
-}
-
-/**
- * Shows the layer. Shows the layer again after a hide command.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplayLayer::unhide(void)
-{
-    _hidden = false;
-    return this->command_flush("s");
-}
-
-/**
- * Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.
- *
- * @return an YDisplay object
- */
-YDisplay* YDisplayLayer::get_display(void)
-{
-    return _display;
-}
-
-/**
- * Returns the display width, in pixels.
- *
- * @return an integer corresponding to the display width, in pixels
- *
- * On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.
- */
-int YDisplayLayer::get_displayWidth(void)
-{
-    return _display->get_displayWidth();
-}
-
-/**
- * Returns the display height, in pixels.
- *
- * @return an integer corresponding to the display height, in pixels
- *
- * On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.
- */
-int YDisplayLayer::get_displayHeight(void)
-{
-    return _display->get_displayHeight();
-}
-
-/**
- * Returns the width of the layers to draw on, in pixels.
- *
- * @return an integer corresponding to the width of the layers to draw on, in pixels
- *
- * On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.
- */
-int YDisplayLayer::get_layerWidth(void)
-{
-    return _display->get_layerWidth();
-}
-
-/**
- * Returns the height of the layers to draw on, in pixels.
- *
- * @return an integer corresponding to the height of the layers to draw on, in pixels
- *
- * On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.
- */
-int YDisplayLayer::get_layerHeight(void)
-{
-    return _display->get_layerHeight();
-}
-
-int YDisplayLayer::resetHiddenFlag(void)
-{
-    _hidden = false;
-    return YAPI_SUCCESS;
-}
-//--- (end of generated code: YDisplayLayer implementation)
-
-
-YDisplay::YDisplay(const string& func): YFunction(func)
-//--- (generated code: YDisplay initialization)
-    ,_enabled(ENABLED_INVALID)
-    ,_startupSeq(STARTUPSEQ_INVALID)
-    ,_brightness(BRIGHTNESS_INVALID)
-    ,_orientation(ORIENTATION_INVALID)
-    ,_displayWidth(DISPLAYWIDTH_INVALID)
-    ,_displayHeight(DISPLAYHEIGHT_INVALID)
-    ,_displayType(DISPLAYTYPE_INVALID)
-    ,_layerWidth(LAYERWIDTH_INVALID)
-    ,_layerHeight(LAYERHEIGHT_INVALID)
-    ,_layerCount(LAYERCOUNT_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackDisplay(NULL)
-//--- (end of generated code: YDisplay initialization)
-            ,_allDisplayLayers(0)
-            ,_recording(false)
-            ,_sequence("")
-{
-    _className ="Display";
-}
-
-YDisplay::~YDisplay()
-{
-    unsigned int i;
-    for (i=0;i<_allDisplayLayers.size();i++){
-        delete _allDisplayLayers[i];
-    }
-    _allDisplayLayers.clear();
-    //--- (generated code: YDisplay cleanup)
-//--- (end of generated code: YDisplay cleanup)
-}
-
-
-//--- (generated code: YDisplay implementation)
-// static attributes
-const string YDisplay::STARTUPSEQ_INVALID = YAPI_INVALID_STRING;
-const string YDisplay::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YDisplay::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    if(json_val->has("startupSeq")) {
-        _startupSeq =  json_val->getString("startupSeq");
-    }
-    if(json_val->has("brightness")) {
-        _brightness =  json_val->getInt("brightness");
-    }
-    if(json_val->has("orientation")) {
-        _orientation =  (Y_ORIENTATION_enum)json_val->getInt("orientation");
-    }
-    if(json_val->has("displayWidth")) {
-        _displayWidth =  json_val->getInt("displayWidth");
-    }
-    if(json_val->has("displayHeight")) {
-        _displayHeight =  json_val->getInt("displayHeight");
-    }
-    if(json_val->has("displayType")) {
-        _displayType =  (Y_DISPLAYTYPE_enum)json_val->getInt("displayType");
-    }
-    if(json_val->has("layerWidth")) {
-        _layerWidth =  json_val->getInt("layerWidth");
-    }
-    if(json_val->has("layerHeight")) {
-        _layerHeight =  json_val->getInt("layerHeight");
-    }
-    if(json_val->has("layerCount")) {
-        _layerCount =  json_val->getInt("layerCount");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns true if the screen is powered, false otherwise.
- *
- * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to true if the screen is powered, false otherwise
- *
- * On failure, throws an exception or returns Y_ENABLED_INVALID.
- */
-Y_ENABLED_enum YDisplay::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the power state of the display.
- *
- * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the power state of the display
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the name of the sequence to play when the displayed is powered on.
- *
- * @return a string corresponding to the name of the sequence to play when the displayed is powered on
- *
- * On failure, throws an exception or returns Y_STARTUPSEQ_INVALID.
- */
-string YDisplay::get_startupSeq(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::STARTUPSEQ_INVALID;
-                }
-            }
-        }
-        res = _startupSeq;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the name of the sequence to play when the displayed is powered on.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the name of the sequence to play when the displayed is powered on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::set_startupSeq(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("startupSeq", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the luminosity of the  module informative LEDs (from 0 to 100).
- *
- * @return an integer corresponding to the luminosity of the  module informative LEDs (from 0 to 100)
- *
- * On failure, throws an exception or returns Y_BRIGHTNESS_INVALID.
- */
-int YDisplay::get_brightness(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::BRIGHTNESS_INVALID;
-                }
-            }
-        }
-        res = _brightness;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the brightness of the display. The parameter is a value between 0 and
- * 100. Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : an integer corresponding to the brightness of the display
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::set_brightness(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("brightness", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the currently selected display orientation.
- *
- * @return a value among Y_ORIENTATION_LEFT, Y_ORIENTATION_UP, Y_ORIENTATION_RIGHT and
- * Y_ORIENTATION_DOWN corresponding to the currently selected display orientation
- *
- * On failure, throws an exception or returns Y_ORIENTATION_INVALID.
- */
-Y_ORIENTATION_enum YDisplay::get_orientation(void)
-{
-    Y_ORIENTATION_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::ORIENTATION_INVALID;
-                }
-            }
-        }
-        res = _orientation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the display orientation. Remember to call the saveToFlash()
- * method of the module if the modification must be kept.
- *
- * @param newval : a value among Y_ORIENTATION_LEFT, Y_ORIENTATION_UP, Y_ORIENTATION_RIGHT and
- * Y_ORIENTATION_DOWN corresponding to the display orientation
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::set_orientation(Y_ORIENTATION_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("orientation", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the display width, in pixels.
- *
- * @return an integer corresponding to the display width, in pixels
- *
- * On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.
- */
-int YDisplay::get_displayWidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::DISPLAYWIDTH_INVALID;
-                }
-            }
-        }
-        res = _displayWidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the display height, in pixels.
- *
- * @return an integer corresponding to the display height, in pixels
- *
- * On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.
- */
-int YDisplay::get_displayHeight(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::DISPLAYHEIGHT_INVALID;
-                }
-            }
-        }
-        res = _displayHeight;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the display type: monochrome, gray levels or full color.
- *
- * @return a value among Y_DISPLAYTYPE_MONO, Y_DISPLAYTYPE_GRAY and Y_DISPLAYTYPE_RGB corresponding to
- * the display type: monochrome, gray levels or full color
- *
- * On failure, throws an exception or returns Y_DISPLAYTYPE_INVALID.
- */
-Y_DISPLAYTYPE_enum YDisplay::get_displayType(void)
-{
-    Y_DISPLAYTYPE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::DISPLAYTYPE_INVALID;
-                }
-            }
-        }
-        res = _displayType;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the width of the layers to draw on, in pixels.
- *
- * @return an integer corresponding to the width of the layers to draw on, in pixels
- *
- * On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.
- */
-int YDisplay::get_layerWidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::LAYERWIDTH_INVALID;
-                }
-            }
-        }
-        res = _layerWidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the height of the layers to draw on, in pixels.
- *
- * @return an integer corresponding to the height of the layers to draw on, in pixels
- *
- * On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.
- */
-int YDisplay::get_layerHeight(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::LAYERHEIGHT_INVALID;
-                }
-            }
-        }
-        res = _layerHeight;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of available layers to draw on.
- *
- * @return an integer corresponding to the number of available layers to draw on
- *
- * On failure, throws an exception or returns Y_LAYERCOUNT_INVALID.
- */
-int YDisplay::get_layerCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::LAYERCOUNT_INVALID;
-                }
-            }
-        }
-        res = _layerCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YDisplay::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDisplay::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YDisplay::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a display for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the display is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDisplay.isOnline() to test if the display is
- * indeed online at a given time. In case of ambiguity when looking for
- * a display by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the display
- *
- * @return a YDisplay object allowing you to drive the display.
- */
-YDisplay* YDisplay::FindDisplay(string func)
-{
-    YDisplay* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YDisplay*) YFunction::_FindFromCache("Display", func);
-        if (obj == NULL) {
-            obj = new YDisplay(func);
-            YFunction::_AddToCache("Display", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YDisplay::registerValueCallback(YDisplayValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackDisplay = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YDisplay::_invokeValueCallback(string value)
-{
-    if (_valueCallbackDisplay != NULL) {
-        _valueCallbackDisplay(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Clears the display screen and resets all display layers to their default state.
- * Using this function in a sequence will kill the sequence play-back. Don't use that
- * function to reset the display at sequence start-up.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::resetAll(void)
-{
-    this->flushLayers();
-    this->resetHiddenLayerFlags();
-    return this->sendCommand("Z");
-}
-
-/**
- * Smoothly changes the brightness of the screen to produce a fade-in or fade-out
- * effect.
- *
- * @param brightness : the new screen brightness
- * @param duration : duration of the brightness transition, in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::fade(int brightness,int duration)
-{
-    this->flushLayers();
-    return this->sendCommand(YapiWrapper::ysprintf("+%d,%d",brightness,duration));
-}
-
-/**
- * Starts to record all display commands into a sequence, for later replay.
- * The name used to store the sequence is specified when calling
- * saveSequence(), once the recording is complete.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::newSequence(void)
-{
-    this->flushLayers();
-    _sequence = "";
-    _recording = true;
-    return YAPI_SUCCESS;
-}
-
-/**
- * Stops recording display commands and saves the sequence into the specified
- * file on the display internal memory. The sequence can be later replayed
- * using playSequence().
- *
- * @param sequenceName : the name of the newly created sequence
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::saveSequence(string sequenceName)
-{
-    this->flushLayers();
-    _recording = false;
-    this->_upload(sequenceName, _sequence);
-    //We need to use YPRINTF("") for Objective-C
-    _sequence = YapiWrapper::ysprintf("");
-    return YAPI_SUCCESS;
-}
-
-/**
- * Replays a display sequence previously recorded using
- * newSequence() and saveSequence().
- *
- * @param sequenceName : the name of the newly created sequence
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::playSequence(string sequenceName)
-{
-    this->flushLayers();
-    return this->sendCommand(YapiWrapper::ysprintf("S%s",sequenceName.c_str()));
-}
-
-/**
- * Waits for a specified delay (in milliseconds) before playing next
- * commands in current sequence. This method can be used while
- * recording a display sequence, to insert a timed wait in the sequence
- * (without any immediate effect). It can also be used dynamically while
- * playing a pre-recorded sequence, to suspend or resume the execution of
- * the sequence. To cancel a delay, call the same method with a zero delay.
- *
- * @param delay_ms : the duration to wait, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::pauseSequence(int delay_ms)
-{
-    this->flushLayers();
-    return this->sendCommand(YapiWrapper::ysprintf("W%d",delay_ms));
-}
-
-/**
- * Stops immediately any ongoing sequence replay.
- * The display is left as is.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::stopSequence(void)
-{
-    this->flushLayers();
-    return this->sendCommand("S");
-}
-
-/**
- * Uploads an arbitrary file (for instance a GIF file) to the display, to the
- * specified full path name. If a file already exists with the same path name,
- * its content is overwritten.
- *
- * @param pathname : path and name of the new file to create
- * @param content : binary buffer with the content to set
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::upload(string pathname,string content)
-{
-    return this->_upload(pathname, content);
-}
-
-/**
- * Copies the whole content of a layer to another layer. The color and transparency
- * of all the pixels from the destination layer are set to match the source pixels.
- * This method only affects the displayed content, but does not change any
- * property of the layer object.
- * Note that layer 0 has no transparency support (it is always completely opaque).
- *
- * @param srcLayerId : the identifier of the source layer (a number in range 0..layerCount-1)
- * @param dstLayerId : the identifier of the destination layer (a number in range 0..layerCount-1)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::copyLayerContent(int srcLayerId,int dstLayerId)
-{
-    this->flushLayers();
-    return this->sendCommand(YapiWrapper::ysprintf("o%d,%d",srcLayerId,dstLayerId));
-}
-
-/**
- * Swaps the whole content of two layers. The color and transparency of all the pixels from
- * the two layers are swapped. This method only affects the displayed content, but does
- * not change any property of the layer objects. In particular, the visibility of each
- * layer stays unchanged. When used between one hidden layer and a visible layer,
- * this method makes it possible to easily implement double-buffering.
- * Note that layer 0 has no transparency support (it is always completely opaque).
- *
- * @param layerIdA : the first layer (a number in range 0..layerCount-1)
- * @param layerIdB : the second layer (a number in range 0..layerCount-1)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDisplay::swapLayerContent(int layerIdA,int layerIdB)
-{
-    this->flushLayers();
-    return this->sendCommand(YapiWrapper::ysprintf("E%d,%d",layerIdA,layerIdB));
-}
-
-YDisplay *YDisplay::nextDisplay(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YDisplay::FindDisplay(hwid);
-}
-
-YDisplay* YDisplay::FirstDisplay(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Display", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YDisplay::FindDisplay(serial+"."+funcId);
-}
-
-//--- (end of generated code: YDisplay implementation)
-
-
-YDisplayLayer* YDisplay::get_displayLayer(unsigned layerId)
-{
-    if(_allDisplayLayers.size()==0) {
-        unsigned nb_display_layer = this->get_layerCount();
-        for(unsigned i = 0; i < nb_display_layer; i++) {
-            _allDisplayLayers.push_back(new YDisplayLayer(this, i));
-        }
-    }
-    if(layerId >= _allDisplayLayers.size()) {
-        this->_throw(YAPI_INVALID_ARGUMENT, "Invalid layerId");
-        return NULL;
-    }
-    return _allDisplayLayers[layerId];
-}
-
-
-int YDisplay::flushLayers(void)
-{
-    for(unsigned i = 0; i < _allDisplayLayers.size(); i++) {
-        _allDisplayLayers[i]->flush_now();
-    }
-    return YAPI_SUCCESS;
-}
-
-// internal function to clear hidden flag during resetAll
-void YDisplay::resetHiddenLayerFlags(void)
-{
-    for(unsigned i = 0; i < _allDisplayLayers.size(); i++) {
-        _allDisplayLayers[i]->resetHiddenFlag();
-    }
-}
-
-int YDisplay::sendCommand(string cmd)
-{
-    if(!_recording) {
-        return this->set_command(cmd);
-    }
-    _sequence += cmd+"\n";
-    return YAPI_SUCCESS;
-}
-
-
-//--- (generated code: YDisplay functions)
-//--- (end of generated code: YDisplay functions)
--- a/Sources/cpplib/yocto_display.h
+++ /dev/null
@@ -1,1120 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_display.h 33710 2018-12-14 14:18:53Z seb $
- *
- * Declares yFindDisplay(), the high-level API for Display functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_DISPLAY_H
-#define YOCTO_DISPLAY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-
-//--- (generated code: YDisplay definitions)
-class YDisplay; // forward declaration
-
-typedef void (*YDisplayValueCallback)(YDisplay *func, const string& functionValue);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-#ifndef _Y_ORIENTATION_ENUM
-#define _Y_ORIENTATION_ENUM
-typedef enum {
-    Y_ORIENTATION_LEFT = 0,
-    Y_ORIENTATION_UP = 1,
-    Y_ORIENTATION_RIGHT = 2,
-    Y_ORIENTATION_DOWN = 3,
-    Y_ORIENTATION_INVALID = -1,
-} Y_ORIENTATION_enum;
-#endif
-#ifndef _Y_DISPLAYTYPE_ENUM
-#define _Y_DISPLAYTYPE_ENUM
-typedef enum {
-    Y_DISPLAYTYPE_MONO = 0,
-    Y_DISPLAYTYPE_GRAY = 1,
-    Y_DISPLAYTYPE_RGB = 2,
-    Y_DISPLAYTYPE_INVALID = -1,
-} Y_DISPLAYTYPE_enum;
-#endif
-#define Y_STARTUPSEQ_INVALID            (YAPI_INVALID_STRING)
-#define Y_BRIGHTNESS_INVALID            (YAPI_INVALID_UINT)
-#define Y_DISPLAYWIDTH_INVALID          (YAPI_INVALID_UINT)
-#define Y_DISPLAYHEIGHT_INVALID         (YAPI_INVALID_UINT)
-#define Y_LAYERWIDTH_INVALID            (YAPI_INVALID_UINT)
-#define Y_LAYERHEIGHT_INVALID           (YAPI_INVALID_UINT)
-#define Y_LAYERCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of generated code: YDisplay definitions)
-
-//--- (generated code: YDisplayLayer definitions)
-    #ifndef _Y_ALIGN
-    #define _Y_ALIGN
-    typedef enum {
-        Y_ALIGN_TOP_LEFT = 0 ,
-        Y_ALIGN_CENTER_LEFT = 1 ,
-        Y_ALIGN_BASELINE_LEFT = 2 ,
-        Y_ALIGN_BOTTOM_LEFT = 3 ,
-        Y_ALIGN_TOP_CENTER = 4 ,
-        Y_ALIGN_CENTER = 5 ,
-        Y_ALIGN_BASELINE_CENTER = 6 ,
-        Y_ALIGN_BOTTOM_CENTER = 7 ,
-        Y_ALIGN_TOP_DECIMAL = 8 ,
-        Y_ALIGN_CENTER_DECIMAL = 9 ,
-        Y_ALIGN_BASELINE_DECIMAL = 10 ,
-        Y_ALIGN_BOTTOM_DECIMAL = 11 ,
-        Y_ALIGN_TOP_RIGHT = 12 ,
-        Y_ALIGN_CENTER_RIGHT = 13 ,
-        Y_ALIGN_BASELINE_RIGHT = 14 ,
-        Y_ALIGN_BOTTOM_RIGHT = 15
-    } Y_ALIGN;
-    #endif
-
-//--- (end of generated code: YDisplayLayer definitions)
-
-class YDisplay;
-
-//--- (generated code: YDisplayLayer declaration)
-/**
- * YDisplayLayer Class: DisplayLayer object interface
- *
- * A DisplayLayer is an image layer containing objects to display
- * (bitmaps, text, etc.). The content is displayed only when
- * the layer is active on the screen (and not masked by other
- * overlapping layers).
- */
-class YOCTO_CLASS_EXPORT YDisplayLayer {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YDisplayLayer declaration)
-    //--- (generated code: YDisplayLayer attributes)
-    // Attributes (function value cache)
-    //--- (end of generated code: YDisplayLayer attributes)
-    //--- (generated code: YDisplayLayer constructor)
-
-    //--- (end of generated code: YDisplayLayer constructor)
-    //--- (generated code: YDisplayLayer initialization)
-    //--- (end of generated code: YDisplayLayer initialization)
-
-    YDisplay *_display;
-    int    _id;
-    string _cmdbuff;
-    bool   _hidden;
-
-    // internal function to send a command for this layer
-    int command_push(string cmd);
-    int command_flush(string cmd);
-
-public:
-    int flush_now();
-    virtual ~YDisplayLayer(){};
-    YDisplayLayer(YDisplay *parent, int id);
-    //--- (generated code: YDisplayLayer accessors declaration)
-
-    static const Y_ALIGN ALIGN_TOP_LEFT = Y_ALIGN_TOP_LEFT;
-    static const Y_ALIGN ALIGN_CENTER_LEFT = Y_ALIGN_CENTER_LEFT;
-    static const Y_ALIGN ALIGN_BASELINE_LEFT = Y_ALIGN_BASELINE_LEFT;
-    static const Y_ALIGN ALIGN_BOTTOM_LEFT = Y_ALIGN_BOTTOM_LEFT;
-    static const Y_ALIGN ALIGN_TOP_CENTER = Y_ALIGN_TOP_CENTER;
-    static const Y_ALIGN ALIGN_CENTER = Y_ALIGN_CENTER;
-    static const Y_ALIGN ALIGN_BASELINE_CENTER = Y_ALIGN_BASELINE_CENTER;
-    static const Y_ALIGN ALIGN_BOTTOM_CENTER = Y_ALIGN_BOTTOM_CENTER;
-    static const Y_ALIGN ALIGN_TOP_DECIMAL = Y_ALIGN_TOP_DECIMAL;
-    static const Y_ALIGN ALIGN_CENTER_DECIMAL = Y_ALIGN_CENTER_DECIMAL;
-    static const Y_ALIGN ALIGN_BASELINE_DECIMAL = Y_ALIGN_BASELINE_DECIMAL;
-    static const Y_ALIGN ALIGN_BOTTOM_DECIMAL = Y_ALIGN_BOTTOM_DECIMAL;
-    static const Y_ALIGN ALIGN_TOP_RIGHT = Y_ALIGN_TOP_RIGHT;
-    static const Y_ALIGN ALIGN_CENTER_RIGHT = Y_ALIGN_CENTER_RIGHT;
-    static const Y_ALIGN ALIGN_BASELINE_RIGHT = Y_ALIGN_BASELINE_RIGHT;
-    static const Y_ALIGN ALIGN_BOTTOM_RIGHT = Y_ALIGN_BOTTOM_RIGHT;
-
-    /**
-     * Reverts the layer to its initial state (fully transparent, default settings).
-     * Reinitializes the drawing pointer to the upper left position,
-     * and selects the most visible pen color. If you only want to erase the layer
-     * content, use the method clear() instead.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-    /**
-     * Erases the whole content of the layer (makes it fully transparent).
-     * This method does not change any other attribute of the layer.
-     * To reinitialize the layer attributes to defaults settings, use the method
-     * reset() instead.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         clear(void);
-
-    /**
-     * Selects the pen color for all subsequent drawing functions,
-     * including text drawing. The pen color is provided as an RGB value.
-     * For grayscale or monochrome displays, the value is
-     * automatically converted to the proper range.
-     *
-     * @param color : the desired pen color, as a 24-bit RGB value
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectColorPen(int color);
-
-    /**
-     * Selects the pen gray level for all subsequent drawing functions,
-     * including text drawing. The gray level is provided as a number between
-     * 0 (black) and 255 (white, or whichever the lightest color is).
-     * For monochrome displays (without gray levels), any value
-     * lower than 128 is rendered as black, and any value equal
-     * or above to 128 is non-black.
-     *
-     * @param graylevel : the desired gray level, from 0 to 255
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectGrayPen(int graylevel);
-
-    /**
-     * Selects an eraser instead of a pen for all subsequent drawing functions,
-     * except for bitmap copy functions. Any point drawn using the eraser
-     * becomes transparent (as when the layer is empty), showing the other
-     * layers beneath it.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectEraser(void);
-
-    /**
-     * Enables or disables anti-aliasing for drawing oblique lines and circles.
-     * Anti-aliasing provides a smoother aspect when looked from far enough,
-     * but it can add fuzziness when the display is looked from very close.
-     * At the end of the day, it is your personal choice.
-     * Anti-aliasing is enabled by default on grayscale and color displays,
-     * but you can disable it if you prefer. This setting has no effect
-     * on monochrome displays.
-     *
-     * @param mode : true to enable anti-aliasing, false to
-     *         disable it.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setAntialiasingMode(bool mode);
-
-    /**
-     * Draws a single pixel at the specified position.
-     *
-     * @param x : the distance from left of layer, in pixels
-     * @param y : the distance from top of layer, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawPixel(int x,int y);
-
-    /**
-     * Draws an empty rectangle at a specified position.
-     *
-     * @param x1 : the distance from left of layer to the left border of the rectangle, in pixels
-     * @param y1 : the distance from top of layer to the top border of the rectangle, in pixels
-     * @param x2 : the distance from left of layer to the right border of the rectangle, in pixels
-     * @param y2 : the distance from top of layer to the bottom border of the rectangle, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawRect(int x1,int y1,int x2,int y2);
-
-    /**
-     * Draws a filled rectangular bar at a specified position.
-     *
-     * @param x1 : the distance from left of layer to the left border of the rectangle, in pixels
-     * @param y1 : the distance from top of layer to the top border of the rectangle, in pixels
-     * @param x2 : the distance from left of layer to the right border of the rectangle, in pixels
-     * @param y2 : the distance from top of layer to the bottom border of the rectangle, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawBar(int x1,int y1,int x2,int y2);
-
-    /**
-     * Draws an empty circle at a specified position.
-     *
-     * @param x : the distance from left of layer to the center of the circle, in pixels
-     * @param y : the distance from top of layer to the center of the circle, in pixels
-     * @param r : the radius of the circle, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawCircle(int x,int y,int r);
-
-    /**
-     * Draws a filled disc at a given position.
-     *
-     * @param x : the distance from left of layer to the center of the disc, in pixels
-     * @param y : the distance from top of layer to the center of the disc, in pixels
-     * @param r : the radius of the disc, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawDisc(int x,int y,int r);
-
-    /**
-     * Selects a font to use for the next text drawing functions, by providing the name of the
-     * font file. You can use a built-in font as well as a font file that you have previously
-     * uploaded to the device built-in memory. If you experience problems selecting a font
-     * file, check the device logs for any error message such as missing font file or bad font
-     * file format.
-     *
-     * @param fontname : the font file name
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectFont(string fontname);
-
-    /**
-     * Draws a text string at the specified position. The point of the text that is aligned
-     * to the specified pixel position is called the anchor point, and can be chosen among
-     * several options. Text is rendered from left to right, without implicit wrapping.
-     *
-     * @param x : the distance from left of layer to the text anchor point, in pixels
-     * @param y : the distance from top of layer to the text anchor point, in pixels
-     * @param anchor : the text anchor point, chosen among the Y_ALIGN enumeration:
-     *         Y_ALIGN_TOP_LEFT,    Y_ALIGN_CENTER_LEFT,    Y_ALIGN_BASELINE_LEFT,    Y_ALIGN_BOTTOM_LEFT,
-     *         Y_ALIGN_TOP_CENTER,  Y_ALIGN_CENTER,         Y_ALIGN_BASELINE_CENTER,  Y_ALIGN_BOTTOM_CENTER,
-     *         Y_ALIGN_TOP_DECIMAL, Y_ALIGN_CENTER_DECIMAL, Y_ALIGN_BASELINE_DECIMAL, Y_ALIGN_BOTTOM_DECIMAL,
-     *         Y_ALIGN_TOP_RIGHT,   Y_ALIGN_CENTER_RIGHT,   Y_ALIGN_BASELINE_RIGHT,   Y_ALIGN_BOTTOM_RIGHT.
-     * @param text : the text string to draw
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawText(int x,int y,Y_ALIGN anchor,string text);
-
-    /**
-     * Draws a GIF image at the specified position. The GIF image must have been previously
-     * uploaded to the device built-in memory. If you experience problems using an image
-     * file, check the device logs for any error message such as missing image file or bad
-     * image file format.
-     *
-     * @param x : the distance from left of layer to the left of the image, in pixels
-     * @param y : the distance from top of layer to the top of the image, in pixels
-     * @param imagename : the GIF file name
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawImage(int x,int y,string imagename);
-
-    /**
-     * Draws a bitmap at the specified position. The bitmap is provided as a binary object,
-     * where each pixel maps to a bit, from left to right and from top to bottom.
-     * The most significant bit of each byte maps to the leftmost pixel, and the least
-     * significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the
-     * layer selected pen color. Bits set to 0 are drawn using the specified background
-     * gray level, unless -1 is specified, in which case they are not drawn at all
-     * (as if transparent).
-     *
-     * @param x : the distance from left of layer to the left of the bitmap, in pixels
-     * @param y : the distance from top of layer to the top of the bitmap, in pixels
-     * @param w : the width of the bitmap, in pixels
-     * @param bitmap : a binary object
-     * @param bgcol : the background gray level to use for zero bits (0 = black,
-     *         255 = white), or -1 to leave the pixels unchanged
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drawBitmap(int x,int y,int w,string bitmap,int bgcol);
-
-    /**
-     * Moves the drawing pointer of this layer to the specified position.
-     *
-     * @param x : the distance from left of layer, in pixels
-     * @param y : the distance from top of layer, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveTo(int x,int y);
-
-    /**
-     * Draws a line from current drawing pointer position to the specified position.
-     * The specified destination pixel is included in the line. The pointer position
-     * is then moved to the end point of the line.
-     *
-     * @param x : the distance from left of layer to the end point of the line, in pixels
-     * @param y : the distance from top of layer to the end point of the line, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         lineTo(int x,int y);
-
-    /**
-     * Outputs a message in the console area, and advances the console pointer accordingly.
-     * The console pointer position is automatically moved to the beginning
-     * of the next line when a newline character is met, or when the right margin
-     * is hit. When the new text to display extends below the lower margin, the
-     * console area is automatically scrolled up.
-     *
-     * @param text : the message to display
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         consoleOut(string text);
-
-    /**
-     * Sets up display margins for the consoleOut function.
-     *
-     * @param x1 : the distance from left of layer to the left margin, in pixels
-     * @param y1 : the distance from top of layer to the top margin, in pixels
-     * @param x2 : the distance from left of layer to the right margin, in pixels
-     * @param y2 : the distance from top of layer to the bottom margin, in pixels
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setConsoleMargins(int x1,int y1,int x2,int y2);
-
-    /**
-     * Sets up the background color used by the clearConsole function and by
-     * the console scrolling feature.
-     *
-     * @param bgcol : the background gray level to use when scrolling (0 = black,
-     *         255 = white), or -1 for transparent
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setConsoleBackground(int bgcol);
-
-    /**
-     * Sets up the wrapping behavior used by the consoleOut function.
-     *
-     * @param wordwrap : true to wrap only between words,
-     *         false to wrap on the last column anyway.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setConsoleWordWrap(bool wordwrap);
-
-    /**
-     * Blanks the console area within console margins, and resets the console pointer
-     * to the upper left corner of the console.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         clearConsole(void);
-
-    /**
-     * Sets the position of the layer relative to the display upper left corner.
-     * When smooth scrolling is used, the display offset of the layer is
-     * automatically updated during the next milliseconds to animate the move of the layer.
-     *
-     * @param x : the distance from left of display to the upper left corner of the layer
-     * @param y : the distance from top of display to the upper left corner of the layer
-     * @param scrollTime : number of milliseconds to use for smooth scrolling, or
-     *         0 if the scrolling should be immediate.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setLayerPosition(int x,int y,int scrollTime);
-
-    /**
-     * Hides the layer. The state of the layer is preserved but the layer is not displayed
-     * on the screen until the next call to unhide(). Hiding the layer can positively
-     * affect the drawing speed, since it postpones the rendering until all operations are
-     * completed (double-buffering).
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         hide(void);
-
-    /**
-     * Shows the layer. Shows the layer again after a hide command.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         unhide(void);
-
-    /**
-     * Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.
-     *
-     * @return an YDisplay object
-     */
-    virtual YDisplay*   get_display(void);
-
-    /**
-     * Returns the display width, in pixels.
-     *
-     * @return an integer corresponding to the display width, in pixels
-     *
-     * On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.
-     */
-    virtual int         get_displayWidth(void);
-
-    /**
-     * Returns the display height, in pixels.
-     *
-     * @return an integer corresponding to the display height, in pixels
-     *
-     * On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.
-     */
-    virtual int         get_displayHeight(void);
-
-    /**
-     * Returns the width of the layers to draw on, in pixels.
-     *
-     * @return an integer corresponding to the width of the layers to draw on, in pixels
-     *
-     * On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.
-     */
-    virtual int         get_layerWidth(void);
-
-    /**
-     * Returns the height of the layers to draw on, in pixels.
-     *
-     * @return an integer corresponding to the height of the layers to draw on, in pixels
-     *
-     * On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.
-     */
-    virtual int         get_layerHeight(void);
-
-    virtual int         resetHiddenFlag(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YDisplayLayer accessors declaration)
-    int drawBitmap(int x,int y,int w,const std::vector<unsigned char>& data,int bgcol);
-};
-
-
-//--- (generated code: YDisplay declaration)
-/**
- * YDisplay Class: Display function interface
- *
- * Yoctopuce display interface has been designed to easily
- * show information and images. The device provides built-in
- * multi-layer rendering. Layers can be drawn offline, individually,
- * and freely moved on the display. It can also replay recorded
- * sequences (animations).
- */
-class YOCTO_CLASS_EXPORT YDisplay: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YDisplay declaration)
-    //--- (generated code: YDisplay attributes)
-    // Attributes (function value cache)
-    Y_ENABLED_enum  _enabled;
-    string          _startupSeq;
-    int             _brightness;
-    Y_ORIENTATION_enum _orientation;
-    int             _displayWidth;
-    int             _displayHeight;
-    Y_DISPLAYTYPE_enum _displayType;
-    int             _layerWidth;
-    int             _layerHeight;
-    int             _layerCount;
-    string          _command;
-    YDisplayValueCallback _valueCallbackDisplay;
-
-    friend YDisplay *yFindDisplay(const string& func);
-    friend YDisplay *yFirstDisplay(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindDisplay factory function to instantiate
-    YDisplay(const string& func);
-    //--- (end of generated code: YDisplay attributes)
-    vector<YDisplayLayer*>  _allDisplayLayers;
-    bool                    _recording;
-    string                  _sequence;
-
-    //--- (generated code: YDisplay initialization)
-    //--- (end of generated code: YDisplay initialization)
-
-public:
-    ~YDisplay();
-    //--- (generated code: YDisplay accessors declaration)
-
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-    static const string STARTUPSEQ_INVALID;
-    static const int BRIGHTNESS_INVALID = YAPI_INVALID_UINT;
-    static const Y_ORIENTATION_enum ORIENTATION_LEFT = Y_ORIENTATION_LEFT;
-    static const Y_ORIENTATION_enum ORIENTATION_UP = Y_ORIENTATION_UP;
-    static const Y_ORIENTATION_enum ORIENTATION_RIGHT = Y_ORIENTATION_RIGHT;
-    static const Y_ORIENTATION_enum ORIENTATION_DOWN = Y_ORIENTATION_DOWN;
-    static const Y_ORIENTATION_enum ORIENTATION_INVALID = Y_ORIENTATION_INVALID;
-    static const int DISPLAYWIDTH_INVALID = YAPI_INVALID_UINT;
-    static const int DISPLAYHEIGHT_INVALID = YAPI_INVALID_UINT;
-    static const Y_DISPLAYTYPE_enum DISPLAYTYPE_MONO = Y_DISPLAYTYPE_MONO;
-    static const Y_DISPLAYTYPE_enum DISPLAYTYPE_GRAY = Y_DISPLAYTYPE_GRAY;
-    static const Y_DISPLAYTYPE_enum DISPLAYTYPE_RGB = Y_DISPLAYTYPE_RGB;
-    static const Y_DISPLAYTYPE_enum DISPLAYTYPE_INVALID = Y_DISPLAYTYPE_INVALID;
-    static const int LAYERWIDTH_INVALID = YAPI_INVALID_UINT;
-    static const int LAYERHEIGHT_INVALID = YAPI_INVALID_UINT;
-    static const int LAYERCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns true if the screen is powered, false otherwise.
-     *
-     * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to true if the screen is powered, false otherwise
-     *
-     * On failure, throws an exception or returns Y_ENABLED_INVALID.
-     */
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    /**
-     * Changes the power state of the display.
-     *
-     * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the power state of the display
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Returns the name of the sequence to play when the displayed is powered on.
-     *
-     * @return a string corresponding to the name of the sequence to play when the displayed is powered on
-     *
-     * On failure, throws an exception or returns Y_STARTUPSEQ_INVALID.
-     */
-    string              get_startupSeq(void);
-
-    inline string       startupSeq(void)
-    { return this->get_startupSeq(); }
-
-    /**
-     * Changes the name of the sequence to play when the displayed is powered on.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the name of the sequence to play when the displayed is powered on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_startupSeq(const string& newval);
-    inline int      setStartupSeq(const string& newval)
-    { return this->set_startupSeq(newval); }
-
-    /**
-     * Returns the luminosity of the  module informative LEDs (from 0 to 100).
-     *
-     * @return an integer corresponding to the luminosity of the  module informative LEDs (from 0 to 100)
-     *
-     * On failure, throws an exception or returns Y_BRIGHTNESS_INVALID.
-     */
-    int                 get_brightness(void);
-
-    inline int          brightness(void)
-    { return this->get_brightness(); }
-
-    /**
-     * Changes the brightness of the display. The parameter is a value between 0 and
-     * 100. Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : an integer corresponding to the brightness of the display
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_brightness(int newval);
-    inline int      setBrightness(int newval)
-    { return this->set_brightness(newval); }
-
-    /**
-     * Returns the currently selected display orientation.
-     *
-     * @return a value among Y_ORIENTATION_LEFT, Y_ORIENTATION_UP, Y_ORIENTATION_RIGHT and
-     * Y_ORIENTATION_DOWN corresponding to the currently selected display orientation
-     *
-     * On failure, throws an exception or returns Y_ORIENTATION_INVALID.
-     */
-    Y_ORIENTATION_enum  get_orientation(void);
-
-    inline Y_ORIENTATION_enum orientation(void)
-    { return this->get_orientation(); }
-
-    /**
-     * Changes the display orientation. Remember to call the saveToFlash()
-     * method of the module if the modification must be kept.
-     *
-     * @param newval : a value among Y_ORIENTATION_LEFT, Y_ORIENTATION_UP, Y_ORIENTATION_RIGHT and
-     * Y_ORIENTATION_DOWN corresponding to the display orientation
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_orientation(Y_ORIENTATION_enum newval);
-    inline int      setOrientation(Y_ORIENTATION_enum newval)
-    { return this->set_orientation(newval); }
-
-    /**
-     * Returns the display width, in pixels.
-     *
-     * @return an integer corresponding to the display width, in pixels
-     *
-     * On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.
-     */
-    int                 get_displayWidth(void);
-
-    inline int          displayWidth(void)
-    { return this->get_displayWidth(); }
-
-    /**
-     * Returns the display height, in pixels.
-     *
-     * @return an integer corresponding to the display height, in pixels
-     *
-     * On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.
-     */
-    int                 get_displayHeight(void);
-
-    inline int          displayHeight(void)
-    { return this->get_displayHeight(); }
-
-    /**
-     * Returns the display type: monochrome, gray levels or full color.
-     *
-     * @return a value among Y_DISPLAYTYPE_MONO, Y_DISPLAYTYPE_GRAY and Y_DISPLAYTYPE_RGB corresponding to
-     * the display type: monochrome, gray levels or full color
-     *
-     * On failure, throws an exception or returns Y_DISPLAYTYPE_INVALID.
-     */
-    Y_DISPLAYTYPE_enum  get_displayType(void);
-
-    inline Y_DISPLAYTYPE_enum displayType(void)
-    { return this->get_displayType(); }
-
-    /**
-     * Returns the width of the layers to draw on, in pixels.
-     *
-     * @return an integer corresponding to the width of the layers to draw on, in pixels
-     *
-     * On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.
-     */
-    int                 get_layerWidth(void);
-
-    inline int          layerWidth(void)
-    { return this->get_layerWidth(); }
-
-    /**
-     * Returns the height of the layers to draw on, in pixels.
-     *
-     * @return an integer corresponding to the height of the layers to draw on, in pixels
-     *
-     * On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.
-     */
-    int                 get_layerHeight(void);
-
-    inline int          layerHeight(void)
-    { return this->get_layerHeight(); }
-
-    /**
-     * Returns the number of available layers to draw on.
-     *
-     * @return an integer corresponding to the number of available layers to draw on
-     *
-     * On failure, throws an exception or returns Y_LAYERCOUNT_INVALID.
-     */
-    int                 get_layerCount(void);
-
-    inline int          layerCount(void)
-    { return this->get_layerCount(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a display for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the display is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YDisplay.isOnline() to test if the display is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a display by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the display
-     *
-     * @return a YDisplay object allowing you to drive the display.
-     */
-    static YDisplay*    FindDisplay(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YDisplayValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Clears the display screen and resets all display layers to their default state.
-     * Using this function in a sequence will kill the sequence play-back. Don't use that
-     * function to reset the display at sequence start-up.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetAll(void);
-
-    /**
-     * Smoothly changes the brightness of the screen to produce a fade-in or fade-out
-     * effect.
-     *
-     * @param brightness : the new screen brightness
-     * @param duration : duration of the brightness transition, in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         fade(int brightness,int duration);
-
-    /**
-     * Starts to record all display commands into a sequence, for later replay.
-     * The name used to store the sequence is specified when calling
-     * saveSequence(), once the recording is complete.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         newSequence(void);
-
-    /**
-     * Stops recording display commands and saves the sequence into the specified
-     * file on the display internal memory. The sequence can be later replayed
-     * using playSequence().
-     *
-     * @param sequenceName : the name of the newly created sequence
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         saveSequence(string sequenceName);
-
-    /**
-     * Replays a display sequence previously recorded using
-     * newSequence() and saveSequence().
-     *
-     * @param sequenceName : the name of the newly created sequence
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         playSequence(string sequenceName);
-
-    /**
-     * Waits for a specified delay (in milliseconds) before playing next
-     * commands in current sequence. This method can be used while
-     * recording a display sequence, to insert a timed wait in the sequence
-     * (without any immediate effect). It can also be used dynamically while
-     * playing a pre-recorded sequence, to suspend or resume the execution of
-     * the sequence. To cancel a delay, call the same method with a zero delay.
-     *
-     * @param delay_ms : the duration to wait, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pauseSequence(int delay_ms);
-
-    /**
-     * Stops immediately any ongoing sequence replay.
-     * The display is left as is.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         stopSequence(void);
-
-    /**
-     * Uploads an arbitrary file (for instance a GIF file) to the display, to the
-     * specified full path name. If a file already exists with the same path name,
-     * its content is overwritten.
-     *
-     * @param pathname : path and name of the new file to create
-     * @param content : binary buffer with the content to set
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         upload(string pathname,string content);
-
-    /**
-     * Copies the whole content of a layer to another layer. The color and transparency
-     * of all the pixels from the destination layer are set to match the source pixels.
-     * This method only affects the displayed content, but does not change any
-     * property of the layer object.
-     * Note that layer 0 has no transparency support (it is always completely opaque).
-     *
-     * @param srcLayerId : the identifier of the source layer (a number in range 0..layerCount-1)
-     * @param dstLayerId : the identifier of the destination layer (a number in range 0..layerCount-1)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         copyLayerContent(int srcLayerId,int dstLayerId);
-
-    /**
-     * Swaps the whole content of two layers. The color and transparency of all the pixels from
-     * the two layers are swapped. This method only affects the displayed content, but does
-     * not change any property of the layer objects. In particular, the visibility of each
-     * layer stays unchanged. When used between one hidden layer and a visible layer,
-     * this method makes it possible to easily implement double-buffering.
-     * Note that layer 0 has no transparency support (it is always completely opaque).
-     *
-     * @param layerIdA : the first layer (a number in range 0..layerCount-1)
-     * @param layerIdB : the second layer (a number in range 0..layerCount-1)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         swapLayerContent(int layerIdA,int layerIdB);
-
-
-    inline static YDisplay* Find(string func)
-    { return YDisplay::FindDisplay(func); }
-
-    /**
-     * Continues the enumeration of displays started using yFirstDisplay().
-     * Caution: You can't make any assumption about the returned displays order.
-     * If you want to find a specific a display, use Display.findDisplay()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YDisplay object, corresponding to
-     *         a display currently online, or a NULL pointer
-     *         if there are no more displays to enumerate.
-     */
-           YDisplay        *nextDisplay(void);
-    inline YDisplay        *next(void)
-    { return this->nextDisplay();}
-
-    /**
-     * Starts the enumeration of displays currently accessible.
-     * Use the method YDisplay.nextDisplay() to iterate on
-     * next displays.
-     *
-     * @return a pointer to a YDisplay object, corresponding to
-     *         the first display currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YDisplay* FirstDisplay(void);
-    inline static YDisplay* First(void)
-    { return YDisplay::FirstDisplay();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YDisplay accessors declaration)
-
-
-
-
-
-    /**
-     * Returns a YDisplayLayer object that can be used to draw on the specified
-     * layer. The content is displayed only when the layer is active on the
-     * screen (and not masked by other overlapping layers).
-     *
-     * @param layerId : the identifier of the layer (a number in range 0..layerCount-1)
-     *
-     * @return an YDisplayLayer object
-     *
-     * On failure, throws an exception or returns NULL.
-     */
-    YDisplayLayer* get_displayLayer(unsigned layerId);
-
-
-    int flushLayers(void);
-
-    int sendCommand(string cmd);
-
-    // internal function to clear hidden flag during resetAll
-    void resetHiddenLayerFlags(void);
-};
-
-//--- (generated code: YDisplay functions declaration)
-
-/**
- * Retrieves a display for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the display is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDisplay.isOnline() to test if the display is
- * indeed online at a given time. In case of ambiguity when looking for
- * a display by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the display
- *
- * @return a YDisplay object allowing you to drive the display.
- */
-inline YDisplay* yFindDisplay(const string& func)
-{ return YDisplay::FindDisplay(func);}
-/**
- * Starts the enumeration of displays currently accessible.
- * Use the method YDisplay.nextDisplay() to iterate on
- * next displays.
- *
- * @return a pointer to a YDisplay object, corresponding to
- *         the first display currently online, or a NULL pointer
- *         if there are none.
- */
-inline YDisplay* yFirstDisplay(void)
-{ return YDisplay::FirstDisplay();}
-
-//--- (end of generated code: YDisplay functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_dualpower.cpp
+++ /dev/null
@@ -1,316 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_dualpower.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindDualPower(), the high-level API for DualPower functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_dualpower.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "dualpower"
-
-YDualPower::YDualPower(const string& func): YFunction(func)
-//--- (YDualPower initialization)
-    ,_powerState(POWERSTATE_INVALID)
-    ,_powerControl(POWERCONTROL_INVALID)
-    ,_extVoltage(EXTVOLTAGE_INVALID)
-    ,_valueCallbackDualPower(NULL)
-//--- (end of YDualPower initialization)
-{
-    _className="DualPower";
-}
-
-YDualPower::~YDualPower()
-{
-//--- (YDualPower cleanup)
-//--- (end of YDualPower cleanup)
-}
-//--- (YDualPower implementation)
-// static attributes
-
-int YDualPower::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("powerState")) {
-        _powerState =  (Y_POWERSTATE_enum)json_val->getInt("powerState");
-    }
-    if(json_val->has("powerControl")) {
-        _powerControl =  (Y_POWERCONTROL_enum)json_val->getInt("powerControl");
-    }
-    if(json_val->has("extVoltage")) {
-        _extVoltage =  json_val->getInt("extVoltage");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current power source for module functions that require lots of current.
- *
- * @return a value among Y_POWERSTATE_OFF, Y_POWERSTATE_FROM_USB and Y_POWERSTATE_FROM_EXT
- * corresponding to the current power source for module functions that require lots of current
- *
- * On failure, throws an exception or returns Y_POWERSTATE_INVALID.
- */
-Y_POWERSTATE_enum YDualPower::get_powerState(void)
-{
-    Y_POWERSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDualPower::POWERSTATE_INVALID;
-                }
-            }
-        }
-        res = _powerState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the selected power source for module functions that require lots of current.
- *
- * @return a value among Y_POWERCONTROL_AUTO, Y_POWERCONTROL_FROM_USB, Y_POWERCONTROL_FROM_EXT and
- * Y_POWERCONTROL_OFF corresponding to the selected power source for module functions that require lots of current
- *
- * On failure, throws an exception or returns Y_POWERCONTROL_INVALID.
- */
-Y_POWERCONTROL_enum YDualPower::get_powerControl(void)
-{
-    Y_POWERCONTROL_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDualPower::POWERCONTROL_INVALID;
-                }
-            }
-        }
-        res = _powerControl;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the selected power source for module functions that require lots of current.
- *
- * @param newval : a value among Y_POWERCONTROL_AUTO, Y_POWERCONTROL_FROM_USB, Y_POWERCONTROL_FROM_EXT
- * and Y_POWERCONTROL_OFF corresponding to the selected power source for module functions that require
- * lots of current
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YDualPower::set_powerControl(Y_POWERCONTROL_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("powerControl", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measured voltage on the external power source, in millivolts.
- *
- * @return an integer corresponding to the measured voltage on the external power source, in millivolts
- *
- * On failure, throws an exception or returns Y_EXTVOLTAGE_INVALID.
- */
-int YDualPower::get_extVoltage(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YDualPower::EXTVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _extVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a dual power control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the power control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDualPower.isOnline() to test if the power control is
- * indeed online at a given time. In case of ambiguity when looking for
- * a dual power control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the power control
- *
- * @return a YDualPower object allowing you to drive the power control.
- */
-YDualPower* YDualPower::FindDualPower(string func)
-{
-    YDualPower* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YDualPower*) YFunction::_FindFromCache("DualPower", func);
-        if (obj == NULL) {
-            obj = new YDualPower(func);
-            YFunction::_AddToCache("DualPower", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YDualPower::registerValueCallback(YDualPowerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackDualPower = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YDualPower::_invokeValueCallback(string value)
-{
-    if (_valueCallbackDualPower != NULL) {
-        _valueCallbackDualPower(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YDualPower *YDualPower::nextDualPower(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YDualPower::FindDualPower(hwid);
-}
-
-YDualPower* YDualPower::FirstDualPower(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("DualPower", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YDualPower::FindDualPower(serial+"."+funcId);
-}
-
-//--- (end of YDualPower implementation)
-
-//--- (YDualPower functions)
-//--- (end of YDualPower functions)
--- a/Sources/cpplib/yocto_dualpower.h
+++ /dev/null
@@ -1,306 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_dualpower.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindDualPower(), the high-level API for DualPower functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_DUALPOWER_H
-#define YOCTO_DUALPOWER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YDualPower return codes)
-//--- (end of YDualPower return codes)
-//--- (YDualPower yapiwrapper)
-//--- (end of YDualPower yapiwrapper)
-//--- (YDualPower definitions)
-class YDualPower; // forward declaration
-
-typedef void (*YDualPowerValueCallback)(YDualPower *func, const string& functionValue);
-#ifndef _Y_POWERSTATE_ENUM
-#define _Y_POWERSTATE_ENUM
-typedef enum {
-    Y_POWERSTATE_OFF = 0,
-    Y_POWERSTATE_FROM_USB = 1,
-    Y_POWERSTATE_FROM_EXT = 2,
-    Y_POWERSTATE_INVALID = -1,
-} Y_POWERSTATE_enum;
-#endif
-#ifndef _Y_POWERCONTROL_ENUM
-#define _Y_POWERCONTROL_ENUM
-typedef enum {
-    Y_POWERCONTROL_AUTO = 0,
-    Y_POWERCONTROL_FROM_USB = 1,
-    Y_POWERCONTROL_FROM_EXT = 2,
-    Y_POWERCONTROL_OFF = 3,
-    Y_POWERCONTROL_INVALID = -1,
-} Y_POWERCONTROL_enum;
-#endif
-#define Y_EXTVOLTAGE_INVALID            (YAPI_INVALID_UINT)
-//--- (end of YDualPower definitions)
-
-//--- (YDualPower declaration)
-/**
- * YDualPower Class: External power supply control interface
- *
- * Yoctopuce application programming interface allows you to control
- * the power source to use for module functions that require high current.
- * The module can also automatically disconnect the external power
- * when a voltage drop is observed on the external power source
- * (external battery running out of power).
- */
-class YOCTO_CLASS_EXPORT YDualPower: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YDualPower declaration)
-protected:
-    //--- (YDualPower attributes)
-    // Attributes (function value cache)
-    Y_POWERSTATE_enum _powerState;
-    Y_POWERCONTROL_enum _powerControl;
-    int             _extVoltage;
-    YDualPowerValueCallback _valueCallbackDualPower;
-
-    friend YDualPower *yFindDualPower(const string& func);
-    friend YDualPower *yFirstDualPower(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindDualPower factory function to instantiate
-    YDualPower(const string& func);
-    //--- (end of YDualPower attributes)
-
-public:
-    virtual ~YDualPower();
-    //--- (YDualPower accessors declaration)
-
-    static const Y_POWERSTATE_enum POWERSTATE_OFF = Y_POWERSTATE_OFF;
-    static const Y_POWERSTATE_enum POWERSTATE_FROM_USB = Y_POWERSTATE_FROM_USB;
-    static const Y_POWERSTATE_enum POWERSTATE_FROM_EXT = Y_POWERSTATE_FROM_EXT;
-    static const Y_POWERSTATE_enum POWERSTATE_INVALID = Y_POWERSTATE_INVALID;
-    static const Y_POWERCONTROL_enum POWERCONTROL_AUTO = Y_POWERCONTROL_AUTO;
-    static const Y_POWERCONTROL_enum POWERCONTROL_FROM_USB = Y_POWERCONTROL_FROM_USB;
-    static const Y_POWERCONTROL_enum POWERCONTROL_FROM_EXT = Y_POWERCONTROL_FROM_EXT;
-    static const Y_POWERCONTROL_enum POWERCONTROL_OFF = Y_POWERCONTROL_OFF;
-    static const Y_POWERCONTROL_enum POWERCONTROL_INVALID = Y_POWERCONTROL_INVALID;
-    static const int EXTVOLTAGE_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the current power source for module functions that require lots of current.
-     *
-     * @return a value among Y_POWERSTATE_OFF, Y_POWERSTATE_FROM_USB and Y_POWERSTATE_FROM_EXT
-     * corresponding to the current power source for module functions that require lots of current
-     *
-     * On failure, throws an exception or returns Y_POWERSTATE_INVALID.
-     */
-    Y_POWERSTATE_enum   get_powerState(void);
-
-    inline Y_POWERSTATE_enum powerState(void)
-    { return this->get_powerState(); }
-
-    /**
-     * Returns the selected power source for module functions that require lots of current.
-     *
-     * @return a value among Y_POWERCONTROL_AUTO, Y_POWERCONTROL_FROM_USB, Y_POWERCONTROL_FROM_EXT and
-     * Y_POWERCONTROL_OFF corresponding to the selected power source for module functions that require lots of current
-     *
-     * On failure, throws an exception or returns Y_POWERCONTROL_INVALID.
-     */
-    Y_POWERCONTROL_enum get_powerControl(void);
-
-    inline Y_POWERCONTROL_enum powerControl(void)
-    { return this->get_powerControl(); }
-
-    /**
-     * Changes the selected power source for module functions that require lots of current.
-     *
-     * @param newval : a value among Y_POWERCONTROL_AUTO, Y_POWERCONTROL_FROM_USB, Y_POWERCONTROL_FROM_EXT
-     * and Y_POWERCONTROL_OFF corresponding to the selected power source for module functions that require
-     * lots of current
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_powerControl(Y_POWERCONTROL_enum newval);
-    inline int      setPowerControl(Y_POWERCONTROL_enum newval)
-    { return this->set_powerControl(newval); }
-
-    /**
-     * Returns the measured voltage on the external power source, in millivolts.
-     *
-     * @return an integer corresponding to the measured voltage on the external power source, in millivolts
-     *
-     * On failure, throws an exception or returns Y_EXTVOLTAGE_INVALID.
-     */
-    int                 get_extVoltage(void);
-
-    inline int          extVoltage(void)
-    { return this->get_extVoltage(); }
-
-    /**
-     * Retrieves a dual power control for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the power control is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YDualPower.isOnline() to test if the power control is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a dual power control by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the power control
-     *
-     * @return a YDualPower object allowing you to drive the power control.
-     */
-    static YDualPower*  FindDualPower(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YDualPowerValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YDualPower* Find(string func)
-    { return YDualPower::FindDualPower(func); }
-
-    /**
-     * Continues the enumeration of dual power controls started using yFirstDualPower().
-     * Caution: You can't make any assumption about the returned dual power controls order.
-     * If you want to find a specific a dual power control, use DualPower.findDualPower()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YDualPower object, corresponding to
-     *         a dual power control currently online, or a NULL pointer
-     *         if there are no more dual power controls to enumerate.
-     */
-           YDualPower      *nextDualPower(void);
-    inline YDualPower      *next(void)
-    { return this->nextDualPower();}
-
-    /**
-     * Starts the enumeration of dual power controls currently accessible.
-     * Use the method YDualPower.nextDualPower() to iterate on
-     * next dual power controls.
-     *
-     * @return a pointer to a YDualPower object, corresponding to
-     *         the first dual power control currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YDualPower* FirstDualPower(void);
-    inline static YDualPower* First(void)
-    { return YDualPower::FirstDualPower();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YDualPower accessors declaration)
-};
-
-//--- (YDualPower functions declaration)
-
-/**
- * Retrieves a dual power control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the power control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YDualPower.isOnline() to test if the power control is
- * indeed online at a given time. In case of ambiguity when looking for
- * a dual power control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the power control
- *
- * @return a YDualPower object allowing you to drive the power control.
- */
-inline YDualPower* yFindDualPower(const string& func)
-{ return YDualPower::FindDualPower(func);}
-/**
- * Starts the enumeration of dual power controls currently accessible.
- * Use the method YDualPower.nextDualPower() to iterate on
- * next dual power controls.
- *
- * @return a pointer to a YDualPower object, corresponding to
- *         the first dual power control currently online, or a NULL pointer
- *         if there are none.
- */
-inline YDualPower* yFirstDualPower(void)
-{ return YDualPower::FirstDualPower();}
-
-//--- (end of YDualPower functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_files.cpp
+++ /dev/null
@@ -1,456 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_files.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- * Implements yFindFiles(), the high-level API for Files functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_files.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "files"
-
-
-YFileRecord::YFileRecord(const string& json):
-//--- (generated code: YFileRecord initialization)
-    _size(0)
-    ,_crc(0)
-//--- (end of generated code: YFileRecord initialization)
-{
-    yJsonStateMachine j;
-
-    // Parse JSON data
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if(yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return ;
-    }
-    while(yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "name")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return ;
-            }
-            _name = (string)j.token;
-            while(j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-                _name =(string)j.token;
-            }
-        } else if(!strcmp(j.token, "crc")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return;
-            }
-            _crc = atoi(j.token);;
-        } else if(!strcmp(j.token, "size")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return;
-            }
-            _size = atoi(j.token);;
-        } else {
-            yJsonSkip(&j, 1);
-        }
-    }
-}
-
-//--- (generated code: YFileRecord implementation)
-// static attributes
-
-
-string YFileRecord::get_name(void)
-{
-    return _name;
-}
-
-int YFileRecord::get_size(void)
-{
-    return _size;
-}
-
-int YFileRecord::get_crc(void)
-{
-    return _crc;
-}
-//--- (end of generated code: YFileRecord implementation)
-
-
-
-
-
-YFiles::YFiles(const string& func): YFunction(func)
-    //--- (generated code: YFiles initialization)
-    ,_filesCount(FILESCOUNT_INVALID)
-    ,_freeSpace(FREESPACE_INVALID)
-    ,_valueCallbackFiles(NULL)
-//--- (end of generated code: YFiles initialization)
-{
-    _className = "Files";
-}
-
-YFiles::~YFiles()
-{
-    //--- (generated code: YFiles cleanup)
-//--- (end of generated code: YFiles cleanup)
-}
-
-//--- (generated code: YFiles implementation)
-// static attributes
-
-int YFiles::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("filesCount")) {
-        _filesCount =  json_val->getInt("filesCount");
-    }
-    if(json_val->has("freeSpace")) {
-        _freeSpace =  json_val->getInt("freeSpace");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the number of files currently loaded in the filesystem.
- *
- * @return an integer corresponding to the number of files currently loaded in the filesystem
- *
- * On failure, throws an exception or returns Y_FILESCOUNT_INVALID.
- */
-int YFiles::get_filesCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YFiles::FILESCOUNT_INVALID;
-                }
-            }
-        }
-        res = _filesCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the free space for uploading new files to the filesystem, in bytes.
- *
- * @return an integer corresponding to the free space for uploading new files to the filesystem, in bytes
- *
- * On failure, throws an exception or returns Y_FREESPACE_INVALID.
- */
-int YFiles::get_freeSpace(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YFiles::FREESPACE_INVALID;
-                }
-            }
-        }
-        res = _freeSpace;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a filesystem for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the filesystem is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YFiles.isOnline() to test if the filesystem is
- * indeed online at a given time. In case of ambiguity when looking for
- * a filesystem by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the filesystem
- *
- * @return a YFiles object allowing you to drive the filesystem.
- */
-YFiles* YFiles::FindFiles(string func)
-{
-    YFiles* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YFiles*) YFunction::_FindFromCache("Files", func);
-        if (obj == NULL) {
-            obj = new YFiles(func);
-            YFunction::_AddToCache("Files", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YFiles::registerValueCallback(YFilesValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackFiles = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YFiles::_invokeValueCallback(string value)
-{
-    if (_valueCallbackFiles != NULL) {
-        _valueCallbackFiles(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-string YFiles::sendCommand(string command)
-{
-    string url;
-    url = YapiWrapper::ysprintf("files.json?a=%s",command.c_str());
-
-    return this->_download(url);
-}
-
-/**
- * Reinitialize the filesystem to its clean, unfragmented, empty state.
- * All files previously uploaded are permanently lost.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFiles::format_fs(void)
-{
-    string json;
-    string res;
-    json = this->sendCommand("format");
-    res = this->_json_get_key(json, "res");
-    if (!(res == "ok")) {
-        _throw(YAPI_IO_ERROR,"format failed");
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns a list of YFileRecord objects that describe files currently loaded
- * in the filesystem.
- *
- * @param pattern : an optional filter pattern, using star and question marks
- *         as wild cards. When an empty pattern is provided, all file records
- *         are returned.
- *
- * @return a list of YFileRecord objects, containing the file path
- *         and name, byte size and 32-bit CRC of the file content.
- *
- * On failure, throws an exception or returns an empty list.
- */
-vector<YFileRecord> YFiles::get_list(string pattern)
-{
-    string json;
-    vector<string> filelist;
-    vector<YFileRecord> res;
-    json = this->sendCommand(YapiWrapper::ysprintf("dir&f=%s",pattern.c_str()));
-    filelist = this->_json_get_array(json);
-    res.clear();
-    for (unsigned ii = 0; ii < filelist.size(); ii++) {
-        res.push_back(YFileRecord(filelist[ii]));
-    }
-    return res;
-}
-
-/**
- * Test if a file exist on the filesystem of the module.
- *
- * @param filename : the file name to test.
- *
- * @return a true if the file exist, false otherwise.
- *
- * On failure, throws an exception.
- */
-bool YFiles::fileExist(string filename)
-{
-    string json;
-    vector<string> filelist;
-    if ((int)(filename).length() == 0) {
-        return false;
-    }
-    json = this->sendCommand(YapiWrapper::ysprintf("dir&f=%s",filename.c_str()));
-    filelist = this->_json_get_array(json);
-    if ((int)filelist.size() > 0) {
-        return true;
-    }
-    return false;
-}
-
-/**
- * Downloads the requested file and returns a binary buffer with its content.
- *
- * @param pathname : path and name of the file to download
- *
- * @return a binary buffer with the file content
- *
- * On failure, throws an exception or returns an empty content.
- */
-string YFiles::download(string pathname)
-{
-    return this->_download(pathname);
-}
-
-/**
- * Uploads a file to the filesystem, to the specified full path name.
- * If a file already exists with the same path name, its content is overwritten.
- *
- * @param pathname : path and name of the new file to create
- * @param content : binary buffer with the content to set
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFiles::upload(string pathname,string content)
-{
-    return this->_upload(pathname, content);
-}
-
-/**
- * Deletes a file, given by its full path name, from the filesystem.
- * Because of filesystem fragmentation, deleting a file may not always
- * free up the whole space used by the file. However, rewriting a file
- * with the same path name will always reuse any space not freed previously.
- * If you need to ensure that no space is taken by previously deleted files,
- * you can use format_fs to fully reinitialize the filesystem.
- *
- * @param pathname : path and name of the file to remove.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YFiles::remove(string pathname)
-{
-    string json;
-    string res;
-    json = this->sendCommand(YapiWrapper::ysprintf("del&f=%s",pathname.c_str()));
-    res  = this->_json_get_key(json, "res");
-    if (!(res == "ok")) {
-        _throw(YAPI_IO_ERROR,"unable to remove file");
-        return YAPI_IO_ERROR;
-    }
-    return YAPI_SUCCESS;
-}
-
-YFiles *YFiles::nextFiles(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YFiles::FindFiles(hwid);
-}
-
-YFiles* YFiles::FirstFiles(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Files", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YFiles::FindFiles(serial+"."+funcId);
-}
-
-//--- (end of generated code: YFiles implementation)
-
-//--- (generated code: YFiles functions)
-//--- (end of generated code: YFiles functions)
--- a/Sources/cpplib/yocto_files.h
+++ /dev/null
@@ -1,375 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_files.h 33710 2018-12-14 14:18:53Z seb $
- *
- * Declares yFindFiles(), the high-level API for Files functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_FILES_H
-#define YOCTO_FILES_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (generated code: YFiles definitions)
-class YFiles; // forward declaration
-
-typedef void (*YFilesValueCallback)(YFiles *func, const string& functionValue);
-#define Y_FILESCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_FREESPACE_INVALID             (YAPI_INVALID_UINT)
-//--- (end of generated code: YFiles definitions)
-
-
-//--- (generated code: YFileRecord definitions)
-//--- (end of generated code: YFileRecord definitions)
-
-
-//--- (generated code: YFileRecord declaration)
-/**
- * YFileRecord Class: Description of a file on the device filesystem
- *
- *
- */
-class YOCTO_CLASS_EXPORT YFileRecord {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YFileRecord declaration)
-    //--- (generated code: YFileRecord attributes)
-    // Attributes (function value cache)
-    string          _name;
-    int             _size;
-    int             _crc;
-    //--- (end of generated code: YFileRecord attributes)
-    //--- (generated code: YFileRecord constructor)
-
-    //--- (end of generated code: YFileRecord constructor)
-    //--- (generated code: YFileRecord initialization)
-    //--- (end of generated code: YFileRecord initialization)
-
-public:
-    YFileRecord(const string& json);
-    virtual ~YFileRecord(){};
-    //--- (generated code: YFileRecord accessors declaration)
-
-
-    virtual string      get_name(void);
-
-    virtual int         get_size(void);
-
-    virtual int         get_crc(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YFileRecord accessors declaration)
-};
-
-
-
-
-
-//--- (generated code: YFiles declaration)
-/**
- * YFiles Class: Files function interface
- *
- * The filesystem interface makes it possible to store files
- * on some devices, for instance to design a custom web UI
- * (for networked devices) or to add fonts (on display
- * devices).
- */
-class YOCTO_CLASS_EXPORT YFiles: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YFiles declaration)
-    //--- (generated code: YFiles attributes)
-    // Attributes (function value cache)
-    int             _filesCount;
-    int             _freeSpace;
-    YFilesValueCallback _valueCallbackFiles;
-
-    friend YFiles *yFindFiles(const string& func);
-    friend YFiles *yFirstFiles(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindFiles factory function to instantiate
-    YFiles(const string& func);
-    //--- (end of generated code: YFiles attributes)
-
-    //--- (generated code: YFiles initialization)
-    //--- (end of generated code: YFiles initialization)
-
-public:
-    ~YFiles();
-    //--- (generated code: YFiles accessors declaration)
-
-    static const int FILESCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int FREESPACE_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the number of files currently loaded in the filesystem.
-     *
-     * @return an integer corresponding to the number of files currently loaded in the filesystem
-     *
-     * On failure, throws an exception or returns Y_FILESCOUNT_INVALID.
-     */
-    int                 get_filesCount(void);
-
-    inline int          filesCount(void)
-    { return this->get_filesCount(); }
-
-    /**
-     * Returns the free space for uploading new files to the filesystem, in bytes.
-     *
-     * @return an integer corresponding to the free space for uploading new files to the filesystem, in bytes
-     *
-     * On failure, throws an exception or returns Y_FREESPACE_INVALID.
-     */
-    int                 get_freeSpace(void);
-
-    inline int          freeSpace(void)
-    { return this->get_freeSpace(); }
-
-    /**
-     * Retrieves a filesystem for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the filesystem is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YFiles.isOnline() to test if the filesystem is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a filesystem by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the filesystem
-     *
-     * @return a YFiles object allowing you to drive the filesystem.
-     */
-    static YFiles*      FindFiles(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YFilesValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual string      sendCommand(string command);
-
-    /**
-     * Reinitialize the filesystem to its clean, unfragmented, empty state.
-     * All files previously uploaded are permanently lost.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         format_fs(void);
-
-    /**
-     * Returns a list of YFileRecord objects that describe files currently loaded
-     * in the filesystem.
-     *
-     * @param pattern : an optional filter pattern, using star and question marks
-     *         as wild cards. When an empty pattern is provided, all file records
-     *         are returned.
-     *
-     * @return a list of YFileRecord objects, containing the file path
-     *         and name, byte size and 32-bit CRC of the file content.
-     *
-     * On failure, throws an exception or returns an empty list.
-     */
-    virtual vector<YFileRecord> get_list(string pattern);
-
-    /**
-     * Test if a file exist on the filesystem of the module.
-     *
-     * @param filename : the file name to test.
-     *
-     * @return a true if the file exist, false otherwise.
-     *
-     * On failure, throws an exception.
-     */
-    virtual bool        fileExist(string filename);
-
-    /**
-     * Downloads the requested file and returns a binary buffer with its content.
-     *
-     * @param pathname : path and name of the file to download
-     *
-     * @return a binary buffer with the file content
-     *
-     * On failure, throws an exception or returns an empty content.
-     */
-    virtual string      download(string pathname);
-
-    /**
-     * Uploads a file to the filesystem, to the specified full path name.
-     * If a file already exists with the same path name, its content is overwritten.
-     *
-     * @param pathname : path and name of the new file to create
-     * @param content : binary buffer with the content to set
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         upload(string pathname,string content);
-
-    /**
-     * Deletes a file, given by its full path name, from the filesystem.
-     * Because of filesystem fragmentation, deleting a file may not always
-     * free up the whole space used by the file. However, rewriting a file
-     * with the same path name will always reuse any space not freed previously.
-     * If you need to ensure that no space is taken by previously deleted files,
-     * you can use format_fs to fully reinitialize the filesystem.
-     *
-     * @param pathname : path and name of the file to remove.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         remove(string pathname);
-
-
-    inline static YFiles* Find(string func)
-    { return YFiles::FindFiles(func); }
-
-    /**
-     * Continues the enumeration of filesystems started using yFirstFiles().
-     * Caution: You can't make any assumption about the returned filesystems order.
-     * If you want to find a specific a filesystem, use Files.findFiles()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YFiles object, corresponding to
-     *         a filesystem currently online, or a NULL pointer
-     *         if there are no more filesystems to enumerate.
-     */
-           YFiles          *nextFiles(void);
-    inline YFiles          *next(void)
-    { return this->nextFiles();}
-
-    /**
-     * Starts the enumeration of filesystems currently accessible.
-     * Use the method YFiles.nextFiles() to iterate on
-     * next filesystems.
-     *
-     * @return a pointer to a YFiles object, corresponding to
-     *         the first filesystem currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YFiles* FirstFiles(void);
-    inline static YFiles* First(void)
-    { return YFiles::FirstFiles();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YFiles accessors declaration)
-};
-
-//--- (generated code: YFiles functions declaration)
-
-/**
- * Retrieves a filesystem for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the filesystem is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YFiles.isOnline() to test if the filesystem is
- * indeed online at a given time. In case of ambiguity when looking for
- * a filesystem by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the filesystem
- *
- * @return a YFiles object allowing you to drive the filesystem.
- */
-inline YFiles* yFindFiles(const string& func)
-{ return YFiles::FindFiles(func);}
-/**
- * Starts the enumeration of filesystems currently accessible.
- * Use the method YFiles.nextFiles() to iterate on
- * next filesystems.
- *
- * @return a pointer to a YFiles object, corresponding to
- *         the first filesystem currently online, or a NULL pointer
- *         if there are none.
- */
-inline YFiles* yFirstFiles(void)
-{ return YFiles::FirstFiles();}
-
-//--- (end of generated code: YFiles functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_genericsensor.cpp
+++ /dev/null
@@ -1,590 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_genericsensor.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindGenericSensor(), the high-level API for GenericSensor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_genericsensor.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "genericsensor"
-
-YGenericSensor::YGenericSensor(const string& func): YSensor(func)
-//--- (YGenericSensor initialization)
-    ,_signalValue(SIGNALVALUE_INVALID)
-    ,_signalUnit(SIGNALUNIT_INVALID)
-    ,_signalRange(SIGNALRANGE_INVALID)
-    ,_valueRange(VALUERANGE_INVALID)
-    ,_signalBias(SIGNALBIAS_INVALID)
-    ,_signalSampling(SIGNALSAMPLING_INVALID)
-    ,_valueCallbackGenericSensor(NULL)
-    ,_timedReportCallbackGenericSensor(NULL)
-//--- (end of YGenericSensor initialization)
-{
-    _className="GenericSensor";
-}
-
-YGenericSensor::~YGenericSensor()
-{
-//--- (YGenericSensor cleanup)
-//--- (end of YGenericSensor cleanup)
-}
-//--- (YGenericSensor implementation)
-// static attributes
-const double YGenericSensor::SIGNALVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const string YGenericSensor::SIGNALUNIT_INVALID = YAPI_INVALID_STRING;
-const string YGenericSensor::SIGNALRANGE_INVALID = YAPI_INVALID_STRING;
-const string YGenericSensor::VALUERANGE_INVALID = YAPI_INVALID_STRING;
-const double YGenericSensor::SIGNALBIAS_INVALID = YAPI_INVALID_DOUBLE;
-
-int YGenericSensor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("signalValue")) {
-        _signalValue =  floor(json_val->getDouble("signalValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("signalUnit")) {
-        _signalUnit =  json_val->getString("signalUnit");
-    }
-    if(json_val->has("signalRange")) {
-        _signalRange =  json_val->getString("signalRange");
-    }
-    if(json_val->has("valueRange")) {
-        _valueRange =  json_val->getString("valueRange");
-    }
-    if(json_val->has("signalBias")) {
-        _signalBias =  floor(json_val->getDouble("signalBias") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("signalSampling")) {
-        _signalSampling =  (Y_SIGNALSAMPLING_enum)json_val->getInt("signalSampling");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the measured value.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the measuring unit for the measured value
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current value of the electrical signal measured by the sensor.
- *
- * @return a floating point number corresponding to the current value of the electrical signal
- * measured by the sensor
- *
- * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
- */
-double YGenericSensor::get_signalValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::SIGNALVALUE_INVALID;
-                }
-            }
-        }
-        res = floor(_signalValue * 1000+0.5) / 1000;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measuring unit of the electrical signal used by the sensor.
- *
- * @return a string corresponding to the measuring unit of the electrical signal used by the sensor
- *
- * On failure, throws an exception or returns Y_SIGNALUNIT_INVALID.
- */
-string YGenericSensor::get_signalUnit(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::SIGNALUNIT_INVALID;
-                }
-            }
-        }
-        res = _signalUnit;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the electric signal range used by the sensor.
- *
- * @return a string corresponding to the electric signal range used by the sensor
- *
- * On failure, throws an exception or returns Y_SIGNALRANGE_INVALID.
- */
-string YGenericSensor::get_signalRange(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::SIGNALRANGE_INVALID;
-                }
-            }
-        }
-        res = _signalRange;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the electric signal range used by the sensor. Default value is "-999999.999...999999.999".
- *
- * @param newval : a string corresponding to the electric signal range used by the sensor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::set_signalRange(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("signalRange", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the physical value range measured by the sensor.
- *
- * @return a string corresponding to the physical value range measured by the sensor
- *
- * On failure, throws an exception or returns Y_VALUERANGE_INVALID.
- */
-string YGenericSensor::get_valueRange(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::VALUERANGE_INVALID;
-                }
-            }
-        }
-        res = _valueRange;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the physical value range measured by the sensor. As a side effect, the range modification may
- * automatically modify the display resolution. Default value is "-999999.999...999999.999".
- *
- * @param newval : a string corresponding to the physical value range measured by the sensor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::set_valueRange(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("valueRange", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the electric signal bias for zero shift adjustment.
- * If your electric signal reads positive when it should be zero, setup
- * a positive signalBias of the same value to fix the zero shift.
- *
- * @param newval : a floating point number corresponding to the electric signal bias for zero shift adjustment
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::set_signalBias(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("signalBias", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the electric signal bias for zero shift adjustment.
- * A positive bias means that the signal is over-reporting the measure,
- * while a negative bias means that the signal is under-reporting the measure.
- *
- * @return a floating point number corresponding to the electric signal bias for zero shift adjustment
- *
- * On failure, throws an exception or returns Y_SIGNALBIAS_INVALID.
- */
-double YGenericSensor::get_signalBias(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::SIGNALBIAS_INVALID;
-                }
-            }
-        }
-        res = _signalBias;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the electric signal sampling method to use.
- * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
- * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
- * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
- * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
- * to get measures as stable as possible when working on a noisy signal.
- *
- * @return a value among Y_SIGNALSAMPLING_HIGH_RATE, Y_SIGNALSAMPLING_HIGH_RATE_FILTERED,
- * Y_SIGNALSAMPLING_LOW_NOISE, Y_SIGNALSAMPLING_LOW_NOISE_FILTERED and Y_SIGNALSAMPLING_HIGHEST_RATE
- * corresponding to the electric signal sampling method to use
- *
- * On failure, throws an exception or returns Y_SIGNALSAMPLING_INVALID.
- */
-Y_SIGNALSAMPLING_enum YGenericSensor::get_signalSampling(void)
-{
-    Y_SIGNALSAMPLING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGenericSensor::SIGNALSAMPLING_INVALID;
-                }
-            }
-        }
-        res = _signalSampling;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the electric signal sampling method to use.
- * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
- * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
- * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
- * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
- * to get measures as stable as possible when working on a noisy signal.
- *
- * @param newval : a value among Y_SIGNALSAMPLING_HIGH_RATE, Y_SIGNALSAMPLING_HIGH_RATE_FILTERED,
- * Y_SIGNALSAMPLING_LOW_NOISE, Y_SIGNALSAMPLING_LOW_NOISE_FILTERED and Y_SIGNALSAMPLING_HIGHEST_RATE
- * corresponding to the electric signal sampling method to use
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::set_signalSampling(Y_SIGNALSAMPLING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("signalSampling", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a generic sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the generic sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGenericSensor.isOnline() to test if the generic sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a generic sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the generic sensor
- *
- * @return a YGenericSensor object allowing you to drive the generic sensor.
- */
-YGenericSensor* YGenericSensor::FindGenericSensor(string func)
-{
-    YGenericSensor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YGenericSensor*) YFunction::_FindFromCache("GenericSensor", func);
-        if (obj == NULL) {
-            obj = new YGenericSensor(func);
-            YFunction::_AddToCache("GenericSensor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YGenericSensor::registerValueCallback(YGenericSensorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackGenericSensor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YGenericSensor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackGenericSensor != NULL) {
-        _valueCallbackGenericSensor(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YGenericSensor::registerTimedReportCallback(YGenericSensorTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackGenericSensor = callback;
-    return 0;
-}
-
-int YGenericSensor::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackGenericSensor != NULL) {
-        _timedReportCallbackGenericSensor(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Adjusts the signal bias so that the current signal value is need
- * precisely as zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGenericSensor::zeroAdjust(void)
-{
-    double currSignal = 0.0;
-    double currBias = 0.0;
-    currSignal = this->get_signalValue();
-    currBias = this->get_signalBias();
-    return this->set_signalBias(currSignal + currBias);
-}
-
-YGenericSensor *YGenericSensor::nextGenericSensor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YGenericSensor::FindGenericSensor(hwid);
-}
-
-YGenericSensor* YGenericSensor::FirstGenericSensor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("GenericSensor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YGenericSensor::FindGenericSensor(serial+"."+funcId);
-}
-
-//--- (end of YGenericSensor implementation)
-
-//--- (YGenericSensor functions)
-//--- (end of YGenericSensor functions)
--- a/Sources/cpplib/yocto_genericsensor.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_genericsensor.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindGenericSensor(), the high-level API for GenericSensor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_GENERICSENSOR_H
-#define YOCTO_GENERICSENSOR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YGenericSensor return codes)
-//--- (end of YGenericSensor return codes)
-//--- (YGenericSensor yapiwrapper)
-//--- (end of YGenericSensor yapiwrapper)
-//--- (YGenericSensor definitions)
-class YGenericSensor; // forward declaration
-
-typedef void (*YGenericSensorValueCallback)(YGenericSensor *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YGenericSensorTimedReportCallback)(YGenericSensor *func, YMeasure measure);
-#ifndef _Y_SIGNALSAMPLING_ENUM
-#define _Y_SIGNALSAMPLING_ENUM
-typedef enum {
-    Y_SIGNALSAMPLING_HIGH_RATE = 0,
-    Y_SIGNALSAMPLING_HIGH_RATE_FILTERED = 1,
-    Y_SIGNALSAMPLING_LOW_NOISE = 2,
-    Y_SIGNALSAMPLING_LOW_NOISE_FILTERED = 3,
-    Y_SIGNALSAMPLING_HIGHEST_RATE = 4,
-    Y_SIGNALSAMPLING_INVALID = -1,
-} Y_SIGNALSAMPLING_enum;
-#endif
-#define Y_SIGNALVALUE_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_SIGNALUNIT_INVALID            (YAPI_INVALID_STRING)
-#define Y_SIGNALRANGE_INVALID           (YAPI_INVALID_STRING)
-#define Y_VALUERANGE_INVALID            (YAPI_INVALID_STRING)
-#define Y_SIGNALBIAS_INVALID            (YAPI_INVALID_DOUBLE)
-//--- (end of YGenericSensor definitions)
-
-//--- (YGenericSensor declaration)
-/**
- * YGenericSensor Class: GenericSensor function interface
- *
- * The YGenericSensor class allows you to read and configure Yoctopuce signal
- * transducers. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to configure the automatic conversion between the
- * measured signal and the corresponding engineering unit.
- */
-class YOCTO_CLASS_EXPORT YGenericSensor: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YGenericSensor declaration)
-protected:
-    //--- (YGenericSensor attributes)
-    // Attributes (function value cache)
-    double          _signalValue;
-    string          _signalUnit;
-    string          _signalRange;
-    string          _valueRange;
-    double          _signalBias;
-    Y_SIGNALSAMPLING_enum _signalSampling;
-    YGenericSensorValueCallback _valueCallbackGenericSensor;
-    YGenericSensorTimedReportCallback _timedReportCallbackGenericSensor;
-
-    friend YGenericSensor *yFindGenericSensor(const string& func);
-    friend YGenericSensor *yFirstGenericSensor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindGenericSensor factory function to instantiate
-    YGenericSensor(const string& func);
-    //--- (end of YGenericSensor attributes)
-
-public:
-    virtual ~YGenericSensor();
-    //--- (YGenericSensor accessors declaration)
-
-    static const double SIGNALVALUE_INVALID;
-    static const string SIGNALUNIT_INVALID;
-    static const string SIGNALRANGE_INVALID;
-    static const string VALUERANGE_INVALID;
-    static const double SIGNALBIAS_INVALID;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_HIGH_RATE = Y_SIGNALSAMPLING_HIGH_RATE;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_HIGH_RATE_FILTERED = Y_SIGNALSAMPLING_HIGH_RATE_FILTERED;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_LOW_NOISE = Y_SIGNALSAMPLING_LOW_NOISE;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_LOW_NOISE_FILTERED = Y_SIGNALSAMPLING_LOW_NOISE_FILTERED;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_HIGHEST_RATE = Y_SIGNALSAMPLING_HIGHEST_RATE;
-    static const Y_SIGNALSAMPLING_enum SIGNALSAMPLING_INVALID = Y_SIGNALSAMPLING_INVALID;
-
-    /**
-     * Changes the measuring unit for the measured value.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the measuring unit for the measured value
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the current value of the electrical signal measured by the sensor.
-     *
-     * @return a floating point number corresponding to the current value of the electrical signal
-     * measured by the sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
-     */
-    double              get_signalValue(void);
-
-    inline double       signalValue(void)
-    { return this->get_signalValue(); }
-
-    /**
-     * Returns the measuring unit of the electrical signal used by the sensor.
-     *
-     * @return a string corresponding to the measuring unit of the electrical signal used by the sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALUNIT_INVALID.
-     */
-    string              get_signalUnit(void);
-
-    inline string       signalUnit(void)
-    { return this->get_signalUnit(); }
-
-    /**
-     * Returns the electric signal range used by the sensor.
-     *
-     * @return a string corresponding to the electric signal range used by the sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALRANGE_INVALID.
-     */
-    string              get_signalRange(void);
-
-    inline string       signalRange(void)
-    { return this->get_signalRange(); }
-
-    /**
-     * Changes the electric signal range used by the sensor. Default value is "-999999.999...999999.999".
-     *
-     * @param newval : a string corresponding to the electric signal range used by the sensor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_signalRange(const string& newval);
-    inline int      setSignalRange(const string& newval)
-    { return this->set_signalRange(newval); }
-
-    /**
-     * Returns the physical value range measured by the sensor.
-     *
-     * @return a string corresponding to the physical value range measured by the sensor
-     *
-     * On failure, throws an exception or returns Y_VALUERANGE_INVALID.
-     */
-    string              get_valueRange(void);
-
-    inline string       valueRange(void)
-    { return this->get_valueRange(); }
-
-    /**
-     * Changes the physical value range measured by the sensor. As a side effect, the range modification may
-     * automatically modify the display resolution. Default value is "-999999.999...999999.999".
-     *
-     * @param newval : a string corresponding to the physical value range measured by the sensor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_valueRange(const string& newval);
-    inline int      setValueRange(const string& newval)
-    { return this->set_valueRange(newval); }
-
-    /**
-     * Changes the electric signal bias for zero shift adjustment.
-     * If your electric signal reads positive when it should be zero, setup
-     * a positive signalBias of the same value to fix the zero shift.
-     *
-     * @param newval : a floating point number corresponding to the electric signal bias for zero shift adjustment
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_signalBias(double newval);
-    inline int      setSignalBias(double newval)
-    { return this->set_signalBias(newval); }
-
-    /**
-     * Returns the electric signal bias for zero shift adjustment.
-     * A positive bias means that the signal is over-reporting the measure,
-     * while a negative bias means that the signal is under-reporting the measure.
-     *
-     * @return a floating point number corresponding to the electric signal bias for zero shift adjustment
-     *
-     * On failure, throws an exception or returns Y_SIGNALBIAS_INVALID.
-     */
-    double              get_signalBias(void);
-
-    inline double       signalBias(void)
-    { return this->get_signalBias(); }
-
-    /**
-     * Returns the electric signal sampling method to use.
-     * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
-     * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
-     * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
-     * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
-     * to get measures as stable as possible when working on a noisy signal.
-     *
-     * @return a value among Y_SIGNALSAMPLING_HIGH_RATE, Y_SIGNALSAMPLING_HIGH_RATE_FILTERED,
-     * Y_SIGNALSAMPLING_LOW_NOISE, Y_SIGNALSAMPLING_LOW_NOISE_FILTERED and Y_SIGNALSAMPLING_HIGHEST_RATE
-     * corresponding to the electric signal sampling method to use
-     *
-     * On failure, throws an exception or returns Y_SIGNALSAMPLING_INVALID.
-     */
-    Y_SIGNALSAMPLING_enum get_signalSampling(void);
-
-    inline Y_SIGNALSAMPLING_enum signalSampling(void)
-    { return this->get_signalSampling(); }
-
-    /**
-     * Changes the electric signal sampling method to use.
-     * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
-     * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
-     * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
-     * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
-     * to get measures as stable as possible when working on a noisy signal.
-     *
-     * @param newval : a value among Y_SIGNALSAMPLING_HIGH_RATE, Y_SIGNALSAMPLING_HIGH_RATE_FILTERED,
-     * Y_SIGNALSAMPLING_LOW_NOISE, Y_SIGNALSAMPLING_LOW_NOISE_FILTERED and Y_SIGNALSAMPLING_HIGHEST_RATE
-     * corresponding to the electric signal sampling method to use
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_signalSampling(Y_SIGNALSAMPLING_enum newval);
-    inline int      setSignalSampling(Y_SIGNALSAMPLING_enum newval)
-    { return this->set_signalSampling(newval); }
-
-    /**
-     * Retrieves a generic sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the generic sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YGenericSensor.isOnline() to test if the generic sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a generic sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the generic sensor
-     *
-     * @return a YGenericSensor object allowing you to drive the generic sensor.
-     */
-    static YGenericSensor* FindGenericSensor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YGenericSensorValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YGenericSensorTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Adjusts the signal bias so that the current signal value is need
-     * precisely as zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         zeroAdjust(void);
-
-
-    inline static YGenericSensor* Find(string func)
-    { return YGenericSensor::FindGenericSensor(func); }
-
-    /**
-     * Continues the enumeration of generic sensors started using yFirstGenericSensor().
-     * Caution: You can't make any assumption about the returned generic sensors order.
-     * If you want to find a specific a generic sensor, use GenericSensor.findGenericSensor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YGenericSensor object, corresponding to
-     *         a generic sensor currently online, or a NULL pointer
-     *         if there are no more generic sensors to enumerate.
-     */
-           YGenericSensor  *nextGenericSensor(void);
-    inline YGenericSensor  *next(void)
-    { return this->nextGenericSensor();}
-
-    /**
-     * Starts the enumeration of generic sensors currently accessible.
-     * Use the method YGenericSensor.nextGenericSensor() to iterate on
-     * next generic sensors.
-     *
-     * @return a pointer to a YGenericSensor object, corresponding to
-     *         the first generic sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YGenericSensor* FirstGenericSensor(void);
-    inline static YGenericSensor* First(void)
-    { return YGenericSensor::FirstGenericSensor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YGenericSensor accessors declaration)
-};
-
-//--- (YGenericSensor functions declaration)
-
-/**
- * Retrieves a generic sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the generic sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGenericSensor.isOnline() to test if the generic sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a generic sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the generic sensor
- *
- * @return a YGenericSensor object allowing you to drive the generic sensor.
- */
-inline YGenericSensor* yFindGenericSensor(const string& func)
-{ return YGenericSensor::FindGenericSensor(func);}
-/**
- * Starts the enumeration of generic sensors currently accessible.
- * Use the method YGenericSensor.nextGenericSensor() to iterate on
- * next generic sensors.
- *
- * @return a pointer to a YGenericSensor object, corresponding to
- *         the first generic sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YGenericSensor* yFirstGenericSensor(void)
-{ return YGenericSensor::FirstGenericSensor();}
-
-//--- (end of YGenericSensor functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_gps.cpp
+++ /dev/null
@@ -1,696 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_gps.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindGps(), the high-level API for Gps functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_gps.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "gps"
-
-YGps::YGps(const string& func): YFunction(func)
-//--- (YGps initialization)
-    ,_isFixed(ISFIXED_INVALID)
-    ,_satCount(SATCOUNT_INVALID)
-    ,_coordSystem(COORDSYSTEM_INVALID)
-    ,_latitude(LATITUDE_INVALID)
-    ,_longitude(LONGITUDE_INVALID)
-    ,_dilution(DILUTION_INVALID)
-    ,_altitude(ALTITUDE_INVALID)
-    ,_groundSpeed(GROUNDSPEED_INVALID)
-    ,_direction(DIRECTION_INVALID)
-    ,_unixTime(UNIXTIME_INVALID)
-    ,_dateTime(DATETIME_INVALID)
-    ,_utcOffset(UTCOFFSET_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackGps(NULL)
-//--- (end of YGps initialization)
-{
-    _className="Gps";
-}
-
-YGps::~YGps()
-{
-//--- (YGps cleanup)
-//--- (end of YGps cleanup)
-}
-//--- (YGps implementation)
-// static attributes
-const string YGps::LATITUDE_INVALID = YAPI_INVALID_STRING;
-const string YGps::LONGITUDE_INVALID = YAPI_INVALID_STRING;
-const double YGps::DILUTION_INVALID = YAPI_INVALID_DOUBLE;
-const double YGps::ALTITUDE_INVALID = YAPI_INVALID_DOUBLE;
-const double YGps::GROUNDSPEED_INVALID = YAPI_INVALID_DOUBLE;
-const double YGps::DIRECTION_INVALID = YAPI_INVALID_DOUBLE;
-const string YGps::DATETIME_INVALID = YAPI_INVALID_STRING;
-const string YGps::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YGps::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("isFixed")) {
-        _isFixed =  (Y_ISFIXED_enum)json_val->getInt("isFixed");
-    }
-    if(json_val->has("satCount")) {
-        _satCount =  json_val->getLong("satCount");
-    }
-    if(json_val->has("coordSystem")) {
-        _coordSystem =  (Y_COORDSYSTEM_enum)json_val->getInt("coordSystem");
-    }
-    if(json_val->has("latitude")) {
-        _latitude =  json_val->getString("latitude");
-    }
-    if(json_val->has("longitude")) {
-        _longitude =  json_val->getString("longitude");
-    }
-    if(json_val->has("dilution")) {
-        _dilution =  floor(json_val->getDouble("dilution") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("altitude")) {
-        _altitude =  floor(json_val->getDouble("altitude") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("groundSpeed")) {
-        _groundSpeed =  floor(json_val->getDouble("groundSpeed") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("direction")) {
-        _direction =  floor(json_val->getDouble("direction") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("unixTime")) {
-        _unixTime =  json_val->getLong("unixTime");
-    }
-    if(json_val->has("dateTime")) {
-        _dateTime =  json_val->getString("dateTime");
-    }
-    if(json_val->has("utcOffset")) {
-        _utcOffset =  json_val->getInt("utcOffset");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns TRUE if the receiver has found enough satellites to work.
- *
- * @return either Y_ISFIXED_FALSE or Y_ISFIXED_TRUE, according to TRUE if the receiver has found
- * enough satellites to work
- *
- * On failure, throws an exception or returns Y_ISFIXED_INVALID.
- */
-Y_ISFIXED_enum YGps::get_isFixed(void)
-{
-    Y_ISFIXED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::ISFIXED_INVALID;
-                }
-            }
-        }
-        res = _isFixed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the count of visible satellites.
- *
- * @return an integer corresponding to the count of visible satellites
- *
- * On failure, throws an exception or returns Y_SATCOUNT_INVALID.
- */
-s64 YGps::get_satCount(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::SATCOUNT_INVALID;
-                }
-            }
-        }
-        res = _satCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the representation system used for positioning data.
- *
- * @return a value among Y_COORDSYSTEM_GPS_DMS, Y_COORDSYSTEM_GPS_DM and Y_COORDSYSTEM_GPS_D
- * corresponding to the representation system used for positioning data
- *
- * On failure, throws an exception or returns Y_COORDSYSTEM_INVALID.
- */
-Y_COORDSYSTEM_enum YGps::get_coordSystem(void)
-{
-    Y_COORDSYSTEM_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::COORDSYSTEM_INVALID;
-                }
-            }
-        }
-        res = _coordSystem;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the representation system used for positioning data.
- *
- * @param newval : a value among Y_COORDSYSTEM_GPS_DMS, Y_COORDSYSTEM_GPS_DM and Y_COORDSYSTEM_GPS_D
- * corresponding to the representation system used for positioning data
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGps::set_coordSystem(Y_COORDSYSTEM_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("coordSystem", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current latitude.
- *
- * @return a string corresponding to the current latitude
- *
- * On failure, throws an exception or returns Y_LATITUDE_INVALID.
- */
-string YGps::get_latitude(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::LATITUDE_INVALID;
-                }
-            }
-        }
-        res = _latitude;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current longitude.
- *
- * @return a string corresponding to the current longitude
- *
- * On failure, throws an exception or returns Y_LONGITUDE_INVALID.
- */
-string YGps::get_longitude(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::LONGITUDE_INVALID;
-                }
-            }
-        }
-        res = _longitude;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current horizontal dilution of precision,
- * the smaller that number is, the better .
- *
- * @return a floating point number corresponding to the current horizontal dilution of precision,
- *         the smaller that number is, the better
- *
- * On failure, throws an exception or returns Y_DILUTION_INVALID.
- */
-double YGps::get_dilution(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::DILUTION_INVALID;
-                }
-            }
-        }
-        res = _dilution;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current altitude. Beware:  GPS technology
- * is very inaccurate regarding altitude.
- *
- * @return a floating point number corresponding to the current altitude
- *
- * On failure, throws an exception or returns Y_ALTITUDE_INVALID.
- */
-double YGps::get_altitude(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::ALTITUDE_INVALID;
-                }
-            }
-        }
-        res = _altitude;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current ground speed in Km/h.
- *
- * @return a floating point number corresponding to the current ground speed in Km/h
- *
- * On failure, throws an exception or returns Y_GROUNDSPEED_INVALID.
- */
-double YGps::get_groundSpeed(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::GROUNDSPEED_INVALID;
-                }
-            }
-        }
-        res = _groundSpeed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current move bearing in degrees, zero
- * is the true (geographic) north.
- *
- * @return a floating point number corresponding to the current move bearing in degrees, zero
- *         is the true (geographic) north
- *
- * On failure, throws an exception or returns Y_DIRECTION_INVALID.
- */
-double YGps::get_direction(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::DIRECTION_INVALID;
-                }
-            }
-        }
-        res = _direction;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current time in Unix format (number of
- * seconds elapsed since Jan 1st, 1970).
- *
- * @return an integer corresponding to the current time in Unix format (number of
- *         seconds elapsed since Jan 1st, 1970)
- *
- * On failure, throws an exception or returns Y_UNIXTIME_INVALID.
- */
-s64 YGps::get_unixTime(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::UNIXTIME_INVALID;
-                }
-            }
-        }
-        res = _unixTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current time in the form "YYYY/MM/DD hh:mm:ss".
- *
- * @return a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
- *
- * On failure, throws an exception or returns Y_DATETIME_INVALID.
- */
-string YGps::get_dateTime(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::DATETIME_INVALID;
-                }
-            }
-        }
-        res = _dateTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of seconds between current time and UTC time (time zone).
- *
- * @return an integer corresponding to the number of seconds between current time and UTC time (time zone)
- *
- * On failure, throws an exception or returns Y_UTCOFFSET_INVALID.
- */
-int YGps::get_utcOffset(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::UTCOFFSET_INVALID;
-                }
-            }
-        }
-        res = _utcOffset;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of seconds between current time and UTC time (time zone).
- * The timezone is automatically rounded to the nearest multiple of 15 minutes.
- * If current UTC time is known, the current time is automatically be updated according to the selected time zone.
- *
- * @param newval : an integer corresponding to the number of seconds between current time and UTC time (time zone)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGps::set_utcOffset(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("utcOffset", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YGps::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGps::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YGps::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a GPS for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the GPS is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGps.isOnline() to test if the GPS is
- * indeed online at a given time. In case of ambiguity when looking for
- * a GPS by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the GPS
- *
- * @return a YGps object allowing you to drive the GPS.
- */
-YGps* YGps::FindGps(string func)
-{
-    YGps* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YGps*) YFunction::_FindFromCache("Gps", func);
-        if (obj == NULL) {
-            obj = new YGps(func);
-            YFunction::_AddToCache("Gps", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YGps::registerValueCallback(YGpsValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackGps = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YGps::_invokeValueCallback(string value)
-{
-    if (_valueCallbackGps != NULL) {
-        _valueCallbackGps(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YGps *YGps::nextGps(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YGps::FindGps(hwid);
-}
-
-YGps* YGps::FirstGps(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Gps", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YGps::FindGps(serial+"."+funcId);
-}
-
-//--- (end of YGps implementation)
-
-//--- (YGps functions)
-//--- (end of YGps functions)
--- a/Sources/cpplib/yocto_gps.h
+++ /dev/null
@@ -1,470 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_gps.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindGps(), the high-level API for Gps functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_GPS_H
-#define YOCTO_GPS_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YGps return codes)
-//--- (end of YGps return codes)
-//--- (YGps yapiwrapper)
-//--- (end of YGps yapiwrapper)
-//--- (YGps definitions)
-class YGps; // forward declaration
-
-typedef void (*YGpsValueCallback)(YGps *func, const string& functionValue);
-#ifndef _Y_ISFIXED_ENUM
-#define _Y_ISFIXED_ENUM
-typedef enum {
-    Y_ISFIXED_FALSE = 0,
-    Y_ISFIXED_TRUE = 1,
-    Y_ISFIXED_INVALID = -1,
-} Y_ISFIXED_enum;
-#endif
-#ifndef _Y_COORDSYSTEM_ENUM
-#define _Y_COORDSYSTEM_ENUM
-typedef enum {
-    Y_COORDSYSTEM_GPS_DMS = 0,
-    Y_COORDSYSTEM_GPS_DM = 1,
-    Y_COORDSYSTEM_GPS_D = 2,
-    Y_COORDSYSTEM_INVALID = -1,
-} Y_COORDSYSTEM_enum;
-#endif
-#define Y_SATCOUNT_INVALID              (YAPI_INVALID_LONG)
-#define Y_LATITUDE_INVALID              (YAPI_INVALID_STRING)
-#define Y_LONGITUDE_INVALID             (YAPI_INVALID_STRING)
-#define Y_DILUTION_INVALID              (YAPI_INVALID_DOUBLE)
-#define Y_ALTITUDE_INVALID              (YAPI_INVALID_DOUBLE)
-#define Y_GROUNDSPEED_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_DIRECTION_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_UNIXTIME_INVALID              (YAPI_INVALID_LONG)
-#define Y_DATETIME_INVALID              (YAPI_INVALID_STRING)
-#define Y_UTCOFFSET_INVALID             (YAPI_INVALID_INT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YGps definitions)
-
-//--- (YGps declaration)
-/**
- * YGps Class: GPS function interface
- *
- * The GPS function allows you to extract positioning
- * data from the GPS device. This class can provides
- * complete positioning information: However, if you
- * wish to define callbacks on position changes, you
- * should use the YLatitude et YLongitude classes.
- */
-class YOCTO_CLASS_EXPORT YGps: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YGps declaration)
-protected:
-    //--- (YGps attributes)
-    // Attributes (function value cache)
-    Y_ISFIXED_enum  _isFixed;
-    s64             _satCount;
-    Y_COORDSYSTEM_enum _coordSystem;
-    string          _latitude;
-    string          _longitude;
-    double          _dilution;
-    double          _altitude;
-    double          _groundSpeed;
-    double          _direction;
-    s64             _unixTime;
-    string          _dateTime;
-    int             _utcOffset;
-    string          _command;
-    YGpsValueCallback _valueCallbackGps;
-
-    friend YGps *yFindGps(const string& func);
-    friend YGps *yFirstGps(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindGps factory function to instantiate
-    YGps(const string& func);
-    //--- (end of YGps attributes)
-
-public:
-    virtual ~YGps();
-    //--- (YGps accessors declaration)
-
-    static const Y_ISFIXED_enum ISFIXED_FALSE = Y_ISFIXED_FALSE;
-    static const Y_ISFIXED_enum ISFIXED_TRUE = Y_ISFIXED_TRUE;
-    static const Y_ISFIXED_enum ISFIXED_INVALID = Y_ISFIXED_INVALID;
-    static const s64 SATCOUNT_INVALID = YAPI_INVALID_LONG;
-    static const Y_COORDSYSTEM_enum COORDSYSTEM_GPS_DMS = Y_COORDSYSTEM_GPS_DMS;
-    static const Y_COORDSYSTEM_enum COORDSYSTEM_GPS_DM = Y_COORDSYSTEM_GPS_DM;
-    static const Y_COORDSYSTEM_enum COORDSYSTEM_GPS_D = Y_COORDSYSTEM_GPS_D;
-    static const Y_COORDSYSTEM_enum COORDSYSTEM_INVALID = Y_COORDSYSTEM_INVALID;
-    static const string LATITUDE_INVALID;
-    static const string LONGITUDE_INVALID;
-    static const double DILUTION_INVALID;
-    static const double ALTITUDE_INVALID;
-    static const double GROUNDSPEED_INVALID;
-    static const double DIRECTION_INVALID;
-    static const s64 UNIXTIME_INVALID = YAPI_INVALID_LONG;
-    static const string DATETIME_INVALID;
-    static const int UTCOFFSET_INVALID = YAPI_INVALID_INT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns TRUE if the receiver has found enough satellites to work.
-     *
-     * @return either Y_ISFIXED_FALSE or Y_ISFIXED_TRUE, according to TRUE if the receiver has found
-     * enough satellites to work
-     *
-     * On failure, throws an exception or returns Y_ISFIXED_INVALID.
-     */
-    Y_ISFIXED_enum      get_isFixed(void);
-
-    inline Y_ISFIXED_enum isFixed(void)
-    { return this->get_isFixed(); }
-
-    /**
-     * Returns the count of visible satellites.
-     *
-     * @return an integer corresponding to the count of visible satellites
-     *
-     * On failure, throws an exception or returns Y_SATCOUNT_INVALID.
-     */
-    s64                 get_satCount(void);
-
-    inline s64          satCount(void)
-    { return this->get_satCount(); }
-
-    /**
-     * Returns the representation system used for positioning data.
-     *
-     * @return a value among Y_COORDSYSTEM_GPS_DMS, Y_COORDSYSTEM_GPS_DM and Y_COORDSYSTEM_GPS_D
-     * corresponding to the representation system used for positioning data
-     *
-     * On failure, throws an exception or returns Y_COORDSYSTEM_INVALID.
-     */
-    Y_COORDSYSTEM_enum  get_coordSystem(void);
-
-    inline Y_COORDSYSTEM_enum coordSystem(void)
-    { return this->get_coordSystem(); }
-
-    /**
-     * Changes the representation system used for positioning data.
-     *
-     * @param newval : a value among Y_COORDSYSTEM_GPS_DMS, Y_COORDSYSTEM_GPS_DM and Y_COORDSYSTEM_GPS_D
-     * corresponding to the representation system used for positioning data
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_coordSystem(Y_COORDSYSTEM_enum newval);
-    inline int      setCoordSystem(Y_COORDSYSTEM_enum newval)
-    { return this->set_coordSystem(newval); }
-
-    /**
-     * Returns the current latitude.
-     *
-     * @return a string corresponding to the current latitude
-     *
-     * On failure, throws an exception or returns Y_LATITUDE_INVALID.
-     */
-    string              get_latitude(void);
-
-    inline string       latitude(void)
-    { return this->get_latitude(); }
-
-    /**
-     * Returns the current longitude.
-     *
-     * @return a string corresponding to the current longitude
-     *
-     * On failure, throws an exception or returns Y_LONGITUDE_INVALID.
-     */
-    string              get_longitude(void);
-
-    inline string       longitude(void)
-    { return this->get_longitude(); }
-
-    /**
-     * Returns the current horizontal dilution of precision,
-     * the smaller that number is, the better .
-     *
-     * @return a floating point number corresponding to the current horizontal dilution of precision,
-     *         the smaller that number is, the better
-     *
-     * On failure, throws an exception or returns Y_DILUTION_INVALID.
-     */
-    double              get_dilution(void);
-
-    inline double       dilution(void)
-    { return this->get_dilution(); }
-
-    /**
-     * Returns the current altitude. Beware:  GPS technology
-     * is very inaccurate regarding altitude.
-     *
-     * @return a floating point number corresponding to the current altitude
-     *
-     * On failure, throws an exception or returns Y_ALTITUDE_INVALID.
-     */
-    double              get_altitude(void);
-
-    inline double       altitude(void)
-    { return this->get_altitude(); }
-
-    /**
-     * Returns the current ground speed in Km/h.
-     *
-     * @return a floating point number corresponding to the current ground speed in Km/h
-     *
-     * On failure, throws an exception or returns Y_GROUNDSPEED_INVALID.
-     */
-    double              get_groundSpeed(void);
-
-    inline double       groundSpeed(void)
-    { return this->get_groundSpeed(); }
-
-    /**
-     * Returns the current move bearing in degrees, zero
-     * is the true (geographic) north.
-     *
-     * @return a floating point number corresponding to the current move bearing in degrees, zero
-     *         is the true (geographic) north
-     *
-     * On failure, throws an exception or returns Y_DIRECTION_INVALID.
-     */
-    double              get_direction(void);
-
-    inline double       direction(void)
-    { return this->get_direction(); }
-
-    /**
-     * Returns the current time in Unix format (number of
-     * seconds elapsed since Jan 1st, 1970).
-     *
-     * @return an integer corresponding to the current time in Unix format (number of
-     *         seconds elapsed since Jan 1st, 1970)
-     *
-     * On failure, throws an exception or returns Y_UNIXTIME_INVALID.
-     */
-    s64                 get_unixTime(void);
-
-    inline s64          unixTime(void)
-    { return this->get_unixTime(); }
-
-    /**
-     * Returns the current time in the form "YYYY/MM/DD hh:mm:ss".
-     *
-     * @return a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
-     *
-     * On failure, throws an exception or returns Y_DATETIME_INVALID.
-     */
-    string              get_dateTime(void);
-
-    inline string       dateTime(void)
-    { return this->get_dateTime(); }
-
-    /**
-     * Returns the number of seconds between current time and UTC time (time zone).
-     *
-     * @return an integer corresponding to the number of seconds between current time and UTC time (time zone)
-     *
-     * On failure, throws an exception or returns Y_UTCOFFSET_INVALID.
-     */
-    int                 get_utcOffset(void);
-
-    inline int          utcOffset(void)
-    { return this->get_utcOffset(); }
-
-    /**
-     * Changes the number of seconds between current time and UTC time (time zone).
-     * The timezone is automatically rounded to the nearest multiple of 15 minutes.
-     * If current UTC time is known, the current time is automatically be updated according to the selected time zone.
-     *
-     * @param newval : an integer corresponding to the number of seconds between current time and UTC time (time zone)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_utcOffset(int newval);
-    inline int      setUtcOffset(int newval)
-    { return this->set_utcOffset(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a GPS for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the GPS is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YGps.isOnline() to test if the GPS is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a GPS by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the GPS
-     *
-     * @return a YGps object allowing you to drive the GPS.
-     */
-    static YGps*        FindGps(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YGpsValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YGps* Find(string func)
-    { return YGps::FindGps(func); }
-
-    /**
-     * Continues the enumeration of GPS started using yFirstGps().
-     * Caution: You can't make any assumption about the returned GPS order.
-     * If you want to find a specific a GPS, use Gps.findGps()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YGps object, corresponding to
-     *         a GPS currently online, or a NULL pointer
-     *         if there are no more GPS to enumerate.
-     */
-           YGps            *nextGps(void);
-    inline YGps            *next(void)
-    { return this->nextGps();}
-
-    /**
-     * Starts the enumeration of GPS currently accessible.
-     * Use the method YGps.nextGps() to iterate on
-     * next GPS.
-     *
-     * @return a pointer to a YGps object, corresponding to
-     *         the first GPS currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YGps* FirstGps(void);
-    inline static YGps* First(void)
-    { return YGps::FirstGps();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YGps accessors declaration)
-};
-
-//--- (YGps functions declaration)
-
-/**
- * Retrieves a GPS for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the GPS is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGps.isOnline() to test if the GPS is
- * indeed online at a given time. In case of ambiguity when looking for
- * a GPS by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the GPS
- *
- * @return a YGps object allowing you to drive the GPS.
- */
-inline YGps* yFindGps(const string& func)
-{ return YGps::FindGps(func);}
-/**
- * Starts the enumeration of GPS currently accessible.
- * Use the method YGps.nextGps() to iterate on
- * next GPS.
- *
- * @return a pointer to a YGps object, corresponding to
- *         the first GPS currently online, or a NULL pointer
- *         if there are none.
- */
-inline YGps* yFirstGps(void)
-{ return YGps::FirstGps();}
-
-//--- (end of YGps functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_groundspeed.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_groundspeed.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindGroundSpeed(), the high-level API for GroundSpeed functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_groundspeed.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "groundspeed"
-
-YGroundSpeed::YGroundSpeed(const string& func): YSensor(func)
-//--- (YGroundSpeed initialization)
-    ,_valueCallbackGroundSpeed(NULL)
-    ,_timedReportCallbackGroundSpeed(NULL)
-//--- (end of YGroundSpeed initialization)
-{
-    _className="GroundSpeed";
-}
-
-YGroundSpeed::~YGroundSpeed()
-{
-//--- (YGroundSpeed cleanup)
-//--- (end of YGroundSpeed cleanup)
-}
-//--- (YGroundSpeed implementation)
-// static attributes
-
-
-/**
- * Retrieves a ground speed sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the ground speed sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGroundSpeed.isOnline() to test if the ground speed sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a ground speed sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the ground speed sensor
- *
- * @return a YGroundSpeed object allowing you to drive the ground speed sensor.
- */
-YGroundSpeed* YGroundSpeed::FindGroundSpeed(string func)
-{
-    YGroundSpeed* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YGroundSpeed*) YFunction::_FindFromCache("GroundSpeed", func);
-        if (obj == NULL) {
-            obj = new YGroundSpeed(func);
-            YFunction::_AddToCache("GroundSpeed", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YGroundSpeed::registerValueCallback(YGroundSpeedValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackGroundSpeed = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YGroundSpeed::_invokeValueCallback(string value)
-{
-    if (_valueCallbackGroundSpeed != NULL) {
-        _valueCallbackGroundSpeed(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YGroundSpeed::registerTimedReportCallback(YGroundSpeedTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackGroundSpeed = callback;
-    return 0;
-}
-
-int YGroundSpeed::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackGroundSpeed != NULL) {
-        _timedReportCallbackGroundSpeed(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YGroundSpeed *YGroundSpeed::nextGroundSpeed(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YGroundSpeed::FindGroundSpeed(hwid);
-}
-
-YGroundSpeed* YGroundSpeed::FirstGroundSpeed(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("GroundSpeed", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YGroundSpeed::FindGroundSpeed(serial+"."+funcId);
-}
-
-//--- (end of YGroundSpeed implementation)
-
-//--- (YGroundSpeed functions)
-//--- (end of YGroundSpeed functions)
--- a/Sources/cpplib/yocto_groundspeed.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_groundspeed.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindGroundSpeed(), the high-level API for GroundSpeed functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_GROUNDSPEED_H
-#define YOCTO_GROUNDSPEED_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YGroundSpeed return codes)
-//--- (end of YGroundSpeed return codes)
-//--- (YGroundSpeed yapiwrapper)
-//--- (end of YGroundSpeed yapiwrapper)
-//--- (YGroundSpeed definitions)
-class YGroundSpeed; // forward declaration
-
-typedef void (*YGroundSpeedValueCallback)(YGroundSpeed *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YGroundSpeedTimedReportCallback)(YGroundSpeed *func, YMeasure measure);
-//--- (end of YGroundSpeed definitions)
-
-//--- (YGroundSpeed declaration)
-/**
- * YGroundSpeed Class: GroundSpeed function interface
- *
- * The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce
- * geolocation sensors. It inherits from the YSensor class the core functions to
- * read measurements, register callback functions, access the autonomous
- * datalogger.
- */
-class YOCTO_CLASS_EXPORT YGroundSpeed: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YGroundSpeed declaration)
-protected:
-    //--- (YGroundSpeed attributes)
-    // Attributes (function value cache)
-    YGroundSpeedValueCallback _valueCallbackGroundSpeed;
-    YGroundSpeedTimedReportCallback _timedReportCallbackGroundSpeed;
-
-    friend YGroundSpeed *yFindGroundSpeed(const string& func);
-    friend YGroundSpeed *yFirstGroundSpeed(void);
-
-    // Constructor is protected, use yFindGroundSpeed factory function to instantiate
-    YGroundSpeed(const string& func);
-    //--- (end of YGroundSpeed attributes)
-
-public:
-    virtual ~YGroundSpeed();
-    //--- (YGroundSpeed accessors declaration)
-
-
-    /**
-     * Retrieves a ground speed sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the ground speed sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YGroundSpeed.isOnline() to test if the ground speed sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a ground speed sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the ground speed sensor
-     *
-     * @return a YGroundSpeed object allowing you to drive the ground speed sensor.
-     */
-    static YGroundSpeed* FindGroundSpeed(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YGroundSpeedValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YGroundSpeedTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YGroundSpeed* Find(string func)
-    { return YGroundSpeed::FindGroundSpeed(func); }
-
-    /**
-     * Continues the enumeration of ground speed sensors started using yFirstGroundSpeed().
-     * Caution: You can't make any assumption about the returned ground speed sensors order.
-     * If you want to find a specific a ground speed sensor, use GroundSpeed.findGroundSpeed()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YGroundSpeed object, corresponding to
-     *         a ground speed sensor currently online, or a NULL pointer
-     *         if there are no more ground speed sensors to enumerate.
-     */
-           YGroundSpeed    *nextGroundSpeed(void);
-    inline YGroundSpeed    *next(void)
-    { return this->nextGroundSpeed();}
-
-    /**
-     * Starts the enumeration of ground speed sensors currently accessible.
-     * Use the method YGroundSpeed.nextGroundSpeed() to iterate on
-     * next ground speed sensors.
-     *
-     * @return a pointer to a YGroundSpeed object, corresponding to
-     *         the first ground speed sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YGroundSpeed* FirstGroundSpeed(void);
-    inline static YGroundSpeed* First(void)
-    { return YGroundSpeed::FirstGroundSpeed();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YGroundSpeed accessors declaration)
-};
-
-//--- (YGroundSpeed functions declaration)
-
-/**
- * Retrieves a ground speed sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the ground speed sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGroundSpeed.isOnline() to test if the ground speed sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a ground speed sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the ground speed sensor
- *
- * @return a YGroundSpeed object allowing you to drive the ground speed sensor.
- */
-inline YGroundSpeed* yFindGroundSpeed(const string& func)
-{ return YGroundSpeed::FindGroundSpeed(func);}
-/**
- * Starts the enumeration of ground speed sensors currently accessible.
- * Use the method YGroundSpeed.nextGroundSpeed() to iterate on
- * next ground speed sensors.
- *
- * @return a pointer to a YGroundSpeed object, corresponding to
- *         the first ground speed sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YGroundSpeed* yFirstGroundSpeed(void)
-{ return YGroundSpeed::FirstGroundSpeed();}
-
-//--- (end of YGroundSpeed functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_gyro.cpp
+++ /dev/null
@@ -1,891 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_gyro.cpp 31375 2018-07-26 14:03:37Z seb $
- *
- * Implements yFindGyro(), the high-level API for Gyro functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_gyro.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "gyro"
-
-
-
-YQt::YQt(const string& func): YSensor(func)
-//--- (generated code: YQt initialization)
-    ,_valueCallbackQt(NULL)
-    ,_timedReportCallbackQt(NULL)
-//--- (end of generated code: YQt initialization)
-{
-    _className="Qt";
-}
-
-YQt::~YQt()
-{
-//--- (generated code: YQt cleanup)
-//--- (end of generated code: YQt cleanup)
-}
-//--- (generated code: YQt implementation)
-// static attributes
-
-
-/**
- * Retrieves a quaternion component for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the quaternion component is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YQt.isOnline() to test if the quaternion component is
- * indeed online at a given time. In case of ambiguity when looking for
- * a quaternion component by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the quaternion component
- *
- * @return a YQt object allowing you to drive the quaternion component.
- */
-YQt* YQt::FindQt(string func)
-{
-    YQt* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YQt*) YFunction::_FindFromCache("Qt", func);
-        if (obj == NULL) {
-            obj = new YQt(func);
-            YFunction::_AddToCache("Qt", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YQt::registerValueCallback(YQtValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackQt = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YQt::_invokeValueCallback(string value)
-{
-    if (_valueCallbackQt != NULL) {
-        _valueCallbackQt(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YQt::registerTimedReportCallback(YQtTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackQt = callback;
-    return 0;
-}
-
-int YQt::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackQt != NULL) {
-        _timedReportCallbackQt(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YQt *YQt::nextQt(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YQt::FindQt(hwid);
-}
-
-YQt* YQt::FirstQt(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Qt", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YQt::FindQt(serial+"."+funcId);
-}
-
-//--- (end of generated code: YQt implementation)
-
-//--- (generated code: YQt functions)
-//--- (end of generated code: YQt functions)
-
-
-static void yInternalGyroCallback(YQt *obj, const string& value)
-{
-    YGyro *gyro = (YGyro*) obj->get_userData();
-    if (gyro == NULL) {
-        return;
-    }
-    string tmp = obj->get_functionId().substr(2);
-    int idx = atoi(tmp.c_str());
-    double dbl_value = atof(value.c_str());
-    gyro->_invokeGyroCallbacks(idx, dbl_value);
-}
-
-
-
-
-YGyro::YGyro(const string& func): YSensor(func)
-//--- (generated code: YGyro initialization)
-    ,_bandwidth(BANDWIDTH_INVALID)
-    ,_xValue(XVALUE_INVALID)
-    ,_yValue(YVALUE_INVALID)
-    ,_zValue(ZVALUE_INVALID)
-    ,_valueCallbackGyro(NULL)
-    ,_timedReportCallbackGyro(NULL)
-    ,_qt_stamp(0)
-    ,_qt_w(NULL)
-    ,_qt_x(NULL)
-    ,_qt_y(NULL)
-    ,_qt_z(NULL)
-    ,_w(0.0)
-    ,_x(0.0)
-    ,_y(0.0)
-    ,_z(0.0)
-    ,_angles_stamp(0)
-    ,_head(0.0)
-    ,_pitch(0.0)
-    ,_roll(0.0)
-    ,_quatCallback(NULL)
-    ,_anglesCallback(NULL)
-//--- (end of generated code: YGyro initialization)
-{
-    _className="Gyro";
-}
-
-YGyro::~YGyro()
-{
-//--- (generated code: YGyro cleanup)
-//--- (end of generated code: YGyro cleanup)
-}
-//--- (generated code: YGyro implementation)
-// static attributes
-const double YGyro::XVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YGyro::YVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YGyro::ZVALUE_INVALID = YAPI_INVALID_DOUBLE;
-
-int YGyro::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("bandwidth")) {
-        _bandwidth =  json_val->getInt("bandwidth");
-    }
-    if(json_val->has("xValue")) {
-        _xValue =  floor(json_val->getDouble("xValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("yValue")) {
-        _yValue =  floor(json_val->getDouble("yValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("zValue")) {
-        _zValue =  floor(json_val->getDouble("zValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
- *
- * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
- */
-int YGyro::get_bandwidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGyro::BANDWIDTH_INVALID;
-                }
-            }
-        }
-        res = _bandwidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
- * frequency is lower, the device performs averaging.
- *
- * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YGyro::set_bandwidth(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("bandwidth", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the angular velocity around the X axis of the device, as a floating point number.
- *
- * @return a floating point number corresponding to the angular velocity around the X axis of the
- * device, as a floating point number
- *
- * On failure, throws an exception or returns Y_XVALUE_INVALID.
- */
-double YGyro::get_xValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGyro::XVALUE_INVALID;
-                }
-            }
-        }
-        res = _xValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the angular velocity around the Y axis of the device, as a floating point number.
- *
- * @return a floating point number corresponding to the angular velocity around the Y axis of the
- * device, as a floating point number
- *
- * On failure, throws an exception or returns Y_YVALUE_INVALID.
- */
-double YGyro::get_yValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGyro::YVALUE_INVALID;
-                }
-            }
-        }
-        res = _yValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the angular velocity around the Z axis of the device, as a floating point number.
- *
- * @return a floating point number corresponding to the angular velocity around the Z axis of the
- * device, as a floating point number
- *
- * On failure, throws an exception or returns Y_ZVALUE_INVALID.
- */
-double YGyro::get_zValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YGyro::ZVALUE_INVALID;
-                }
-            }
-        }
-        res = _zValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a gyroscope for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the gyroscope is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGyro.isOnline() to test if the gyroscope is
- * indeed online at a given time. In case of ambiguity when looking for
- * a gyroscope by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the gyroscope
- *
- * @return a YGyro object allowing you to drive the gyroscope.
- */
-YGyro* YGyro::FindGyro(string func)
-{
-    YGyro* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YGyro*) YFunction::_FindFromCache("Gyro", func);
-        if (obj == NULL) {
-            obj = new YGyro(func);
-            YFunction::_AddToCache("Gyro", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YGyro::registerValueCallback(YGyroValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackGyro = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YGyro::_invokeValueCallback(string value)
-{
-    if (_valueCallbackGyro != NULL) {
-        _valueCallbackGyro(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YGyro::registerTimedReportCallback(YGyroTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackGyro = callback;
-    return 0;
-}
-
-int YGyro::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackGyro != NULL) {
-        _timedReportCallbackGyro(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-int YGyro::_loadQuaternion(void)
-{
-    int now_stamp = 0;
-    int age_ms = 0;
-    now_stamp = (int) ((YAPI::GetTickCount()) & (0x7FFFFFFF));
-    age_ms = (((now_stamp - _qt_stamp)) & (0x7FFFFFFF));
-    if ((age_ms >= 10) || (_qt_stamp == 0)) {
-        if (this->_load_unsafe(10) != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        if (_qt_stamp == 0) {
-            _qt_w = YQt::FindQt(YapiWrapper::ysprintf("%s.qt1",_serial.c_str()));
-            _qt_x = YQt::FindQt(YapiWrapper::ysprintf("%s.qt2",_serial.c_str()));
-            _qt_y = YQt::FindQt(YapiWrapper::ysprintf("%s.qt3",_serial.c_str()));
-            _qt_z = YQt::FindQt(YapiWrapper::ysprintf("%s.qt4",_serial.c_str()));
-        }
-        if (_qt_w->load(9) != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        if (_qt_x->load(9) != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        if (_qt_y->load(9) != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        if (_qt_z->load(9) != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        _w = _qt_w->get_currentValue();
-        _x = _qt_x->get_currentValue();
-        _y = _qt_y->get_currentValue();
-        _z = _qt_z->get_currentValue();
-        _qt_stamp = now_stamp;
-    }
-    return YAPI_SUCCESS;
-}
-
-int YGyro::_loadAngles(void)
-{
-    double sqw = 0.0;
-    double sqx = 0.0;
-    double sqy = 0.0;
-    double sqz = 0.0;
-    double norm = 0.0;
-    double delta = 0.0;
-
-    if (this->_loadQuaternion() != YAPI_SUCCESS) {
-        return YAPI_DEVICE_NOT_FOUND;
-    }
-    if (_angles_stamp != _qt_stamp) {
-        sqw = _w * _w;
-        sqx = _x * _x;
-        sqy = _y * _y;
-        sqz = _z * _z;
-        norm = sqx + sqy + sqz + sqw;
-        delta = _y * _w - _x * _z;
-        if (delta > 0.499 * norm) {
-            // singularity at north pole
-            _pitch = 90.0;
-            _head  = floor(2.0 * 1800.0/3.141592653589793238463 * atan2(_x,-_w)+0.5) / 10.0;
-        } else {
-            if (delta < -0.499 * norm) {
-                // singularity at south pole
-                _pitch = -90.0;
-                _head  = floor(-2.0 * 1800.0/3.141592653589793238463 * atan2(_x,-_w)+0.5) / 10.0;
-            } else {
-                _roll  = floor(1800.0/3.141592653589793238463 * atan2(2.0 * (_w * _x + _y * _z),sqw - sqx - sqy + sqz)+0.5) / 10.0;
-                _pitch = floor(1800.0/3.141592653589793238463 * asin(2.0 * delta / norm)+0.5) / 10.0;
-                _head  = floor(1800.0/3.141592653589793238463 * atan2(2.0 * (_x * _y + _z * _w),sqw + sqx - sqy - sqz)+0.5) / 10.0;
-            }
-        }
-        _angles_stamp = _qt_stamp;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns the estimated roll angle, based on the integration of
- * gyroscopic measures combined with acceleration and
- * magnetic field measurements.
- * The axis corresponding to the roll angle can be mapped to any
- * of the device X, Y or Z physical directions using methods of
- * the class YRefFrame.
- *
- * @return a floating-point number corresponding to roll angle
- *         in degrees, between -180 and +180.
- */
-double YGyro::get_roll(void)
-{
-    this->_loadAngles();
-    return _roll;
-}
-
-/**
- * Returns the estimated pitch angle, based on the integration of
- * gyroscopic measures combined with acceleration and
- * magnetic field measurements.
- * The axis corresponding to the pitch angle can be mapped to any
- * of the device X, Y or Z physical directions using methods of
- * the class YRefFrame.
- *
- * @return a floating-point number corresponding to pitch angle
- *         in degrees, between -90 and +90.
- */
-double YGyro::get_pitch(void)
-{
-    this->_loadAngles();
-    return _pitch;
-}
-
-/**
- * Returns the estimated heading angle, based on the integration of
- * gyroscopic measures combined with acceleration and
- * magnetic field measurements.
- * The axis corresponding to the heading can be mapped to any
- * of the device X, Y or Z physical directions using methods of
- * the class YRefFrame.
- *
- * @return a floating-point number corresponding to heading
- *         in degrees, between 0 and 360.
- */
-double YGyro::get_heading(void)
-{
-    this->_loadAngles();
-    return _head;
-}
-
-/**
- * Returns the w component (real part) of the quaternion
- * describing the device estimated orientation, based on the
- * integration of gyroscopic measures combined with acceleration and
- * magnetic field measurements.
- *
- * @return a floating-point number corresponding to the w
- *         component of the quaternion.
- */
-double YGyro::get_quaternionW(void)
-{
-    this->_loadQuaternion();
-    return _w;
-}
-
-/**
- * Returns the x component of the quaternion
- * describing the device estimated orientation, based on the
- * integration of gyroscopic measures combined with acceleration and
- * magnetic field measurements. The x component is
- * mostly correlated with rotations on the roll axis.
- *
- * @return a floating-point number corresponding to the x
- *         component of the quaternion.
- */
-double YGyro::get_quaternionX(void)
-{
-    this->_loadQuaternion();
-    return _x;
-}
-
-/**
- * Returns the y component of the quaternion
- * describing the device estimated orientation, based on the
- * integration of gyroscopic measures combined with acceleration and
- * magnetic field measurements. The y component is
- * mostly correlated with rotations on the pitch axis.
- *
- * @return a floating-point number corresponding to the y
- *         component of the quaternion.
- */
-double YGyro::get_quaternionY(void)
-{
-    this->_loadQuaternion();
-    return _y;
-}
-
-/**
- * Returns the x component of the quaternion
- * describing the device estimated orientation, based on the
- * integration of gyroscopic measures combined with acceleration and
- * magnetic field measurements. The x component is
- * mostly correlated with changes of heading.
- *
- * @return a floating-point number corresponding to the z
- *         component of the quaternion.
- */
-double YGyro::get_quaternionZ(void)
-{
-    this->_loadQuaternion();
-    return _z;
-}
-
-/**
- * Registers a callback function that will be invoked each time that the estimated
- * device orientation has changed. The call frequency is typically around 95Hz during a move.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered.
- * For good responsiveness, remember to call one of these two functions periodically.
- * To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to invoke, or a NULL pointer.
- *         The callback function should take five arguments:
- *         the YGyro object of the turning device, and the floating
- *         point values of the four components w, x, y and z
- *         (as floating-point numbers).
- * @noreturn
- */
-int YGyro::registerQuaternionCallback(YQuatCallback callback)
-{
-    _quatCallback = callback;
-    if (callback != NULL) {
-        if (this->_loadQuaternion() != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        _qt_w->set_userData(this);
-        _qt_x->set_userData(this);
-        _qt_y->set_userData(this);
-        _qt_z->set_userData(this);
-        _qt_w->registerValueCallback(yInternalGyroCallback);
-        _qt_x->registerValueCallback(yInternalGyroCallback);
-        _qt_y->registerValueCallback(yInternalGyroCallback);
-        _qt_z->registerValueCallback(yInternalGyroCallback);
-    } else {
-        if (!(_anglesCallback != NULL)) {
-            _qt_w->registerValueCallback((YQtValueCallback) NULL);
-            _qt_x->registerValueCallback((YQtValueCallback) NULL);
-            _qt_y->registerValueCallback((YQtValueCallback) NULL);
-            _qt_z->registerValueCallback((YQtValueCallback) NULL);
-        }
-    }
-    return 0;
-}
-
-/**
- * Registers a callback function that will be invoked each time that the estimated
- * device orientation has changed. The call frequency is typically around 95Hz during a move.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered.
- * For good responsiveness, remember to call one of these two functions periodically.
- * To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to invoke, or a NULL pointer.
- *         The callback function should take four arguments:
- *         the YGyro object of the turning device, and the floating
- *         point values of the three angles roll, pitch and heading
- *         in degrees (as floating-point numbers).
- * @noreturn
- */
-int YGyro::registerAnglesCallback(YAnglesCallback callback)
-{
-    _anglesCallback = callback;
-    if (callback != NULL) {
-        if (this->_loadQuaternion() != YAPI_SUCCESS) {
-            return YAPI_DEVICE_NOT_FOUND;
-        }
-        _qt_w->set_userData(this);
-        _qt_x->set_userData(this);
-        _qt_y->set_userData(this);
-        _qt_z->set_userData(this);
-        _qt_w->registerValueCallback(yInternalGyroCallback);
-        _qt_x->registerValueCallback(yInternalGyroCallback);
-        _qt_y->registerValueCallback(yInternalGyroCallback);
-        _qt_z->registerValueCallback(yInternalGyroCallback);
-    } else {
-        if (!(_quatCallback != NULL)) {
-            _qt_w->registerValueCallback((YQtValueCallback) NULL);
-            _qt_x->registerValueCallback((YQtValueCallback) NULL);
-            _qt_y->registerValueCallback((YQtValueCallback) NULL);
-            _qt_z->registerValueCallback((YQtValueCallback) NULL);
-        }
-    }
-    return 0;
-}
-
-int YGyro::_invokeGyroCallbacks(int qtIndex,double qtValue)
-{
-    switch(qtIndex - 1) {
-    case 0:
-        _w = qtValue;
-        break;
-    case 1:
-        _x = qtValue;
-        break;
-    case 2:
-        _y = qtValue;
-        break;
-    case 3:
-        _z = qtValue;
-        break;
-    }
-    if (qtIndex < 4) {
-        return 0;
-    }
-    _qt_stamp = (int) ((YAPI::GetTickCount()) & (0x7FFFFFFF));
-    if (_quatCallback != NULL) {
-        _quatCallback(this, _w, _x, _y, _z);
-    }
-    if (_anglesCallback != NULL) {
-        this->_loadAngles();
-        _anglesCallback(this, _roll, _pitch, _head);
-    }
-    return 0;
-}
-
-YGyro *YGyro::nextGyro(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YGyro::FindGyro(hwid);
-}
-
-YGyro* YGyro::FirstGyro(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Gyro", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YGyro::FindGyro(serial+"."+funcId);
-}
-
-//--- (end of generated code: YGyro implementation)
-
-//--- (generated code: YGyro functions)
-//--- (end of generated code: YGyro functions)
--- a/Sources/cpplib/yocto_gyro.h
+++ /dev/null
@@ -1,647 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_gyro.h 32901 2018-11-02 10:13:09Z seb $
- *
- * Declares yFindGyro(), the high-level API for Gyro functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_GYRO_H
-#define YOCTO_GYRO_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (generated code: YQt return codes)
-//--- (end of generated code: YQt return codes)
-//--- (generated code: YQt definitions)
-class YQt; // forward declaration
-
-typedef void (*YQtValueCallback)(YQt *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YQtTimedReportCallback)(YQt *func, YMeasure measure);
-//--- (end of generated code: YQt definitions)
-
-//--- (generated code: YQt declaration)
-/**
- * YQt Class: Quaternion interface
- *
- * The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation
- * using a quaternion. It is usually not needed to use the YQt class directly, as the
- * YGyro class provides a more convenient higher-level interface.
- */
-class YOCTO_CLASS_EXPORT YQt: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YQt declaration)
-protected:
-    //--- (generated code: YQt attributes)
-    // Attributes (function value cache)
-    YQtValueCallback _valueCallbackQt;
-    YQtTimedReportCallback _timedReportCallbackQt;
-
-    friend YQt *yFindQt(const string& func);
-    friend YQt *yFirstQt(void);
-
-    // Constructor is protected, use yFindQt factory function to instantiate
-    YQt(const string& func);
-    //--- (end of generated code: YQt attributes)
-
-public:
-    ~YQt();
-    //--- (generated code: YQt accessors declaration)
-
-
-    /**
-     * Retrieves a quaternion component for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the quaternion component is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YQt.isOnline() to test if the quaternion component is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a quaternion component by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the quaternion component
-     *
-     * @return a YQt object allowing you to drive the quaternion component.
-     */
-    static YQt*         FindQt(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YQtValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YQtTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YQt* Find(string func)
-    { return YQt::FindQt(func); }
-
-    /**
-     * Continues the enumeration of quaternion components started using yFirstQt().
-     * Caution: You can't make any assumption about the returned quaternion components order.
-     * If you want to find a specific a quaternion component, use Qt.findQt()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YQt object, corresponding to
-     *         a quaternion component currently online, or a NULL pointer
-     *         if there are no more quaternion components to enumerate.
-     */
-           YQt             *nextQt(void);
-    inline YQt             *next(void)
-    { return this->nextQt();}
-
-    /**
-     * Starts the enumeration of quaternion components currently accessible.
-     * Use the method YQt.nextQt() to iterate on
-     * next quaternion components.
-     *
-     * @return a pointer to a YQt object, corresponding to
-     *         the first quaternion component currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YQt* FirstQt(void);
-    inline static YQt* First(void)
-    { return YQt::FirstQt();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YQt accessors declaration)
-};
-
-//--- (generated code: YQt functions declaration)
-
-/**
- * Retrieves a quaternion component for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the quaternion component is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YQt.isOnline() to test if the quaternion component is
- * indeed online at a given time. In case of ambiguity when looking for
- * a quaternion component by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the quaternion component
- *
- * @return a YQt object allowing you to drive the quaternion component.
- */
-inline YQt* yFindQt(const string& func)
-{ return YQt::FindQt(func);}
-/**
- * Starts the enumeration of quaternion components currently accessible.
- * Use the method YQt.nextQt() to iterate on
- * next quaternion components.
- *
- * @return a pointer to a YQt object, corresponding to
- *         the first quaternion component currently online, or a NULL pointer
- *         if there are none.
- */
-inline YQt* yFirstQt(void)
-{ return YQt::FirstQt();}
-
-//--- (end of generated code: YQt functions declaration)
-
-
-
-//--- (generated code: YGyro return codes)
-//--- (end of generated code: YGyro return codes)
-//--- (generated code: YGyro definitions)
-class YGyro; // forward declaration
-
-typedef void (*YGyroValueCallback)(YGyro *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YGyroTimedReportCallback)(YGyro *func, YMeasure measure);
-#define Y_BANDWIDTH_INVALID             (YAPI_INVALID_INT)
-#define Y_XVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_YVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_ZVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-//--- (end of generated code: YGyro definitions)
-
-typedef void(*YQuatCallback)(YGyro *yGyro, double w, double x, double y, double z);
-typedef void(*YAnglesCallback)(YGyro *yGyro, double roll, double pitch, double head);
-
-//--- (generated code: YGyro declaration)
-/**
- * YGyro Class: Gyroscope function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YGyro: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YGyro declaration)
-protected:
-    //--- (generated code: YGyro attributes)
-    // Attributes (function value cache)
-    int             _bandwidth;
-    double          _xValue;
-    double          _yValue;
-    double          _zValue;
-    YGyroValueCallback _valueCallbackGyro;
-    YGyroTimedReportCallback _timedReportCallbackGyro;
-    int             _qt_stamp;
-    YQt*            _qt_w;
-    YQt*            _qt_x;
-    YQt*            _qt_y;
-    YQt*            _qt_z;
-    double          _w;
-    double          _x;
-    double          _y;
-    double          _z;
-    int             _angles_stamp;
-    double          _head;
-    double          _pitch;
-    double          _roll;
-    YQuatCallback   _quatCallback;
-    YAnglesCallback _anglesCallback;
-
-    friend YGyro *yFindGyro(const string& func);
-    friend YGyro *yFirstGyro(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindGyro factory function to instantiate
-    YGyro(const string& func);
-    //--- (end of generated code: YGyro attributes)
-
-public:
-    ~YGyro();
-    //--- (generated code: YGyro accessors declaration)
-
-    static const int BANDWIDTH_INVALID = YAPI_INVALID_INT;
-    static const double XVALUE_INVALID;
-    static const double YVALUE_INVALID;
-    static const double ZVALUE_INVALID;
-
-    /**
-     * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
-     *
-     * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
-     */
-    int                 get_bandwidth(void);
-
-    inline int          bandwidth(void)
-    { return this->get_bandwidth(); }
-
-    /**
-     * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
-     * frequency is lower, the device performs averaging.
-     *
-     * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bandwidth(int newval);
-    inline int      setBandwidth(int newval)
-    { return this->set_bandwidth(newval); }
-
-    /**
-     * Returns the angular velocity around the X axis of the device, as a floating point number.
-     *
-     * @return a floating point number corresponding to the angular velocity around the X axis of the
-     * device, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_XVALUE_INVALID.
-     */
-    double              get_xValue(void);
-
-    inline double       xValue(void)
-    { return this->get_xValue(); }
-
-    /**
-     * Returns the angular velocity around the Y axis of the device, as a floating point number.
-     *
-     * @return a floating point number corresponding to the angular velocity around the Y axis of the
-     * device, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_YVALUE_INVALID.
-     */
-    double              get_yValue(void);
-
-    inline double       yValue(void)
-    { return this->get_yValue(); }
-
-    /**
-     * Returns the angular velocity around the Z axis of the device, as a floating point number.
-     *
-     * @return a floating point number corresponding to the angular velocity around the Z axis of the
-     * device, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_ZVALUE_INVALID.
-     */
-    double              get_zValue(void);
-
-    inline double       zValue(void)
-    { return this->get_zValue(); }
-
-    /**
-     * Retrieves a gyroscope for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the gyroscope is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YGyro.isOnline() to test if the gyroscope is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a gyroscope by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the gyroscope
-     *
-     * @return a YGyro object allowing you to drive the gyroscope.
-     */
-    static YGyro*       FindGyro(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YGyroValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YGyroTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    virtual int         _loadQuaternion(void);
-
-    virtual int         _loadAngles(void);
-
-    /**
-     * Returns the estimated roll angle, based on the integration of
-     * gyroscopic measures combined with acceleration and
-     * magnetic field measurements.
-     * The axis corresponding to the roll angle can be mapped to any
-     * of the device X, Y or Z physical directions using methods of
-     * the class YRefFrame.
-     *
-     * @return a floating-point number corresponding to roll angle
-     *         in degrees, between -180 and +180.
-     */
-    virtual double      get_roll(void);
-
-    /**
-     * Returns the estimated pitch angle, based on the integration of
-     * gyroscopic measures combined with acceleration and
-     * magnetic field measurements.
-     * The axis corresponding to the pitch angle can be mapped to any
-     * of the device X, Y or Z physical directions using methods of
-     * the class YRefFrame.
-     *
-     * @return a floating-point number corresponding to pitch angle
-     *         in degrees, between -90 and +90.
-     */
-    virtual double      get_pitch(void);
-
-    /**
-     * Returns the estimated heading angle, based on the integration of
-     * gyroscopic measures combined with acceleration and
-     * magnetic field measurements.
-     * The axis corresponding to the heading can be mapped to any
-     * of the device X, Y or Z physical directions using methods of
-     * the class YRefFrame.
-     *
-     * @return a floating-point number corresponding to heading
-     *         in degrees, between 0 and 360.
-     */
-    virtual double      get_heading(void);
-
-    /**
-     * Returns the w component (real part) of the quaternion
-     * describing the device estimated orientation, based on the
-     * integration of gyroscopic measures combined with acceleration and
-     * magnetic field measurements.
-     *
-     * @return a floating-point number corresponding to the w
-     *         component of the quaternion.
-     */
-    virtual double      get_quaternionW(void);
-
-    /**
-     * Returns the x component of the quaternion
-     * describing the device estimated orientation, based on the
-     * integration of gyroscopic measures combined with acceleration and
-     * magnetic field measurements. The x component is
-     * mostly correlated with rotations on the roll axis.
-     *
-     * @return a floating-point number corresponding to the x
-     *         component of the quaternion.
-     */
-    virtual double      get_quaternionX(void);
-
-    /**
-     * Returns the y component of the quaternion
-     * describing the device estimated orientation, based on the
-     * integration of gyroscopic measures combined with acceleration and
-     * magnetic field measurements. The y component is
-     * mostly correlated with rotations on the pitch axis.
-     *
-     * @return a floating-point number corresponding to the y
-     *         component of the quaternion.
-     */
-    virtual double      get_quaternionY(void);
-
-    /**
-     * Returns the x component of the quaternion
-     * describing the device estimated orientation, based on the
-     * integration of gyroscopic measures combined with acceleration and
-     * magnetic field measurements. The x component is
-     * mostly correlated with changes of heading.
-     *
-     * @return a floating-point number corresponding to the z
-     *         component of the quaternion.
-     */
-    virtual double      get_quaternionZ(void);
-
-    /**
-     * Registers a callback function that will be invoked each time that the estimated
-     * device orientation has changed. The call frequency is typically around 95Hz during a move.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered.
-     * For good responsiveness, remember to call one of these two functions periodically.
-     * To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to invoke, or a NULL pointer.
-     *         The callback function should take five arguments:
-     *         the YGyro object of the turning device, and the floating
-     *         point values of the four components w, x, y and z
-     *         (as floating-point numbers).
-     * @noreturn
-     */
-    virtual int         registerQuaternionCallback(YQuatCallback callback);
-
-    /**
-     * Registers a callback function that will be invoked each time that the estimated
-     * device orientation has changed. The call frequency is typically around 95Hz during a move.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered.
-     * For good responsiveness, remember to call one of these two functions periodically.
-     * To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to invoke, or a NULL pointer.
-     *         The callback function should take four arguments:
-     *         the YGyro object of the turning device, and the floating
-     *         point values of the three angles roll, pitch and heading
-     *         in degrees (as floating-point numbers).
-     * @noreturn
-     */
-    virtual int         registerAnglesCallback(YAnglesCallback callback);
-
-    virtual int         _invokeGyroCallbacks(int qtIndex,double qtValue);
-
-
-    inline static YGyro* Find(string func)
-    { return YGyro::FindGyro(func); }
-
-    /**
-     * Continues the enumeration of gyroscopes started using yFirstGyro().
-     * Caution: You can't make any assumption about the returned gyroscopes order.
-     * If you want to find a specific a gyroscope, use Gyro.findGyro()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YGyro object, corresponding to
-     *         a gyroscope currently online, or a NULL pointer
-     *         if there are no more gyroscopes to enumerate.
-     */
-           YGyro           *nextGyro(void);
-    inline YGyro           *next(void)
-    { return this->nextGyro();}
-
-    /**
-     * Starts the enumeration of gyroscopes currently accessible.
-     * Use the method YGyro.nextGyro() to iterate on
-     * next gyroscopes.
-     *
-     * @return a pointer to a YGyro object, corresponding to
-     *         the first gyro currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YGyro* FirstGyro(void);
-    inline static YGyro* First(void)
-    { return YGyro::FirstGyro();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YGyro accessors declaration)
-};
-
-//--- (generated code: YGyro functions declaration)
-
-/**
- * Retrieves a gyroscope for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the gyroscope is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YGyro.isOnline() to test if the gyroscope is
- * indeed online at a given time. In case of ambiguity when looking for
- * a gyroscope by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the gyroscope
- *
- * @return a YGyro object allowing you to drive the gyroscope.
- */
-inline YGyro* yFindGyro(const string& func)
-{ return YGyro::FindGyro(func);}
-/**
- * Starts the enumeration of gyroscopes currently accessible.
- * Use the method YGyro.nextGyro() to iterate on
- * next gyroscopes.
- *
- * @return a pointer to a YGyro object, corresponding to
- *         the first gyro currently online, or a NULL pointer
- *         if there are none.
- */
-inline YGyro* yFirstGyro(void)
-{ return YGyro::FirstGyro();}
-
-//--- (end of generated code: YGyro functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_hubport.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_hubport.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindHubPort(), the high-level API for HubPort functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_hubport.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "hubport"
-
-YHubPort::YHubPort(const string& func): YFunction(func)
-//--- (YHubPort initialization)
-    ,_enabled(ENABLED_INVALID)
-    ,_portState(PORTSTATE_INVALID)
-    ,_baudRate(BAUDRATE_INVALID)
-    ,_valueCallbackHubPort(NULL)
-//--- (end of YHubPort initialization)
-{
-    _className="HubPort";
-}
-
-YHubPort::~YHubPort()
-{
-//--- (YHubPort cleanup)
-//--- (end of YHubPort cleanup)
-}
-//--- (YHubPort implementation)
-// static attributes
-
-int YHubPort::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    if(json_val->has("portState")) {
-        _portState =  (Y_PORTSTATE_enum)json_val->getInt("portState");
-    }
-    if(json_val->has("baudRate")) {
-        _baudRate =  json_val->getInt("baudRate");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns true if the Yocto-hub port is powered, false otherwise.
- *
- * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to true if the Yocto-hub port is
- * powered, false otherwise
- *
- * On failure, throws an exception or returns Y_ENABLED_INVALID.
- */
-Y_ENABLED_enum YHubPort::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YHubPort::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the activation of the Yocto-hub port. If the port is enabled, the
- * connected module is powered. Otherwise, port power is shut down.
- *
- * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the activation of the Yocto-hub port
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YHubPort::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current state of the Yocto-hub port.
- *
- * @return a value among Y_PORTSTATE_OFF, Y_PORTSTATE_OVRLD, Y_PORTSTATE_ON, Y_PORTSTATE_RUN and
- * Y_PORTSTATE_PROG corresponding to the current state of the Yocto-hub port
- *
- * On failure, throws an exception or returns Y_PORTSTATE_INVALID.
- */
-Y_PORTSTATE_enum YHubPort::get_portState(void)
-{
-    Y_PORTSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YHubPort::PORTSTATE_INVALID;
-                }
-            }
-        }
-        res = _portState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current baud rate used by this Yocto-hub port, in kbps.
- * The default value is 1000 kbps, but a slower rate may be used if communication
- * problems are encountered.
- *
- * @return an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps
- *
- * On failure, throws an exception or returns Y_BAUDRATE_INVALID.
- */
-int YHubPort::get_baudRate(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YHubPort::BAUDRATE_INVALID;
-                }
-            }
-        }
-        res = _baudRate;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a Yocto-hub port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Yocto-hub port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YHubPort.isOnline() to test if the Yocto-hub port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Yocto-hub port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Yocto-hub port
- *
- * @return a YHubPort object allowing you to drive the Yocto-hub port.
- */
-YHubPort* YHubPort::FindHubPort(string func)
-{
-    YHubPort* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YHubPort*) YFunction::_FindFromCache("HubPort", func);
-        if (obj == NULL) {
-            obj = new YHubPort(func);
-            YFunction::_AddToCache("HubPort", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YHubPort::registerValueCallback(YHubPortValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackHubPort = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YHubPort::_invokeValueCallback(string value)
-{
-    if (_valueCallbackHubPort != NULL) {
-        _valueCallbackHubPort(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YHubPort *YHubPort::nextHubPort(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YHubPort::FindHubPort(hwid);
-}
-
-YHubPort* YHubPort::FirstHubPort(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("HubPort", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YHubPort::FindHubPort(serial+"."+funcId);
-}
-
-//--- (end of YHubPort implementation)
-
-//--- (YHubPort functions)
-//--- (end of YHubPort functions)
--- a/Sources/cpplib/yocto_hubport.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_hubport.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindHubPort(), the high-level API for HubPort functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_HUBPORT_H
-#define YOCTO_HUBPORT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YHubPort return codes)
-//--- (end of YHubPort return codes)
-//--- (YHubPort yapiwrapper)
-//--- (end of YHubPort yapiwrapper)
-//--- (YHubPort definitions)
-class YHubPort; // forward declaration
-
-typedef void (*YHubPortValueCallback)(YHubPort *func, const string& functionValue);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-#ifndef _Y_PORTSTATE_ENUM
-#define _Y_PORTSTATE_ENUM
-#ifdef Y_PORTSTATE_INVALID
-#undef Y_PORTSTATE_INVALID
-#endif
-typedef enum {
-    Y_PORTSTATE_OFF = 0,
-    Y_PORTSTATE_OVRLD = 1,
-    Y_PORTSTATE_ON = 2,
-    Y_PORTSTATE_RUN = 3,
-    Y_PORTSTATE_PROG = 4,
-    Y_PORTSTATE_INVALID = -1,
-} Y_PORTSTATE_enum;
-#endif
-#define Y_BAUDRATE_INVALID              (YAPI_INVALID_UINT)
-//--- (end of YHubPort definitions)
-
-//--- (YHubPort declaration)
-/**
- * YHubPort Class: Yocto-hub port interface
- *
- * YHubPort objects provide control over the power supply for every
- * YoctoHub port and provide information about the device connected to it.
- * The logical name of a YHubPort is always automatically set to the
- * unique serial number of the Yoctopuce device connected to it.
- */
-class YOCTO_CLASS_EXPORT YHubPort: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YHubPort declaration)
-protected:
-    //--- (YHubPort attributes)
-    // Attributes (function value cache)
-    Y_ENABLED_enum  _enabled;
-    Y_PORTSTATE_enum _portState;
-    int             _baudRate;
-    YHubPortValueCallback _valueCallbackHubPort;
-
-    friend YHubPort *yFindHubPort(const string& func);
-    friend YHubPort *yFirstHubPort(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindHubPort factory function to instantiate
-    YHubPort(const string& func);
-    //--- (end of YHubPort attributes)
-
-public:
-    virtual ~YHubPort();
-    //--- (YHubPort accessors declaration)
-
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-    static const Y_PORTSTATE_enum PORTSTATE_OFF = Y_PORTSTATE_OFF;
-    static const Y_PORTSTATE_enum PORTSTATE_OVRLD = Y_PORTSTATE_OVRLD;
-    static const Y_PORTSTATE_enum PORTSTATE_ON = Y_PORTSTATE_ON;
-    static const Y_PORTSTATE_enum PORTSTATE_RUN = Y_PORTSTATE_RUN;
-    static const Y_PORTSTATE_enum PORTSTATE_PROG = Y_PORTSTATE_PROG;
-    static const Y_PORTSTATE_enum PORTSTATE_INVALID = Y_PORTSTATE_INVALID;
-    static const int BAUDRATE_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns true if the Yocto-hub port is powered, false otherwise.
-     *
-     * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to true if the Yocto-hub port is
-     * powered, false otherwise
-     *
-     * On failure, throws an exception or returns Y_ENABLED_INVALID.
-     */
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    /**
-     * Changes the activation of the Yocto-hub port. If the port is enabled, the
-     * connected module is powered. Otherwise, port power is shut down.
-     *
-     * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the activation of the Yocto-hub port
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Returns the current state of the Yocto-hub port.
-     *
-     * @return a value among Y_PORTSTATE_OFF, Y_PORTSTATE_OVRLD, Y_PORTSTATE_ON, Y_PORTSTATE_RUN and
-     * Y_PORTSTATE_PROG corresponding to the current state of the Yocto-hub port
-     *
-     * On failure, throws an exception or returns Y_PORTSTATE_INVALID.
-     */
-    Y_PORTSTATE_enum    get_portState(void);
-
-    inline Y_PORTSTATE_enum portState(void)
-    { return this->get_portState(); }
-
-    /**
-     * Returns the current baud rate used by this Yocto-hub port, in kbps.
-     * The default value is 1000 kbps, but a slower rate may be used if communication
-     * problems are encountered.
-     *
-     * @return an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps
-     *
-     * On failure, throws an exception or returns Y_BAUDRATE_INVALID.
-     */
-    int                 get_baudRate(void);
-
-    inline int          baudRate(void)
-    { return this->get_baudRate(); }
-
-    /**
-     * Retrieves a Yocto-hub port for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the Yocto-hub port is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YHubPort.isOnline() to test if the Yocto-hub port is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a Yocto-hub port by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the Yocto-hub port
-     *
-     * @return a YHubPort object allowing you to drive the Yocto-hub port.
-     */
-    static YHubPort*    FindHubPort(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YHubPortValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YHubPort* Find(string func)
-    { return YHubPort::FindHubPort(func); }
-
-    /**
-     * Continues the enumeration of Yocto-hub ports started using yFirstHubPort().
-     * Caution: You can't make any assumption about the returned Yocto-hub ports order.
-     * If you want to find a specific a Yocto-hub port, use HubPort.findHubPort()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YHubPort object, corresponding to
-     *         a Yocto-hub port currently online, or a NULL pointer
-     *         if there are no more Yocto-hub ports to enumerate.
-     */
-           YHubPort        *nextHubPort(void);
-    inline YHubPort        *next(void)
-    { return this->nextHubPort();}
-
-    /**
-     * Starts the enumeration of Yocto-hub ports currently accessible.
-     * Use the method YHubPort.nextHubPort() to iterate on
-     * next Yocto-hub ports.
-     *
-     * @return a pointer to a YHubPort object, corresponding to
-     *         the first Yocto-hub port currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YHubPort* FirstHubPort(void);
-    inline static YHubPort* First(void)
-    { return YHubPort::FirstHubPort();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YHubPort accessors declaration)
-};
-
-//--- (YHubPort functions declaration)
-
-/**
- * Retrieves a Yocto-hub port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Yocto-hub port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YHubPort.isOnline() to test if the Yocto-hub port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Yocto-hub port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Yocto-hub port
- *
- * @return a YHubPort object allowing you to drive the Yocto-hub port.
- */
-inline YHubPort* yFindHubPort(const string& func)
-{ return YHubPort::FindHubPort(func);}
-/**
- * Starts the enumeration of Yocto-hub ports currently accessible.
- * Use the method YHubPort.nextHubPort() to iterate on
- * next Yocto-hub ports.
- *
- * @return a pointer to a YHubPort object, corresponding to
- *         the first Yocto-hub port currently online, or a NULL pointer
- *         if there are none.
- */
-inline YHubPort* yFirstHubPort(void)
-{ return YHubPort::FirstHubPort();}
-
-//--- (end of YHubPort functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_humidity.cpp
+++ /dev/null
@@ -1,322 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_humidity.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindHumidity(), the high-level API for Humidity functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_humidity.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "humidity"
-
-YHumidity::YHumidity(const string& func): YSensor(func)
-//--- (YHumidity initialization)
-    ,_relHum(RELHUM_INVALID)
-    ,_absHum(ABSHUM_INVALID)
-    ,_valueCallbackHumidity(NULL)
-    ,_timedReportCallbackHumidity(NULL)
-//--- (end of YHumidity initialization)
-{
-    _className="Humidity";
-}
-
-YHumidity::~YHumidity()
-{
-//--- (YHumidity cleanup)
-//--- (end of YHumidity cleanup)
-}
-//--- (YHumidity implementation)
-// static attributes
-const double YHumidity::RELHUM_INVALID = YAPI_INVALID_DOUBLE;
-const double YHumidity::ABSHUM_INVALID = YAPI_INVALID_DOUBLE;
-
-int YHumidity::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("relHum")) {
-        _relHum =  floor(json_val->getDouble("relHum") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("absHum")) {
-        _absHum =  floor(json_val->getDouble("absHum") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the primary unit for measuring humidity. That unit is a string.
- * If that strings starts with the letter 'g', the primary measured value is the absolute
- * humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity
- * (RH), in per cents.
- *
- * Remember to call the saveToFlash() method of the module if the modification
- * must be kept.
- *
- * @param newval : a string corresponding to the primary unit for measuring humidity
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YHumidity::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current relative humidity, in per cents.
- *
- * @return a floating point number corresponding to the current relative humidity, in per cents
- *
- * On failure, throws an exception or returns Y_RELHUM_INVALID.
- */
-double YHumidity::get_relHum(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YHumidity::RELHUM_INVALID;
-                }
-            }
-        }
-        res = _relHum;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current absolute humidity, in grams per cubic meter of air.
- *
- * @return a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air
- *
- * On failure, throws an exception or returns Y_ABSHUM_INVALID.
- */
-double YHumidity::get_absHum(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YHumidity::ABSHUM_INVALID;
-                }
-            }
-        }
-        res = _absHum;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a humidity sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the humidity sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YHumidity.isOnline() to test if the humidity sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a humidity sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the humidity sensor
- *
- * @return a YHumidity object allowing you to drive the humidity sensor.
- */
-YHumidity* YHumidity::FindHumidity(string func)
-{
-    YHumidity* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YHumidity*) YFunction::_FindFromCache("Humidity", func);
-        if (obj == NULL) {
-            obj = new YHumidity(func);
-            YFunction::_AddToCache("Humidity", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YHumidity::registerValueCallback(YHumidityValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackHumidity = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YHumidity::_invokeValueCallback(string value)
-{
-    if (_valueCallbackHumidity != NULL) {
-        _valueCallbackHumidity(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YHumidity::registerTimedReportCallback(YHumidityTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackHumidity = callback;
-    return 0;
-}
-
-int YHumidity::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackHumidity != NULL) {
-        _timedReportCallbackHumidity(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YHumidity *YHumidity::nextHumidity(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YHumidity::FindHumidity(hwid);
-}
-
-YHumidity* YHumidity::FirstHumidity(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Humidity", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YHumidity::FindHumidity(serial+"."+funcId);
-}
-
-//--- (end of YHumidity implementation)
-
-//--- (YHumidity functions)
-//--- (end of YHumidity functions)
--- a/Sources/cpplib/yocto_humidity.h
+++ /dev/null
@@ -1,286 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_humidity.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindHumidity(), the high-level API for Humidity functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_HUMIDITY_H
-#define YOCTO_HUMIDITY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YHumidity return codes)
-//--- (end of YHumidity return codes)
-//--- (YHumidity yapiwrapper)
-//--- (end of YHumidity yapiwrapper)
-//--- (YHumidity definitions)
-class YHumidity; // forward declaration
-
-typedef void (*YHumidityValueCallback)(YHumidity *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YHumidityTimedReportCallback)(YHumidity *func, YMeasure measure);
-#define Y_RELHUM_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_ABSHUM_INVALID                (YAPI_INVALID_DOUBLE)
-//--- (end of YHumidity definitions)
-
-//--- (YHumidity declaration)
-/**
- * YHumidity Class: Humidity function interface
- *
- * The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YHumidity: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YHumidity declaration)
-protected:
-    //--- (YHumidity attributes)
-    // Attributes (function value cache)
-    double          _relHum;
-    double          _absHum;
-    YHumidityValueCallback _valueCallbackHumidity;
-    YHumidityTimedReportCallback _timedReportCallbackHumidity;
-
-    friend YHumidity *yFindHumidity(const string& func);
-    friend YHumidity *yFirstHumidity(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindHumidity factory function to instantiate
-    YHumidity(const string& func);
-    //--- (end of YHumidity attributes)
-
-public:
-    virtual ~YHumidity();
-    //--- (YHumidity accessors declaration)
-
-    static const double RELHUM_INVALID;
-    static const double ABSHUM_INVALID;
-
-    /**
-     * Changes the primary unit for measuring humidity. That unit is a string.
-     * If that strings starts with the letter 'g', the primary measured value is the absolute
-     * humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity
-     * (RH), in per cents.
-     *
-     * Remember to call the saveToFlash() method of the module if the modification
-     * must be kept.
-     *
-     * @param newval : a string corresponding to the primary unit for measuring humidity
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the current relative humidity, in per cents.
-     *
-     * @return a floating point number corresponding to the current relative humidity, in per cents
-     *
-     * On failure, throws an exception or returns Y_RELHUM_INVALID.
-     */
-    double              get_relHum(void);
-
-    inline double       relHum(void)
-    { return this->get_relHum(); }
-
-    /**
-     * Returns the current absolute humidity, in grams per cubic meter of air.
-     *
-     * @return a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air
-     *
-     * On failure, throws an exception or returns Y_ABSHUM_INVALID.
-     */
-    double              get_absHum(void);
-
-    inline double       absHum(void)
-    { return this->get_absHum(); }
-
-    /**
-     * Retrieves a humidity sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the humidity sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YHumidity.isOnline() to test if the humidity sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a humidity sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the humidity sensor
-     *
-     * @return a YHumidity object allowing you to drive the humidity sensor.
-     */
-    static YHumidity*   FindHumidity(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YHumidityValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YHumidityTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YHumidity* Find(string func)
-    { return YHumidity::FindHumidity(func); }
-
-    /**
-     * Continues the enumeration of humidity sensors started using yFirstHumidity().
-     * Caution: You can't make any assumption about the returned humidity sensors order.
-     * If you want to find a specific a humidity sensor, use Humidity.findHumidity()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YHumidity object, corresponding to
-     *         a humidity sensor currently online, or a NULL pointer
-     *         if there are no more humidity sensors to enumerate.
-     */
-           YHumidity       *nextHumidity(void);
-    inline YHumidity       *next(void)
-    { return this->nextHumidity();}
-
-    /**
-     * Starts the enumeration of humidity sensors currently accessible.
-     * Use the method YHumidity.nextHumidity() to iterate on
-     * next humidity sensors.
-     *
-     * @return a pointer to a YHumidity object, corresponding to
-     *         the first humidity sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YHumidity* FirstHumidity(void);
-    inline static YHumidity* First(void)
-    { return YHumidity::FirstHumidity();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YHumidity accessors declaration)
-};
-
-//--- (YHumidity functions declaration)
-
-/**
- * Retrieves a humidity sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the humidity sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YHumidity.isOnline() to test if the humidity sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a humidity sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the humidity sensor
- *
- * @return a YHumidity object allowing you to drive the humidity sensor.
- */
-inline YHumidity* yFindHumidity(const string& func)
-{ return YHumidity::FindHumidity(func);}
-/**
- * Starts the enumeration of humidity sensors currently accessible.
- * Use the method YHumidity.nextHumidity() to iterate on
- * next humidity sensors.
- *
- * @return a pointer to a YHumidity object, corresponding to
- *         the first humidity sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YHumidity* yFirstHumidity(void)
-{ return YHumidity::FirstHumidity();}
-
-//--- (end of YHumidity functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_latitude.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_latitude.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindLatitude(), the high-level API for Latitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_latitude.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "latitude"
-
-YLatitude::YLatitude(const string& func): YSensor(func)
-//--- (YLatitude initialization)
-    ,_valueCallbackLatitude(NULL)
-    ,_timedReportCallbackLatitude(NULL)
-//--- (end of YLatitude initialization)
-{
-    _className="Latitude";
-}
-
-YLatitude::~YLatitude()
-{
-//--- (YLatitude cleanup)
-//--- (end of YLatitude cleanup)
-}
-//--- (YLatitude implementation)
-// static attributes
-
-
-/**
- * Retrieves a latitude sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the latitude sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLatitude.isOnline() to test if the latitude sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a latitude sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the latitude sensor
- *
- * @return a YLatitude object allowing you to drive the latitude sensor.
- */
-YLatitude* YLatitude::FindLatitude(string func)
-{
-    YLatitude* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YLatitude*) YFunction::_FindFromCache("Latitude", func);
-        if (obj == NULL) {
-            obj = new YLatitude(func);
-            YFunction::_AddToCache("Latitude", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YLatitude::registerValueCallback(YLatitudeValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackLatitude = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YLatitude::_invokeValueCallback(string value)
-{
-    if (_valueCallbackLatitude != NULL) {
-        _valueCallbackLatitude(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YLatitude::registerTimedReportCallback(YLatitudeTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackLatitude = callback;
-    return 0;
-}
-
-int YLatitude::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackLatitude != NULL) {
-        _timedReportCallbackLatitude(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YLatitude *YLatitude::nextLatitude(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YLatitude::FindLatitude(hwid);
-}
-
-YLatitude* YLatitude::FirstLatitude(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Latitude", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YLatitude::FindLatitude(serial+"."+funcId);
-}
-
-//--- (end of YLatitude implementation)
-
-//--- (YLatitude functions)
-//--- (end of YLatitude functions)
--- a/Sources/cpplib/yocto_latitude.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_latitude.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindLatitude(), the high-level API for Latitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_LATITUDE_H
-#define YOCTO_LATITUDE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YLatitude return codes)
-//--- (end of YLatitude return codes)
-//--- (YLatitude yapiwrapper)
-//--- (end of YLatitude yapiwrapper)
-//--- (YLatitude definitions)
-class YLatitude; // forward declaration
-
-typedef void (*YLatitudeValueCallback)(YLatitude *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YLatitudeTimedReportCallback)(YLatitude *func, YMeasure measure);
-//--- (end of YLatitude definitions)
-
-//--- (YLatitude declaration)
-/**
- * YLatitude Class: Latitude function interface
- *
- * The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce
- * geolocation sensors. It inherits from the YSensor class the core functions to
- * read measurements, to register callback functions, to access the autonomous
- * datalogger.
- */
-class YOCTO_CLASS_EXPORT YLatitude: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YLatitude declaration)
-protected:
-    //--- (YLatitude attributes)
-    // Attributes (function value cache)
-    YLatitudeValueCallback _valueCallbackLatitude;
-    YLatitudeTimedReportCallback _timedReportCallbackLatitude;
-
-    friend YLatitude *yFindLatitude(const string& func);
-    friend YLatitude *yFirstLatitude(void);
-
-    // Constructor is protected, use yFindLatitude factory function to instantiate
-    YLatitude(const string& func);
-    //--- (end of YLatitude attributes)
-
-public:
-    virtual ~YLatitude();
-    //--- (YLatitude accessors declaration)
-
-
-    /**
-     * Retrieves a latitude sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the latitude sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YLatitude.isOnline() to test if the latitude sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a latitude sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the latitude sensor
-     *
-     * @return a YLatitude object allowing you to drive the latitude sensor.
-     */
-    static YLatitude*   FindLatitude(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YLatitudeValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YLatitudeTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YLatitude* Find(string func)
-    { return YLatitude::FindLatitude(func); }
-
-    /**
-     * Continues the enumeration of latitude sensors started using yFirstLatitude().
-     * Caution: You can't make any assumption about the returned latitude sensors order.
-     * If you want to find a specific a latitude sensor, use Latitude.findLatitude()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YLatitude object, corresponding to
-     *         a latitude sensor currently online, or a NULL pointer
-     *         if there are no more latitude sensors to enumerate.
-     */
-           YLatitude       *nextLatitude(void);
-    inline YLatitude       *next(void)
-    { return this->nextLatitude();}
-
-    /**
-     * Starts the enumeration of latitude sensors currently accessible.
-     * Use the method YLatitude.nextLatitude() to iterate on
-     * next latitude sensors.
-     *
-     * @return a pointer to a YLatitude object, corresponding to
-     *         the first latitude sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YLatitude* FirstLatitude(void);
-    inline static YLatitude* First(void)
-    { return YLatitude::FirstLatitude();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YLatitude accessors declaration)
-};
-
-//--- (YLatitude functions declaration)
-
-/**
- * Retrieves a latitude sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the latitude sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLatitude.isOnline() to test if the latitude sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a latitude sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the latitude sensor
- *
- * @return a YLatitude object allowing you to drive the latitude sensor.
- */
-inline YLatitude* yFindLatitude(const string& func)
-{ return YLatitude::FindLatitude(func);}
-/**
- * Starts the enumeration of latitude sensors currently accessible.
- * Use the method YLatitude.nextLatitude() to iterate on
- * next latitude sensors.
- *
- * @return a pointer to a YLatitude object, corresponding to
- *         the first latitude sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YLatitude* yFirstLatitude(void)
-{ return YLatitude::FirstLatitude();}
-
-//--- (end of YLatitude functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_led.cpp
+++ /dev/null
@@ -1,364 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_led.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindLed(), the high-level API for Led functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_led.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "led"
-
-YLed::YLed(const string& func): YFunction(func)
-//--- (YLed initialization)
-    ,_power(POWER_INVALID)
-    ,_luminosity(LUMINOSITY_INVALID)
-    ,_blinking(BLINKING_INVALID)
-    ,_valueCallbackLed(NULL)
-//--- (end of YLed initialization)
-{
-    _className="Led";
-}
-
-YLed::~YLed()
-{
-//--- (YLed cleanup)
-//--- (end of YLed cleanup)
-}
-//--- (YLed implementation)
-// static attributes
-
-int YLed::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("power")) {
-        _power =  (Y_POWER_enum)json_val->getInt("power");
-    }
-    if(json_val->has("luminosity")) {
-        _luminosity =  json_val->getInt("luminosity");
-    }
-    if(json_val->has("blinking")) {
-        _blinking =  (Y_BLINKING_enum)json_val->getInt("blinking");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current LED state.
- *
- * @return either Y_POWER_OFF or Y_POWER_ON, according to the current LED state
- *
- * On failure, throws an exception or returns Y_POWER_INVALID.
- */
-Y_POWER_enum YLed::get_power(void)
-{
-    Y_POWER_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YLed::POWER_INVALID;
-                }
-            }
-        }
-        res = _power;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the LED.
- *
- * @param newval : either Y_POWER_OFF or Y_POWER_ON, according to the state of the LED
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YLed::set_power(Y_POWER_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("power", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current LED intensity (in per cent).
- *
- * @return an integer corresponding to the current LED intensity (in per cent)
- *
- * On failure, throws an exception or returns Y_LUMINOSITY_INVALID.
- */
-int YLed::get_luminosity(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YLed::LUMINOSITY_INVALID;
-                }
-            }
-        }
-        res = _luminosity;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current LED intensity (in per cent).
- *
- * @param newval : an integer corresponding to the current LED intensity (in per cent)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YLed::set_luminosity(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("luminosity", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current LED signaling mode.
- *
- * @return a value among Y_BLINKING_STILL, Y_BLINKING_RELAX, Y_BLINKING_AWARE, Y_BLINKING_RUN,
- * Y_BLINKING_CALL and Y_BLINKING_PANIC corresponding to the current LED signaling mode
- *
- * On failure, throws an exception or returns Y_BLINKING_INVALID.
- */
-Y_BLINKING_enum YLed::get_blinking(void)
-{
-    Y_BLINKING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YLed::BLINKING_INVALID;
-                }
-            }
-        }
-        res = _blinking;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current LED signaling mode.
- *
- * @param newval : a value among Y_BLINKING_STILL, Y_BLINKING_RELAX, Y_BLINKING_AWARE, Y_BLINKING_RUN,
- * Y_BLINKING_CALL and Y_BLINKING_PANIC corresponding to the current LED signaling mode
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YLed::set_blinking(Y_BLINKING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("blinking", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a LED for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the LED is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLed.isOnline() to test if the LED is
- * indeed online at a given time. In case of ambiguity when looking for
- * a LED by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the LED
- *
- * @return a YLed object allowing you to drive the LED.
- */
-YLed* YLed::FindLed(string func)
-{
-    YLed* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YLed*) YFunction::_FindFromCache("Led", func);
-        if (obj == NULL) {
-            obj = new YLed(func);
-            YFunction::_AddToCache("Led", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YLed::registerValueCallback(YLedValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackLed = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YLed::_invokeValueCallback(string value)
-{
-    if (_valueCallbackLed != NULL) {
-        _valueCallbackLed(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YLed *YLed::nextLed(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YLed::FindLed(hwid);
-}
-
-YLed* YLed::FirstLed(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Led", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YLed::FindLed(serial+"."+funcId);
-}
-
-//--- (end of YLed implementation)
-
-//--- (YLed functions)
-//--- (end of YLed functions)
--- a/Sources/cpplib/yocto_led.h
+++ /dev/null
@@ -1,330 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_led.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindLed(), the high-level API for Led functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_LED_H
-#define YOCTO_LED_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YLed return codes)
-//--- (end of YLed return codes)
-//--- (YLed yapiwrapper)
-//--- (end of YLed yapiwrapper)
-//--- (YLed definitions)
-class YLed; // forward declaration
-
-typedef void (*YLedValueCallback)(YLed *func, const string& functionValue);
-#ifndef _Y_POWER_ENUM
-#define _Y_POWER_ENUM
-typedef enum {
-    Y_POWER_OFF = 0,
-    Y_POWER_ON = 1,
-    Y_POWER_INVALID = -1,
-} Y_POWER_enum;
-#endif
-#ifndef _Y_BLINKING_ENUM
-#define _Y_BLINKING_ENUM
-typedef enum {
-    Y_BLINKING_STILL = 0,
-    Y_BLINKING_RELAX = 1,
-    Y_BLINKING_AWARE = 2,
-    Y_BLINKING_RUN = 3,
-    Y_BLINKING_CALL = 4,
-    Y_BLINKING_PANIC = 5,
-    Y_BLINKING_INVALID = -1,
-} Y_BLINKING_enum;
-#endif
-#define Y_LUMINOSITY_INVALID            (YAPI_INVALID_UINT)
-//--- (end of YLed definitions)
-
-//--- (YLed declaration)
-/**
- * YLed Class: Led function interface
- *
- * The Yoctopuce application programming interface
- * allows you not only to drive the intensity of the LED, but also to
- * have it blink at various preset frequencies.
- */
-class YOCTO_CLASS_EXPORT YLed: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YLed declaration)
-protected:
-    //--- (YLed attributes)
-    // Attributes (function value cache)
-    Y_POWER_enum    _power;
-    int             _luminosity;
-    Y_BLINKING_enum _blinking;
-    YLedValueCallback _valueCallbackLed;
-
-    friend YLed *yFindLed(const string& func);
-    friend YLed *yFirstLed(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindLed factory function to instantiate
-    YLed(const string& func);
-    //--- (end of YLed attributes)
-
-public:
-    virtual ~YLed();
-    //--- (YLed accessors declaration)
-
-    static const Y_POWER_enum POWER_OFF = Y_POWER_OFF;
-    static const Y_POWER_enum POWER_ON = Y_POWER_ON;
-    static const Y_POWER_enum POWER_INVALID = Y_POWER_INVALID;
-    static const int LUMINOSITY_INVALID = YAPI_INVALID_UINT;
-    static const Y_BLINKING_enum BLINKING_STILL = Y_BLINKING_STILL;
-    static const Y_BLINKING_enum BLINKING_RELAX = Y_BLINKING_RELAX;
-    static const Y_BLINKING_enum BLINKING_AWARE = Y_BLINKING_AWARE;
-    static const Y_BLINKING_enum BLINKING_RUN = Y_BLINKING_RUN;
-    static const Y_BLINKING_enum BLINKING_CALL = Y_BLINKING_CALL;
-    static const Y_BLINKING_enum BLINKING_PANIC = Y_BLINKING_PANIC;
-    static const Y_BLINKING_enum BLINKING_INVALID = Y_BLINKING_INVALID;
-
-    /**
-     * Returns the current LED state.
-     *
-     * @return either Y_POWER_OFF or Y_POWER_ON, according to the current LED state
-     *
-     * On failure, throws an exception or returns Y_POWER_INVALID.
-     */
-    Y_POWER_enum        get_power(void);
-
-    inline Y_POWER_enum power(void)
-    { return this->get_power(); }
-
-    /**
-     * Changes the state of the LED.
-     *
-     * @param newval : either Y_POWER_OFF or Y_POWER_ON, according to the state of the LED
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_power(Y_POWER_enum newval);
-    inline int      setPower(Y_POWER_enum newval)
-    { return this->set_power(newval); }
-
-    /**
-     * Returns the current LED intensity (in per cent).
-     *
-     * @return an integer corresponding to the current LED intensity (in per cent)
-     *
-     * On failure, throws an exception or returns Y_LUMINOSITY_INVALID.
-     */
-    int                 get_luminosity(void);
-
-    inline int          luminosity(void)
-    { return this->get_luminosity(); }
-
-    /**
-     * Changes the current LED intensity (in per cent).
-     *
-     * @param newval : an integer corresponding to the current LED intensity (in per cent)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_luminosity(int newval);
-    inline int      setLuminosity(int newval)
-    { return this->set_luminosity(newval); }
-
-    /**
-     * Returns the current LED signaling mode.
-     *
-     * @return a value among Y_BLINKING_STILL, Y_BLINKING_RELAX, Y_BLINKING_AWARE, Y_BLINKING_RUN,
-     * Y_BLINKING_CALL and Y_BLINKING_PANIC corresponding to the current LED signaling mode
-     *
-     * On failure, throws an exception or returns Y_BLINKING_INVALID.
-     */
-    Y_BLINKING_enum     get_blinking(void);
-
-    inline Y_BLINKING_enum blinking(void)
-    { return this->get_blinking(); }
-
-    /**
-     * Changes the current LED signaling mode.
-     *
-     * @param newval : a value among Y_BLINKING_STILL, Y_BLINKING_RELAX, Y_BLINKING_AWARE, Y_BLINKING_RUN,
-     * Y_BLINKING_CALL and Y_BLINKING_PANIC corresponding to the current LED signaling mode
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_blinking(Y_BLINKING_enum newval);
-    inline int      setBlinking(Y_BLINKING_enum newval)
-    { return this->set_blinking(newval); }
-
-    /**
-     * Retrieves a LED for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the LED is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YLed.isOnline() to test if the LED is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a LED by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the LED
-     *
-     * @return a YLed object allowing you to drive the LED.
-     */
-    static YLed*        FindLed(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YLedValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YLed* Find(string func)
-    { return YLed::FindLed(func); }
-
-    /**
-     * Continues the enumeration of LEDs started using yFirstLed().
-     * Caution: You can't make any assumption about the returned LEDs order.
-     * If you want to find a specific a LED, use Led.findLed()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YLed object, corresponding to
-     *         a LED currently online, or a NULL pointer
-     *         if there are no more LEDs to enumerate.
-     */
-           YLed            *nextLed(void);
-    inline YLed            *next(void)
-    { return this->nextLed();}
-
-    /**
-     * Starts the enumeration of LEDs currently accessible.
-     * Use the method YLed.nextLed() to iterate on
-     * next LEDs.
-     *
-     * @return a pointer to a YLed object, corresponding to
-     *         the first LED currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YLed* FirstLed(void);
-    inline static YLed* First(void)
-    { return YLed::FirstLed();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YLed accessors declaration)
-};
-
-//--- (YLed functions declaration)
-
-/**
- * Retrieves a LED for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the LED is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLed.isOnline() to test if the LED is
- * indeed online at a given time. In case of ambiguity when looking for
- * a LED by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the LED
- *
- * @return a YLed object allowing you to drive the LED.
- */
-inline YLed* yFindLed(const string& func)
-{ return YLed::FindLed(func);}
-/**
- * Starts the enumeration of LEDs currently accessible.
- * Use the method YLed.nextLed() to iterate on
- * next LEDs.
- *
- * @return a pointer to a YLed object, corresponding to
- *         the first LED currently online, or a NULL pointer
- *         if there are none.
- */
-inline YLed* yFirstLed(void)
-{ return YLed::FirstLed();}
-
-//--- (end of YLed functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_lightsensor.cpp
+++ /dev/null
@@ -1,324 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_lightsensor.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindLightSensor(), the high-level API for LightSensor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_lightsensor.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "lightsensor"
-
-YLightSensor::YLightSensor(const string& func): YSensor(func)
-//--- (YLightSensor initialization)
-    ,_measureType(MEASURETYPE_INVALID)
-    ,_valueCallbackLightSensor(NULL)
-    ,_timedReportCallbackLightSensor(NULL)
-//--- (end of YLightSensor initialization)
-{
-    _className="LightSensor";
-}
-
-YLightSensor::~YLightSensor()
-{
-//--- (YLightSensor cleanup)
-//--- (end of YLightSensor cleanup)
-}
-//--- (YLightSensor implementation)
-// static attributes
-
-int YLightSensor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("measureType")) {
-        _measureType =  (Y_MEASURETYPE_enum)json_val->getInt("measureType");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-int YLightSensor::set_currentValue(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the sensor-specific calibration parameter so that the current value
- * matches a desired target (linear scaling).
- *
- * @param calibratedVal : the desired target value.
- *
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YLightSensor::calibrate(double calibratedVal)
-{
-    string rest_val;
-    char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(calibratedVal * 65536.0 + 0.5)); rest_val = string(buf);
-    return _setAttr("currentValue", rest_val);
-}
-
-/**
- * Returns the type of light measure.
- *
- * @return a value among Y_MEASURETYPE_HUMAN_EYE, Y_MEASURETYPE_WIDE_SPECTRUM, Y_MEASURETYPE_INFRARED,
- * Y_MEASURETYPE_HIGH_RATE and Y_MEASURETYPE_HIGH_ENERGY corresponding to the type of light measure
- *
- * On failure, throws an exception or returns Y_MEASURETYPE_INVALID.
- */
-Y_MEASURETYPE_enum YLightSensor::get_measureType(void)
-{
-    Y_MEASURETYPE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YLightSensor::MEASURETYPE_INVALID;
-                }
-            }
-        }
-        res = _measureType;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the light sensor type used in the device. The measure can either
- * approximate the response of the human eye, focus on a specific light
- * spectrum, depending on the capabilities of the light-sensitive cell.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a value among Y_MEASURETYPE_HUMAN_EYE, Y_MEASURETYPE_WIDE_SPECTRUM,
- * Y_MEASURETYPE_INFRARED, Y_MEASURETYPE_HIGH_RATE and Y_MEASURETYPE_HIGH_ENERGY corresponding to the
- * light sensor type used in the device
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YLightSensor::set_measureType(Y_MEASURETYPE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("measureType", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a light sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the light sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLightSensor.isOnline() to test if the light sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a light sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the light sensor
- *
- * @return a YLightSensor object allowing you to drive the light sensor.
- */
-YLightSensor* YLightSensor::FindLightSensor(string func)
-{
-    YLightSensor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YLightSensor*) YFunction::_FindFromCache("LightSensor", func);
-        if (obj == NULL) {
-            obj = new YLightSensor(func);
-            YFunction::_AddToCache("LightSensor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YLightSensor::registerValueCallback(YLightSensorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackLightSensor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YLightSensor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackLightSensor != NULL) {
-        _valueCallbackLightSensor(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YLightSensor::registerTimedReportCallback(YLightSensorTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackLightSensor = callback;
-    return 0;
-}
-
-int YLightSensor::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackLightSensor != NULL) {
-        _timedReportCallbackLightSensor(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YLightSensor *YLightSensor::nextLightSensor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YLightSensor::FindLightSensor(hwid);
-}
-
-YLightSensor* YLightSensor::FirstLightSensor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("LightSensor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YLightSensor::FindLightSensor(serial+"."+funcId);
-}
-
-//--- (end of YLightSensor implementation)
-
-//--- (YLightSensor functions)
-//--- (end of YLightSensor functions)
--- a/Sources/cpplib/yocto_lightsensor.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_lightsensor.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindLightSensor(), the high-level API for LightSensor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_LIGHTSENSOR_H
-#define YOCTO_LIGHTSENSOR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YLightSensor return codes)
-//--- (end of YLightSensor return codes)
-//--- (YLightSensor yapiwrapper)
-//--- (end of YLightSensor yapiwrapper)
-//--- (YLightSensor definitions)
-class YLightSensor; // forward declaration
-
-typedef void (*YLightSensorValueCallback)(YLightSensor *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YLightSensorTimedReportCallback)(YLightSensor *func, YMeasure measure);
-#ifndef _Y_MEASURETYPE_ENUM
-#define _Y_MEASURETYPE_ENUM
-typedef enum {
-    Y_MEASURETYPE_HUMAN_EYE = 0,
-    Y_MEASURETYPE_WIDE_SPECTRUM = 1,
-    Y_MEASURETYPE_INFRARED = 2,
-    Y_MEASURETYPE_HIGH_RATE = 3,
-    Y_MEASURETYPE_HIGH_ENERGY = 4,
-    Y_MEASURETYPE_INVALID = -1,
-} Y_MEASURETYPE_enum;
-#endif
-//--- (end of YLightSensor definitions)
-
-//--- (YLightSensor declaration)
-/**
- * YLightSensor Class: LightSensor function interface
- *
- * The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to easily perform a one-point linear calibration
- * to compensate the effect of a glass or filter placed in front of the sensor.
- * For some light sensors with several working modes, this class can select the
- * desired working mode.
- */
-class YOCTO_CLASS_EXPORT YLightSensor: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YLightSensor declaration)
-protected:
-    //--- (YLightSensor attributes)
-    // Attributes (function value cache)
-    Y_MEASURETYPE_enum _measureType;
-    YLightSensorValueCallback _valueCallbackLightSensor;
-    YLightSensorTimedReportCallback _timedReportCallbackLightSensor;
-
-    friend YLightSensor *yFindLightSensor(const string& func);
-    friend YLightSensor *yFirstLightSensor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindLightSensor factory function to instantiate
-    YLightSensor(const string& func);
-    //--- (end of YLightSensor attributes)
-
-public:
-    virtual ~YLightSensor();
-    //--- (YLightSensor accessors declaration)
-
-    static const Y_MEASURETYPE_enum MEASURETYPE_HUMAN_EYE = Y_MEASURETYPE_HUMAN_EYE;
-    static const Y_MEASURETYPE_enum MEASURETYPE_WIDE_SPECTRUM = Y_MEASURETYPE_WIDE_SPECTRUM;
-    static const Y_MEASURETYPE_enum MEASURETYPE_INFRARED = Y_MEASURETYPE_INFRARED;
-    static const Y_MEASURETYPE_enum MEASURETYPE_HIGH_RATE = Y_MEASURETYPE_HIGH_RATE;
-    static const Y_MEASURETYPE_enum MEASURETYPE_HIGH_ENERGY = Y_MEASURETYPE_HIGH_ENERGY;
-    static const Y_MEASURETYPE_enum MEASURETYPE_INVALID = Y_MEASURETYPE_INVALID;
-
-    int             set_currentValue(double newval);
-    inline int      setCurrentValue(double newval)
-    { return this->set_currentValue(newval); }
-
-    /**
-     * Changes the sensor-specific calibration parameter so that the current value
-     * matches a desired target (linear scaling).
-     *
-     * @param calibratedVal : the desired target value.
-     *
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             calibrate(double calibratedVal);
-
-    /**
-     * Returns the type of light measure.
-     *
-     * @return a value among Y_MEASURETYPE_HUMAN_EYE, Y_MEASURETYPE_WIDE_SPECTRUM, Y_MEASURETYPE_INFRARED,
-     * Y_MEASURETYPE_HIGH_RATE and Y_MEASURETYPE_HIGH_ENERGY corresponding to the type of light measure
-     *
-     * On failure, throws an exception or returns Y_MEASURETYPE_INVALID.
-     */
-    Y_MEASURETYPE_enum  get_measureType(void);
-
-    inline Y_MEASURETYPE_enum measureType(void)
-    { return this->get_measureType(); }
-
-    /**
-     * Changes the light sensor type used in the device. The measure can either
-     * approximate the response of the human eye, focus on a specific light
-     * spectrum, depending on the capabilities of the light-sensitive cell.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a value among Y_MEASURETYPE_HUMAN_EYE, Y_MEASURETYPE_WIDE_SPECTRUM,
-     * Y_MEASURETYPE_INFRARED, Y_MEASURETYPE_HIGH_RATE and Y_MEASURETYPE_HIGH_ENERGY corresponding to the
-     * light sensor type used in the device
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_measureType(Y_MEASURETYPE_enum newval);
-    inline int      setMeasureType(Y_MEASURETYPE_enum newval)
-    { return this->set_measureType(newval); }
-
-    /**
-     * Retrieves a light sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the light sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YLightSensor.isOnline() to test if the light sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a light sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the light sensor
-     *
-     * @return a YLightSensor object allowing you to drive the light sensor.
-     */
-    static YLightSensor* FindLightSensor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YLightSensorValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YLightSensorTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YLightSensor* Find(string func)
-    { return YLightSensor::FindLightSensor(func); }
-
-    /**
-     * Continues the enumeration of light sensors started using yFirstLightSensor().
-     * Caution: You can't make any assumption about the returned light sensors order.
-     * If you want to find a specific a light sensor, use LightSensor.findLightSensor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YLightSensor object, corresponding to
-     *         a light sensor currently online, or a NULL pointer
-     *         if there are no more light sensors to enumerate.
-     */
-           YLightSensor    *nextLightSensor(void);
-    inline YLightSensor    *next(void)
-    { return this->nextLightSensor();}
-
-    /**
-     * Starts the enumeration of light sensors currently accessible.
-     * Use the method YLightSensor.nextLightSensor() to iterate on
-     * next light sensors.
-     *
-     * @return a pointer to a YLightSensor object, corresponding to
-     *         the first light sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YLightSensor* FirstLightSensor(void);
-    inline static YLightSensor* First(void)
-    { return YLightSensor::FirstLightSensor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YLightSensor accessors declaration)
-};
-
-//--- (YLightSensor functions declaration)
-
-/**
- * Retrieves a light sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the light sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLightSensor.isOnline() to test if the light sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a light sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the light sensor
- *
- * @return a YLightSensor object allowing you to drive the light sensor.
- */
-inline YLightSensor* yFindLightSensor(const string& func)
-{ return YLightSensor::FindLightSensor(func);}
-/**
- * Starts the enumeration of light sensors currently accessible.
- * Use the method YLightSensor.nextLightSensor() to iterate on
- * next light sensors.
- *
- * @return a pointer to a YLightSensor object, corresponding to
- *         the first light sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YLightSensor* yFirstLightSensor(void)
-{ return YLightSensor::FirstLightSensor();}
-
-//--- (end of YLightSensor functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_longitude.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_longitude.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindLongitude(), the high-level API for Longitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_longitude.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "longitude"
-
-YLongitude::YLongitude(const string& func): YSensor(func)
-//--- (YLongitude initialization)
-    ,_valueCallbackLongitude(NULL)
-    ,_timedReportCallbackLongitude(NULL)
-//--- (end of YLongitude initialization)
-{
-    _className="Longitude";
-}
-
-YLongitude::~YLongitude()
-{
-//--- (YLongitude cleanup)
-//--- (end of YLongitude cleanup)
-}
-//--- (YLongitude implementation)
-// static attributes
-
-
-/**
- * Retrieves a longitude sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the longitude sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLongitude.isOnline() to test if the longitude sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a longitude sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the longitude sensor
- *
- * @return a YLongitude object allowing you to drive the longitude sensor.
- */
-YLongitude* YLongitude::FindLongitude(string func)
-{
-    YLongitude* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YLongitude*) YFunction::_FindFromCache("Longitude", func);
-        if (obj == NULL) {
-            obj = new YLongitude(func);
-            YFunction::_AddToCache("Longitude", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YLongitude::registerValueCallback(YLongitudeValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackLongitude = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YLongitude::_invokeValueCallback(string value)
-{
-    if (_valueCallbackLongitude != NULL) {
-        _valueCallbackLongitude(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YLongitude::registerTimedReportCallback(YLongitudeTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackLongitude = callback;
-    return 0;
-}
-
-int YLongitude::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackLongitude != NULL) {
-        _timedReportCallbackLongitude(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YLongitude *YLongitude::nextLongitude(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YLongitude::FindLongitude(hwid);
-}
-
-YLongitude* YLongitude::FirstLongitude(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Longitude", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YLongitude::FindLongitude(serial+"."+funcId);
-}
-
-//--- (end of YLongitude implementation)
-
-//--- (YLongitude functions)
-//--- (end of YLongitude functions)
--- a/Sources/cpplib/yocto_longitude.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_longitude.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindLongitude(), the high-level API for Longitude functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_LONGITUDE_H
-#define YOCTO_LONGITUDE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YLongitude return codes)
-//--- (end of YLongitude return codes)
-//--- (YLongitude yapiwrapper)
-//--- (end of YLongitude yapiwrapper)
-//--- (YLongitude definitions)
-class YLongitude; // forward declaration
-
-typedef void (*YLongitudeValueCallback)(YLongitude *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YLongitudeTimedReportCallback)(YLongitude *func, YMeasure measure);
-//--- (end of YLongitude definitions)
-
-//--- (YLongitude declaration)
-/**
- * YLongitude Class: Longitude function interface
- *
- * The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce
- * geolocation sensors. It inherits from the YSensor class the core functions to
- * read measurements, register callback functions, access the autonomous
- * datalogger.
- */
-class YOCTO_CLASS_EXPORT YLongitude: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YLongitude declaration)
-protected:
-    //--- (YLongitude attributes)
-    // Attributes (function value cache)
-    YLongitudeValueCallback _valueCallbackLongitude;
-    YLongitudeTimedReportCallback _timedReportCallbackLongitude;
-
-    friend YLongitude *yFindLongitude(const string& func);
-    friend YLongitude *yFirstLongitude(void);
-
-    // Constructor is protected, use yFindLongitude factory function to instantiate
-    YLongitude(const string& func);
-    //--- (end of YLongitude attributes)
-
-public:
-    virtual ~YLongitude();
-    //--- (YLongitude accessors declaration)
-
-
-    /**
-     * Retrieves a longitude sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the longitude sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YLongitude.isOnline() to test if the longitude sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a longitude sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the longitude sensor
-     *
-     * @return a YLongitude object allowing you to drive the longitude sensor.
-     */
-    static YLongitude*  FindLongitude(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YLongitudeValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YLongitudeTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YLongitude* Find(string func)
-    { return YLongitude::FindLongitude(func); }
-
-    /**
-     * Continues the enumeration of longitude sensors started using yFirstLongitude().
-     * Caution: You can't make any assumption about the returned longitude sensors order.
-     * If you want to find a specific a longitude sensor, use Longitude.findLongitude()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YLongitude object, corresponding to
-     *         a longitude sensor currently online, or a NULL pointer
-     *         if there are no more longitude sensors to enumerate.
-     */
-           YLongitude      *nextLongitude(void);
-    inline YLongitude      *next(void)
-    { return this->nextLongitude();}
-
-    /**
-     * Starts the enumeration of longitude sensors currently accessible.
-     * Use the method YLongitude.nextLongitude() to iterate on
-     * next longitude sensors.
-     *
-     * @return a pointer to a YLongitude object, corresponding to
-     *         the first longitude sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YLongitude* FirstLongitude(void);
-    inline static YLongitude* First(void)
-    { return YLongitude::FirstLongitude();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YLongitude accessors declaration)
-};
-
-//--- (YLongitude functions declaration)
-
-/**
- * Retrieves a longitude sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the longitude sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YLongitude.isOnline() to test if the longitude sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a longitude sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the longitude sensor
- *
- * @return a YLongitude object allowing you to drive the longitude sensor.
- */
-inline YLongitude* yFindLongitude(const string& func)
-{ return YLongitude::FindLongitude(func);}
-/**
- * Starts the enumeration of longitude sensors currently accessible.
- * Use the method YLongitude.nextLongitude() to iterate on
- * next longitude sensors.
- *
- * @return a pointer to a YLongitude object, corresponding to
- *         the first longitude sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YLongitude* yFirstLongitude(void)
-{ return YLongitude::FirstLongitude();}
-
-//--- (end of YLongitude functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_magnetometer.cpp
+++ /dev/null
@@ -1,387 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_magnetometer.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindMagnetometer(), the high-level API for Magnetometer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_magnetometer.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "magnetometer"
-
-YMagnetometer::YMagnetometer(const string& func): YSensor(func)
-//--- (YMagnetometer initialization)
-    ,_bandwidth(BANDWIDTH_INVALID)
-    ,_xValue(XVALUE_INVALID)
-    ,_yValue(YVALUE_INVALID)
-    ,_zValue(ZVALUE_INVALID)
-    ,_valueCallbackMagnetometer(NULL)
-    ,_timedReportCallbackMagnetometer(NULL)
-//--- (end of YMagnetometer initialization)
-{
-    _className="Magnetometer";
-}
-
-YMagnetometer::~YMagnetometer()
-{
-//--- (YMagnetometer cleanup)
-//--- (end of YMagnetometer cleanup)
-}
-//--- (YMagnetometer implementation)
-// static attributes
-const double YMagnetometer::XVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YMagnetometer::YVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const double YMagnetometer::ZVALUE_INVALID = YAPI_INVALID_DOUBLE;
-
-int YMagnetometer::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("bandwidth")) {
-        _bandwidth =  json_val->getInt("bandwidth");
-    }
-    if(json_val->has("xValue")) {
-        _xValue =  floor(json_val->getDouble("xValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("yValue")) {
-        _yValue =  floor(json_val->getDouble("yValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("zValue")) {
-        _zValue =  floor(json_val->getDouble("zValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
- *
- * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
- */
-int YMagnetometer::get_bandwidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMagnetometer::BANDWIDTH_INVALID;
-                }
-            }
-        }
-        res = _bandwidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
- * frequency is lower, the device performs averaging.
- *
- * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMagnetometer::set_bandwidth(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("bandwidth", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the X component of the magnetic field, as a floating point number.
- *
- * @return a floating point number corresponding to the X component of the magnetic field, as a
- * floating point number
- *
- * On failure, throws an exception or returns Y_XVALUE_INVALID.
- */
-double YMagnetometer::get_xValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMagnetometer::XVALUE_INVALID;
-                }
-            }
-        }
-        res = _xValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Y component of the magnetic field, as a floating point number.
- *
- * @return a floating point number corresponding to the Y component of the magnetic field, as a
- * floating point number
- *
- * On failure, throws an exception or returns Y_YVALUE_INVALID.
- */
-double YMagnetometer::get_yValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMagnetometer::YVALUE_INVALID;
-                }
-            }
-        }
-        res = _yValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the Z component of the magnetic field, as a floating point number.
- *
- * @return a floating point number corresponding to the Z component of the magnetic field, as a
- * floating point number
- *
- * On failure, throws an exception or returns Y_ZVALUE_INVALID.
- */
-double YMagnetometer::get_zValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMagnetometer::ZVALUE_INVALID;
-                }
-            }
-        }
-        res = _zValue;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a magnetometer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the magnetometer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMagnetometer.isOnline() to test if the magnetometer is
- * indeed online at a given time. In case of ambiguity when looking for
- * a magnetometer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the magnetometer
- *
- * @return a YMagnetometer object allowing you to drive the magnetometer.
- */
-YMagnetometer* YMagnetometer::FindMagnetometer(string func)
-{
-    YMagnetometer* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMagnetometer*) YFunction::_FindFromCache("Magnetometer", func);
-        if (obj == NULL) {
-            obj = new YMagnetometer(func);
-            YFunction::_AddToCache("Magnetometer", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMagnetometer::registerValueCallback(YMagnetometerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMagnetometer = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMagnetometer::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMagnetometer != NULL) {
-        _valueCallbackMagnetometer(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YMagnetometer::registerTimedReportCallback(YMagnetometerTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackMagnetometer = callback;
-    return 0;
-}
-
-int YMagnetometer::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackMagnetometer != NULL) {
-        _timedReportCallbackMagnetometer(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YMagnetometer *YMagnetometer::nextMagnetometer(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMagnetometer::FindMagnetometer(hwid);
-}
-
-YMagnetometer* YMagnetometer::FirstMagnetometer(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Magnetometer", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMagnetometer::FindMagnetometer(serial+"."+funcId);
-}
-
-//--- (end of YMagnetometer implementation)
-
-//--- (YMagnetometer functions)
-//--- (end of YMagnetometer functions)
--- a/Sources/cpplib/yocto_magnetometer.h
+++ /dev/null
@@ -1,320 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_magnetometer.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindMagnetometer(), the high-level API for Magnetometer functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MAGNETOMETER_H
-#define YOCTO_MAGNETOMETER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YMagnetometer return codes)
-//--- (end of YMagnetometer return codes)
-//--- (YMagnetometer yapiwrapper)
-//--- (end of YMagnetometer yapiwrapper)
-//--- (YMagnetometer definitions)
-class YMagnetometer; // forward declaration
-
-typedef void (*YMagnetometerValueCallback)(YMagnetometer *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YMagnetometerTimedReportCallback)(YMagnetometer *func, YMeasure measure);
-#define Y_BANDWIDTH_INVALID             (YAPI_INVALID_INT)
-#define Y_XVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_YVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_ZVALUE_INVALID                (YAPI_INVALID_DOUBLE)
-//--- (end of YMagnetometer definitions)
-
-//--- (YMagnetometer declaration)
-/**
- * YMagnetometer Class: Magnetometer function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YMagnetometer: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YMagnetometer declaration)
-protected:
-    //--- (YMagnetometer attributes)
-    // Attributes (function value cache)
-    int             _bandwidth;
-    double          _xValue;
-    double          _yValue;
-    double          _zValue;
-    YMagnetometerValueCallback _valueCallbackMagnetometer;
-    YMagnetometerTimedReportCallback _timedReportCallbackMagnetometer;
-
-    friend YMagnetometer *yFindMagnetometer(const string& func);
-    friend YMagnetometer *yFirstMagnetometer(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMagnetometer factory function to instantiate
-    YMagnetometer(const string& func);
-    //--- (end of YMagnetometer attributes)
-
-public:
-    virtual ~YMagnetometer();
-    //--- (YMagnetometer accessors declaration)
-
-    static const int BANDWIDTH_INVALID = YAPI_INVALID_INT;
-    static const double XVALUE_INVALID;
-    static const double YVALUE_INVALID;
-    static const double ZVALUE_INVALID;
-
-    /**
-     * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
-     *
-     * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
-     */
-    int                 get_bandwidth(void);
-
-    inline int          bandwidth(void)
-    { return this->get_bandwidth(); }
-
-    /**
-     * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
-     * frequency is lower, the device performs averaging.
-     *
-     * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bandwidth(int newval);
-    inline int      setBandwidth(int newval)
-    { return this->set_bandwidth(newval); }
-
-    /**
-     * Returns the X component of the magnetic field, as a floating point number.
-     *
-     * @return a floating point number corresponding to the X component of the magnetic field, as a
-     * floating point number
-     *
-     * On failure, throws an exception or returns Y_XVALUE_INVALID.
-     */
-    double              get_xValue(void);
-
-    inline double       xValue(void)
-    { return this->get_xValue(); }
-
-    /**
-     * Returns the Y component of the magnetic field, as a floating point number.
-     *
-     * @return a floating point number corresponding to the Y component of the magnetic field, as a
-     * floating point number
-     *
-     * On failure, throws an exception or returns Y_YVALUE_INVALID.
-     */
-    double              get_yValue(void);
-
-    inline double       yValue(void)
-    { return this->get_yValue(); }
-
-    /**
-     * Returns the Z component of the magnetic field, as a floating point number.
-     *
-     * @return a floating point number corresponding to the Z component of the magnetic field, as a
-     * floating point number
-     *
-     * On failure, throws an exception or returns Y_ZVALUE_INVALID.
-     */
-    double              get_zValue(void);
-
-    inline double       zValue(void)
-    { return this->get_zValue(); }
-
-    /**
-     * Retrieves a magnetometer for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the magnetometer is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMagnetometer.isOnline() to test if the magnetometer is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a magnetometer by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the magnetometer
-     *
-     * @return a YMagnetometer object allowing you to drive the magnetometer.
-     */
-    static YMagnetometer* FindMagnetometer(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMagnetometerValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YMagnetometerTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YMagnetometer* Find(string func)
-    { return YMagnetometer::FindMagnetometer(func); }
-
-    /**
-     * Continues the enumeration of magnetometers started using yFirstMagnetometer().
-     * Caution: You can't make any assumption about the returned magnetometers order.
-     * If you want to find a specific a magnetometer, use Magnetometer.findMagnetometer()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMagnetometer object, corresponding to
-     *         a magnetometer currently online, or a NULL pointer
-     *         if there are no more magnetometers to enumerate.
-     */
-           YMagnetometer   *nextMagnetometer(void);
-    inline YMagnetometer   *next(void)
-    { return this->nextMagnetometer();}
-
-    /**
-     * Starts the enumeration of magnetometers currently accessible.
-     * Use the method YMagnetometer.nextMagnetometer() to iterate on
-     * next magnetometers.
-     *
-     * @return a pointer to a YMagnetometer object, corresponding to
-     *         the first magnetometer currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMagnetometer* FirstMagnetometer(void);
-    inline static YMagnetometer* First(void)
-    { return YMagnetometer::FirstMagnetometer();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YMagnetometer accessors declaration)
-};
-
-//--- (YMagnetometer functions declaration)
-
-/**
- * Retrieves a magnetometer for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the magnetometer is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMagnetometer.isOnline() to test if the magnetometer is
- * indeed online at a given time. In case of ambiguity when looking for
- * a magnetometer by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the magnetometer
- *
- * @return a YMagnetometer object allowing you to drive the magnetometer.
- */
-inline YMagnetometer* yFindMagnetometer(const string& func)
-{ return YMagnetometer::FindMagnetometer(func);}
-/**
- * Starts the enumeration of magnetometers currently accessible.
- * Use the method YMagnetometer.nextMagnetometer() to iterate on
- * next magnetometers.
- *
- * @return a pointer to a YMagnetometer object, corresponding to
- *         the first magnetometer currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMagnetometer* yFirstMagnetometer(void)
-{ return YMagnetometer::FirstMagnetometer();}
-
-//--- (end of YMagnetometer functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_messagebox.cpp
+++ /dev/null
@@ -1,2263 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_messagebox.cpp 31375 2018-07-26 14:03:37Z seb $
- *
- * Implements yFindMessageBox(), the high-level API for MessageBox functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_messagebox.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#include <iostream>
-#define  __FILE_ID__  "messagebox"
-
-
-YSms::YSms(void):
-//--- (generated code: YSms initialization)
-    _mbox(NULL)
-    ,_slot(0)
-    ,_deliv(0)
-    ,_mref(0)
-    ,_pid(0)
-    ,_alphab(0)
-    ,_mclass(0)
-    ,_npdu(0)
-    ,_aggIdx(0)
-    ,_aggCnt(0)
-//--- (end of generated code: YSms initialization)
-{ }
-
-YSms::YSms(YMessageBox *mbox) :
-//--- (generated code: YSms initialization)
-    _mbox(NULL)
-    ,_slot(0)
-    ,_deliv(0)
-    ,_mref(0)
-    ,_pid(0)
-    ,_alphab(0)
-    ,_mclass(0)
-    ,_npdu(0)
-    ,_aggIdx(0)
-    ,_aggCnt(0)
-//--- (end of generated code: YSms initialization)
-{
-    _mbox = mbox;
-}
-
-//--- (generated code: YSms implementation)
-// static attributes
-
-
-int YSms::get_slot(void)
-{
-    return _slot;
-}
-
-string YSms::get_smsc(void)
-{
-    return _smsc;
-}
-
-int YSms::get_msgRef(void)
-{
-    return _mref;
-}
-
-string YSms::get_sender(void)
-{
-    return _orig;
-}
-
-string YSms::get_recipient(void)
-{
-    return _dest;
-}
-
-int YSms::get_protocolId(void)
-{
-    return _pid;
-}
-
-bool YSms::isReceived(void)
-{
-    return _deliv;
-}
-
-int YSms::get_alphabet(void)
-{
-    return _alphab;
-}
-
-int YSms::get_msgClass(void)
-{
-    if (((_mclass) & (16)) == 0) {
-        return -1;
-    }
-    return ((_mclass) & (3));
-}
-
-int YSms::get_dcs(void)
-{
-    return ((_mclass) | ((((_alphab) << (2)))));
-}
-
-string YSms::get_timestamp(void)
-{
-    return _stamp;
-}
-
-string YSms::get_userDataHeader(void)
-{
-    return _udh;
-}
-
-string YSms::get_userData(void)
-{
-    return _udata;
-}
-
-string YSms::get_textData(void)
-{
-    string isolatin;
-    int isosize = 0;
-    int i = 0;
-    if (_alphab == 0) {
-        // using GSM standard 7-bit alphabet
-        return _mbox->gsm2str(_udata);
-    }
-    if (_alphab == 2) {
-        // using UCS-2 alphabet
-        isosize = (((int)(_udata).size()) >> (1));
-        isolatin = string(isosize, (char)0);
-        i = 0;
-        while (i < isosize) {
-            isolatin[i] = (char)(((u8)_udata[2*i+1]));
-            i = i + 1;
-        }
-        return isolatin;
-    }
-    // default: convert 8 bit to string as-is
-    return _udata;
-}
-
-vector<int> YSms::get_unicodeData(void)
-{
-    vector<int> res;
-    int unisize = 0;
-    int unival = 0;
-    int i = 0;
-    if (_alphab == 0) {
-        // using GSM standard 7-bit alphabet
-        return _mbox->gsm2unicode(_udata);
-    }
-    if (_alphab == 2) {
-        // using UCS-2 alphabet
-        unisize = (((int)(_udata).size()) >> (1));
-        res.clear();
-        i = 0;
-        while (i < unisize) {
-            unival = 256*((u8)_udata[2*i])+((u8)_udata[2*i+1]);
-            res.push_back(unival);
-            i = i + 1;
-        }
-    } else {
-        // return straight 8-bit values
-        unisize = (int)(_udata).size();
-        res.clear();
-        i = 0;
-        while (i < unisize) {
-            res.push_back(((u8)_udata[i])+0);
-            i = i + 1;
-        }
-    }
-    return res;
-}
-
-int YSms::get_partCount(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _npdu;
-}
-
-string YSms::get_pdu(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _pdu;
-}
-
-vector<YSms> YSms::get_parts(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _parts;
-}
-
-string YSms::get_concatSignature(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _aggSig;
-}
-
-int YSms::get_concatIndex(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _aggIdx;
-}
-
-int YSms::get_concatCount(void)
-{
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    return _aggCnt;
-}
-
-int YSms::set_slot(int val)
-{
-    _slot = val;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_received(bool val)
-{
-    _deliv = val;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_smsc(string val)
-{
-    _smsc = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_msgRef(int val)
-{
-    _mref = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_sender(string val)
-{
-    _orig = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_recipient(string val)
-{
-    _dest = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_protocolId(int val)
-{
-    _pid = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_alphabet(int val)
-{
-    _alphab = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_msgClass(int val)
-{
-    if (val == -1) {
-        _mclass = 0;
-    } else {
-        _mclass = 16+val;
-    }
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_dcs(int val)
-{
-    _alphab = (((((val) >> (2)))) & (3));
-    _mclass = ((val) & (16+3));
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_timestamp(string val)
-{
-    _stamp = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_userDataHeader(string val)
-{
-    _udh = val;
-    _npdu = 0;
-    this->parseUserDataHeader();
-    return YAPI_SUCCESS;
-}
-
-int YSms::set_userData(string val)
-{
-    _udata = val;
-    _npdu = 0;
-    return YAPI_SUCCESS;
-}
-
-int YSms::convertToUnicode(void)
-{
-    vector<int> ucs2;
-    int udatalen = 0;
-    int i = 0;
-    int uni = 0;
-    if (_alphab == 2) {
-        return YAPI_SUCCESS;
-    }
-    if (_alphab == 0) {
-        ucs2 = _mbox->gsm2unicode(_udata);
-    } else {
-        udatalen = (int)(_udata).size();
-        ucs2.clear();
-        i = 0;
-        while (i < udatalen) {
-            uni = ((u8)_udata[i]);
-            ucs2.push_back(uni);
-            i = i + 1;
-        }
-    }
-    _alphab = 2;
-    _udata = string(0, (char)0);
-    this->addUnicodeData(ucs2);
-    return YAPI_SUCCESS;
-}
-
-int YSms::addText(string val)
-{
-    string udata;
-    int udatalen = 0;
-    string newdata;
-    int newdatalen = 0;
-    int i = 0;
-    if ((int)(val).length() == 0) {
-        return YAPI_SUCCESS;
-    }
-    if (_alphab == 0) {
-        // Try to append using GSM 7-bit alphabet
-        newdata = _mbox->str2gsm(val);
-        newdatalen = (int)(newdata).size();
-        if (newdatalen == 0) {
-            // 7-bit not possible, switch to unicode
-            this->convertToUnicode();
-            newdata = val;
-            newdatalen = (int)(newdata).size();
-        }
-    } else {
-        newdata = val;
-        newdatalen = (int)(newdata).size();
-    }
-    udatalen = (int)(_udata).size();
-    if (_alphab == 2) {
-        // Append in unicode directly
-        udata = string(udatalen + 2*newdatalen, (char)0);
-        i = 0;
-        while (i < udatalen) {
-            udata[i] = (char)(((u8)_udata[i]));
-            i = i + 1;
-        }
-        i = 0;
-        while (i < newdatalen) {
-            udata[udatalen+1] = (char)(((u8)newdata[i]));
-            udatalen = udatalen + 2;
-            i = i + 1;
-        }
-    } else {
-        // Append binary buffers
-        udata = string(udatalen+newdatalen, (char)0);
-        i = 0;
-        while (i < udatalen) {
-            udata[i] = (char)(((u8)_udata[i]));
-            i = i + 1;
-        }
-        i = 0;
-        while (i < newdatalen) {
-            udata[udatalen] = (char)(((u8)newdata[i]));
-            udatalen = udatalen + 1;
-            i = i + 1;
-        }
-    }
-    return this->set_userData(udata);
-}
-
-int YSms::addUnicodeData(vector<int> val)
-{
-    int arrlen = 0;
-    int newdatalen = 0;
-    int i = 0;
-    int uni = 0;
-    string udata;
-    int udatalen = 0;
-    int surrogate = 0;
-    if (_alphab != 2) {
-        this->convertToUnicode();
-    }
-    // compute number of 16-bit code units
-    arrlen = (int)val.size();
-    newdatalen = arrlen;
-    i = 0;
-    while (i < arrlen) {
-        uni = val[i];
-        if (uni > 65535) {
-            newdatalen = newdatalen + 1;
-        }
-        i = i + 1;
-    }
-    // now build utf-16 buffer
-    udatalen = (int)(_udata).size();
-    udata = string(udatalen+2*newdatalen, (char)0);
-    i = 0;
-    while (i < udatalen) {
-        udata[i] = (char)(((u8)_udata[i]));
-        i = i + 1;
-    }
-    i = 0;
-    while (i < arrlen) {
-        uni = val[i];
-        if (uni >= 65536) {
-            surrogate = uni - 65536;
-            uni = (((((surrogate) >> (10))) & (1023))) + 55296;
-            udata[udatalen] = (char)(((uni) >> (8)));
-            udata[udatalen+1] = (char)(((uni) & (255)));
-            udatalen = udatalen + 2;
-            uni = (((surrogate) & (1023))) + 56320;
-        }
-        udata[udatalen] = (char)(((uni) >> (8)));
-        udata[udatalen+1] = (char)(((uni) & (255)));
-        udatalen = udatalen + 2;
-        i = i + 1;
-    }
-    return this->set_userData(udata);
-}
-
-int YSms::set_pdu(string pdu)
-{
-    _pdu = pdu;
-    _npdu = 1;
-    return this->parsePdu(pdu);
-}
-
-int YSms::set_parts(vector<YSms> parts)
-{
-    vector<YSms> sorted;
-    int partno = 0;
-    int initpartno = 0;
-    int i = 0;
-    int retcode = 0;
-    int totsize = 0;
-    YSms subsms;
-    string subdata;
-    string res;
-    _npdu = (int)parts.size();
-    if (_npdu == 0) {
-        return YAPI_INVALID_ARGUMENT;
-    }
-    sorted.clear();
-    partno = 0;
-    while (partno < _npdu) {
-        initpartno = partno;
-        i = 0;
-        while (i < _npdu) {
-            subsms = parts[i];
-            if (subsms.get_concatIndex() == partno) {
-                sorted.push_back(subsms);
-                partno = partno + 1;
-            }
-            i = i + 1;
-        }
-        if (initpartno == partno) {
-            partno = partno + 1;
-        }
-    }
-    _parts = sorted;
-    _npdu = (int)sorted.size();
-    // inherit header fields from first part
-    subsms = _parts[0];
-    retcode = this->parsePdu(subsms.get_pdu());
-    if (retcode != YAPI_SUCCESS) {
-        return retcode;
-    }
-    // concatenate user data from all parts
-    totsize = 0;
-    partno = 0;
-    while (partno < (int)_parts.size()) {
-        subsms = _parts[partno];
-        subdata = subsms.get_userData();
-        totsize = totsize + (int)(subdata).size();
-        partno = partno + 1;
-    }
-    res = string(totsize, (char)0);
-    totsize = 0;
-    partno = 0;
-    while (partno < (int)_parts.size()) {
-        subsms = _parts[partno];
-        subdata = subsms.get_userData();
-        i = 0;
-        while (i < (int)(subdata).size()) {
-            res[totsize] = (char)(((u8)subdata[i]));
-            totsize = totsize + 1;
-            i = i + 1;
-        }
-        partno = partno + 1;
-    }
-    _udata = res;
-    return YAPI_SUCCESS;
-}
-
-string YSms::encodeAddress(string addr)
-{
-    string bytes;
-    int srclen = 0;
-    int numlen = 0;
-    int i = 0;
-    int val = 0;
-    int digit = 0;
-    string res;
-    bytes = addr;
-    srclen = (int)(bytes).size();
-    numlen = 0;
-    i = 0;
-    while (i < srclen) {
-        val = ((u8)bytes[i]);
-        if ((val >= 48) && (val < 58)) {
-            numlen = numlen + 1;
-        }
-        i = i + 1;
-    }
-    if (numlen == 0) {
-        res = string(1, (char)0);
-        res[0] = (char)(0);
-        return res;
-    }
-    res = string(2+((numlen+1) >> (1)), (char)0);
-    res[0] = (char)(numlen);
-    if (((u8)bytes[0]) == 43) {
-        res[1] = (char)(145);
-    } else {
-        res[1] = (char)(129);
-    }
-    numlen = 4;
-    digit = 0;
-    i = 0;
-    while (i < srclen) {
-        val = ((u8)bytes[i]);
-        if ((val >= 48) && (val < 58)) {
-            if (((numlen) & (1)) == 0) {
-                digit = val - 48;
-            } else {
-                res[((numlen) >> (1))] = (char)(digit + 16*(val-48));
-            }
-            numlen = numlen + 1;
-        }
-        i = i + 1;
-    }
-    // pad with F if needed
-    if (((numlen) & (1)) != 0) {
-        res[((numlen) >> (1))] = (char)(digit + 240);
-    }
-    return res;
-}
-
-string YSms::decodeAddress(string addr,int ofs,int siz)
-{
-    int addrType = 0;
-    string gsm7;
-    string res;
-    int i = 0;
-    int rpos = 0;
-    int carry = 0;
-    int nbits = 0;
-    int byt = 0;
-    if (siz == 0) {
-        return "";
-    }
-    res = "";
-    addrType = ((((u8)addr[ofs])) & (112));
-    if (addrType == 80) {
-        // alphanumeric number
-        siz = ((4*siz) / (7));
-        gsm7 = string(siz, (char)0);
-        rpos = 1;
-        carry = 0;
-        nbits = 0;
-        i = 0;
-        while (i < siz) {
-            if (nbits == 7) {
-                gsm7[i] = (char)(carry);
-                carry = 0;
-                nbits = 0;
-            } else {
-                byt = ((u8)addr[ofs+rpos]);
-                rpos = rpos + 1;
-                gsm7[i] = (char)(((carry) | ((((((byt) << (nbits)))) & (127)))));
-                carry = ((byt) >> ((7 - nbits)));
-                nbits = nbits + 1;
-            }
-            i = i + 1;
-        }
-        return _mbox->gsm2str(gsm7);
-    } else {
-        // standard phone number
-        if (addrType == 16) {
-            res = "+";
-        }
-        siz = (((siz+1)) >> (1));
-        i = 0;
-        while (i < siz) {
-            byt = ((u8)addr[ofs+i+1]);
-            res = YapiWrapper::ysprintf("%s%x%x", res.c_str(), ((byt) & (15)),((byt) >> (4)));
-            i = i + 1;
-        }
-        // remove padding digit if needed
-        if (((((u8)addr[ofs+siz])) >> (4)) == 15) {
-            res = (res).substr( 0, (int)(res).length()-1);
-        }
-        return res;
-    }
-}
-
-string YSms::encodeTimeStamp(string exp)
-{
-    int explen = 0;
-    int i = 0;
-    string res;
-    int n = 0;
-    string expasc;
-    int v1 = 0;
-    int v2 = 0;
-    explen = (int)(exp).length();
-    if (explen == 0) {
-        res = string(0, (char)0);
-        return res;
-    }
-    if ((exp).substr(0, 1) == "+") {
-        n = atoi(((exp).substr(1, explen-1)).c_str());
-        res = string(1, (char)0);
-        if (n > 30*86400) {
-            n = 192+(((n+6*86400)) / ((7*86400)));
-        } else {
-            if (n > 86400) {
-                n = 166+(((n+86399)) / (86400));
-            } else {
-                if (n > 43200) {
-                    n = 143+(((n-43200+1799)) / (1800));
-                } else {
-                    n = -1+(((n+299)) / (300));
-                }
-            }
-        }
-        if (n < 0) {
-            n = 0;
-        }
-        res[0] = (char)(n);
-        return res;
-    }
-    if ((exp).substr(4, 1) == "-" || (exp).substr(4, 1) == "/") {
-        // ignore century
-        exp = (exp).substr( 2, explen-2);
-        explen = (int)(exp).length();
-    }
-    expasc = exp;
-    res = string(7, (char)0);
-    n = 0;
-    i = 0;
-    while ((i+1 < explen) && (n < 7)) {
-        v1 = ((u8)expasc[i]);
-        if ((v1 >= 48) && (v1 < 58)) {
-            v2 = ((u8)expasc[i+1]);
-            if ((v2 >= 48) && (v2 < 58)) {
-                v1 = v1 - 48;
-                v2 = v2 - 48;
-                res[n] = (char)((((v2) << (4))) + v1);
-                n = n + 1;
-                i = i + 1;
-            }
-        }
-        i = i + 1;
-    }
-    while (n < 7) {
-        res[n] = (char)(0);
-        n = n + 1;
-    }
-    if (i+2 < explen) {
-        // convert for timezone in cleartext ISO format +/-nn:nn
-        v1 = ((u8)expasc[i-3]);
-        v2 = ((u8)expasc[i]);
-        if (((v1 == 43) || (v1 == 45)) && (v2 == 58)) {
-            v1 = ((u8)expasc[i+1]);
-            v2 = ((u8)expasc[i+2]);
-            if ((v1 >= 48) && (v1 < 58) && (v1 >= 48) && (v1 < 58)) {
-                v1 = (((10*(v1 - 48)+(v2 - 48))) / (15));
-                n = n - 1;
-                v2 = 4 * ((u8)res[n]) + v1;
-                if (((u8)expasc[i-3]) == 45) {
-                    v2 += 128;
-                }
-                res[n] = (char)(v2);
-            }
-        }
-    }
-    return res;
-}
-
-string YSms::decodeTimeStamp(string exp,int ofs,int siz)
-{
-    int n = 0;
-    string res;
-    int i = 0;
-    int byt = 0;
-    string sign;
-    string hh;
-    string ss;
-    if (siz < 1) {
-        return "";
-    }
-    if (siz == 1) {
-        n = ((u8)exp[ofs]);
-        if (n < 144) {
-            n = n * 300;
-        } else {
-            if (n < 168) {
-                n = (n-143) * 1800;
-            } else {
-                if (n < 197) {
-                    n = (n-166) * 86400;
-                } else {
-                    n = (n-192) * 7 * 86400;
-                }
-            }
-        }
-        return YapiWrapper::ysprintf("+%d",n);
-    }
-    res = "20";
-    i = 0;
-    while ((i < siz) && (i < 6)) {
-        byt = ((u8)exp[ofs+i]);
-        res = YapiWrapper::ysprintf("%s%x%x", res.c_str(), ((byt) & (15)),((byt) >> (4)));
-        if (i < 3) {
-            if (i < 2) {
-                res = YapiWrapper::ysprintf("%s-",res.c_str());
-            } else {
-                res = YapiWrapper::ysprintf("%s ",res.c_str());
-            }
-        } else {
-            if (i < 5) {
-                res = YapiWrapper::ysprintf("%s:",res.c_str());
-            }
-        }
-        i = i + 1;
-    }
-    if (siz == 7) {
-        byt = ((u8)exp[ofs+i]);
-        sign = "+";
-        if (((byt) & (8)) != 0) {
-            byt = byt - 8;
-            sign = "-";
-        }
-        byt = (10*(((byt) & (15)))) + (((byt) >> (4)));
-        hh = YapiWrapper::ysprintf("%d",((byt) >> (2)));
-        ss = YapiWrapper::ysprintf("%d",15*(((byt) & (3))));
-        if ((int)(hh).length()<2) {
-            hh = YapiWrapper::ysprintf("0%s",hh.c_str());
-        }
-        if ((int)(ss).length()<2) {
-            ss = YapiWrapper::ysprintf("0%s",ss.c_str());
-        }
-        res = YapiWrapper::ysprintf("%s%s%s:%s", res.c_str(), sign.c_str(), hh.c_str(),ss.c_str());
-    }
-    return res;
-}
-
-int YSms::udataSize(void)
-{
-    int res = 0;
-    int udhsize = 0;
-    udhsize = (int)(_udh).size();
-    res = (int)(_udata).size();
-    if (_alphab == 0) {
-        if (udhsize > 0) {
-            res = res + (((8 + 8*udhsize + 6)) / (7));
-        }
-        res = (((res * 7 + 7)) / (8));
-    } else {
-        if (udhsize > 0) {
-            res = res + 1 + udhsize;
-        }
-    }
-    return res;
-}
-
-string YSms::encodeUserData(void)
-{
-    int udsize = 0;
-    int udlen = 0;
-    int udhsize = 0;
-    int udhlen = 0;
-    string res;
-    int i = 0;
-    int wpos = 0;
-    int carry = 0;
-    int nbits = 0;
-    int thi_b = 0;
-    // nbits = number of bits in carry
-    udsize = this->udataSize();
-    udhsize = (int)(_udh).size();
-    udlen = (int)(_udata).size();
-    res = string(1+udsize, (char)0);
-    udhlen = 0;
-    nbits = 0;
-    carry = 0;
-    // 1. Encode UDL
-    if (_alphab == 0) {
-        // 7-bit encoding
-        if (udhsize > 0) {
-            udhlen = (((8 + 8*udhsize + 6)) / (7));
-            nbits = 7*udhlen - 8 - 8*udhsize;
-        }
-        res[0] = (char)(udhlen+udlen);
-    } else {
-        // 8-bit encoding
-        res[0] = (char)(udsize);
-    }
-    // 2. Encode UDHL and UDL
-    wpos = 1;
-    if (udhsize > 0) {
-        res[wpos] = (char)(udhsize);
-        wpos = wpos + 1;
-        i = 0;
-        while (i < udhsize) {
-            res[wpos] = (char)(((u8)_udh[i]));
-            wpos = wpos + 1;
-            i = i + 1;
-        }
-    }
-    // 3. Encode UD
-    if (_alphab == 0) {
-        // 7-bit encoding
-        i = 0;
-        while (i < udlen) {
-            if (nbits == 0) {
-                carry = ((u8)_udata[i]);
-                nbits = 7;
-            } else {
-                thi_b = ((u8)_udata[i]);
-                res[wpos] = (char)(((carry) | ((((((thi_b) << (nbits)))) & (255)))));
-                wpos = wpos + 1;
-                nbits = nbits - 1;
-                carry = ((thi_b) >> ((7 - nbits)));
-            }
-            i = i + 1;
-        }
-        if (nbits > 0) {
-            res[wpos] = (char)(carry);
-        }
-    } else {
-        // 8-bit encoding
-        i = 0;
-        while (i < udlen) {
-            res[wpos] = (char)(((u8)_udata[i]));
-            wpos = wpos + 1;
-            i = i + 1;
-        }
-    }
-    return res;
-}
-
-int YSms::generateParts(void)
-{
-    int udhsize = 0;
-    int udlen = 0;
-    int mss = 0;
-    int partno = 0;
-    int partlen = 0;
-    string newud;
-    string newudh;
-    YSms newpdu;
-    int i = 0;
-    int wpos = 0;
-    udhsize = (int)(_udh).size();
-    udlen = (int)(_udata).size();
-    mss = 140 - 1 - 5 - udhsize;
-    if (_alphab == 0) {
-        mss = (((mss * 8 - 6)) / (7));
-    }
-    _npdu = (((udlen+mss-1)) / (mss));
-    _parts.clear();
-    partno = 0;
-    wpos = 0;
-    while (wpos < udlen) {
-        partno = partno + 1;
-        newudh = string(5+udhsize, (char)0);
-        newudh[0] = (char)(0);           // IEI: concatenated message
-        newudh[1] = (char)(3);           // IEDL: 3 bytes
-        newudh[2] = (char)(_mref);
-        newudh[3] = (char)(_npdu);
-        newudh[4] = (char)(partno);
-        i = 0;
-        while (i < udhsize) {
-            newudh[5+i] = (char)(((u8)_udh[i]));
-            i = i + 1;
-        }
-        if (wpos+mss < udlen) {
-            partlen = mss;
-        } else {
-            partlen = udlen-wpos;
-        }
-        newud = string(partlen, (char)0);
-        i = 0;
-        while (i < partlen) {
-            newud[i] = (char)(((u8)_udata[wpos]));
-            wpos = wpos + 1;
-            i = i + 1;
-        }
-        newpdu = YSms(_mbox);
-        newpdu.set_received(this->isReceived());
-        newpdu.set_smsc(this->get_smsc());
-        newpdu.set_msgRef(this->get_msgRef());
-        newpdu.set_sender(this->get_sender());
-        newpdu.set_recipient(this->get_recipient());
-        newpdu.set_protocolId(this->get_protocolId());
-        newpdu.set_dcs(this->get_dcs());
-        newpdu.set_timestamp(this->get_timestamp());
-        newpdu.set_userDataHeader(newudh);
-        newpdu.set_userData(newud);
-        _parts.push_back(newpdu);
-    }
-    return YAPI_SUCCESS;
-}
-
-int YSms::generatePdu(void)
-{
-    string sca;
-    string hdr;
-    string addr;
-    string stamp;
-    string udata;
-    int pdutyp = 0;
-    int pdulen = 0;
-    int i = 0;
-    // Determine if the message can fit within a single PDU
-    _parts.clear();
-    if (this->udataSize() > 140) {
-        // multiple PDU are needed
-        _pdu = string(0, (char)0);
-        return this->generateParts();
-    }
-    sca = this->encodeAddress(_smsc);
-    if ((int)(sca).size() > 0) {
-        sca[0] = (char)((int)(sca).size()-1);
-    }
-    stamp = this->encodeTimeStamp(_stamp);
-    udata = this->encodeUserData();
-    if (_deliv) {
-        addr = this->encodeAddress(_orig);
-        hdr = string(1, (char)0);
-        pdutyp = 0;
-    } else {
-        addr = this->encodeAddress(_dest);
-        _mref = _mbox->nextMsgRef();
-        hdr = string(2, (char)0);
-        hdr[1] = (char)(_mref);
-        pdutyp = 1;
-        if ((int)(stamp).size() > 0) {
-            pdutyp = pdutyp + 16;
-        }
-        if ((int)(stamp).size() == 7) {
-            pdutyp = pdutyp + 8;
-        }
-    }
-    if ((int)(_udh).size() > 0) {
-        pdutyp = pdutyp + 64;
-    }
-    hdr[0] = (char)(pdutyp);
-    pdulen = (int)(sca).size()+(int)(hdr).size()+(int)(addr).size()+2+(int)(stamp).size()+(int)(udata).size();
-    _pdu = string(pdulen, (char)0);
-    pdulen = 0;
-    i = 0;
-    while (i < (int)(sca).size()) {
-        _pdu[pdulen] = (char)(((u8)sca[i]));
-        pdulen = pdulen + 1;
-        i = i + 1;
-    }
-    i = 0;
-    while (i < (int)(hdr).size()) {
-        _pdu[pdulen] = (char)(((u8)hdr[i]));
-        pdulen = pdulen + 1;
-        i = i + 1;
-    }
-    i = 0;
-    while (i < (int)(addr).size()) {
-        _pdu[pdulen] = (char)(((u8)addr[i]));
-        pdulen = pdulen + 1;
-        i = i + 1;
-    }
-    _pdu[pdulen] = (char)(_pid);
-    pdulen = pdulen + 1;
-    _pdu[pdulen] = (char)(this->get_dcs());
-    pdulen = pdulen + 1;
-    i = 0;
-    while (i < (int)(stamp).size()) {
-        _pdu[pdulen] = (char)(((u8)stamp[i]));
-        pdulen = pdulen + 1;
-        i = i + 1;
-    }
-    i = 0;
-    while (i < (int)(udata).size()) {
-        _pdu[pdulen] = (char)(((u8)udata[i]));
-        pdulen = pdulen + 1;
-        i = i + 1;
-    }
-    _npdu = 1;
-    return YAPI_SUCCESS;
-}
-
-int YSms::parseUserDataHeader(void)
-{
-    int udhlen = 0;
-    int i = 0;
-    int iei = 0;
-    int ielen = 0;
-    string sig;
-    _aggSig = "";
-    _aggIdx = 0;
-    _aggCnt = 0;
-    udhlen = (int)(_udh).size();
-    i = 0;
-    while (i+1 < udhlen) {
-        iei = ((u8)_udh[i]);
-        ielen = ((u8)_udh[i+1]);
-        i = i + 2;
-        if (i + ielen <= udhlen) {
-            if ((iei == 0) && (ielen == 3)) {
-                // concatenated SMS, 8-bit ref
-                sig = YapiWrapper::ysprintf("%s-%s-%02x-%02x", _orig.c_str(), _dest.c_str(),
-                _mref,((u8)_udh[i]));
-                _aggSig = sig;
-                _aggCnt = ((u8)_udh[i+1]);
-                _aggIdx = ((u8)_udh[i+2]);
-            }
-            if ((iei == 8) && (ielen == 4)) {
-                // concatenated SMS, 16-bit ref
-                sig = YapiWrapper::ysprintf("%s-%s-%02x-%02x%02x", _orig.c_str(), _dest.c_str(),
-                _mref, ((u8)_udh[i]),((u8)_udh[i+1]));
-                _aggSig = sig;
-                _aggCnt = ((u8)_udh[i+2]);
-                _aggIdx = ((u8)_udh[i+3]);
-            }
-        }
-        i = i + ielen;
-    }
-    return YAPI_SUCCESS;
-}
-
-int YSms::parsePdu(string pdu)
-{
-    int rpos = 0;
-    int addrlen = 0;
-    int pdutyp = 0;
-    int tslen = 0;
-    int dcs = 0;
-    int udlen = 0;
-    int udhsize = 0;
-    int udhlen = 0;
-    int i = 0;
-    int carry = 0;
-    int nbits = 0;
-    int thi_b = 0;
-    _pdu = pdu;
-    _npdu = 1;
-    // parse meta-data
-    _smsc = this->decodeAddress(pdu, 1, 2*(((u8)pdu[0])-1));
-    rpos = 1+((u8)pdu[0]);
-    pdutyp = ((u8)pdu[rpos]);
-    rpos = rpos + 1;
-    _deliv = (((pdutyp) & (3)) == 0);
-    if (_deliv) {
-        addrlen = ((u8)pdu[rpos]);
-        rpos = rpos + 1;
-        _orig = this->decodeAddress(pdu, rpos, addrlen);
-        _dest = "";
-        tslen = 7;
-    } else {
-        _mref = ((u8)pdu[rpos]);
-        rpos = rpos + 1;
-        addrlen = ((u8)pdu[rpos]);
-        rpos = rpos + 1;
-        _dest = this->decodeAddress(pdu, rpos, addrlen);
-        _orig = "";
-        if ((((pdutyp) & (16))) != 0) {
-            if ((((pdutyp) & (8))) != 0) {
-                tslen = 7;
-            } else {
-                tslen= 1;
-            }
-        } else {
-            tslen = 0;
-        }
-    }
-    rpos = rpos + ((((addrlen+3)) >> (1)));
-    _pid = ((u8)pdu[rpos]);
-    rpos = rpos + 1;
-    dcs = ((u8)pdu[rpos]);
-    rpos = rpos + 1;
-    _alphab = (((((dcs) >> (2)))) & (3));
-    _mclass = ((dcs) & (16+3));
-    _stamp = this->decodeTimeStamp(pdu, rpos, tslen);
-    rpos = rpos + tslen;
-    // parse user data (including udh)
-    nbits = 0;
-    carry = 0;
-    udlen = ((u8)pdu[rpos]);
-    rpos = rpos + 1;
-    if (((pdutyp) & (64)) != 0) {
-        udhsize = ((u8)pdu[rpos]);
-        rpos = rpos + 1;
-        _udh = string(udhsize, (char)0);
-        i = 0;
-        while (i < udhsize) {
-            _udh[i] = (char)(((u8)pdu[rpos]));
-            rpos = rpos + 1;
-            i = i + 1;
-        }
-        if (_alphab == 0) {
-            // 7-bit encoding
-            udhlen = (((8 + 8*udhsize + 6)) / (7));
-            nbits = 7*udhlen - 8 - 8*udhsize;
-            if (nbits > 0) {
-                thi_b = ((u8)pdu[rpos]);
-                rpos = rpos + 1;
-                carry = ((thi_b) >> (nbits));
-                nbits = 8 - nbits;
-            }
-        } else {
-            // byte encoding
-            udhlen = 1+udhsize;
-        }
-        udlen = udlen - udhlen;
-    } else {
-        udhsize = 0;
-        _udh = string(0, (char)0);
-    }
-    _udata = string(udlen, (char)0);
-    if (_alphab == 0) {
-        // 7-bit encoding
-        i = 0;
-        while (i < udlen) {
-            if (nbits == 7) {
-                _udata[i] = (char)(carry);
-                carry = 0;
-                nbits = 0;
-            } else {
-                thi_b = ((u8)pdu[rpos]);
-                rpos = rpos + 1;
-                _udata[i] = (char)(((carry) | ((((((thi_b) << (nbits)))) & (127)))));
-                carry = ((thi_b) >> ((7 - nbits)));
-                nbits = nbits + 1;
-            }
-            i = i + 1;
-        }
-    } else {
-        // 8-bit encoding
-        i = 0;
-        while (i < udlen) {
-            _udata[i] = (char)(((u8)pdu[rpos]));
-            rpos = rpos + 1;
-            i = i + 1;
-        }
-    }
-    this->parseUserDataHeader();
-    return YAPI_SUCCESS;
-}
-
-int YSms::send(void)
-{
-    int i = 0;
-    int retcode = 0;
-    YSms pdu;
-
-    if (_npdu == 0) {
-        this->generatePdu();
-    }
-    if (_npdu == 1) {
-        return _mbox->_upload("sendSMS", _pdu);
-    }
-    retcode = YAPI_SUCCESS;
-    i = 0;
-    while ((i < _npdu) && (retcode == YAPI_SUCCESS)) {
-        pdu = _parts[i];
-        retcode= pdu.send();
-        i = i + 1;
-    }
-    return retcode;
-}
-
-int YSms::deleteFromSIM(void)
-{
-    int i = 0;
-    int retcode = 0;
-    YSms pdu;
-
-    if (_slot > 0) {
-        return _mbox->clearSIMSlot(_slot);
-    }
-    retcode = YAPI_SUCCESS;
-    i = 0;
-    while ((i < _npdu) && (retcode == YAPI_SUCCESS)) {
-        pdu = _parts[i];
-        retcode= pdu.deleteFromSIM();
-        i = i + 1;
-    }
-    return retcode;
-}
-//--- (end of generated code: YSms implementation)
-
-
-YMessageBox::YMessageBox(const string& func): YFunction(func)
-//--- (generated code: YMessageBox initialization)
-    ,_slotsInUse(SLOTSINUSE_INVALID)
-    ,_slotsCount(SLOTSCOUNT_INVALID)
-    ,_slotsBitmap(SLOTSBITMAP_INVALID)
-    ,_pduSent(PDUSENT_INVALID)
-    ,_pduReceived(PDURECEIVED_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackMessageBox(NULL)
-    ,_nextMsgRef(0)
-    ,_gsm2unicodeReady(0)
-//--- (end of generated code: YMessageBox initialization)
-{
-    _className="MessageBox";
-}
-
-YMessageBox::~YMessageBox()
-{
-//--- (generated code: YMessageBox cleanup)
-//--- (end of generated code: YMessageBox cleanup)
-}
-//--- (generated code: YMessageBox implementation)
-// static attributes
-const string YMessageBox::SLOTSBITMAP_INVALID = YAPI_INVALID_STRING;
-const string YMessageBox::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YMessageBox::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("slotsInUse")) {
-        _slotsInUse =  json_val->getInt("slotsInUse");
-    }
-    if(json_val->has("slotsCount")) {
-        _slotsCount =  json_val->getInt("slotsCount");
-    }
-    if(json_val->has("slotsBitmap")) {
-        _slotsBitmap =  json_val->getString("slotsBitmap");
-    }
-    if(json_val->has("pduSent")) {
-        _pduSent =  json_val->getInt("pduSent");
-    }
-    if(json_val->has("pduReceived")) {
-        _pduReceived =  json_val->getInt("pduReceived");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the number of message storage slots currently in use.
- *
- * @return an integer corresponding to the number of message storage slots currently in use
- *
- * On failure, throws an exception or returns Y_SLOTSINUSE_INVALID.
- */
-int YMessageBox::get_slotsInUse(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::SLOTSINUSE_INVALID;
-                }
-            }
-        }
-        res = _slotsInUse;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of message storage slots on the SIM card.
- *
- * @return an integer corresponding to the total number of message storage slots on the SIM card
- *
- * On failure, throws an exception or returns Y_SLOTSCOUNT_INVALID.
- */
-int YMessageBox::get_slotsCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::SLOTSCOUNT_INVALID;
-                }
-            }
-        }
-        res = _slotsCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMessageBox::get_slotsBitmap(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::SLOTSBITMAP_INVALID;
-                }
-            }
-        }
-        res = _slotsBitmap;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of SMS units sent so far.
- *
- * @return an integer corresponding to the number of SMS units sent so far
- *
- * On failure, throws an exception or returns Y_PDUSENT_INVALID.
- */
-int YMessageBox::get_pduSent(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::PDUSENT_INVALID;
-                }
-            }
-        }
-        res = _pduSent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the value of the outgoing SMS units counter.
- *
- * @param newval : an integer corresponding to the value of the outgoing SMS units counter
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMessageBox::set_pduSent(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("pduSent", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of SMS units received so far.
- *
- * @return an integer corresponding to the number of SMS units received so far
- *
- * On failure, throws an exception or returns Y_PDURECEIVED_INVALID.
- */
-int YMessageBox::get_pduReceived(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::PDURECEIVED_INVALID;
-                }
-            }
-        }
-        res = _pduReceived;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the value of the incoming SMS units counter.
- *
- * @param newval : an integer corresponding to the value of the incoming SMS units counter
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMessageBox::set_pduReceived(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("pduReceived", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMessageBox::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMessageBox::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMessageBox::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a MessageBox interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the MessageBox interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMessageBox.isOnline() to test if the MessageBox interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a MessageBox interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the MessageBox interface
- *
- * @return a YMessageBox object allowing you to drive the MessageBox interface.
- */
-YMessageBox* YMessageBox::FindMessageBox(string func)
-{
-    YMessageBox* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMessageBox*) YFunction::_FindFromCache("MessageBox", func);
-        if (obj == NULL) {
-            obj = new YMessageBox(func);
-            YFunction::_AddToCache("MessageBox", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMessageBox::registerValueCallback(YMessageBoxValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMessageBox = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMessageBox::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMessageBox != NULL) {
-        _valueCallbackMessageBox(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YMessageBox::nextMsgRef(void)
-{
-    _nextMsgRef = _nextMsgRef + 1;
-    return _nextMsgRef;
-}
-
-int YMessageBox::clearSIMSlot(int slot)
-{
-    _prevBitmapStr = "";
-    return this->set_command(YapiWrapper::ysprintf("DS%d",slot));
-}
-
-YSms YMessageBox::fetchPdu(int slot)
-{
-    string binPdu;
-    vector<string> arrPdu;
-    string hexPdu;
-    YSms sms;
-
-    binPdu = this->_download(YapiWrapper::ysprintf("sms.json?pos=%d&len=1",slot));
-    arrPdu = this->_json_get_array(binPdu);
-    hexPdu = this->_decode_json_string(arrPdu[0]);
-    sms = YSms(this);
-    sms.set_slot(slot);
-    sms.parsePdu(YAPI::_hexStr2Bin(hexPdu));
-    return sms;
-}
-
-int YMessageBox::initGsm2Unicode(void)
-{
-    int i = 0;
-    int uni = 0;
-    _gsm2unicode.clear();
-    // 00-07
-    _gsm2unicode.push_back(64);
-    _gsm2unicode.push_back(163);
-    _gsm2unicode.push_back(36);
-    _gsm2unicode.push_back(165);
-    _gsm2unicode.push_back(232);
-    _gsm2unicode.push_back(233);
-    _gsm2unicode.push_back(249);
-    _gsm2unicode.push_back(236);
-    // 08-0F
-    _gsm2unicode.push_back(242);
-    _gsm2unicode.push_back(199);
-    _gsm2unicode.push_back(10);
-    _gsm2unicode.push_back(216);
-    _gsm2unicode.push_back(248);
-    _gsm2unicode.push_back(13);
-    _gsm2unicode.push_back(197);
-    _gsm2unicode.push_back(229);
-    // 10-17
-    _gsm2unicode.push_back(916);
-    _gsm2unicode.push_back(95);
-    _gsm2unicode.push_back(934);
-    _gsm2unicode.push_back(915);
-    _gsm2unicode.push_back(923);
-    _gsm2unicode.push_back(937);
-    _gsm2unicode.push_back(928);
-    _gsm2unicode.push_back(936);
-    // 18-1F
-    _gsm2unicode.push_back(931);
-    _gsm2unicode.push_back(920);
-    _gsm2unicode.push_back(926);
-    _gsm2unicode.push_back(27);
-    _gsm2unicode.push_back(198);
-    _gsm2unicode.push_back(230);
-    _gsm2unicode.push_back(223);
-    _gsm2unicode.push_back(201);
-    // 20-7A
-    i = 32;
-    while (i <= 122) {
-        _gsm2unicode.push_back(i);
-        i = i + 1;
-    }
-    // exceptions in range 20-7A
-    _gsm2unicode[36] = 164;
-    _gsm2unicode[64] = 161;
-    _gsm2unicode[91] = 196;
-    _gsm2unicode[92] = 214;
-    _gsm2unicode[93] = 209;
-    _gsm2unicode[94] = 220;
-    _gsm2unicode[95] = 167;
-    _gsm2unicode[96] = 191;
-    // 7B-7F
-    _gsm2unicode.push_back(228);
-    _gsm2unicode.push_back(246);
-    _gsm2unicode.push_back(241);
-    _gsm2unicode.push_back(252);
-    _gsm2unicode.push_back(224);
-    // Invert table as well wherever possible
-    _iso2gsm = string(256, (char)0);
-    i = 0;
-    while (i <= 127) {
-        uni = _gsm2unicode[i];
-        if (uni <= 255) {
-            _iso2gsm[uni] = (char)(i);
-        }
-        i = i + 1;
-    }
-    i = 0;
-    while (i < 4) {
-        // mark escape sequences
-        _iso2gsm[91+i] = (char)(27);
-        _iso2gsm[123+i] = (char)(27);
-        i = i + 1;
-    }
-    // Done
-    _gsm2unicodeReady = true;
-    return YAPI_SUCCESS;
-}
-
-vector<int> YMessageBox::gsm2unicode(string gsm)
-{
-    int i = 0;
-    int gsmlen = 0;
-    int reslen = 0;
-    vector<int> res;
-    int uni = 0;
-    if (!(_gsm2unicodeReady)) {
-        this->initGsm2Unicode();
-    }
-    gsmlen = (int)(gsm).size();
-    reslen = gsmlen;
-    i = 0;
-    while (i < gsmlen) {
-        if (((u8)gsm[i]) == 27) {
-            reslen = reslen - 1;
-        }
-        i = i + 1;
-    }
-    res.clear();
-    i = 0;
-    while (i < gsmlen) {
-        uni = _gsm2unicode[((u8)gsm[i])];
-        if ((uni == 27) && (i+1 < gsmlen)) {
-            i = i + 1;
-            uni = ((u8)gsm[i]);
-            if (uni < 60) {
-                if (uni < 41) {
-                    if (uni==20) {
-                        uni=94;
-                    } else {
-                        if (uni==40) {
-                            uni=123;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                } else {
-                    if (uni==41) {
-                        uni=125;
-                    } else {
-                        if (uni==47) {
-                            uni=92;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                }
-            } else {
-                if (uni < 62) {
-                    if (uni==60) {
-                        uni=91;
-                    } else {
-                        if (uni==61) {
-                            uni=126;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                } else {
-                    if (uni==62) {
-                        uni=93;
-                    } else {
-                        if (uni==64) {
-                            uni=124;
-                        } else {
-                            if (uni==101) {
-                                uni=164;
-                            } else {
-                                uni=0;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        if (uni > 0) {
-            res.push_back(uni);
-        }
-        i = i + 1;
-    }
-    return res;
-}
-
-string YMessageBox::gsm2str(string gsm)
-{
-    int i = 0;
-    int gsmlen = 0;
-    int reslen = 0;
-    string resbin;
-    string resstr;
-    int uni = 0;
-    if (!(_gsm2unicodeReady)) {
-        this->initGsm2Unicode();
-    }
-    gsmlen = (int)(gsm).size();
-    reslen = gsmlen;
-    i = 0;
-    while (i < gsmlen) {
-        if (((u8)gsm[i]) == 27) {
-            reslen = reslen - 1;
-        }
-        i = i + 1;
-    }
-    resbin = string(reslen, (char)0);
-    i = 0;
-    reslen = 0;
-    while (i < gsmlen) {
-        uni = _gsm2unicode[((u8)gsm[i])];
-        if ((uni == 27) && (i+1 < gsmlen)) {
-            i = i + 1;
-            uni = ((u8)gsm[i]);
-            if (uni < 60) {
-                if (uni < 41) {
-                    if (uni==20) {
-                        uni=94;
-                    } else {
-                        if (uni==40) {
-                            uni=123;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                } else {
-                    if (uni==41) {
-                        uni=125;
-                    } else {
-                        if (uni==47) {
-                            uni=92;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                }
-            } else {
-                if (uni < 62) {
-                    if (uni==60) {
-                        uni=91;
-                    } else {
-                        if (uni==61) {
-                            uni=126;
-                        } else {
-                            uni=0;
-                        }
-                    }
-                } else {
-                    if (uni==62) {
-                        uni=93;
-                    } else {
-                        if (uni==64) {
-                            uni=124;
-                        } else {
-                            if (uni==101) {
-                                uni=164;
-                            } else {
-                                uni=0;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        if ((uni > 0) && (uni < 256)) {
-            resbin[reslen] = (char)(uni);
-            reslen = reslen + 1;
-        }
-        i = i + 1;
-    }
-    resstr = resbin;
-    if ((int)(resstr).length() > reslen) {
-        resstr = (resstr).substr(0, reslen);
-    }
-    return resstr;
-}
-
-string YMessageBox::str2gsm(string msg)
-{
-    string asc;
-    int asclen = 0;
-    int i = 0;
-    int ch = 0;
-    int gsm7 = 0;
-    int extra = 0;
-    string res;
-    int wpos = 0;
-    if (!(_gsm2unicodeReady)) {
-        this->initGsm2Unicode();
-    }
-    asc = msg;
-    asclen = (int)(asc).size();
-    extra = 0;
-    i = 0;
-    while (i < asclen) {
-        ch = ((u8)asc[i]);
-        gsm7 = ((u8)_iso2gsm[ch]);
-        if (gsm7 == 27) {
-            extra = extra + 1;
-        }
-        if (gsm7 == 0) {
-            // cannot use standard GSM encoding
-            res = string(0, (char)0);
-            return res;
-        }
-        i = i + 1;
-    }
-    res = string(asclen+extra, (char)0);
-    wpos = 0;
-    i = 0;
-    while (i < asclen) {
-        ch = ((u8)asc[i]);
-        gsm7 = ((u8)_iso2gsm[ch]);
-        res[wpos] = (char)(gsm7);
-        wpos = wpos + 1;
-        if (gsm7 == 27) {
-            if (ch < 100) {
-                if (ch<93) {
-                    if (ch<92) {
-                        gsm7=60;
-                    } else {
-                        gsm7=47;
-                    }
-                } else {
-                    if (ch<94) {
-                        gsm7=62;
-                    } else {
-                        gsm7=20;
-                    }
-                }
-            } else {
-                if (ch<125) {
-                    if (ch<124) {
-                        gsm7=40;
-                    } else {
-                        gsm7=64;
-                    }
-                } else {
-                    if (ch<126) {
-                        gsm7=41;
-                    } else {
-                        gsm7=61;
-                    }
-                }
-            }
-            res[wpos] = (char)(gsm7);
-            wpos = wpos + 1;
-        }
-        i = i + 1;
-    }
-    return res;
-}
-
-int YMessageBox::checkNewMessages(void)
-{
-    string bitmapStr;
-    string prevBitmap;
-    string newBitmap;
-    int slot = 0;
-    int nslots = 0;
-    int pduIdx = 0;
-    int idx = 0;
-    int bitVal = 0;
-    int prevBit = 0;
-    int i = 0;
-    int nsig = 0;
-    int cnt = 0;
-    string sig;
-    vector<YSms> newArr;
-    vector<YSms> newMsg;
-    vector<YSms> newAgg;
-    vector<string> signatures;
-    YSms sms;
-
-    bitmapStr = this->get_slotsBitmap();
-    if (bitmapStr == _prevBitmapStr) {
-        return YAPI_SUCCESS;
-    }
-    prevBitmap = YAPI::_hexStr2Bin(_prevBitmapStr);
-    newBitmap = YAPI::_hexStr2Bin(bitmapStr);
-    _prevBitmapStr = bitmapStr;
-    nslots = 8*(int)(newBitmap).size();
-    newArr.clear();
-    newMsg.clear();
-    signatures.clear();
-    nsig = 0;
-    // copy known messages
-    pduIdx = 0;
-    while (pduIdx < (int)_pdus.size()) {
-        sms = _pdus[pduIdx];
-        slot = sms.get_slot();
-        idx = ((slot) >> (3));
-        if (idx < (int)(newBitmap).size()) {
-            bitVal = ((1) << ((((slot) & (7)))));
-            if ((((((u8)newBitmap[idx])) & (bitVal))) != 0) {
-                newArr.push_back(sms);
-                if (sms.get_concatCount() == 0) {
-                    newMsg.push_back(sms);
-                } else {
-                    sig = sms.get_concatSignature();
-                    i = 0;
-                    while ((i < nsig) && ((int)(sig).length() > 0)) {
-                        if (signatures[i] == sig) {
-                            sig = "";
-                        }
-                        i = i + 1;
-                    }
-                    if ((int)(sig).length() > 0) {
-                        signatures.push_back(sig);
-                        nsig = nsig + 1;
-                    }
-                }
-            }
-        }
-        pduIdx = pduIdx + 1;
-    }
-    // receive new messages
-    slot = 0;
-    while (slot < nslots) {
-        idx = ((slot) >> (3));
-        bitVal = ((1) << ((((slot) & (7)))));
-        prevBit = 0;
-        if (idx < (int)(prevBitmap).size()) {
-            prevBit = ((((u8)prevBitmap[idx])) & (bitVal));
-        }
-        if ((((((u8)newBitmap[idx])) & (bitVal))) != 0) {
-            if (prevBit == 0) {
-                sms = this->fetchPdu(slot);
-                newArr.push_back(sms);
-                if (sms.get_concatCount() == 0) {
-                    newMsg.push_back(sms);
-                } else {
-                    sig = sms.get_concatSignature();
-                    i = 0;
-                    while ((i < nsig) && ((int)(sig).length() > 0)) {
-                        if (signatures[i] == sig) {
-                            sig = "";
-                        }
-                        i = i + 1;
-                    }
-                    if ((int)(sig).length() > 0) {
-                        signatures.push_back(sig);
-                        nsig = nsig + 1;
-                    }
-                }
-            }
-        }
-        slot = slot + 1;
-    }
-    _pdus = newArr;
-    // append complete concatenated messages
-    i = 0;
-    while (i < nsig) {
-        sig = signatures[i];
-        cnt = 0;
-        pduIdx = 0;
-        while (pduIdx < (int)_pdus.size()) {
-            sms = _pdus[pduIdx];
-            if (sms.get_concatCount() > 0) {
-                if (sms.get_concatSignature() == sig) {
-                    if (cnt == 0) {
-                        cnt = sms.get_concatCount();
-                        newAgg.clear();
-                    }
-                    newAgg.push_back(sms);
-                }
-            }
-            pduIdx = pduIdx + 1;
-        }
-        if ((cnt > 0) && ((int)newAgg.size() == cnt)) {
-            sms = YSms(this);
-            sms.set_parts(newAgg);
-            newMsg.push_back(sms);
-        }
-        i = i + 1;
-    }
-    _messages = newMsg;
-    return YAPI_SUCCESS;
-}
-
-vector<YSms> YMessageBox::get_pdus(void)
-{
-    this->checkNewMessages();
-    return _pdus;
-}
-
-/**
- * Clear the SMS units counters.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMessageBox::clearPduCounters(void)
-{
-    int retcode = 0;
-
-    retcode = this->set_pduReceived(0);
-    if (retcode != YAPI_SUCCESS) {
-        return retcode;
-    }
-    retcode = this->set_pduSent(0);
-    return retcode;
-}
-
-/**
- * Sends a regular text SMS, with standard parameters. This function can send messages
- * of more than 160 characters, using SMS concatenation. ISO-latin accented characters
- * are supported. For sending messages with special unicode characters such as asian
- * characters and emoticons, use newMessage to create a new message and define
- * the content of using methods addText and addUnicodeData.
- *
- * @param recipient : a text string with the recipient phone number, either as a
- *         national number, or in international format starting with a plus sign
- * @param message : the text to be sent in the message
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMessageBox::sendTextMessage(string recipient,string message)
-{
-    YSms sms;
-
-    sms = YSms(this);
-    sms.set_recipient(recipient);
-    sms.addText(message);
-    return sms.send();
-}
-
-/**
- * Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset
- * immediately and are usually not saved on the SIM card. This function can send messages
- * of more than 160 characters, using SMS concatenation. ISO-latin accented characters
- * are supported. For sending messages with special unicode characters such as asian
- * characters and emoticons, use newMessage to create a new message and define
- * the content of using methods addText et addUnicodeData.
- *
- * @param recipient : a text string with the recipient phone number, either as a
- *         national number, or in international format starting with a plus sign
- * @param message : the text to be sent in the message
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMessageBox::sendFlashMessage(string recipient,string message)
-{
-    YSms sms;
-
-    sms = YSms(this);
-    sms.set_recipient(recipient);
-    sms.set_msgClass(0);
-    sms.addText(message);
-    return sms.send();
-}
-
-/**
- * Creates a new empty SMS message, to be configured and sent later on.
- *
- * @param recipient : a text string with the recipient phone number, either as a
- *         national number, or in international format starting with a plus sign
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-YSms YMessageBox::newMessage(string recipient)
-{
-    YSms sms;
-    sms = YSms(this);
-    sms.set_recipient(recipient);
-    return sms;
-}
-
-/**
- * Returns the list of messages received and not deleted. This function
- * will automatically decode concatenated SMS.
- *
- * @return an YSms object list.
- *
- * On failure, throws an exception or returns an empty list.
- */
-vector<YSms> YMessageBox::get_messages(void)
-{
-    this->checkNewMessages();
-    return _messages;
-}
-
-YMessageBox *YMessageBox::nextMessageBox(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMessageBox::FindMessageBox(hwid);
-}
-
-YMessageBox* YMessageBox::FirstMessageBox(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("MessageBox", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMessageBox::FindMessageBox(serial+"."+funcId);
-}
-
-//--- (end of generated code: YMessageBox implementation)
-
-//--- (generated code: YMessageBox functions)
-//--- (end of generated code: YMessageBox functions)
--- a/Sources/cpplib/yocto_messagebox.h
+++ /dev/null
@@ -1,569 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_messagebox.h 32901 2018-11-02 10:13:09Z seb $
- *
- * Declares yFindMessageBox(), the high-level API for MessageBox functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MESSAGEBOX_H
-#define YOCTO_MESSAGEBOX_H
-
-#include "yocto_api.h"
-
-
-//--- (generated code: YMessageBox return codes)
-//--- (end of generated code: YMessageBox return codes)
-//--- (generated code: YMessageBox definitions)
-class YMessageBox; // forward declaration
-
-typedef void (*YMessageBoxValueCallback)(YMessageBox *func, const string& functionValue);
-#define Y_SLOTSINUSE_INVALID            (YAPI_INVALID_UINT)
-#define Y_SLOTSCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_SLOTSBITMAP_INVALID           (YAPI_INVALID_STRING)
-#define Y_PDUSENT_INVALID               (YAPI_INVALID_UINT)
-#define Y_PDURECEIVED_INVALID           (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of generated code: YMessageBox definitions)
-
-//--- (generated code: YSms definitions)
-//--- (end of generated code: YSms definitions)
-
-
-//--- (generated code: YSms declaration)
-/**
- * YSms Class: SMS message sent or received
- *
- *
- */
-class YOCTO_CLASS_EXPORT YSms {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YSms declaration)
-    //--- (generated code: YSms attributes)
-    // Attributes (function value cache)
-    YMessageBox*    _mbox;
-    int             _slot;
-    bool            _deliv;
-    string          _smsc;
-    int             _mref;
-    string          _orig;
-    string          _dest;
-    int             _pid;
-    int             _alphab;
-    int             _mclass;
-    string          _stamp;
-    string          _udh;
-    string          _udata;
-    int             _npdu;
-    string          _pdu;
-    vector<YSms>    _parts;
-    string          _aggSig;
-    int             _aggIdx;
-    int             _aggCnt;
-    //--- (end of generated code: YSms attributes)
-    //--- (generated code: YSms constructor)
-
-    //--- (end of generated code: YSms constructor)
-    //--- (generated code: YSms initialization)
-    //--- (end of generated code: YSms initialization)
-
-public:
-    YSms(void);
-    YSms(YMessageBox *mbox);
-    virtual ~YSms(){};
-    //--- (generated code: YSms accessors declaration)
-
-
-    virtual int         get_slot(void);
-
-    virtual string      get_smsc(void);
-
-    virtual int         get_msgRef(void);
-
-    virtual string      get_sender(void);
-
-    virtual string      get_recipient(void);
-
-    virtual int         get_protocolId(void);
-
-    virtual bool        isReceived(void);
-
-    virtual int         get_alphabet(void);
-
-    virtual int         get_msgClass(void);
-
-    virtual int         get_dcs(void);
-
-    virtual string      get_timestamp(void);
-
-    virtual string      get_userDataHeader(void);
-
-    virtual string      get_userData(void);
-
-    virtual string      get_textData(void);
-
-    virtual vector<int> get_unicodeData(void);
-
-    virtual int         get_partCount(void);
-
-    virtual string      get_pdu(void);
-
-    virtual vector<YSms> get_parts(void);
-
-    virtual string      get_concatSignature(void);
-
-    virtual int         get_concatIndex(void);
-
-    virtual int         get_concatCount(void);
-
-    virtual int         set_slot(int val);
-
-    virtual int         set_received(bool val);
-
-    virtual int         set_smsc(string val);
-
-    virtual int         set_msgRef(int val);
-
-    virtual int         set_sender(string val);
-
-    virtual int         set_recipient(string val);
-
-    virtual int         set_protocolId(int val);
-
-    virtual int         set_alphabet(int val);
-
-    virtual int         set_msgClass(int val);
-
-    virtual int         set_dcs(int val);
-
-    virtual int         set_timestamp(string val);
-
-    virtual int         set_userDataHeader(string val);
-
-    virtual int         set_userData(string val);
-
-    virtual int         convertToUnicode(void);
-
-    virtual int         addText(string val);
-
-    virtual int         addUnicodeData(vector<int> val);
-
-    virtual int         set_pdu(string pdu);
-
-    virtual int         set_parts(vector<YSms> parts);
-
-    virtual string      encodeAddress(string addr);
-
-    virtual string      decodeAddress(string addr,int ofs,int siz);
-
-    virtual string      encodeTimeStamp(string exp);
-
-    virtual string      decodeTimeStamp(string exp,int ofs,int siz);
-
-    virtual int         udataSize(void);
-
-    virtual string      encodeUserData(void);
-
-    virtual int         generateParts(void);
-
-    virtual int         generatePdu(void);
-
-    virtual int         parseUserDataHeader(void);
-
-    virtual int         parsePdu(string pdu);
-
-    virtual int         send(void);
-
-    virtual int         deleteFromSIM(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YSms accessors declaration)
-};
-
-
-//--- (generated code: YMessageBox declaration)
-/**
- * YMessageBox Class: MessageBox function interface
- *
- * YMessageBox functions provides SMS sending and receiving capability to
- * GSM-enabled Yoctopuce devices.
- */
-class YOCTO_CLASS_EXPORT YMessageBox: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YMessageBox declaration)
-protected:
-    //--- (generated code: YMessageBox attributes)
-    // Attributes (function value cache)
-    int             _slotsInUse;
-    int             _slotsCount;
-    string          _slotsBitmap;
-    int             _pduSent;
-    int             _pduReceived;
-    string          _command;
-    YMessageBoxValueCallback _valueCallbackMessageBox;
-    int             _nextMsgRef;
-    string          _prevBitmapStr;
-    vector<YSms>    _pdus;
-    vector<YSms>    _messages;
-    bool            _gsm2unicodeReady;
-    vector<int>     _gsm2unicode;
-    string          _iso2gsm;
-
-    friend YMessageBox *yFindMessageBox(const string& func);
-    friend YMessageBox *yFirstMessageBox(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMessageBox factory function to instantiate
-    YMessageBox(const string& func);
-    //--- (end of generated code: YMessageBox attributes)
-
-public:
-    ~YMessageBox();
-    //--- (generated code: YMessageBox accessors declaration)
-
-    static const int SLOTSINUSE_INVALID = YAPI_INVALID_UINT;
-    static const int SLOTSCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const string SLOTSBITMAP_INVALID;
-    static const int PDUSENT_INVALID = YAPI_INVALID_UINT;
-    static const int PDURECEIVED_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the number of message storage slots currently in use.
-     *
-     * @return an integer corresponding to the number of message storage slots currently in use
-     *
-     * On failure, throws an exception or returns Y_SLOTSINUSE_INVALID.
-     */
-    int                 get_slotsInUse(void);
-
-    inline int          slotsInUse(void)
-    { return this->get_slotsInUse(); }
-
-    /**
-     * Returns the total number of message storage slots on the SIM card.
-     *
-     * @return an integer corresponding to the total number of message storage slots on the SIM card
-     *
-     * On failure, throws an exception or returns Y_SLOTSCOUNT_INVALID.
-     */
-    int                 get_slotsCount(void);
-
-    inline int          slotsCount(void)
-    { return this->get_slotsCount(); }
-
-    string              get_slotsBitmap(void);
-
-    inline string       slotsBitmap(void)
-    { return this->get_slotsBitmap(); }
-
-    /**
-     * Returns the number of SMS units sent so far.
-     *
-     * @return an integer corresponding to the number of SMS units sent so far
-     *
-     * On failure, throws an exception or returns Y_PDUSENT_INVALID.
-     */
-    int                 get_pduSent(void);
-
-    inline int          pduSent(void)
-    { return this->get_pduSent(); }
-
-    /**
-     * Changes the value of the outgoing SMS units counter.
-     *
-     * @param newval : an integer corresponding to the value of the outgoing SMS units counter
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pduSent(int newval);
-    inline int      setPduSent(int newval)
-    { return this->set_pduSent(newval); }
-
-    /**
-     * Returns the number of SMS units received so far.
-     *
-     * @return an integer corresponding to the number of SMS units received so far
-     *
-     * On failure, throws an exception or returns Y_PDURECEIVED_INVALID.
-     */
-    int                 get_pduReceived(void);
-
-    inline int          pduReceived(void)
-    { return this->get_pduReceived(); }
-
-    /**
-     * Changes the value of the incoming SMS units counter.
-     *
-     * @param newval : an integer corresponding to the value of the incoming SMS units counter
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pduReceived(int newval);
-    inline int      setPduReceived(int newval)
-    { return this->set_pduReceived(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a MessageBox interface for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the MessageBox interface is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMessageBox.isOnline() to test if the MessageBox interface is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a MessageBox interface by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the MessageBox interface
-     *
-     * @return a YMessageBox object allowing you to drive the MessageBox interface.
-     */
-    static YMessageBox* FindMessageBox(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMessageBoxValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         nextMsgRef(void);
-
-    virtual int         clearSIMSlot(int slot);
-
-    virtual YSms        fetchPdu(int slot);
-
-    virtual int         initGsm2Unicode(void);
-
-    virtual vector<int> gsm2unicode(string gsm);
-
-    virtual string      gsm2str(string gsm);
-
-    virtual string      str2gsm(string msg);
-
-    virtual int         checkNewMessages(void);
-
-    virtual vector<YSms> get_pdus(void);
-
-    /**
-     * Clear the SMS units counters.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         clearPduCounters(void);
-
-    /**
-     * Sends a regular text SMS, with standard parameters. This function can send messages
-     * of more than 160 characters, using SMS concatenation. ISO-latin accented characters
-     * are supported. For sending messages with special unicode characters such as asian
-     * characters and emoticons, use newMessage to create a new message and define
-     * the content of using methods addText and addUnicodeData.
-     *
-     * @param recipient : a text string with the recipient phone number, either as a
-     *         national number, or in international format starting with a plus sign
-     * @param message : the text to be sent in the message
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sendTextMessage(string recipient,string message);
-
-    /**
-     * Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset
-     * immediately and are usually not saved on the SIM card. This function can send messages
-     * of more than 160 characters, using SMS concatenation. ISO-latin accented characters
-     * are supported. For sending messages with special unicode characters such as asian
-     * characters and emoticons, use newMessage to create a new message and define
-     * the content of using methods addText et addUnicodeData.
-     *
-     * @param recipient : a text string with the recipient phone number, either as a
-     *         national number, or in international format starting with a plus sign
-     * @param message : the text to be sent in the message
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sendFlashMessage(string recipient,string message);
-
-    /**
-     * Creates a new empty SMS message, to be configured and sent later on.
-     *
-     * @param recipient : a text string with the recipient phone number, either as a
-     *         national number, or in international format starting with a plus sign
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual YSms        newMessage(string recipient);
-
-    /**
-     * Returns the list of messages received and not deleted. This function
-     * will automatically decode concatenated SMS.
-     *
-     * @return an YSms object list.
-     *
-     * On failure, throws an exception or returns an empty list.
-     */
-    virtual vector<YSms> get_messages(void);
-
-
-    inline static YMessageBox* Find(string func)
-    { return YMessageBox::FindMessageBox(func); }
-
-    /**
-     * Continues the enumeration of MessageBox interfaces started using yFirstMessageBox().
-     * Caution: You can't make any assumption about the returned MessageBox interfaces order.
-     * If you want to find a specific a MessageBox interface, use MessageBox.findMessageBox()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMessageBox object, corresponding to
-     *         a MessageBox interface currently online, or a NULL pointer
-     *         if there are no more MessageBox interfaces to enumerate.
-     */
-           YMessageBox     *nextMessageBox(void);
-    inline YMessageBox     *next(void)
-    { return this->nextMessageBox();}
-
-    /**
-     * Starts the enumeration of MessageBox interfaces currently accessible.
-     * Use the method YMessageBox.nextMessageBox() to iterate on
-     * next MessageBox interfaces.
-     *
-     * @return a pointer to a YMessageBox object, corresponding to
-     *         the first MessageBox interface currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMessageBox* FirstMessageBox(void);
-    inline static YMessageBox* First(void)
-    { return YMessageBox::FirstMessageBox();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YMessageBox accessors declaration)
-};
-
-//--- (generated code: YMessageBox functions declaration)
-
-/**
- * Retrieves a MessageBox interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the MessageBox interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMessageBox.isOnline() to test if the MessageBox interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a MessageBox interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the MessageBox interface
- *
- * @return a YMessageBox object allowing you to drive the MessageBox interface.
- */
-inline YMessageBox* yFindMessageBox(const string& func)
-{ return YMessageBox::FindMessageBox(func);}
-/**
- * Starts the enumeration of MessageBox interfaces currently accessible.
- * Use the method YMessageBox.nextMessageBox() to iterate on
- * next MessageBox interfaces.
- *
- * @return a pointer to a YMessageBox object, corresponding to
- *         the first MessageBox interface currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMessageBox* yFirstMessageBox(void)
-{ return YMessageBox::FirstMessageBox();}
-
-//--- (end of generated code: YMessageBox functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_motor.cpp
+++ /dev/null
@@ -1,797 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_motor.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindMotor(), the high-level API for Motor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_motor.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "motor"
-
-YMotor::YMotor(const string& func): YFunction(func)
-//--- (YMotor initialization)
-    ,_motorStatus(MOTORSTATUS_INVALID)
-    ,_drivingForce(DRIVINGFORCE_INVALID)
-    ,_brakingForce(BRAKINGFORCE_INVALID)
-    ,_cutOffVoltage(CUTOFFVOLTAGE_INVALID)
-    ,_overCurrentLimit(OVERCURRENTLIMIT_INVALID)
-    ,_frequency(FREQUENCY_INVALID)
-    ,_starterTime(STARTERTIME_INVALID)
-    ,_failSafeTimeout(FAILSAFETIMEOUT_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackMotor(NULL)
-//--- (end of YMotor initialization)
-{
-    _className="Motor";
-}
-
-YMotor::~YMotor()
-{
-//--- (YMotor cleanup)
-//--- (end of YMotor cleanup)
-}
-//--- (YMotor implementation)
-// static attributes
-const double YMotor::DRIVINGFORCE_INVALID = YAPI_INVALID_DOUBLE;
-const double YMotor::BRAKINGFORCE_INVALID = YAPI_INVALID_DOUBLE;
-const double YMotor::CUTOFFVOLTAGE_INVALID = YAPI_INVALID_DOUBLE;
-const double YMotor::FREQUENCY_INVALID = YAPI_INVALID_DOUBLE;
-const string YMotor::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YMotor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("motorStatus")) {
-        _motorStatus =  (Y_MOTORSTATUS_enum)json_val->getInt("motorStatus");
-    }
-    if(json_val->has("drivingForce")) {
-        _drivingForce =  floor(json_val->getDouble("drivingForce") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("brakingForce")) {
-        _brakingForce =  floor(json_val->getDouble("brakingForce") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("cutOffVoltage")) {
-        _cutOffVoltage =  floor(json_val->getDouble("cutOffVoltage") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("overCurrentLimit")) {
-        _overCurrentLimit =  json_val->getInt("overCurrentLimit");
-    }
-    if(json_val->has("frequency")) {
-        _frequency =  floor(json_val->getDouble("frequency") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("starterTime")) {
-        _starterTime =  json_val->getInt("starterTime");
-    }
-    if(json_val->has("failSafeTimeout")) {
-        _failSafeTimeout =  json_val->getInt("failSafeTimeout");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Return the controller state. Possible states are:
- * IDLE   when the motor is stopped/in free wheel, ready to start;
- * FORWD  when the controller is driving the motor forward;
- * BACKWD when the controller is driving the motor backward;
- * BRAKE  when the controller is braking;
- * LOVOLT when the controller has detected a low voltage condition;
- * HICURR when the controller has detected an over current condition;
- * HIHEAT when the controller has detected an overheat condition;
- * FAILSF when the controller switched on the failsafe security.
- *
- * When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller
- * status must be explicitly reset using the resetStatus function.
- *
- * @return a value among Y_MOTORSTATUS_IDLE, Y_MOTORSTATUS_BRAKE, Y_MOTORSTATUS_FORWD,
- * Y_MOTORSTATUS_BACKWD, Y_MOTORSTATUS_LOVOLT, Y_MOTORSTATUS_HICURR, Y_MOTORSTATUS_HIHEAT and Y_MOTORSTATUS_FAILSF
- *
- * On failure, throws an exception or returns Y_MOTORSTATUS_INVALID.
- */
-Y_MOTORSTATUS_enum YMotor::get_motorStatus(void)
-{
-    Y_MOTORSTATUS_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::MOTORSTATUS_INVALID;
-                }
-            }
-        }
-        res = _motorStatus;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMotor::set_motorStatus(Y_MOTORSTATUS_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("motorStatus", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes immediately the power sent to the motor. The value is a percentage between -100%
- * to 100%. If you want go easy on your mechanics and avoid excessive current consumption,
- * try to avoid brutal power changes. For example, immediate transition from forward full power
- * to reverse full power is a very bad idea. Each time the driving power is modified, the
- * braking power is set to zero.
- *
- * @param newval : a floating point number corresponding to immediately the power sent to the motor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_drivingForce(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("drivingForce", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the power sent to the motor, as a percentage between -100% and +100%.
- *
- * @return a floating point number corresponding to the power sent to the motor, as a percentage
- * between -100% and +100%
- *
- * On failure, throws an exception or returns Y_DRIVINGFORCE_INVALID.
- */
-double YMotor::get_drivingForce(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::DRIVINGFORCE_INVALID;
-                }
-            }
-        }
-        res = _drivingForce;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes immediately the braking force applied to the motor (in percents).
- * The value 0 corresponds to no braking (free wheel). When the braking force
- * is changed, the driving power is set to zero. The value is a percentage.
- *
- * @param newval : a floating point number corresponding to immediately the braking force applied to
- * the motor (in percents)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_brakingForce(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("brakingForce", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the braking force applied to the motor, as a percentage.
- * The value 0 corresponds to no braking (free wheel).
- *
- * @return a floating point number corresponding to the braking force applied to the motor, as a percentage
- *
- * On failure, throws an exception or returns Y_BRAKINGFORCE_INVALID.
- */
-double YMotor::get_brakingForce(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::BRAKINGFORCE_INVALID;
-                }
-            }
-        }
-        res = _brakingForce;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the threshold voltage under which the controller automatically switches to error state
- * and prevents further current draw. This setting prevent damage to a battery that can
- * occur when drawing current from an "empty" battery.
- * Note that whatever the cutoff threshold, the controller switches to undervoltage
- * error state if the power supply goes under 3V, even for a very brief time.
- *
- * @param newval : a floating point number corresponding to the threshold voltage under which the
- * controller automatically switches to error state
- *         and prevents further current draw
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_cutOffVoltage(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("cutOffVoltage", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the threshold voltage under which the controller automatically switches to error state
- * and prevents further current draw. This setting prevents damage to a battery that can
- * occur when drawing current from an "empty" battery.
- *
- * @return a floating point number corresponding to the threshold voltage under which the controller
- * automatically switches to error state
- *         and prevents further current draw
- *
- * On failure, throws an exception or returns Y_CUTOFFVOLTAGE_INVALID.
- */
-double YMotor::get_cutOffVoltage(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::CUTOFFVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _cutOffVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current threshold (in mA) above which the controller automatically
- * switches to error state. A zero value means that there is no limit.
- *
- * @return an integer corresponding to the current threshold (in mA) above which the controller automatically
- *         switches to error state
- *
- * On failure, throws an exception or returns Y_OVERCURRENTLIMIT_INVALID.
- */
-int YMotor::get_overCurrentLimit(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::OVERCURRENTLIMIT_INVALID;
-                }
-            }
-        }
-        res = _overCurrentLimit;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current threshold (in mA) above which the controller automatically
- * switches to error state. A zero value means that there is no limit. Note that whatever the
- * current limit is, the controller switches to OVERCURRENT status if the current
- * goes above 32A, even for a very brief time.
- *
- * @param newval : an integer corresponding to the current threshold (in mA) above which the
- * controller automatically
- *         switches to error state
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_overCurrentLimit(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("overCurrentLimit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM frequency used to control the motor. Low frequency is usually
- * more efficient and may help the motor to start, but an audible noise might be
- * generated. A higher frequency reduces the noise, but more energy is converted
- * into heat.
- *
- * @param newval : a floating point number corresponding to the PWM frequency used to control the motor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_frequency(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("frequency", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM frequency used to control the motor.
- *
- * @return a floating point number corresponding to the PWM frequency used to control the motor
- *
- * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
- */
-double YMotor::get_frequency(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::FREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _frequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the duration (in ms) during which the motor is driven at low frequency to help
- * it start up.
- *
- * @return an integer corresponding to the duration (in ms) during which the motor is driven at low
- * frequency to help
- *         it start up
- *
- * On failure, throws an exception or returns Y_STARTERTIME_INVALID.
- */
-int YMotor::get_starterTime(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::STARTERTIME_INVALID;
-                }
-            }
-        }
-        res = _starterTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the duration (in ms) during which the motor is driven at low frequency to help
- * it start up.
- *
- * @param newval : an integer corresponding to the duration (in ms) during which the motor is driven
- * at low frequency to help
- *         it start up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_starterTime(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("starterTime", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the delay in milliseconds allowed for the controller to run autonomously without
- * receiving any instruction from the control process. When this delay has elapsed,
- * the controller automatically stops the motor and switches to FAILSAFE error.
- * Failsafe security is disabled when the value is zero.
- *
- * @return an integer corresponding to the delay in milliseconds allowed for the controller to run
- * autonomously without
- *         receiving any instruction from the control process
- *
- * On failure, throws an exception or returns Y_FAILSAFETIMEOUT_INVALID.
- */
-int YMotor::get_failSafeTimeout(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::FAILSAFETIMEOUT_INVALID;
-                }
-            }
-        }
-        res = _failSafeTimeout;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the delay in milliseconds allowed for the controller to run autonomously without
- * receiving any instruction from the control process. When this delay has elapsed,
- * the controller automatically stops the motor and switches to FAILSAFE error.
- * Failsafe security is disabled when the value is zero.
- *
- * @param newval : an integer corresponding to the delay in milliseconds allowed for the controller to
- * run autonomously without
- *         receiving any instruction from the control process
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::set_failSafeTimeout(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("failSafeTimeout", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMotor::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMotor::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMotor::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a motor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the motor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMotor.isOnline() to test if the motor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a motor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the motor
- *
- * @return a YMotor object allowing you to drive the motor.
- */
-YMotor* YMotor::FindMotor(string func)
-{
-    YMotor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMotor*) YFunction::_FindFromCache("Motor", func);
-        if (obj == NULL) {
-            obj = new YMotor(func);
-            YFunction::_AddToCache("Motor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMotor::registerValueCallback(YMotorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMotor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMotor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMotor != NULL) {
-        _valueCallbackMotor(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Rearms the controller failsafe timer. When the motor is running and the failsafe feature
- * is active, this function should be called periodically to prove that the control process
- * is running properly. Otherwise, the motor is automatically stopped after the specified
- * timeout. Calling a motor <i>set</i> function implicitly rearms the failsafe timer.
- */
-int YMotor::keepALive(void)
-{
-    return this->set_command("K");
-}
-
-/**
- * Reset the controller state to IDLE. This function must be invoked explicitly
- * after any error condition is signaled.
- */
-int YMotor::resetStatus(void)
-{
-    return this->set_motorStatus(Y_MOTORSTATUS_IDLE);
-}
-
-/**
- * Changes progressively the power sent to the motor for a specific duration.
- *
- * @param targetPower : desired motor power, in percents (between -100% and +100%)
- * @param delay : duration (in ms) of the transition
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::drivingForceMove(double targetPower,int delay)
-{
-    return this->set_command(YapiWrapper::ysprintf("P%d,%d",(int) floor(targetPower*10+0.5),delay));
-}
-
-/**
- * Changes progressively the braking force applied to the motor for a specific duration.
- *
- * @param targetPower : desired braking force, in percents
- * @param delay : duration (in ms) of the transition
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMotor::brakingForceMove(double targetPower,int delay)
-{
-    return this->set_command(YapiWrapper::ysprintf("B%d,%d",(int) floor(targetPower*10+0.5),delay));
-}
-
-YMotor *YMotor::nextMotor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMotor::FindMotor(hwid);
-}
-
-YMotor* YMotor::FirstMotor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Motor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMotor::FindMotor(serial+"."+funcId);
-}
-
-//--- (end of YMotor implementation)
-
-//--- (YMotor functions)
-//--- (end of YMotor functions)
--- a/Sources/cpplib/yocto_motor.h
+++ /dev/null
@@ -1,563 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_motor.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindMotor(), the high-level API for Motor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MOTOR_H
-#define YOCTO_MOTOR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YMotor return codes)
-//--- (end of YMotor return codes)
-//--- (YMotor yapiwrapper)
-//--- (end of YMotor yapiwrapper)
-//--- (YMotor definitions)
-class YMotor; // forward declaration
-
-typedef void (*YMotorValueCallback)(YMotor *func, const string& functionValue);
-#ifndef _Y_MOTORSTATUS_ENUM
-#define _Y_MOTORSTATUS_ENUM
-typedef enum {
-    Y_MOTORSTATUS_IDLE = 0,
-    Y_MOTORSTATUS_BRAKE = 1,
-    Y_MOTORSTATUS_FORWD = 2,
-    Y_MOTORSTATUS_BACKWD = 3,
-    Y_MOTORSTATUS_LOVOLT = 4,
-    Y_MOTORSTATUS_HICURR = 5,
-    Y_MOTORSTATUS_HIHEAT = 6,
-    Y_MOTORSTATUS_FAILSF = 7,
-    Y_MOTORSTATUS_INVALID = -1,
-} Y_MOTORSTATUS_enum;
-#endif
-#define Y_DRIVINGFORCE_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_BRAKINGFORCE_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_CUTOFFVOLTAGE_INVALID         (YAPI_INVALID_DOUBLE)
-#define Y_OVERCURRENTLIMIT_INVALID      (YAPI_INVALID_INT)
-#define Y_FREQUENCY_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_STARTERTIME_INVALID           (YAPI_INVALID_INT)
-#define Y_FAILSAFETIMEOUT_INVALID       (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YMotor definitions)
-
-//--- (YMotor declaration)
-/**
- * YMotor Class: Motor function interface
- *
- * Yoctopuce application programming interface allows you to drive the
- * power sent to the motor to make it turn both ways, but also to drive accelerations
- * and decelerations. The motor will then accelerate automatically: you will not
- * have to monitor it. The API also allows to slow down the motor by shortening
- * its terminals: the motor will then act as an electromagnetic brake.
- */
-class YOCTO_CLASS_EXPORT YMotor: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YMotor declaration)
-protected:
-    //--- (YMotor attributes)
-    // Attributes (function value cache)
-    Y_MOTORSTATUS_enum _motorStatus;
-    double          _drivingForce;
-    double          _brakingForce;
-    double          _cutOffVoltage;
-    int             _overCurrentLimit;
-    double          _frequency;
-    int             _starterTime;
-    int             _failSafeTimeout;
-    string          _command;
-    YMotorValueCallback _valueCallbackMotor;
-
-    friend YMotor *yFindMotor(const string& func);
-    friend YMotor *yFirstMotor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMotor factory function to instantiate
-    YMotor(const string& func);
-    //--- (end of YMotor attributes)
-
-public:
-    virtual ~YMotor();
-    //--- (YMotor accessors declaration)
-
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_IDLE = Y_MOTORSTATUS_IDLE;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_BRAKE = Y_MOTORSTATUS_BRAKE;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_FORWD = Y_MOTORSTATUS_FORWD;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_BACKWD = Y_MOTORSTATUS_BACKWD;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_LOVOLT = Y_MOTORSTATUS_LOVOLT;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_HICURR = Y_MOTORSTATUS_HICURR;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_HIHEAT = Y_MOTORSTATUS_HIHEAT;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_FAILSF = Y_MOTORSTATUS_FAILSF;
-    static const Y_MOTORSTATUS_enum MOTORSTATUS_INVALID = Y_MOTORSTATUS_INVALID;
-    static const double DRIVINGFORCE_INVALID;
-    static const double BRAKINGFORCE_INVALID;
-    static const double CUTOFFVOLTAGE_INVALID;
-    static const int OVERCURRENTLIMIT_INVALID = YAPI_INVALID_INT;
-    static const double FREQUENCY_INVALID;
-    static const int STARTERTIME_INVALID = YAPI_INVALID_INT;
-    static const int FAILSAFETIMEOUT_INVALID = YAPI_INVALID_UINT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Return the controller state. Possible states are:
-     * IDLE   when the motor is stopped/in free wheel, ready to start;
-     * FORWD  when the controller is driving the motor forward;
-     * BACKWD when the controller is driving the motor backward;
-     * BRAKE  when the controller is braking;
-     * LOVOLT when the controller has detected a low voltage condition;
-     * HICURR when the controller has detected an over current condition;
-     * HIHEAT when the controller has detected an overheat condition;
-     * FAILSF when the controller switched on the failsafe security.
-     *
-     * When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller
-     * status must be explicitly reset using the resetStatus function.
-     *
-     * @return a value among Y_MOTORSTATUS_IDLE, Y_MOTORSTATUS_BRAKE, Y_MOTORSTATUS_FORWD,
-     * Y_MOTORSTATUS_BACKWD, Y_MOTORSTATUS_LOVOLT, Y_MOTORSTATUS_HICURR, Y_MOTORSTATUS_HIHEAT and Y_MOTORSTATUS_FAILSF
-     *
-     * On failure, throws an exception or returns Y_MOTORSTATUS_INVALID.
-     */
-    Y_MOTORSTATUS_enum  get_motorStatus(void);
-
-    inline Y_MOTORSTATUS_enum motorStatus(void)
-    { return this->get_motorStatus(); }
-
-    int             set_motorStatus(Y_MOTORSTATUS_enum newval);
-    inline int      setMotorStatus(Y_MOTORSTATUS_enum newval)
-    { return this->set_motorStatus(newval); }
-
-    /**
-     * Changes immediately the power sent to the motor. The value is a percentage between -100%
-     * to 100%. If you want go easy on your mechanics and avoid excessive current consumption,
-     * try to avoid brutal power changes. For example, immediate transition from forward full power
-     * to reverse full power is a very bad idea. Each time the driving power is modified, the
-     * braking power is set to zero.
-     *
-     * @param newval : a floating point number corresponding to immediately the power sent to the motor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_drivingForce(double newval);
-    inline int      setDrivingForce(double newval)
-    { return this->set_drivingForce(newval); }
-
-    /**
-     * Returns the power sent to the motor, as a percentage between -100% and +100%.
-     *
-     * @return a floating point number corresponding to the power sent to the motor, as a percentage
-     * between -100% and +100%
-     *
-     * On failure, throws an exception or returns Y_DRIVINGFORCE_INVALID.
-     */
-    double              get_drivingForce(void);
-
-    inline double       drivingForce(void)
-    { return this->get_drivingForce(); }
-
-    /**
-     * Changes immediately the braking force applied to the motor (in percents).
-     * The value 0 corresponds to no braking (free wheel). When the braking force
-     * is changed, the driving power is set to zero. The value is a percentage.
-     *
-     * @param newval : a floating point number corresponding to immediately the braking force applied to
-     * the motor (in percents)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_brakingForce(double newval);
-    inline int      setBrakingForce(double newval)
-    { return this->set_brakingForce(newval); }
-
-    /**
-     * Returns the braking force applied to the motor, as a percentage.
-     * The value 0 corresponds to no braking (free wheel).
-     *
-     * @return a floating point number corresponding to the braking force applied to the motor, as a percentage
-     *
-     * On failure, throws an exception or returns Y_BRAKINGFORCE_INVALID.
-     */
-    double              get_brakingForce(void);
-
-    inline double       brakingForce(void)
-    { return this->get_brakingForce(); }
-
-    /**
-     * Changes the threshold voltage under which the controller automatically switches to error state
-     * and prevents further current draw. This setting prevent damage to a battery that can
-     * occur when drawing current from an "empty" battery.
-     * Note that whatever the cutoff threshold, the controller switches to undervoltage
-     * error state if the power supply goes under 3V, even for a very brief time.
-     *
-     * @param newval : a floating point number corresponding to the threshold voltage under which the
-     * controller automatically switches to error state
-     *         and prevents further current draw
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_cutOffVoltage(double newval);
-    inline int      setCutOffVoltage(double newval)
-    { return this->set_cutOffVoltage(newval); }
-
-    /**
-     * Returns the threshold voltage under which the controller automatically switches to error state
-     * and prevents further current draw. This setting prevents damage to a battery that can
-     * occur when drawing current from an "empty" battery.
-     *
-     * @return a floating point number corresponding to the threshold voltage under which the controller
-     * automatically switches to error state
-     *         and prevents further current draw
-     *
-     * On failure, throws an exception or returns Y_CUTOFFVOLTAGE_INVALID.
-     */
-    double              get_cutOffVoltage(void);
-
-    inline double       cutOffVoltage(void)
-    { return this->get_cutOffVoltage(); }
-
-    /**
-     * Returns the current threshold (in mA) above which the controller automatically
-     * switches to error state. A zero value means that there is no limit.
-     *
-     * @return an integer corresponding to the current threshold (in mA) above which the controller automatically
-     *         switches to error state
-     *
-     * On failure, throws an exception or returns Y_OVERCURRENTLIMIT_INVALID.
-     */
-    int                 get_overCurrentLimit(void);
-
-    inline int          overCurrentLimit(void)
-    { return this->get_overCurrentLimit(); }
-
-    /**
-     * Changes the current threshold (in mA) above which the controller automatically
-     * switches to error state. A zero value means that there is no limit. Note that whatever the
-     * current limit is, the controller switches to OVERCURRENT status if the current
-     * goes above 32A, even for a very brief time.
-     *
-     * @param newval : an integer corresponding to the current threshold (in mA) above which the
-     * controller automatically
-     *         switches to error state
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_overCurrentLimit(int newval);
-    inline int      setOverCurrentLimit(int newval)
-    { return this->set_overCurrentLimit(newval); }
-
-    /**
-     * Changes the PWM frequency used to control the motor. Low frequency is usually
-     * more efficient and may help the motor to start, but an audible noise might be
-     * generated. A higher frequency reduces the noise, but more energy is converted
-     * into heat.
-     *
-     * @param newval : a floating point number corresponding to the PWM frequency used to control the motor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_frequency(double newval);
-    inline int      setFrequency(double newval)
-    { return this->set_frequency(newval); }
-
-    /**
-     * Returns the PWM frequency used to control the motor.
-     *
-     * @return a floating point number corresponding to the PWM frequency used to control the motor
-     *
-     * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
-     */
-    double              get_frequency(void);
-
-    inline double       frequency(void)
-    { return this->get_frequency(); }
-
-    /**
-     * Returns the duration (in ms) during which the motor is driven at low frequency to help
-     * it start up.
-     *
-     * @return an integer corresponding to the duration (in ms) during which the motor is driven at low
-     * frequency to help
-     *         it start up
-     *
-     * On failure, throws an exception or returns Y_STARTERTIME_INVALID.
-     */
-    int                 get_starterTime(void);
-
-    inline int          starterTime(void)
-    { return this->get_starterTime(); }
-
-    /**
-     * Changes the duration (in ms) during which the motor is driven at low frequency to help
-     * it start up.
-     *
-     * @param newval : an integer corresponding to the duration (in ms) during which the motor is driven
-     * at low frequency to help
-     *         it start up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_starterTime(int newval);
-    inline int      setStarterTime(int newval)
-    { return this->set_starterTime(newval); }
-
-    /**
-     * Returns the delay in milliseconds allowed for the controller to run autonomously without
-     * receiving any instruction from the control process. When this delay has elapsed,
-     * the controller automatically stops the motor and switches to FAILSAFE error.
-     * Failsafe security is disabled when the value is zero.
-     *
-     * @return an integer corresponding to the delay in milliseconds allowed for the controller to run
-     * autonomously without
-     *         receiving any instruction from the control process
-     *
-     * On failure, throws an exception or returns Y_FAILSAFETIMEOUT_INVALID.
-     */
-    int                 get_failSafeTimeout(void);
-
-    inline int          failSafeTimeout(void)
-    { return this->get_failSafeTimeout(); }
-
-    /**
-     * Changes the delay in milliseconds allowed for the controller to run autonomously without
-     * receiving any instruction from the control process. When this delay has elapsed,
-     * the controller automatically stops the motor and switches to FAILSAFE error.
-     * Failsafe security is disabled when the value is zero.
-     *
-     * @param newval : an integer corresponding to the delay in milliseconds allowed for the controller to
-     * run autonomously without
-     *         receiving any instruction from the control process
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_failSafeTimeout(int newval);
-    inline int      setFailSafeTimeout(int newval)
-    { return this->set_failSafeTimeout(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a motor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the motor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMotor.isOnline() to test if the motor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a motor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the motor
-     *
-     * @return a YMotor object allowing you to drive the motor.
-     */
-    static YMotor*      FindMotor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMotorValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Rearms the controller failsafe timer. When the motor is running and the failsafe feature
-     * is active, this function should be called periodically to prove that the control process
-     * is running properly. Otherwise, the motor is automatically stopped after the specified
-     * timeout. Calling a motor <i>set</i> function implicitly rearms the failsafe timer.
-     */
-    virtual int         keepALive(void);
-
-    /**
-     * Reset the controller state to IDLE. This function must be invoked explicitly
-     * after any error condition is signaled.
-     */
-    virtual int         resetStatus(void);
-
-    /**
-     * Changes progressively the power sent to the motor for a specific duration.
-     *
-     * @param targetPower : desired motor power, in percents (between -100% and +100%)
-     * @param delay : duration (in ms) of the transition
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         drivingForceMove(double targetPower,int delay);
-
-    /**
-     * Changes progressively the braking force applied to the motor for a specific duration.
-     *
-     * @param targetPower : desired braking force, in percents
-     * @param delay : duration (in ms) of the transition
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         brakingForceMove(double targetPower,int delay);
-
-
-    inline static YMotor* Find(string func)
-    { return YMotor::FindMotor(func); }
-
-    /**
-     * Continues the enumeration of motors started using yFirstMotor().
-     * Caution: You can't make any assumption about the returned motors order.
-     * If you want to find a specific a motor, use Motor.findMotor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMotor object, corresponding to
-     *         a motor currently online, or a NULL pointer
-     *         if there are no more motors to enumerate.
-     */
-           YMotor          *nextMotor(void);
-    inline YMotor          *next(void)
-    { return this->nextMotor();}
-
-    /**
-     * Starts the enumeration of motors currently accessible.
-     * Use the method YMotor.nextMotor() to iterate on
-     * next motors.
-     *
-     * @return a pointer to a YMotor object, corresponding to
-     *         the first motor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMotor* FirstMotor(void);
-    inline static YMotor* First(void)
-    { return YMotor::FirstMotor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YMotor accessors declaration)
-};
-
-//--- (YMotor functions declaration)
-
-/**
- * Retrieves a motor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the motor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMotor.isOnline() to test if the motor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a motor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the motor
- *
- * @return a YMotor object allowing you to drive the motor.
- */
-inline YMotor* yFindMotor(const string& func)
-{ return YMotor::FindMotor(func);}
-/**
- * Starts the enumeration of motors currently accessible.
- * Use the method YMotor.nextMotor() to iterate on
- * next motors.
- *
- * @return a pointer to a YMotor object, corresponding to
- *         the first motor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMotor* yFirstMotor(void)
-{ return YMotor::FirstMotor();}
-
-//--- (end of YMotor functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_multiaxiscontroller.cpp
+++ /dev/null
@@ -1,479 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multiaxiscontroller.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindMultiAxisController(), the high-level API for MultiAxisController functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_multiaxiscontroller.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "multiaxiscontroller"
-
-YMultiAxisController::YMultiAxisController(const string& func): YFunction(func)
-//--- (YMultiAxisController initialization)
-    ,_nAxis(NAXIS_INVALID)
-    ,_globalState(GLOBALSTATE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackMultiAxisController(NULL)
-//--- (end of YMultiAxisController initialization)
-{
-    _className="MultiAxisController";
-}
-
-YMultiAxisController::~YMultiAxisController()
-{
-//--- (YMultiAxisController cleanup)
-//--- (end of YMultiAxisController cleanup)
-}
-//--- (YMultiAxisController implementation)
-// static attributes
-const string YMultiAxisController::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YMultiAxisController::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("nAxis")) {
-        _nAxis =  json_val->getInt("nAxis");
-    }
-    if(json_val->has("globalState")) {
-        _globalState =  (Y_GLOBALSTATE_enum)json_val->getInt("globalState");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the number of synchronized controllers.
- *
- * @return an integer corresponding to the number of synchronized controllers
- *
- * On failure, throws an exception or returns Y_NAXIS_INVALID.
- */
-int YMultiAxisController::get_nAxis(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiAxisController::NAXIS_INVALID;
-                }
-            }
-        }
-        res = _nAxis;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of synchronized controllers.
- *
- * @param newval : an integer corresponding to the number of synchronized controllers
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::set_nAxis(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("nAxis", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the stepper motor set overall state.
- *
- * @return a value among Y_GLOBALSTATE_ABSENT, Y_GLOBALSTATE_ALERT, Y_GLOBALSTATE_HI_Z,
- * Y_GLOBALSTATE_STOP, Y_GLOBALSTATE_RUN and Y_GLOBALSTATE_BATCH corresponding to the stepper motor
- * set overall state
- *
- * On failure, throws an exception or returns Y_GLOBALSTATE_INVALID.
- */
-Y_GLOBALSTATE_enum YMultiAxisController::get_globalState(void)
-{
-    Y_GLOBALSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiAxisController::GLOBALSTATE_INVALID;
-                }
-            }
-        }
-        res = _globalState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMultiAxisController::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiAxisController::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMultiAxisController::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a multi-axis controller for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-axis controller is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiAxisController.isOnline() to test if the multi-axis controller is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-axis controller by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-axis controller
- *
- * @return a YMultiAxisController object allowing you to drive the multi-axis controller.
- */
-YMultiAxisController* YMultiAxisController::FindMultiAxisController(string func)
-{
-    YMultiAxisController* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMultiAxisController*) YFunction::_FindFromCache("MultiAxisController", func);
-        if (obj == NULL) {
-            obj = new YMultiAxisController(func);
-            YFunction::_AddToCache("MultiAxisController", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMultiAxisController::registerValueCallback(YMultiAxisControllerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMultiAxisController = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMultiAxisController::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMultiAxisController != NULL) {
-        _valueCallbackMultiAxisController(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YMultiAxisController::sendCommand(string command)
-{
-    string url;
-    string retBin;
-    int res = 0;
-    url = YapiWrapper::ysprintf("cmd.txt?X=%s",command.c_str());
-    //may throw an exception
-    retBin = this->_download(url);
-    res = ((u8)retBin[0]);
-    if (res == 49) {
-        if (!(res == 48)) {
-            _throw(YAPI_DEVICE_BUSY,"Motor command pipeline is full, try again later");
-            return YAPI_DEVICE_BUSY;
-        }
-    } else {
-        if (!(res == 48)) {
-            _throw(YAPI_IO_ERROR,"Motor command failed permanently");
-            return YAPI_IO_ERROR;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Reinitialize all controllers and clear all alert flags.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::reset(void)
-{
-    return this->set_command("Z");
-}
-
-/**
- * Starts all motors backward at the specified speeds, to search for the motor home position.
- *
- * @param speed : desired speed for all axis, in steps per second.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::findHomePosition(vector<double> speed)
-{
-    string cmd;
-    int i = 0;
-    int ndim = 0;
-    ndim = (int)speed.size();
-    cmd = YapiWrapper::ysprintf("H%d",(int) floor(1000*speed[0]+0.5));
-    i = 1;
-    while (i < ndim) {
-        cmd = YapiWrapper::ysprintf("%s,%d", cmd.c_str(),(int) floor(1000*speed[i]+0.5));
-        i = i + 1;
-    }
-    return this->sendCommand(cmd);
-}
-
-/**
- * Starts all motors synchronously to reach a given absolute position.
- * The time needed to reach the requested position will depend on the lowest
- * acceleration and max speed parameters configured for all motors.
- * The final position will be reached on all axis at the same time.
- *
- * @param absPos : absolute position, measured in steps from each origin.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::moveTo(vector<double> absPos)
-{
-    string cmd;
-    int i = 0;
-    int ndim = 0;
-    ndim = (int)absPos.size();
-    cmd = YapiWrapper::ysprintf("M%d",(int) floor(16*absPos[0]+0.5));
-    i = 1;
-    while (i < ndim) {
-        cmd = YapiWrapper::ysprintf("%s,%d", cmd.c_str(),(int) floor(16*absPos[i]+0.5));
-        i = i + 1;
-    }
-    return this->sendCommand(cmd);
-}
-
-/**
- * Starts all motors synchronously to reach a given relative position.
- * The time needed to reach the requested position will depend on the lowest
- * acceleration and max speed parameters configured for all motors.
- * The final position will be reached on all axis at the same time.
- *
- * @param relPos : relative position, measured in steps from the current position.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::moveRel(vector<double> relPos)
-{
-    string cmd;
-    int i = 0;
-    int ndim = 0;
-    ndim = (int)relPos.size();
-    cmd = YapiWrapper::ysprintf("m%d",(int) floor(16*relPos[0]+0.5));
-    i = 1;
-    while (i < ndim) {
-        cmd = YapiWrapper::ysprintf("%s,%d", cmd.c_str(),(int) floor(16*relPos[i]+0.5));
-        i = i + 1;
-    }
-    return this->sendCommand(cmd);
-}
-
-/**
- * Keep the motor in the same state for the specified amount of time, before processing next command.
- *
- * @param waitMs : wait time, specified in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::pause(int waitMs)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("_%d",waitMs));
-}
-
-/**
- * Stops the motor with an emergency alert, without taking any additional precaution.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::emergencyStop(void)
-{
-    return this->set_command("!");
-}
-
-/**
- * Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::abortAndBrake(void)
-{
-    return this->set_command("B");
-}
-
-/**
- * Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiAxisController::abortAndHiZ(void)
-{
-    return this->set_command("z");
-}
-
-YMultiAxisController *YMultiAxisController::nextMultiAxisController(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMultiAxisController::FindMultiAxisController(hwid);
-}
-
-YMultiAxisController* YMultiAxisController::FirstMultiAxisController(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("MultiAxisController", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMultiAxisController::FindMultiAxisController(serial+"."+funcId);
-}
-
-//--- (end of YMultiAxisController implementation)
-
-//--- (YMultiAxisController functions)
-//--- (end of YMultiAxisController functions)
--- a/Sources/cpplib/yocto_multiaxiscontroller.h
+++ /dev/null
@@ -1,370 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multiaxiscontroller.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindMultiAxisController(), the high-level API for MultiAxisController functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MULTIAXISCONTROLLER_H
-#define YOCTO_MULTIAXISCONTROLLER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YMultiAxisController return codes)
-//--- (end of YMultiAxisController return codes)
-//--- (YMultiAxisController yapiwrapper)
-//--- (end of YMultiAxisController yapiwrapper)
-//--- (YMultiAxisController definitions)
-class YMultiAxisController; // forward declaration
-
-typedef void (*YMultiAxisControllerValueCallback)(YMultiAxisController *func, const string& functionValue);
-#ifndef _Y_GLOBALSTATE_ENUM
-#define _Y_GLOBALSTATE_ENUM
-typedef enum {
-    Y_GLOBALSTATE_ABSENT = 0,
-    Y_GLOBALSTATE_ALERT = 1,
-    Y_GLOBALSTATE_HI_Z = 2,
-    Y_GLOBALSTATE_STOP = 3,
-    Y_GLOBALSTATE_RUN = 4,
-    Y_GLOBALSTATE_BATCH = 5,
-    Y_GLOBALSTATE_INVALID = -1,
-} Y_GLOBALSTATE_enum;
-#endif
-#define Y_NAXIS_INVALID                 (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YMultiAxisController definitions)
-
-//--- (YMultiAxisController declaration)
-/**
- * YMultiAxisController Class: MultiAxisController function interface
- *
- * The Yoctopuce application programming interface allows you to drive a stepper motor.
- */
-class YOCTO_CLASS_EXPORT YMultiAxisController: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YMultiAxisController declaration)
-protected:
-    //--- (YMultiAxisController attributes)
-    // Attributes (function value cache)
-    int             _nAxis;
-    Y_GLOBALSTATE_enum _globalState;
-    string          _command;
-    YMultiAxisControllerValueCallback _valueCallbackMultiAxisController;
-
-    friend YMultiAxisController *yFindMultiAxisController(const string& func);
-    friend YMultiAxisController *yFirstMultiAxisController(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMultiAxisController factory function to instantiate
-    YMultiAxisController(const string& func);
-    //--- (end of YMultiAxisController attributes)
-
-public:
-    virtual ~YMultiAxisController();
-    //--- (YMultiAxisController accessors declaration)
-
-    static const int NAXIS_INVALID = YAPI_INVALID_UINT;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_ABSENT = Y_GLOBALSTATE_ABSENT;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_ALERT = Y_GLOBALSTATE_ALERT;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_HI_Z = Y_GLOBALSTATE_HI_Z;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_STOP = Y_GLOBALSTATE_STOP;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_RUN = Y_GLOBALSTATE_RUN;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_BATCH = Y_GLOBALSTATE_BATCH;
-    static const Y_GLOBALSTATE_enum GLOBALSTATE_INVALID = Y_GLOBALSTATE_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the number of synchronized controllers.
-     *
-     * @return an integer corresponding to the number of synchronized controllers
-     *
-     * On failure, throws an exception or returns Y_NAXIS_INVALID.
-     */
-    int                 get_nAxis(void);
-
-    inline int          nAxis(void)
-    { return this->get_nAxis(); }
-
-    /**
-     * Changes the number of synchronized controllers.
-     *
-     * @param newval : an integer corresponding to the number of synchronized controllers
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_nAxis(int newval);
-    inline int      setNAxis(int newval)
-    { return this->set_nAxis(newval); }
-
-    /**
-     * Returns the stepper motor set overall state.
-     *
-     * @return a value among Y_GLOBALSTATE_ABSENT, Y_GLOBALSTATE_ALERT, Y_GLOBALSTATE_HI_Z,
-     * Y_GLOBALSTATE_STOP, Y_GLOBALSTATE_RUN and Y_GLOBALSTATE_BATCH corresponding to the stepper motor
-     * set overall state
-     *
-     * On failure, throws an exception or returns Y_GLOBALSTATE_INVALID.
-     */
-    Y_GLOBALSTATE_enum  get_globalState(void);
-
-    inline Y_GLOBALSTATE_enum globalState(void)
-    { return this->get_globalState(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a multi-axis controller for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the multi-axis controller is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMultiAxisController.isOnline() to test if the multi-axis controller is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a multi-axis controller by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the multi-axis controller
-     *
-     * @return a YMultiAxisController object allowing you to drive the multi-axis controller.
-     */
-    static YMultiAxisController* FindMultiAxisController(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMultiAxisControllerValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string command);
-
-    /**
-     * Reinitialize all controllers and clear all alert flags.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-    /**
-     * Starts all motors backward at the specified speeds, to search for the motor home position.
-     *
-     * @param speed : desired speed for all axis, in steps per second.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         findHomePosition(vector<double> speed);
-
-    /**
-     * Starts all motors synchronously to reach a given absolute position.
-     * The time needed to reach the requested position will depend on the lowest
-     * acceleration and max speed parameters configured for all motors.
-     * The final position will be reached on all axis at the same time.
-     *
-     * @param absPos : absolute position, measured in steps from each origin.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveTo(vector<double> absPos);
-
-    /**
-     * Starts all motors synchronously to reach a given relative position.
-     * The time needed to reach the requested position will depend on the lowest
-     * acceleration and max speed parameters configured for all motors.
-     * The final position will be reached on all axis at the same time.
-     *
-     * @param relPos : relative position, measured in steps from the current position.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveRel(vector<double> relPos);
-
-    /**
-     * Keep the motor in the same state for the specified amount of time, before processing next command.
-     *
-     * @param waitMs : wait time, specified in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pause(int waitMs);
-
-    /**
-     * Stops the motor with an emergency alert, without taking any additional precaution.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         emergencyStop(void);
-
-    /**
-     * Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         abortAndBrake(void);
-
-    /**
-     * Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         abortAndHiZ(void);
-
-
-    inline static YMultiAxisController* Find(string func)
-    { return YMultiAxisController::FindMultiAxisController(func); }
-
-    /**
-     * Continues the enumeration of multi-axis controllers started using yFirstMultiAxisController().
-     * Caution: You can't make any assumption about the returned multi-axis controllers order.
-     * If you want to find a specific a multi-axis controller, use MultiAxisController.findMultiAxisController()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMultiAxisController object, corresponding to
-     *         a multi-axis controller currently online, or a NULL pointer
-     *         if there are no more multi-axis controllers to enumerate.
-     */
-           YMultiAxisController *nextMultiAxisController(void);
-    inline YMultiAxisController *next(void)
-    { return this->nextMultiAxisController();}
-
-    /**
-     * Starts the enumeration of multi-axis controllers currently accessible.
-     * Use the method YMultiAxisController.nextMultiAxisController() to iterate on
-     * next multi-axis controllers.
-     *
-     * @return a pointer to a YMultiAxisController object, corresponding to
-     *         the first multi-axis controller currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMultiAxisController* FirstMultiAxisController(void);
-    inline static YMultiAxisController* First(void)
-    { return YMultiAxisController::FirstMultiAxisController();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YMultiAxisController accessors declaration)
-};
-
-//--- (YMultiAxisController functions declaration)
-
-/**
- * Retrieves a multi-axis controller for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-axis controller is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiAxisController.isOnline() to test if the multi-axis controller is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-axis controller by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-axis controller
- *
- * @return a YMultiAxisController object allowing you to drive the multi-axis controller.
- */
-inline YMultiAxisController* yFindMultiAxisController(const string& func)
-{ return YMultiAxisController::FindMultiAxisController(func);}
-/**
- * Starts the enumeration of multi-axis controllers currently accessible.
- * Use the method YMultiAxisController.nextMultiAxisController() to iterate on
- * next multi-axis controllers.
- *
- * @return a pointer to a YMultiAxisController object, corresponding to
- *         the first multi-axis controller currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMultiAxisController* yFirstMultiAxisController(void)
-{ return YMultiAxisController::FirstMultiAxisController();}
-
-//--- (end of YMultiAxisController functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_multicellweighscale.cpp
+++ /dev/null
@@ -1,738 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multicellweighscale.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindMultiCellWeighScale(), the high-level API for MultiCellWeighScale functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_multicellweighscale.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "multicellweighscale"
-
-YMultiCellWeighScale::YMultiCellWeighScale(const string& func): YSensor(func)
-//--- (YMultiCellWeighScale initialization)
-    ,_cellCount(CELLCOUNT_INVALID)
-    ,_excitation(EXCITATION_INVALID)
-    ,_tempAvgAdaptRatio(TEMPAVGADAPTRATIO_INVALID)
-    ,_tempChgAdaptRatio(TEMPCHGADAPTRATIO_INVALID)
-    ,_compTempAvg(COMPTEMPAVG_INVALID)
-    ,_compTempChg(COMPTEMPCHG_INVALID)
-    ,_compensation(COMPENSATION_INVALID)
-    ,_zeroTracking(ZEROTRACKING_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackMultiCellWeighScale(NULL)
-    ,_timedReportCallbackMultiCellWeighScale(NULL)
-//--- (end of YMultiCellWeighScale initialization)
-{
-    _className="MultiCellWeighScale";
-}
-
-YMultiCellWeighScale::~YMultiCellWeighScale()
-{
-//--- (YMultiCellWeighScale cleanup)
-//--- (end of YMultiCellWeighScale cleanup)
-}
-//--- (YMultiCellWeighScale implementation)
-// static attributes
-const double YMultiCellWeighScale::TEMPAVGADAPTRATIO_INVALID = YAPI_INVALID_DOUBLE;
-const double YMultiCellWeighScale::TEMPCHGADAPTRATIO_INVALID = YAPI_INVALID_DOUBLE;
-const double YMultiCellWeighScale::COMPTEMPAVG_INVALID = YAPI_INVALID_DOUBLE;
-const double YMultiCellWeighScale::COMPTEMPCHG_INVALID = YAPI_INVALID_DOUBLE;
-const double YMultiCellWeighScale::COMPENSATION_INVALID = YAPI_INVALID_DOUBLE;
-const double YMultiCellWeighScale::ZEROTRACKING_INVALID = YAPI_INVALID_DOUBLE;
-const string YMultiCellWeighScale::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YMultiCellWeighScale::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("cellCount")) {
-        _cellCount =  json_val->getInt("cellCount");
-    }
-    if(json_val->has("excitation")) {
-        _excitation =  (Y_EXCITATION_enum)json_val->getInt("excitation");
-    }
-    if(json_val->has("tempAvgAdaptRatio")) {
-        _tempAvgAdaptRatio =  floor(json_val->getDouble("tempAvgAdaptRatio") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("tempChgAdaptRatio")) {
-        _tempChgAdaptRatio =  floor(json_val->getDouble("tempChgAdaptRatio") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compTempAvg")) {
-        _compTempAvg =  floor(json_val->getDouble("compTempAvg") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compTempChg")) {
-        _compTempChg =  floor(json_val->getDouble("compTempChg") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compensation")) {
-        _compensation =  floor(json_val->getDouble("compensation") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("zeroTracking")) {
-        _zeroTracking =  floor(json_val->getDouble("zeroTracking") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the weight.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the measuring unit for the weight
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of load cells in use.
- *
- * @return an integer corresponding to the number of load cells in use
- *
- * On failure, throws an exception or returns Y_CELLCOUNT_INVALID.
- */
-int YMultiCellWeighScale::get_cellCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::CELLCOUNT_INVALID;
-                }
-            }
-        }
-        res = _cellCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of load cells in use.
- *
- * @param newval : an integer corresponding to the number of load cells in use
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_cellCount(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("cellCount", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current load cell bridge excitation method.
- *
- * @return a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding to the
- * current load cell bridge excitation method
- *
- * On failure, throws an exception or returns Y_EXCITATION_INVALID.
- */
-Y_EXCITATION_enum YMultiCellWeighScale::get_excitation(void)
-{
-    Y_EXCITATION_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::EXCITATION_INVALID;
-                }
-            }
-        }
-        res = _excitation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current load cell bridge excitation method.
- *
- * @param newval : a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding
- * to the current load cell bridge excitation method
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_excitation(Y_EXCITATION_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("excitation", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the averaged temperature update rate, in per mille.
- * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
- * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current compensation
- * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
- *
- * @param newval : a floating point number corresponding to the averaged temperature update rate, in per mille
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_tempAvgAdaptRatio(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("tempAvgAdaptRatio", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the averaged temperature update rate, in per mille.
- * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
- * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current compensation
- * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
- *
- * @return a floating point number corresponding to the averaged temperature update rate, in per mille
- *
- * On failure, throws an exception or returns Y_TEMPAVGADAPTRATIO_INVALID.
- */
-double YMultiCellWeighScale::get_tempAvgAdaptRatio(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::TEMPAVGADAPTRATIO_INVALID;
-                }
-            }
-        }
-        res = _tempAvgAdaptRatio;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the temperature change update rate, in per mille.
- * The temperature change is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current temperature used for
- * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
- *
- * @param newval : a floating point number corresponding to the temperature change update rate, in per mille
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_tempChgAdaptRatio(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("tempChgAdaptRatio", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the temperature change update rate, in per mille.
- * The temperature change is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current temperature used for
- * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
- *
- * @return a floating point number corresponding to the temperature change update rate, in per mille
- *
- * On failure, throws an exception or returns Y_TEMPCHGADAPTRATIO_INVALID.
- */
-double YMultiCellWeighScale::get_tempChgAdaptRatio(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::TEMPCHGADAPTRATIO_INVALID;
-                }
-            }
-        }
-        res = _tempChgAdaptRatio;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current averaged temperature, used for thermal compensation.
- *
- * @return a floating point number corresponding to the current averaged temperature, used for thermal compensation
- *
- * On failure, throws an exception or returns Y_COMPTEMPAVG_INVALID.
- */
-double YMultiCellWeighScale::get_compTempAvg(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::COMPTEMPAVG_INVALID;
-                }
-            }
-        }
-        res = _compTempAvg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current temperature variation, used for thermal compensation.
- *
- * @return a floating point number corresponding to the current temperature variation, used for
- * thermal compensation
- *
- * On failure, throws an exception or returns Y_COMPTEMPCHG_INVALID.
- */
-double YMultiCellWeighScale::get_compTempChg(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::COMPTEMPCHG_INVALID;
-                }
-            }
-        }
-        res = _compTempChg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current current thermal compensation value.
- *
- * @return a floating point number corresponding to the current current thermal compensation value
- *
- * On failure, throws an exception or returns Y_COMPENSATION_INVALID.
- */
-double YMultiCellWeighScale::get_compensation(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::COMPENSATION_INVALID;
-                }
-            }
-        }
-        res = _compensation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the zero tracking threshold value. When this threshold is larger than
- * zero, any measure under the threshold will automatically be ignored and the
- * zero compensation will be updated.
- *
- * @param newval : a floating point number corresponding to the zero tracking threshold value
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::set_zeroTracking(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("zeroTracking", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the zero tracking threshold value. When this threshold is larger than
- * zero, any measure under the threshold will automatically be ignored and the
- * zero compensation will be updated.
- *
- * @return a floating point number corresponding to the zero tracking threshold value
- *
- * On failure, throws an exception or returns Y_ZEROTRACKING_INVALID.
- */
-double YMultiCellWeighScale::get_zeroTracking(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::ZEROTRACKING_INVALID;
-                }
-            }
-        }
-        res = _zeroTracking;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMultiCellWeighScale::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiCellWeighScale::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMultiCellWeighScale::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a multi-cell weighing scale sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-cell weighing scale sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiCellWeighScale.isOnline() to test if the multi-cell weighing scale sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-cell weighing scale sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-cell weighing scale sensor
- *
- * @return a YMultiCellWeighScale object allowing you to drive the multi-cell weighing scale sensor.
- */
-YMultiCellWeighScale* YMultiCellWeighScale::FindMultiCellWeighScale(string func)
-{
-    YMultiCellWeighScale* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMultiCellWeighScale*) YFunction::_FindFromCache("MultiCellWeighScale", func);
-        if (obj == NULL) {
-            obj = new YMultiCellWeighScale(func);
-            YFunction::_AddToCache("MultiCellWeighScale", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMultiCellWeighScale::registerValueCallback(YMultiCellWeighScaleValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMultiCellWeighScale = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMultiCellWeighScale::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMultiCellWeighScale != NULL) {
-        _valueCallbackMultiCellWeighScale(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YMultiCellWeighScale::registerTimedReportCallback(YMultiCellWeighScaleTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackMultiCellWeighScale = callback;
-    return 0;
-}
-
-int YMultiCellWeighScale::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackMultiCellWeighScale != NULL) {
-        _timedReportCallbackMultiCellWeighScale(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Adapts the load cell signal bias (stored in the corresponding genericSensor)
- * so that the current signal corresponds to a zero weight.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::tare(void)
-{
-    return this->set_command("T");
-}
-
-/**
- * Configures the load cells span parameters (stored in the corresponding genericSensors)
- * so that the current signal corresponds to the specified reference weight.
- *
- * @param currWeight : reference weight presently on the load cell.
- * @param maxWeight : maximum weight to be expected on the load cell.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiCellWeighScale::setupSpan(double currWeight,double maxWeight)
-{
-    return this->set_command(YapiWrapper::ysprintf("S%d:%d", (int) floor(1000*currWeight+0.5),(int) floor(1000*maxWeight+0.5)));
-}
-
-YMultiCellWeighScale *YMultiCellWeighScale::nextMultiCellWeighScale(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMultiCellWeighScale::FindMultiCellWeighScale(hwid);
-}
-
-YMultiCellWeighScale* YMultiCellWeighScale::FirstMultiCellWeighScale(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("MultiCellWeighScale", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMultiCellWeighScale::FindMultiCellWeighScale(serial+"."+funcId);
-}
-
-//--- (end of YMultiCellWeighScale implementation)
-
-//--- (YMultiCellWeighScale functions)
-//--- (end of YMultiCellWeighScale functions)
--- a/Sources/cpplib/yocto_multicellweighscale.h
+++ /dev/null
@@ -1,507 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multicellweighscale.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindMultiCellWeighScale(), the high-level API for MultiCellWeighScale functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MULTICELLWEIGHSCALE_H
-#define YOCTO_MULTICELLWEIGHSCALE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YMultiCellWeighScale return codes)
-//--- (end of YMultiCellWeighScale return codes)
-//--- (YMultiCellWeighScale yapiwrapper)
-//--- (end of YMultiCellWeighScale yapiwrapper)
-//--- (YMultiCellWeighScale definitions)
-class YMultiCellWeighScale; // forward declaration
-
-typedef void (*YMultiCellWeighScaleValueCallback)(YMultiCellWeighScale *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YMultiCellWeighScaleTimedReportCallback)(YMultiCellWeighScale *func, YMeasure measure);
-#ifndef _Y_EXCITATION_ENUM
-#define _Y_EXCITATION_ENUM
-typedef enum {
-    Y_EXCITATION_OFF = 0,
-    Y_EXCITATION_DC = 1,
-    Y_EXCITATION_AC = 2,
-    Y_EXCITATION_INVALID = -1,
-} Y_EXCITATION_enum;
-#endif
-#define Y_CELLCOUNT_INVALID             (YAPI_INVALID_UINT)
-#define Y_TEMPAVGADAPTRATIO_INVALID     (YAPI_INVALID_DOUBLE)
-#define Y_TEMPCHGADAPTRATIO_INVALID     (YAPI_INVALID_DOUBLE)
-#define Y_COMPTEMPAVG_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_COMPTEMPCHG_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_COMPENSATION_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_ZEROTRACKING_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YMultiCellWeighScale definitions)
-
-//--- (YMultiCellWeighScale declaration)
-/**
- * YMultiCellWeighScale Class: MultiCellWeighScale function interface
- *
- * The YMultiCellWeighScale class provides a weight measurement from a set of ratiometric load cells
- * sensor. It can be used to control the bridge excitation parameters, in order to avoid
- * measure shifts caused by temperature variation in the electronics, and can also
- * automatically apply an additional correction factor based on temperature to
- * compensate for offsets in the load cells themselves.
- */
-class YOCTO_CLASS_EXPORT YMultiCellWeighScale: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YMultiCellWeighScale declaration)
-protected:
-    //--- (YMultiCellWeighScale attributes)
-    // Attributes (function value cache)
-    int             _cellCount;
-    Y_EXCITATION_enum _excitation;
-    double          _tempAvgAdaptRatio;
-    double          _tempChgAdaptRatio;
-    double          _compTempAvg;
-    double          _compTempChg;
-    double          _compensation;
-    double          _zeroTracking;
-    string          _command;
-    YMultiCellWeighScaleValueCallback _valueCallbackMultiCellWeighScale;
-    YMultiCellWeighScaleTimedReportCallback _timedReportCallbackMultiCellWeighScale;
-
-    friend YMultiCellWeighScale *yFindMultiCellWeighScale(const string& func);
-    friend YMultiCellWeighScale *yFirstMultiCellWeighScale(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMultiCellWeighScale factory function to instantiate
-    YMultiCellWeighScale(const string& func);
-    //--- (end of YMultiCellWeighScale attributes)
-
-public:
-    virtual ~YMultiCellWeighScale();
-    //--- (YMultiCellWeighScale accessors declaration)
-
-    static const int CELLCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const Y_EXCITATION_enum EXCITATION_OFF = Y_EXCITATION_OFF;
-    static const Y_EXCITATION_enum EXCITATION_DC = Y_EXCITATION_DC;
-    static const Y_EXCITATION_enum EXCITATION_AC = Y_EXCITATION_AC;
-    static const Y_EXCITATION_enum EXCITATION_INVALID = Y_EXCITATION_INVALID;
-    static const double TEMPAVGADAPTRATIO_INVALID;
-    static const double TEMPCHGADAPTRATIO_INVALID;
-    static const double COMPTEMPAVG_INVALID;
-    static const double COMPTEMPCHG_INVALID;
-    static const double COMPENSATION_INVALID;
-    static const double ZEROTRACKING_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the measuring unit for the weight.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the measuring unit for the weight
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the number of load cells in use.
-     *
-     * @return an integer corresponding to the number of load cells in use
-     *
-     * On failure, throws an exception or returns Y_CELLCOUNT_INVALID.
-     */
-    int                 get_cellCount(void);
-
-    inline int          cellCount(void)
-    { return this->get_cellCount(); }
-
-    /**
-     * Changes the number of load cells in use.
-     *
-     * @param newval : an integer corresponding to the number of load cells in use
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_cellCount(int newval);
-    inline int      setCellCount(int newval)
-    { return this->set_cellCount(newval); }
-
-    /**
-     * Returns the current load cell bridge excitation method.
-     *
-     * @return a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding to the
-     * current load cell bridge excitation method
-     *
-     * On failure, throws an exception or returns Y_EXCITATION_INVALID.
-     */
-    Y_EXCITATION_enum   get_excitation(void);
-
-    inline Y_EXCITATION_enum excitation(void)
-    { return this->get_excitation(); }
-
-    /**
-     * Changes the current load cell bridge excitation method.
-     *
-     * @param newval : a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding
-     * to the current load cell bridge excitation method
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_excitation(Y_EXCITATION_enum newval);
-    inline int      setExcitation(Y_EXCITATION_enum newval)
-    { return this->set_excitation(newval); }
-
-    /**
-     * Changes the averaged temperature update rate, in per mille.
-     * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
-     * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current compensation
-     * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
-     *
-     * @param newval : a floating point number corresponding to the averaged temperature update rate, in per mille
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tempAvgAdaptRatio(double newval);
-    inline int      setTempAvgAdaptRatio(double newval)
-    { return this->set_tempAvgAdaptRatio(newval); }
-
-    /**
-     * Returns the averaged temperature update rate, in per mille.
-     * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
-     * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current compensation
-     * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
-     *
-     * @return a floating point number corresponding to the averaged temperature update rate, in per mille
-     *
-     * On failure, throws an exception or returns Y_TEMPAVGADAPTRATIO_INVALID.
-     */
-    double              get_tempAvgAdaptRatio(void);
-
-    inline double       tempAvgAdaptRatio(void)
-    { return this->get_tempAvgAdaptRatio(); }
-
-    /**
-     * Changes the temperature change update rate, in per mille.
-     * The temperature change is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current temperature used for
-     * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
-     *
-     * @param newval : a floating point number corresponding to the temperature change update rate, in per mille
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tempChgAdaptRatio(double newval);
-    inline int      setTempChgAdaptRatio(double newval)
-    { return this->set_tempChgAdaptRatio(newval); }
-
-    /**
-     * Returns the temperature change update rate, in per mille.
-     * The temperature change is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current temperature used for
-     * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
-     *
-     * @return a floating point number corresponding to the temperature change update rate, in per mille
-     *
-     * On failure, throws an exception or returns Y_TEMPCHGADAPTRATIO_INVALID.
-     */
-    double              get_tempChgAdaptRatio(void);
-
-    inline double       tempChgAdaptRatio(void)
-    { return this->get_tempChgAdaptRatio(); }
-
-    /**
-     * Returns the current averaged temperature, used for thermal compensation.
-     *
-     * @return a floating point number corresponding to the current averaged temperature, used for thermal compensation
-     *
-     * On failure, throws an exception or returns Y_COMPTEMPAVG_INVALID.
-     */
-    double              get_compTempAvg(void);
-
-    inline double       compTempAvg(void)
-    { return this->get_compTempAvg(); }
-
-    /**
-     * Returns the current temperature variation, used for thermal compensation.
-     *
-     * @return a floating point number corresponding to the current temperature variation, used for
-     * thermal compensation
-     *
-     * On failure, throws an exception or returns Y_COMPTEMPCHG_INVALID.
-     */
-    double              get_compTempChg(void);
-
-    inline double       compTempChg(void)
-    { return this->get_compTempChg(); }
-
-    /**
-     * Returns the current current thermal compensation value.
-     *
-     * @return a floating point number corresponding to the current current thermal compensation value
-     *
-     * On failure, throws an exception or returns Y_COMPENSATION_INVALID.
-     */
-    double              get_compensation(void);
-
-    inline double       compensation(void)
-    { return this->get_compensation(); }
-
-    /**
-     * Changes the zero tracking threshold value. When this threshold is larger than
-     * zero, any measure under the threshold will automatically be ignored and the
-     * zero compensation will be updated.
-     *
-     * @param newval : a floating point number corresponding to the zero tracking threshold value
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_zeroTracking(double newval);
-    inline int      setZeroTracking(double newval)
-    { return this->set_zeroTracking(newval); }
-
-    /**
-     * Returns the zero tracking threshold value. When this threshold is larger than
-     * zero, any measure under the threshold will automatically be ignored and the
-     * zero compensation will be updated.
-     *
-     * @return a floating point number corresponding to the zero tracking threshold value
-     *
-     * On failure, throws an exception or returns Y_ZEROTRACKING_INVALID.
-     */
-    double              get_zeroTracking(void);
-
-    inline double       zeroTracking(void)
-    { return this->get_zeroTracking(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a multi-cell weighing scale sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the multi-cell weighing scale sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMultiCellWeighScale.isOnline() to test if the multi-cell weighing scale sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a multi-cell weighing scale sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the multi-cell weighing scale sensor
-     *
-     * @return a YMultiCellWeighScale object allowing you to drive the multi-cell weighing scale sensor.
-     */
-    static YMultiCellWeighScale* FindMultiCellWeighScale(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMultiCellWeighScaleValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YMultiCellWeighScaleTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Adapts the load cell signal bias (stored in the corresponding genericSensor)
-     * so that the current signal corresponds to a zero weight.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         tare(void);
-
-    /**
-     * Configures the load cells span parameters (stored in the corresponding genericSensors)
-     * so that the current signal corresponds to the specified reference weight.
-     *
-     * @param currWeight : reference weight presently on the load cell.
-     * @param maxWeight : maximum weight to be expected on the load cell.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setupSpan(double currWeight,double maxWeight);
-
-
-    inline static YMultiCellWeighScale* Find(string func)
-    { return YMultiCellWeighScale::FindMultiCellWeighScale(func); }
-
-    /**
-     * Continues the enumeration of multi-cell weighing scale sensors started using yFirstMultiCellWeighScale().
-     * Caution: You can't make any assumption about the returned multi-cell weighing scale sensors order.
-     * If you want to find a specific a multi-cell weighing scale sensor, use
-     * MultiCellWeighScale.findMultiCellWeighScale()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMultiCellWeighScale object, corresponding to
-     *         a multi-cell weighing scale sensor currently online, or a NULL pointer
-     *         if there are no more multi-cell weighing scale sensors to enumerate.
-     */
-           YMultiCellWeighScale *nextMultiCellWeighScale(void);
-    inline YMultiCellWeighScale *next(void)
-    { return this->nextMultiCellWeighScale();}
-
-    /**
-     * Starts the enumeration of multi-cell weighing scale sensors currently accessible.
-     * Use the method YMultiCellWeighScale.nextMultiCellWeighScale() to iterate on
-     * next multi-cell weighing scale sensors.
-     *
-     * @return a pointer to a YMultiCellWeighScale object, corresponding to
-     *         the first multi-cell weighing scale sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMultiCellWeighScale* FirstMultiCellWeighScale(void);
-    inline static YMultiCellWeighScale* First(void)
-    { return YMultiCellWeighScale::FirstMultiCellWeighScale();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YMultiCellWeighScale accessors declaration)
-};
-
-//--- (YMultiCellWeighScale functions declaration)
-
-/**
- * Retrieves a multi-cell weighing scale sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-cell weighing scale sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiCellWeighScale.isOnline() to test if the multi-cell weighing scale sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-cell weighing scale sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-cell weighing scale sensor
- *
- * @return a YMultiCellWeighScale object allowing you to drive the multi-cell weighing scale sensor.
- */
-inline YMultiCellWeighScale* yFindMultiCellWeighScale(const string& func)
-{ return YMultiCellWeighScale::FindMultiCellWeighScale(func);}
-/**
- * Starts the enumeration of multi-cell weighing scale sensors currently accessible.
- * Use the method YMultiCellWeighScale.nextMultiCellWeighScale() to iterate on
- * next multi-cell weighing scale sensors.
- *
- * @return a pointer to a YMultiCellWeighScale object, corresponding to
- *         the first multi-cell weighing scale sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMultiCellWeighScale* yFirstMultiCellWeighScale(void)
-{ return YMultiCellWeighScale::FirstMultiCellWeighScale();}
-
-//--- (end of YMultiCellWeighScale functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_multisenscontroller.cpp
+++ /dev/null
@@ -1,409 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multisenscontroller.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindMultiSensController(), the high-level API for MultiSensController functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_multisenscontroller.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "multisenscontroller"
-
-YMultiSensController::YMultiSensController(const string& func): YFunction(func)
-//--- (YMultiSensController initialization)
-    ,_nSensors(NSENSORS_INVALID)
-    ,_maxSensors(MAXSENSORS_INVALID)
-    ,_maintenanceMode(MAINTENANCEMODE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackMultiSensController(NULL)
-//--- (end of YMultiSensController initialization)
-{
-    _className="MultiSensController";
-}
-
-YMultiSensController::~YMultiSensController()
-{
-//--- (YMultiSensController cleanup)
-//--- (end of YMultiSensController cleanup)
-}
-//--- (YMultiSensController implementation)
-// static attributes
-const string YMultiSensController::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YMultiSensController::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("nSensors")) {
-        _nSensors =  json_val->getInt("nSensors");
-    }
-    if(json_val->has("maxSensors")) {
-        _maxSensors =  json_val->getInt("maxSensors");
-    }
-    if(json_val->has("maintenanceMode")) {
-        _maintenanceMode =  (Y_MAINTENANCEMODE_enum)json_val->getInt("maintenanceMode");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the number of sensors to poll.
- *
- * @return an integer corresponding to the number of sensors to poll
- *
- * On failure, throws an exception or returns Y_NSENSORS_INVALID.
- */
-int YMultiSensController::get_nSensors(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiSensController::NSENSORS_INVALID;
-                }
-            }
-        }
-        res = _nSensors;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of sensors to poll. Remember to call the
- * saveToFlash() method of the module if the
- * modification must be kept. It's recommended to restart the
- * device with  module->reboot() after modifying
- * (and saving) this settings
- *
- * @param newval : an integer corresponding to the number of sensors to poll
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiSensController::set_nSensors(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("nSensors", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximum configurable sensor count allowed on this device.
- *
- * @return an integer corresponding to the maximum configurable sensor count allowed on this device
- *
- * On failure, throws an exception or returns Y_MAXSENSORS_INVALID.
- */
-int YMultiSensController::get_maxSensors(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiSensController::MAXSENSORS_INVALID;
-                }
-            }
-        }
-        res = _maxSensors;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true when the device is in maintenance mode.
- *
- * @return either Y_MAINTENANCEMODE_FALSE or Y_MAINTENANCEMODE_TRUE, according to true when the device
- * is in maintenance mode
- *
- * On failure, throws an exception or returns Y_MAINTENANCEMODE_INVALID.
- */
-Y_MAINTENANCEMODE_enum YMultiSensController::get_maintenanceMode(void)
-{
-    Y_MAINTENANCEMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiSensController::MAINTENANCEMODE_INVALID;
-                }
-            }
-        }
-        res = _maintenanceMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the device mode to enable maintenance and stop sensors polling.
- * This way, the device will not restart automatically in case it cannot
- * communicate with one of the sensors.
- *
- * @param newval : either Y_MAINTENANCEMODE_FALSE or Y_MAINTENANCEMODE_TRUE, according to the device
- * mode to enable maintenance and stop sensors polling
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YMultiSensController::set_maintenanceMode(Y_MAINTENANCEMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("maintenanceMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YMultiSensController::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YMultiSensController::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YMultiSensController::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a multi-sensor controller for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-sensor controller is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiSensController.isOnline() to test if the multi-sensor controller is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-sensor controller by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-sensor controller
- *
- * @return a YMultiSensController object allowing you to drive the multi-sensor controller.
- */
-YMultiSensController* YMultiSensController::FindMultiSensController(string func)
-{
-    YMultiSensController* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YMultiSensController*) YFunction::_FindFromCache("MultiSensController", func);
-        if (obj == NULL) {
-            obj = new YMultiSensController(func);
-            YFunction::_AddToCache("MultiSensController", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YMultiSensController::registerValueCallback(YMultiSensControllerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackMultiSensController = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YMultiSensController::_invokeValueCallback(string value)
-{
-    if (_valueCallbackMultiSensController != NULL) {
-        _valueCallbackMultiSensController(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Configure the I2C address of the only sensor connected to the device.
- * It is recommended to put the the device in maintenance mode before
- * changing Sensors addresses.  This method is only intended to work with a single
- * sensor connected to the device, if several sensors are connected, result
- * is unpredictable.
- * Note that the device is probably expecting to find a string of sensors with specific
- * addresses. Check the device documentation to find out which addresses should be used.
- *
- * @param addr : new address of the connected sensor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YMultiSensController::setupAddress(int addr)
-{
-    string cmd;
-    cmd = YapiWrapper::ysprintf("A%d",addr);
-    return this->set_command(cmd);
-}
-
-YMultiSensController *YMultiSensController::nextMultiSensController(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YMultiSensController::FindMultiSensController(hwid);
-}
-
-YMultiSensController* YMultiSensController::FirstMultiSensController(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("MultiSensController", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YMultiSensController::FindMultiSensController(serial+"."+funcId);
-}
-
-//--- (end of YMultiSensController implementation)
-
-//--- (YMultiSensController functions)
-//--- (end of YMultiSensController functions)
--- a/Sources/cpplib/yocto_multisenscontroller.h
+++ /dev/null
@@ -1,332 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_multisenscontroller.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindMultiSensController(), the high-level API for MultiSensController functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_MULTISENSCONTROLLER_H
-#define YOCTO_MULTISENSCONTROLLER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YMultiSensController return codes)
-//--- (end of YMultiSensController return codes)
-//--- (YMultiSensController yapiwrapper)
-//--- (end of YMultiSensController yapiwrapper)
-//--- (YMultiSensController definitions)
-class YMultiSensController; // forward declaration
-
-typedef void (*YMultiSensControllerValueCallback)(YMultiSensController *func, const string& functionValue);
-#ifndef _Y_MAINTENANCEMODE_ENUM
-#define _Y_MAINTENANCEMODE_ENUM
-typedef enum {
-    Y_MAINTENANCEMODE_FALSE = 0,
-    Y_MAINTENANCEMODE_TRUE = 1,
-    Y_MAINTENANCEMODE_INVALID = -1,
-} Y_MAINTENANCEMODE_enum;
-#endif
-#define Y_NSENSORS_INVALID              (YAPI_INVALID_UINT)
-#define Y_MAXSENSORS_INVALID            (YAPI_INVALID_UINT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YMultiSensController definitions)
-
-//--- (YMultiSensController declaration)
-/**
- * YMultiSensController Class: MultiSensController function interface
- *
- * The Yoctopuce application programming interface allows you to drive a stepper motor.
- */
-class YOCTO_CLASS_EXPORT YMultiSensController: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YMultiSensController declaration)
-protected:
-    //--- (YMultiSensController attributes)
-    // Attributes (function value cache)
-    int             _nSensors;
-    int             _maxSensors;
-    Y_MAINTENANCEMODE_enum _maintenanceMode;
-    string          _command;
-    YMultiSensControllerValueCallback _valueCallbackMultiSensController;
-
-    friend YMultiSensController *yFindMultiSensController(const string& func);
-    friend YMultiSensController *yFirstMultiSensController(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindMultiSensController factory function to instantiate
-    YMultiSensController(const string& func);
-    //--- (end of YMultiSensController attributes)
-
-public:
-    virtual ~YMultiSensController();
-    //--- (YMultiSensController accessors declaration)
-
-    static const int NSENSORS_INVALID = YAPI_INVALID_UINT;
-    static const int MAXSENSORS_INVALID = YAPI_INVALID_UINT;
-    static const Y_MAINTENANCEMODE_enum MAINTENANCEMODE_FALSE = Y_MAINTENANCEMODE_FALSE;
-    static const Y_MAINTENANCEMODE_enum MAINTENANCEMODE_TRUE = Y_MAINTENANCEMODE_TRUE;
-    static const Y_MAINTENANCEMODE_enum MAINTENANCEMODE_INVALID = Y_MAINTENANCEMODE_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the number of sensors to poll.
-     *
-     * @return an integer corresponding to the number of sensors to poll
-     *
-     * On failure, throws an exception or returns Y_NSENSORS_INVALID.
-     */
-    int                 get_nSensors(void);
-
-    inline int          nSensors(void)
-    { return this->get_nSensors(); }
-
-    /**
-     * Changes the number of sensors to poll. Remember to call the
-     * saveToFlash() method of the module if the
-     * modification must be kept. It's recommended to restart the
-     * device with  module->reboot() after modifying
-     * (and saving) this settings
-     *
-     * @param newval : an integer corresponding to the number of sensors to poll
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_nSensors(int newval);
-    inline int      setNSensors(int newval)
-    { return this->set_nSensors(newval); }
-
-    /**
-     * Returns the maximum configurable sensor count allowed on this device.
-     *
-     * @return an integer corresponding to the maximum configurable sensor count allowed on this device
-     *
-     * On failure, throws an exception or returns Y_MAXSENSORS_INVALID.
-     */
-    int                 get_maxSensors(void);
-
-    inline int          maxSensors(void)
-    { return this->get_maxSensors(); }
-
-    /**
-     * Returns true when the device is in maintenance mode.
-     *
-     * @return either Y_MAINTENANCEMODE_FALSE or Y_MAINTENANCEMODE_TRUE, according to true when the device
-     * is in maintenance mode
-     *
-     * On failure, throws an exception or returns Y_MAINTENANCEMODE_INVALID.
-     */
-    Y_MAINTENANCEMODE_enum get_maintenanceMode(void);
-
-    inline Y_MAINTENANCEMODE_enum maintenanceMode(void)
-    { return this->get_maintenanceMode(); }
-
-    /**
-     * Changes the device mode to enable maintenance and stop sensors polling.
-     * This way, the device will not restart automatically in case it cannot
-     * communicate with one of the sensors.
-     *
-     * @param newval : either Y_MAINTENANCEMODE_FALSE or Y_MAINTENANCEMODE_TRUE, according to the device
-     * mode to enable maintenance and stop sensors polling
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maintenanceMode(Y_MAINTENANCEMODE_enum newval);
-    inline int      setMaintenanceMode(Y_MAINTENANCEMODE_enum newval)
-    { return this->set_maintenanceMode(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a multi-sensor controller for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the multi-sensor controller is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YMultiSensController.isOnline() to test if the multi-sensor controller is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a multi-sensor controller by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the multi-sensor controller
-     *
-     * @return a YMultiSensController object allowing you to drive the multi-sensor controller.
-     */
-    static YMultiSensController* FindMultiSensController(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YMultiSensControllerValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Configure the I2C address of the only sensor connected to the device.
-     * It is recommended to put the the device in maintenance mode before
-     * changing Sensors addresses.  This method is only intended to work with a single
-     * sensor connected to the device, if several sensors are connected, result
-     * is unpredictable.
-     * Note that the device is probably expecting to find a string of sensors with specific
-     * addresses. Check the device documentation to find out which addresses should be used.
-     *
-     * @param addr : new address of the connected sensor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setupAddress(int addr);
-
-
-    inline static YMultiSensController* Find(string func)
-    { return YMultiSensController::FindMultiSensController(func); }
-
-    /**
-     * Continues the enumeration of multi-sensor controllers started using yFirstMultiSensController().
-     * Caution: You can't make any assumption about the returned multi-sensor controllers order.
-     * If you want to find a specific a multi-sensor controller, use MultiSensController.findMultiSensController()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YMultiSensController object, corresponding to
-     *         a multi-sensor controller currently online, or a NULL pointer
-     *         if there are no more multi-sensor controllers to enumerate.
-     */
-           YMultiSensController *nextMultiSensController(void);
-    inline YMultiSensController *next(void)
-    { return this->nextMultiSensController();}
-
-    /**
-     * Starts the enumeration of multi-sensor controllers currently accessible.
-     * Use the method YMultiSensController.nextMultiSensController() to iterate on
-     * next multi-sensor controllers.
-     *
-     * @return a pointer to a YMultiSensController object, corresponding to
-     *         the first multi-sensor controller currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YMultiSensController* FirstMultiSensController(void);
-    inline static YMultiSensController* First(void)
-    { return YMultiSensController::FirstMultiSensController();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YMultiSensController accessors declaration)
-};
-
-//--- (YMultiSensController functions declaration)
-
-/**
- * Retrieves a multi-sensor controller for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the multi-sensor controller is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YMultiSensController.isOnline() to test if the multi-sensor controller is
- * indeed online at a given time. In case of ambiguity when looking for
- * a multi-sensor controller by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the multi-sensor controller
- *
- * @return a YMultiSensController object allowing you to drive the multi-sensor controller.
- */
-inline YMultiSensController* yFindMultiSensController(const string& func)
-{ return YMultiSensController::FindMultiSensController(func);}
-/**
- * Starts the enumeration of multi-sensor controllers currently accessible.
- * Use the method YMultiSensController.nextMultiSensController() to iterate on
- * next multi-sensor controllers.
- *
- * @return a pointer to a YMultiSensController object, corresponding to
- *         the first multi-sensor controller currently online, or a NULL pointer
- *         if there are none.
- */
-inline YMultiSensController* yFirstMultiSensController(void)
-{ return YMultiSensController::FirstMultiSensController();}
-
-//--- (end of YMultiSensController functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_network.cpp
+++ /dev/null
@@ -1,1655 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_network.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindNetwork(), the high-level API for Network functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_network.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "network"
-
-YNetwork::YNetwork(const string& func): YFunction(func)
-//--- (YNetwork initialization)
-    ,_readiness(READINESS_INVALID)
-    ,_macAddress(MACADDRESS_INVALID)
-    ,_ipAddress(IPADDRESS_INVALID)
-    ,_subnetMask(SUBNETMASK_INVALID)
-    ,_router(ROUTER_INVALID)
-    ,_ipConfig(IPCONFIG_INVALID)
-    ,_primaryDNS(PRIMARYDNS_INVALID)
-    ,_secondaryDNS(SECONDARYDNS_INVALID)
-    ,_ntpServer(NTPSERVER_INVALID)
-    ,_userPassword(USERPASSWORD_INVALID)
-    ,_adminPassword(ADMINPASSWORD_INVALID)
-    ,_httpPort(HTTPPORT_INVALID)
-    ,_defaultPage(DEFAULTPAGE_INVALID)
-    ,_discoverable(DISCOVERABLE_INVALID)
-    ,_wwwWatchdogDelay(WWWWATCHDOGDELAY_INVALID)
-    ,_callbackUrl(CALLBACKURL_INVALID)
-    ,_callbackMethod(CALLBACKMETHOD_INVALID)
-    ,_callbackEncoding(CALLBACKENCODING_INVALID)
-    ,_callbackCredentials(CALLBACKCREDENTIALS_INVALID)
-    ,_callbackInitialDelay(CALLBACKINITIALDELAY_INVALID)
-    ,_callbackSchedule(CALLBACKSCHEDULE_INVALID)
-    ,_callbackMinDelay(CALLBACKMINDELAY_INVALID)
-    ,_callbackMaxDelay(CALLBACKMAXDELAY_INVALID)
-    ,_poeCurrent(POECURRENT_INVALID)
-    ,_valueCallbackNetwork(NULL)
-//--- (end of YNetwork initialization)
-{
-    _className="Network";
-}
-
-YNetwork::~YNetwork()
-{
-//--- (YNetwork cleanup)
-//--- (end of YNetwork cleanup)
-}
-//--- (YNetwork implementation)
-// static attributes
-const string YNetwork::MACADDRESS_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::IPADDRESS_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::SUBNETMASK_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::ROUTER_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::IPCONFIG_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::PRIMARYDNS_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::SECONDARYDNS_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::NTPSERVER_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::USERPASSWORD_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::ADMINPASSWORD_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::DEFAULTPAGE_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::CALLBACKURL_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::CALLBACKCREDENTIALS_INVALID = YAPI_INVALID_STRING;
-const string YNetwork::CALLBACKSCHEDULE_INVALID = YAPI_INVALID_STRING;
-
-int YNetwork::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("readiness")) {
-        _readiness =  (Y_READINESS_enum)json_val->getInt("readiness");
-    }
-    if(json_val->has("macAddress")) {
-        _macAddress =  json_val->getString("macAddress");
-    }
-    if(json_val->has("ipAddress")) {
-        _ipAddress =  json_val->getString("ipAddress");
-    }
-    if(json_val->has("subnetMask")) {
-        _subnetMask =  json_val->getString("subnetMask");
-    }
-    if(json_val->has("router")) {
-        _router =  json_val->getString("router");
-    }
-    if(json_val->has("ipConfig")) {
-        _ipConfig =  json_val->getString("ipConfig");
-    }
-    if(json_val->has("primaryDNS")) {
-        _primaryDNS =  json_val->getString("primaryDNS");
-    }
-    if(json_val->has("secondaryDNS")) {
-        _secondaryDNS =  json_val->getString("secondaryDNS");
-    }
-    if(json_val->has("ntpServer")) {
-        _ntpServer =  json_val->getString("ntpServer");
-    }
-    if(json_val->has("userPassword")) {
-        _userPassword =  json_val->getString("userPassword");
-    }
-    if(json_val->has("adminPassword")) {
-        _adminPassword =  json_val->getString("adminPassword");
-    }
-    if(json_val->has("httpPort")) {
-        _httpPort =  json_val->getInt("httpPort");
-    }
-    if(json_val->has("defaultPage")) {
-        _defaultPage =  json_val->getString("defaultPage");
-    }
-    if(json_val->has("discoverable")) {
-        _discoverable =  (Y_DISCOVERABLE_enum)json_val->getInt("discoverable");
-    }
-    if(json_val->has("wwwWatchdogDelay")) {
-        _wwwWatchdogDelay =  json_val->getInt("wwwWatchdogDelay");
-    }
-    if(json_val->has("callbackUrl")) {
-        _callbackUrl =  json_val->getString("callbackUrl");
-    }
-    if(json_val->has("callbackMethod")) {
-        _callbackMethod =  (Y_CALLBACKMETHOD_enum)json_val->getInt("callbackMethod");
-    }
-    if(json_val->has("callbackEncoding")) {
-        _callbackEncoding =  (Y_CALLBACKENCODING_enum)json_val->getInt("callbackEncoding");
-    }
-    if(json_val->has("callbackCredentials")) {
-        _callbackCredentials =  json_val->getString("callbackCredentials");
-    }
-    if(json_val->has("callbackInitialDelay")) {
-        _callbackInitialDelay =  json_val->getInt("callbackInitialDelay");
-    }
-    if(json_val->has("callbackSchedule")) {
-        _callbackSchedule =  json_val->getString("callbackSchedule");
-    }
-    if(json_val->has("callbackMinDelay")) {
-        _callbackMinDelay =  json_val->getInt("callbackMinDelay");
-    }
-    if(json_val->has("callbackMaxDelay")) {
-        _callbackMaxDelay =  json_val->getInt("callbackMaxDelay");
-    }
-    if(json_val->has("poeCurrent")) {
-        _poeCurrent =  json_val->getInt("poeCurrent");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current established working mode of the network interface.
- * Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal
- * on the network cable, or the selected wireless access point cannot be detected.
- * Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected.
- * For a wireless network, this shows that the requested SSID is present.
- * Level 2 (LINK_2) is reached when the hardware connection is established.
- * For a wired network connection, level 2 means that the cable is attached at both ends.
- * For a connection to a wireless access point, it shows that the security parameters
- * are properly configured. For an ad-hoc wireless connection, it means that there is
- * at least one other device connected on the ad-hoc network.
- * Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP.
- * Level 4 (DNS_4) is reached when the DNS server is reachable on the network.
- * Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the
- * current time from an NTP server.
- *
- * @return a value among Y_READINESS_DOWN, Y_READINESS_EXISTS, Y_READINESS_LINKED, Y_READINESS_LAN_OK
- * and Y_READINESS_WWW_OK corresponding to the current established working mode of the network interface
- *
- * On failure, throws an exception or returns Y_READINESS_INVALID.
- */
-Y_READINESS_enum YNetwork::get_readiness(void)
-{
-    Y_READINESS_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::READINESS_INVALID;
-                }
-            }
-        }
-        res = _readiness;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the MAC address of the network interface. The MAC address is also available on a sticker
- * on the module, in both numeric and barcode forms.
- *
- * @return a string corresponding to the MAC address of the network interface
- *
- * On failure, throws an exception or returns Y_MACADDRESS_INVALID.
- */
-string YNetwork::get_macAddress(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::MACADDRESS_INVALID;
-                }
-            }
-        }
-        res = _macAddress;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP address currently in use by the device. The address may have been configured
- * statically, or provided by a DHCP server.
- *
- * @return a string corresponding to the IP address currently in use by the device
- *
- * On failure, throws an exception or returns Y_IPADDRESS_INVALID.
- */
-string YNetwork::get_ipAddress(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::IPADDRESS_INVALID;
-                }
-            }
-        }
-        res = _ipAddress;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the subnet mask currently used by the device.
- *
- * @return a string corresponding to the subnet mask currently used by the device
- *
- * On failure, throws an exception or returns Y_SUBNETMASK_INVALID.
- */
-string YNetwork::get_subnetMask(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::SUBNETMASK_INVALID;
-                }
-            }
-        }
-        res = _subnetMask;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP address of the router on the device subnet (default gateway).
- *
- * @return a string corresponding to the IP address of the router on the device subnet (default gateway)
- *
- * On failure, throws an exception or returns Y_ROUTER_INVALID.
- */
-string YNetwork::get_router(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::ROUTER_INVALID;
-                }
-            }
-        }
-        res = _router;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP configuration of the network interface.
- *
- * If the network interface is setup to use a static IP address, the string starts with "STATIC:" and
- * is followed by three
- * parameters, separated by "/". The first is the device IP address, followed by the subnet mask
- * length, and finally the
- * router IP address (default gateway). For instance: "STATIC:192.168.1.14/16/192.168.1.1"
- *
- * If the network interface is configured to receive its IP from a DHCP server, the string start with
- * "DHCP:" and is followed by
- * three parameters separated by "/". The first is the fallback IP address, then the fallback subnet
- * mask length and finally the
- * fallback router IP address. These three parameters are used when no DHCP reply is received.
- *
- * @return a string corresponding to the IP configuration of the network interface
- *
- * On failure, throws an exception or returns Y_IPCONFIG_INVALID.
- */
-string YNetwork::get_ipConfig(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::IPCONFIG_INVALID;
-                }
-            }
-        }
-        res = _ipConfig;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YNetwork::set_ipConfig(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("ipConfig", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP address of the primary name server to be used by the module.
- *
- * @return a string corresponding to the IP address of the primary name server to be used by the module
- *
- * On failure, throws an exception or returns Y_PRIMARYDNS_INVALID.
- */
-string YNetwork::get_primaryDNS(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::PRIMARYDNS_INVALID;
-                }
-            }
-        }
-        res = _primaryDNS;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the IP address of the primary name server to be used by the module.
- * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param newval : a string corresponding to the IP address of the primary name server to be used by the module
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_primaryDNS(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("primaryDNS", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP address of the secondary name server to be used by the module.
- *
- * @return a string corresponding to the IP address of the secondary name server to be used by the module
- *
- * On failure, throws an exception or returns Y_SECONDARYDNS_INVALID.
- */
-string YNetwork::get_secondaryDNS(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::SECONDARYDNS_INVALID;
-                }
-            }
-        }
-        res = _secondaryDNS;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the IP address of the secondary name server to be used by the module.
- * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param newval : a string corresponding to the IP address of the secondary name server to be used by the module
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_secondaryDNS(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("secondaryDNS", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the IP address of the NTP server to be used by the device.
- *
- * @return a string corresponding to the IP address of the NTP server to be used by the device
- *
- * On failure, throws an exception or returns Y_NTPSERVER_INVALID.
- */
-string YNetwork::get_ntpServer(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::NTPSERVER_INVALID;
-                }
-            }
-        }
-        res = _ntpServer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the IP address of the NTP server to be used by the module.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param newval : a string corresponding to the IP address of the NTP server to be used by the module
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_ntpServer(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("ntpServer", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns a hash string if a password has been set for "user" user,
- * or an empty string otherwise.
- *
- * @return a string corresponding to a hash string if a password has been set for "user" user,
- *         or an empty string otherwise
- *
- * On failure, throws an exception or returns Y_USERPASSWORD_INVALID.
- */
-string YNetwork::get_userPassword(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::USERPASSWORD_INVALID;
-                }
-            }
-        }
-        res = _userPassword;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the password for the "user" user. This password becomes instantly required
- * to perform any use of the module. If the specified value is an
- * empty string, a password is not required anymore.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the password for the "user" user
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_userPassword(const string& newval)
-{
-    string rest_val;
-    int res;
-    if (newval.length() > YAPI_HASH_BUF_SIZE) {
-        _throw(YAPI_INVALID_ARGUMENT, "Password too long :" + newval);
-        return YAPI_INVALID_ARGUMENT;
-    }
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("userPassword", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns a hash string if a password has been set for user "admin",
- * or an empty string otherwise.
- *
- * @return a string corresponding to a hash string if a password has been set for user "admin",
- *         or an empty string otherwise
- *
- * On failure, throws an exception or returns Y_ADMINPASSWORD_INVALID.
- */
-string YNetwork::get_adminPassword(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::ADMINPASSWORD_INVALID;
-                }
-            }
-        }
-        res = _adminPassword;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the password for the "admin" user. This password becomes instantly required
- * to perform any change of the module state. If the specified value is an
- * empty string, a password is not required anymore.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the password for the "admin" user
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_adminPassword(const string& newval)
-{
-    string rest_val;
-    int res;
-    if (newval.length() > YAPI_HASH_BUF_SIZE) {
-        _throw(YAPI_INVALID_ARGUMENT, "Password too long :" + newval);
-        return YAPI_INVALID_ARGUMENT;
-    }
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("adminPassword", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the HTML page to serve for the URL "/"" of the hub.
- *
- * @return an integer corresponding to the HTML page to serve for the URL "/"" of the hub
- *
- * On failure, throws an exception or returns Y_HTTPPORT_INVALID.
- */
-int YNetwork::get_httpPort(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::HTTPPORT_INVALID;
-                }
-            }
-        }
-        res = _httpPort;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the default HTML page returned by the hub. If not value are set the hub return
- * "index.html" which is the web interface of the hub. It is possible to change this page
- * for file that has been uploaded on the hub.
- *
- * @param newval : an integer corresponding to the default HTML page returned by the hub
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_httpPort(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("httpPort", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the HTML page to serve for the URL "/"" of the hub.
- *
- * @return a string corresponding to the HTML page to serve for the URL "/"" of the hub
- *
- * On failure, throws an exception or returns Y_DEFAULTPAGE_INVALID.
- */
-string YNetwork::get_defaultPage(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::DEFAULTPAGE_INVALID;
-                }
-            }
-        }
-        res = _defaultPage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the default HTML page returned by the hub. If not value are set the hub return
- * "index.html" which is the web interface of the hub. It is possible to change this page
- * for file that has been uploaded on the hub.
- *
- * @param newval : a string corresponding to the default HTML page returned by the hub
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_defaultPage(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("defaultPage", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the activation state of the multicast announce protocols to allow easy
- * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
- *
- * @return either Y_DISCOVERABLE_FALSE or Y_DISCOVERABLE_TRUE, according to the activation state of
- * the multicast announce protocols to allow easy
- *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
- *
- * On failure, throws an exception or returns Y_DISCOVERABLE_INVALID.
- */
-Y_DISCOVERABLE_enum YNetwork::get_discoverable(void)
-{
-    Y_DISCOVERABLE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::DISCOVERABLE_INVALID;
-                }
-            }
-        }
-        res = _discoverable;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the activation state of the multicast announce protocols to allow easy
- * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
- *
- * @param newval : either Y_DISCOVERABLE_FALSE or Y_DISCOVERABLE_TRUE, according to the activation
- * state of the multicast announce protocols to allow easy
- *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_discoverable(Y_DISCOVERABLE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("discoverable", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the allowed downtime of the WWW link (in seconds) before triggering an automated
- * reboot to try to recover Internet connectivity. A zero value disables automated reboot
- * in case of Internet connectivity loss.
- *
- * @return an integer corresponding to the allowed downtime of the WWW link (in seconds) before
- * triggering an automated
- *         reboot to try to recover Internet connectivity
- *
- * On failure, throws an exception or returns Y_WWWWATCHDOGDELAY_INVALID.
- */
-int YNetwork::get_wwwWatchdogDelay(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::WWWWATCHDOGDELAY_INVALID;
-                }
-            }
-        }
-        res = _wwwWatchdogDelay;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the allowed downtime of the WWW link (in seconds) before triggering an automated
- * reboot to try to recover Internet connectivity. A zero value disables automated reboot
- * in case of Internet connectivity loss. The smallest valid non-zero timeout is
- * 90 seconds.
- *
- * @param newval : an integer corresponding to the allowed downtime of the WWW link (in seconds)
- * before triggering an automated
- *         reboot to try to recover Internet connectivity
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_wwwWatchdogDelay(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("wwwWatchdogDelay", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the callback URL to notify of significant state changes.
- *
- * @return a string corresponding to the callback URL to notify of significant state changes
- *
- * On failure, throws an exception or returns Y_CALLBACKURL_INVALID.
- */
-string YNetwork::get_callbackUrl(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKURL_INVALID;
-                }
-            }
-        }
-        res = _callbackUrl;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the callback URL to notify significant state changes. Remember to call the
- * saveToFlash() method of the module if the modification must be kept.
- *
- * @param newval : a string corresponding to the callback URL to notify significant state changes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackUrl(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("callbackUrl", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the HTTP method used to notify callbacks for significant state changes.
- *
- * @return a value among Y_CALLBACKMETHOD_POST, Y_CALLBACKMETHOD_GET and Y_CALLBACKMETHOD_PUT
- * corresponding to the HTTP method used to notify callbacks for significant state changes
- *
- * On failure, throws an exception or returns Y_CALLBACKMETHOD_INVALID.
- */
-Y_CALLBACKMETHOD_enum YNetwork::get_callbackMethod(void)
-{
-    Y_CALLBACKMETHOD_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKMETHOD_INVALID;
-                }
-            }
-        }
-        res = _callbackMethod;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the HTTP method used to notify callbacks for significant state changes.
- *
- * @param newval : a value among Y_CALLBACKMETHOD_POST, Y_CALLBACKMETHOD_GET and Y_CALLBACKMETHOD_PUT
- * corresponding to the HTTP method used to notify callbacks for significant state changes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackMethod(Y_CALLBACKMETHOD_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("callbackMethod", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the encoding standard to use for representing notification values.
- *
- * @return a value among Y_CALLBACKENCODING_FORM, Y_CALLBACKENCODING_JSON,
- * Y_CALLBACKENCODING_JSON_ARRAY, Y_CALLBACKENCODING_CSV, Y_CALLBACKENCODING_YOCTO_API,
- * Y_CALLBACKENCODING_JSON_NUM, Y_CALLBACKENCODING_EMONCMS, Y_CALLBACKENCODING_AZURE,
- * Y_CALLBACKENCODING_INFLUXDB, Y_CALLBACKENCODING_MQTT, Y_CALLBACKENCODING_YOCTO_API_JZON and
- * Y_CALLBACKENCODING_PRTG corresponding to the encoding standard to use for representing notification values
- *
- * On failure, throws an exception or returns Y_CALLBACKENCODING_INVALID.
- */
-Y_CALLBACKENCODING_enum YNetwork::get_callbackEncoding(void)
-{
-    Y_CALLBACKENCODING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKENCODING_INVALID;
-                }
-            }
-        }
-        res = _callbackEncoding;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the encoding standard to use for representing notification values.
- *
- * @param newval : a value among Y_CALLBACKENCODING_FORM, Y_CALLBACKENCODING_JSON,
- * Y_CALLBACKENCODING_JSON_ARRAY, Y_CALLBACKENCODING_CSV, Y_CALLBACKENCODING_YOCTO_API,
- * Y_CALLBACKENCODING_JSON_NUM, Y_CALLBACKENCODING_EMONCMS, Y_CALLBACKENCODING_AZURE,
- * Y_CALLBACKENCODING_INFLUXDB, Y_CALLBACKENCODING_MQTT, Y_CALLBACKENCODING_YOCTO_API_JZON and
- * Y_CALLBACKENCODING_PRTG corresponding to the encoding standard to use for representing notification values
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackEncoding(Y_CALLBACKENCODING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("callbackEncoding", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns a hashed version of the notification callback credentials if set,
- * or an empty string otherwise.
- *
- * @return a string corresponding to a hashed version of the notification callback credentials if set,
- *         or an empty string otherwise
- *
- * On failure, throws an exception or returns Y_CALLBACKCREDENTIALS_INVALID.
- */
-string YNetwork::get_callbackCredentials(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKCREDENTIALS_INVALID;
-                }
-            }
-        }
-        res = _callbackCredentials;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the credentials required to connect to the callback address. The credentials
- * must be provided as returned by function get_callbackCredentials,
- * in the form username:hash. The method used to compute the hash varies according
- * to the the authentication scheme implemented by the callback, For Basic authentication,
- * the hash is the MD5 of the string username:password. For Digest authentication,
- * the hash is the MD5 of the string username:realm:password. For a simpler
- * way to configure callback credentials, use function callbackLogin instead.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the credentials required to connect to the callback address
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackCredentials(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("callbackCredentials", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Connects to the notification callback and saves the credentials required to
- * log into it. The password is not stored into the module, only a hashed
- * copy of the credentials are saved. Remember to call the
- * saveToFlash() method of the module if the modification must be kept.
- *
- * @param username : username required to log to the callback
- * @param password : password required to log to the callback
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::callbackLogin(string username,string password)
-{
-    string rest_val;
-    rest_val = string(username)+string(":")+string(password);
-    return _setAttr("callbackCredentials", rest_val);
-}
-
-/**
- * Returns the initial waiting time before first callback notifications, in seconds.
- *
- * @return an integer corresponding to the initial waiting time before first callback notifications, in seconds
- *
- * On failure, throws an exception or returns Y_CALLBACKINITIALDELAY_INVALID.
- */
-int YNetwork::get_callbackInitialDelay(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKINITIALDELAY_INVALID;
-                }
-            }
-        }
-        res = _callbackInitialDelay;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the initial waiting time before first callback notifications, in seconds.
- *
- * @param newval : an integer corresponding to the initial waiting time before first callback
- * notifications, in seconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackInitialDelay(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("callbackInitialDelay", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the HTTP callback schedule strategy, as a text string.
- *
- * @return a string corresponding to the HTTP callback schedule strategy, as a text string
- *
- * On failure, throws an exception or returns Y_CALLBACKSCHEDULE_INVALID.
- */
-string YNetwork::get_callbackSchedule(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKSCHEDULE_INVALID;
-                }
-            }
-        }
-        res = _callbackSchedule;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the HTTP callback schedule strategy, as a text string.
- *
- * @param newval : a string corresponding to the HTTP callback schedule strategy, as a text string
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackSchedule(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("callbackSchedule", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minimum waiting time between two HTTP callbacks, in seconds.
- *
- * @return an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
- *
- * On failure, throws an exception or returns Y_CALLBACKMINDELAY_INVALID.
- */
-int YNetwork::get_callbackMinDelay(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKMINDELAY_INVALID;
-                }
-            }
-        }
-        res = _callbackMinDelay;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minimum waiting time between two HTTP callbacks, in seconds.
- *
- * @param newval : an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackMinDelay(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("callbackMinDelay", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the waiting time between two HTTP callbacks when there is nothing new.
- *
- * @return an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new
- *
- * On failure, throws an exception or returns Y_CALLBACKMAXDELAY_INVALID.
- */
-int YNetwork::get_callbackMaxDelay(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::CALLBACKMAXDELAY_INVALID;
-                }
-            }
-        }
-        res = _callbackMaxDelay;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the waiting time between two HTTP callbacks when there is nothing new.
- *
- * @param newval : an integer corresponding to the waiting time between two HTTP callbacks when there
- * is nothing new
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_callbackMaxDelay(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("callbackMaxDelay", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.
- * The current consumption is measured after converting PoE source to 5 Volt, and should
- * never exceed 1800 mA.
- *
- * @return an integer corresponding to the current consumed by the module from Power-over-Ethernet
- * (PoE), in milliamps
- *
- * On failure, throws an exception or returns Y_POECURRENT_INVALID.
- */
-int YNetwork::get_poeCurrent(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YNetwork::POECURRENT_INVALID;
-                }
-            }
-        }
-        res = _poeCurrent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a network interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the network interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YNetwork.isOnline() to test if the network interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a network interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the network interface
- *
- * @return a YNetwork object allowing you to drive the network interface.
- */
-YNetwork* YNetwork::FindNetwork(string func)
-{
-    YNetwork* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YNetwork*) YFunction::_FindFromCache("Network", func);
-        if (obj == NULL) {
-            obj = new YNetwork(func);
-            YFunction::_AddToCache("Network", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YNetwork::registerValueCallback(YNetworkValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackNetwork = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YNetwork::_invokeValueCallback(string value)
-{
-    if (_valueCallbackNetwork != NULL) {
-        _valueCallbackNetwork(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Changes the configuration of the network interface to enable the use of an
- * IP address received from a DHCP server. Until an address is received from a DHCP
- * server, the module uses the IP parameters specified to this function.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param fallbackIpAddr : fallback IP address, to be used when no DHCP reply is received
- * @param fallbackSubnetMaskLen : fallback subnet mask length when no DHCP reply is received, as an
- *         integer (e.g. 24 means 255.255.255.0)
- * @param fallbackRouter : fallback router IP address, to be used when no DHCP reply is received
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::useDHCP(string fallbackIpAddr,int fallbackSubnetMaskLen,string fallbackRouter)
-{
-    return this->set_ipConfig(YapiWrapper::ysprintf("DHCP:%s/%d/%s", fallbackIpAddr.c_str(), fallbackSubnetMaskLen,fallbackRouter.c_str()));
-}
-
-/**
- * Changes the configuration of the network interface to enable the use of an
- * IP address received from a DHCP server. Until an address is received from a DHCP
- * server, the module uses an IP of the network 169.254.0.0/16 (APIPA).
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::useDHCPauto(void)
-{
-    return this->set_ipConfig("DHCP:");
-}
-
-/**
- * Changes the configuration of the network interface to use a static IP address.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param ipAddress : device IP address
- * @param subnetMaskLen : subnet mask length, as an integer (e.g. 24 means 255.255.255.0)
- * @param router : router IP address (default gateway)
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::useStaticIP(string ipAddress,int subnetMaskLen,string router)
-{
-    return this->set_ipConfig(YapiWrapper::ysprintf("STATIC:%s/%d/%s", ipAddress.c_str(), subnetMaskLen,router.c_str()));
-}
-
-/**
- * Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the
- * module to the target host. This method returns a string with the result of the
- * 4 ICMP ECHO_REQUEST requests.
- *
- * @param host : the hostname or the IP address of the target
- *
- * @return a string with the result of the ping.
- */
-string YNetwork::ping(string host)
-{
-    string content;
-
-    content = this->_download(YapiWrapper::ysprintf("ping.txt?host=%s",host.c_str()));
-    return content;
-}
-
-/**
- * Trigger an HTTP callback quickly. This function can even be called within
- * an HTTP callback, in which case the next callback will be triggered 5 seconds
- * after the end of the current callback, regardless if the minimum time between
- * callbacks configured in the device.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::triggerCallback(void)
-{
-    return this->set_callbackMethod(this->get_callbackMethod());
-}
-
-/**
- * Setup periodic HTTP callbacks (simplified function).
- *
- * @param interval : a string representing the callback periodicity, expressed in
- *         seconds, minutes or hours, eg. "60s", "5m", "1h", "48h".
- * @param offset : an integer representing the time offset relative to the period
- *         when the callback should occur. For instance, if the periodicity is
- *         24h, an offset of 7 will make the callback occur each day at 7AM.
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YNetwork::set_periodicCallbackSchedule(string interval,int offset)
-{
-    return this->set_callbackSchedule(YapiWrapper::ysprintf("every %s+%d",interval.c_str(),offset));
-}
-
-YNetwork *YNetwork::nextNetwork(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YNetwork::FindNetwork(hwid);
-}
-
-YNetwork* YNetwork::FirstNetwork(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Network", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YNetwork::FindNetwork(serial+"."+funcId);
-}
-
-//--- (end of YNetwork implementation)
-
-//--- (YNetwork functions)
-//--- (end of YNetwork functions)
--- a/Sources/cpplib/yocto_network.h
+++ /dev/null
@@ -1,1052 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_network.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindNetwork(), the high-level API for Network functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_NETWORK_H
-#define YOCTO_NETWORK_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YNetwork return codes)
-//--- (end of YNetwork return codes)
-//--- (YNetwork yapiwrapper)
-//--- (end of YNetwork yapiwrapper)
-//--- (YNetwork definitions)
-class YNetwork; // forward declaration
-
-typedef void (*YNetworkValueCallback)(YNetwork *func, const string& functionValue);
-#ifndef _Y_READINESS_ENUM
-#define _Y_READINESS_ENUM
-typedef enum {
-    Y_READINESS_DOWN = 0,
-    Y_READINESS_EXISTS = 1,
-    Y_READINESS_LINKED = 2,
-    Y_READINESS_LAN_OK = 3,
-    Y_READINESS_WWW_OK = 4,
-    Y_READINESS_INVALID = -1,
-} Y_READINESS_enum;
-#endif
-#ifndef _Y_DISCOVERABLE_ENUM
-#define _Y_DISCOVERABLE_ENUM
-typedef enum {
-    Y_DISCOVERABLE_FALSE = 0,
-    Y_DISCOVERABLE_TRUE = 1,
-    Y_DISCOVERABLE_INVALID = -1,
-} Y_DISCOVERABLE_enum;
-#endif
-#ifndef _Y_CALLBACKMETHOD_ENUM
-#define _Y_CALLBACKMETHOD_ENUM
-typedef enum {
-    Y_CALLBACKMETHOD_POST = 0,
-    Y_CALLBACKMETHOD_GET = 1,
-    Y_CALLBACKMETHOD_PUT = 2,
-    Y_CALLBACKMETHOD_INVALID = -1,
-} Y_CALLBACKMETHOD_enum;
-#endif
-#ifndef _Y_CALLBACKENCODING_ENUM
-#define _Y_CALLBACKENCODING_ENUM
-typedef enum {
-    Y_CALLBACKENCODING_FORM = 0,
-    Y_CALLBACKENCODING_JSON = 1,
-    Y_CALLBACKENCODING_JSON_ARRAY = 2,
-    Y_CALLBACKENCODING_CSV = 3,
-    Y_CALLBACKENCODING_YOCTO_API = 4,
-    Y_CALLBACKENCODING_JSON_NUM = 5,
-    Y_CALLBACKENCODING_EMONCMS = 6,
-    Y_CALLBACKENCODING_AZURE = 7,
-    Y_CALLBACKENCODING_INFLUXDB = 8,
-    Y_CALLBACKENCODING_MQTT = 9,
-    Y_CALLBACKENCODING_YOCTO_API_JZON = 10,
-    Y_CALLBACKENCODING_PRTG = 11,
-    Y_CALLBACKENCODING_INVALID = -1,
-} Y_CALLBACKENCODING_enum;
-#endif
-#define Y_MACADDRESS_INVALID            (YAPI_INVALID_STRING)
-#define Y_IPADDRESS_INVALID             (YAPI_INVALID_STRING)
-#define Y_SUBNETMASK_INVALID            (YAPI_INVALID_STRING)
-#define Y_ROUTER_INVALID                (YAPI_INVALID_STRING)
-#define Y_IPCONFIG_INVALID              (YAPI_INVALID_STRING)
-#define Y_PRIMARYDNS_INVALID            (YAPI_INVALID_STRING)
-#define Y_SECONDARYDNS_INVALID          (YAPI_INVALID_STRING)
-#define Y_NTPSERVER_INVALID             (YAPI_INVALID_STRING)
-#define Y_USERPASSWORD_INVALID          (YAPI_INVALID_STRING)
-#define Y_ADMINPASSWORD_INVALID         (YAPI_INVALID_STRING)
-#define Y_HTTPPORT_INVALID              (YAPI_INVALID_UINT)
-#define Y_DEFAULTPAGE_INVALID           (YAPI_INVALID_STRING)
-#define Y_WWWWATCHDOGDELAY_INVALID      (YAPI_INVALID_UINT)
-#define Y_CALLBACKURL_INVALID           (YAPI_INVALID_STRING)
-#define Y_CALLBACKCREDENTIALS_INVALID   (YAPI_INVALID_STRING)
-#define Y_CALLBACKINITIALDELAY_INVALID  (YAPI_INVALID_UINT)
-#define Y_CALLBACKSCHEDULE_INVALID      (YAPI_INVALID_STRING)
-#define Y_CALLBACKMINDELAY_INVALID      (YAPI_INVALID_UINT)
-#define Y_CALLBACKMAXDELAY_INVALID      (YAPI_INVALID_UINT)
-#define Y_POECURRENT_INVALID            (YAPI_INVALID_UINT)
-//--- (end of YNetwork definitions)
-
-//--- (YNetwork declaration)
-/**
- * YNetwork Class: Network function interface
- *
- * YNetwork objects provide access to TCP/IP parameters of Yoctopuce
- * modules that include a built-in network interface.
- */
-class YOCTO_CLASS_EXPORT YNetwork: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YNetwork declaration)
-protected:
-    //--- (YNetwork attributes)
-    // Attributes (function value cache)
-    Y_READINESS_enum _readiness;
-    string          _macAddress;
-    string          _ipAddress;
-    string          _subnetMask;
-    string          _router;
-    string          _ipConfig;
-    string          _primaryDNS;
-    string          _secondaryDNS;
-    string          _ntpServer;
-    string          _userPassword;
-    string          _adminPassword;
-    int             _httpPort;
-    string          _defaultPage;
-    Y_DISCOVERABLE_enum _discoverable;
-    int             _wwwWatchdogDelay;
-    string          _callbackUrl;
-    Y_CALLBACKMETHOD_enum _callbackMethod;
-    Y_CALLBACKENCODING_enum _callbackEncoding;
-    string          _callbackCredentials;
-    int             _callbackInitialDelay;
-    string          _callbackSchedule;
-    int             _callbackMinDelay;
-    int             _callbackMaxDelay;
-    int             _poeCurrent;
-    YNetworkValueCallback _valueCallbackNetwork;
-
-    friend YNetwork *yFindNetwork(const string& func);
-    friend YNetwork *yFirstNetwork(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindNetwork factory function to instantiate
-    YNetwork(const string& func);
-    //--- (end of YNetwork attributes)
-
-public:
-    virtual ~YNetwork();
-    //--- (YNetwork accessors declaration)
-
-    static const Y_READINESS_enum READINESS_DOWN = Y_READINESS_DOWN;
-    static const Y_READINESS_enum READINESS_EXISTS = Y_READINESS_EXISTS;
-    static const Y_READINESS_enum READINESS_LINKED = Y_READINESS_LINKED;
-    static const Y_READINESS_enum READINESS_LAN_OK = Y_READINESS_LAN_OK;
-    static const Y_READINESS_enum READINESS_WWW_OK = Y_READINESS_WWW_OK;
-    static const Y_READINESS_enum READINESS_INVALID = Y_READINESS_INVALID;
-    static const string MACADDRESS_INVALID;
-    static const string IPADDRESS_INVALID;
-    static const string SUBNETMASK_INVALID;
-    static const string ROUTER_INVALID;
-    static const string IPCONFIG_INVALID;
-    static const string PRIMARYDNS_INVALID;
-    static const string SECONDARYDNS_INVALID;
-    static const string NTPSERVER_INVALID;
-    static const string USERPASSWORD_INVALID;
-    static const string ADMINPASSWORD_INVALID;
-    static const int HTTPPORT_INVALID = YAPI_INVALID_UINT;
-    static const string DEFAULTPAGE_INVALID;
-    static const Y_DISCOVERABLE_enum DISCOVERABLE_FALSE = Y_DISCOVERABLE_FALSE;
-    static const Y_DISCOVERABLE_enum DISCOVERABLE_TRUE = Y_DISCOVERABLE_TRUE;
-    static const Y_DISCOVERABLE_enum DISCOVERABLE_INVALID = Y_DISCOVERABLE_INVALID;
-    static const int WWWWATCHDOGDELAY_INVALID = YAPI_INVALID_UINT;
-    static const string CALLBACKURL_INVALID;
-    static const Y_CALLBACKMETHOD_enum CALLBACKMETHOD_POST = Y_CALLBACKMETHOD_POST;
-    static const Y_CALLBACKMETHOD_enum CALLBACKMETHOD_GET = Y_CALLBACKMETHOD_GET;
-    static const Y_CALLBACKMETHOD_enum CALLBACKMETHOD_PUT = Y_CALLBACKMETHOD_PUT;
-    static const Y_CALLBACKMETHOD_enum CALLBACKMETHOD_INVALID = Y_CALLBACKMETHOD_INVALID;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_FORM = Y_CALLBACKENCODING_FORM;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_JSON = Y_CALLBACKENCODING_JSON;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_JSON_ARRAY = Y_CALLBACKENCODING_JSON_ARRAY;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_CSV = Y_CALLBACKENCODING_CSV;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_YOCTO_API = Y_CALLBACKENCODING_YOCTO_API;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_JSON_NUM = Y_CALLBACKENCODING_JSON_NUM;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_EMONCMS = Y_CALLBACKENCODING_EMONCMS;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_AZURE = Y_CALLBACKENCODING_AZURE;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_INFLUXDB = Y_CALLBACKENCODING_INFLUXDB;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_MQTT = Y_CALLBACKENCODING_MQTT;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_YOCTO_API_JZON = Y_CALLBACKENCODING_YOCTO_API_JZON;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_PRTG = Y_CALLBACKENCODING_PRTG;
-    static const Y_CALLBACKENCODING_enum CALLBACKENCODING_INVALID = Y_CALLBACKENCODING_INVALID;
-    static const string CALLBACKCREDENTIALS_INVALID;
-    static const int CALLBACKINITIALDELAY_INVALID = YAPI_INVALID_UINT;
-    static const string CALLBACKSCHEDULE_INVALID;
-    static const int CALLBACKMINDELAY_INVALID = YAPI_INVALID_UINT;
-    static const int CALLBACKMAXDELAY_INVALID = YAPI_INVALID_UINT;
-    static const int POECURRENT_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the current established working mode of the network interface.
-     * Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal
-     * on the network cable, or the selected wireless access point cannot be detected.
-     * Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected.
-     * For a wireless network, this shows that the requested SSID is present.
-     * Level 2 (LINK_2) is reached when the hardware connection is established.
-     * For a wired network connection, level 2 means that the cable is attached at both ends.
-     * For a connection to a wireless access point, it shows that the security parameters
-     * are properly configured. For an ad-hoc wireless connection, it means that there is
-     * at least one other device connected on the ad-hoc network.
-     * Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP.
-     * Level 4 (DNS_4) is reached when the DNS server is reachable on the network.
-     * Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the
-     * current time from an NTP server.
-     *
-     * @return a value among Y_READINESS_DOWN, Y_READINESS_EXISTS, Y_READINESS_LINKED, Y_READINESS_LAN_OK
-     * and Y_READINESS_WWW_OK corresponding to the current established working mode of the network interface
-     *
-     * On failure, throws an exception or returns Y_READINESS_INVALID.
-     */
-    Y_READINESS_enum    get_readiness(void);
-
-    inline Y_READINESS_enum readiness(void)
-    { return this->get_readiness(); }
-
-    /**
-     * Returns the MAC address of the network interface. The MAC address is also available on a sticker
-     * on the module, in both numeric and barcode forms.
-     *
-     * @return a string corresponding to the MAC address of the network interface
-     *
-     * On failure, throws an exception or returns Y_MACADDRESS_INVALID.
-     */
-    string              get_macAddress(void);
-
-    inline string       macAddress(void)
-    { return this->get_macAddress(); }
-
-    /**
-     * Returns the IP address currently in use by the device. The address may have been configured
-     * statically, or provided by a DHCP server.
-     *
-     * @return a string corresponding to the IP address currently in use by the device
-     *
-     * On failure, throws an exception or returns Y_IPADDRESS_INVALID.
-     */
-    string              get_ipAddress(void);
-
-    inline string       ipAddress(void)
-    { return this->get_ipAddress(); }
-
-    /**
-     * Returns the subnet mask currently used by the device.
-     *
-     * @return a string corresponding to the subnet mask currently used by the device
-     *
-     * On failure, throws an exception or returns Y_SUBNETMASK_INVALID.
-     */
-    string              get_subnetMask(void);
-
-    inline string       subnetMask(void)
-    { return this->get_subnetMask(); }
-
-    /**
-     * Returns the IP address of the router on the device subnet (default gateway).
-     *
-     * @return a string corresponding to the IP address of the router on the device subnet (default gateway)
-     *
-     * On failure, throws an exception or returns Y_ROUTER_INVALID.
-     */
-    string              get_router(void);
-
-    inline string       router(void)
-    { return this->get_router(); }
-
-    /**
-     * Returns the IP configuration of the network interface.
-     *
-     * If the network interface is setup to use a static IP address, the string starts with "STATIC:" and
-     * is followed by three
-     * parameters, separated by "/". The first is the device IP address, followed by the subnet mask
-     * length, and finally the
-     * router IP address (default gateway). For instance: "STATIC:192.168.1.14/16/192.168.1.1"
-     *
-     * If the network interface is configured to receive its IP from a DHCP server, the string start with
-     * "DHCP:" and is followed by
-     * three parameters separated by "/". The first is the fallback IP address, then the fallback subnet
-     * mask length and finally the
-     * fallback router IP address. These three parameters are used when no DHCP reply is received.
-     *
-     * @return a string corresponding to the IP configuration of the network interface
-     *
-     * On failure, throws an exception or returns Y_IPCONFIG_INVALID.
-     */
-    string              get_ipConfig(void);
-
-    inline string       ipConfig(void)
-    { return this->get_ipConfig(); }
-
-    int             set_ipConfig(const string& newval);
-    inline int      setIpConfig(const string& newval)
-    { return this->set_ipConfig(newval); }
-
-    /**
-     * Returns the IP address of the primary name server to be used by the module.
-     *
-     * @return a string corresponding to the IP address of the primary name server to be used by the module
-     *
-     * On failure, throws an exception or returns Y_PRIMARYDNS_INVALID.
-     */
-    string              get_primaryDNS(void);
-
-    inline string       primaryDNS(void)
-    { return this->get_primaryDNS(); }
-
-    /**
-     * Changes the IP address of the primary name server to be used by the module.
-     * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param newval : a string corresponding to the IP address of the primary name server to be used by the module
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_primaryDNS(const string& newval);
-    inline int      setPrimaryDNS(const string& newval)
-    { return this->set_primaryDNS(newval); }
-
-    /**
-     * Returns the IP address of the secondary name server to be used by the module.
-     *
-     * @return a string corresponding to the IP address of the secondary name server to be used by the module
-     *
-     * On failure, throws an exception or returns Y_SECONDARYDNS_INVALID.
-     */
-    string              get_secondaryDNS(void);
-
-    inline string       secondaryDNS(void)
-    { return this->get_secondaryDNS(); }
-
-    /**
-     * Changes the IP address of the secondary name server to be used by the module.
-     * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param newval : a string corresponding to the IP address of the secondary name server to be used by the module
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_secondaryDNS(const string& newval);
-    inline int      setSecondaryDNS(const string& newval)
-    { return this->set_secondaryDNS(newval); }
-
-    /**
-     * Returns the IP address of the NTP server to be used by the device.
-     *
-     * @return a string corresponding to the IP address of the NTP server to be used by the device
-     *
-     * On failure, throws an exception or returns Y_NTPSERVER_INVALID.
-     */
-    string              get_ntpServer(void);
-
-    inline string       ntpServer(void)
-    { return this->get_ntpServer(); }
-
-    /**
-     * Changes the IP address of the NTP server to be used by the module.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param newval : a string corresponding to the IP address of the NTP server to be used by the module
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_ntpServer(const string& newval);
-    inline int      setNtpServer(const string& newval)
-    { return this->set_ntpServer(newval); }
-
-    /**
-     * Returns a hash string if a password has been set for "user" user,
-     * or an empty string otherwise.
-     *
-     * @return a string corresponding to a hash string if a password has been set for "user" user,
-     *         or an empty string otherwise
-     *
-     * On failure, throws an exception or returns Y_USERPASSWORD_INVALID.
-     */
-    string              get_userPassword(void);
-
-    inline string       userPassword(void)
-    { return this->get_userPassword(); }
-
-    /**
-     * Changes the password for the "user" user. This password becomes instantly required
-     * to perform any use of the module. If the specified value is an
-     * empty string, a password is not required anymore.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the password for the "user" user
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_userPassword(const string& newval);
-    inline int      setUserPassword(const string& newval)
-    { return this->set_userPassword(newval); }
-
-    /**
-     * Returns a hash string if a password has been set for user "admin",
-     * or an empty string otherwise.
-     *
-     * @return a string corresponding to a hash string if a password has been set for user "admin",
-     *         or an empty string otherwise
-     *
-     * On failure, throws an exception or returns Y_ADMINPASSWORD_INVALID.
-     */
-    string              get_adminPassword(void);
-
-    inline string       adminPassword(void)
-    { return this->get_adminPassword(); }
-
-    /**
-     * Changes the password for the "admin" user. This password becomes instantly required
-     * to perform any change of the module state. If the specified value is an
-     * empty string, a password is not required anymore.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the password for the "admin" user
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_adminPassword(const string& newval);
-    inline int      setAdminPassword(const string& newval)
-    { return this->set_adminPassword(newval); }
-
-    /**
-     * Returns the HTML page to serve for the URL "/"" of the hub.
-     *
-     * @return an integer corresponding to the HTML page to serve for the URL "/"" of the hub
-     *
-     * On failure, throws an exception or returns Y_HTTPPORT_INVALID.
-     */
-    int                 get_httpPort(void);
-
-    inline int          httpPort(void)
-    { return this->get_httpPort(); }
-
-    /**
-     * Changes the default HTML page returned by the hub. If not value are set the hub return
-     * "index.html" which is the web interface of the hub. It is possible to change this page
-     * for file that has been uploaded on the hub.
-     *
-     * @param newval : an integer corresponding to the default HTML page returned by the hub
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_httpPort(int newval);
-    inline int      setHttpPort(int newval)
-    { return this->set_httpPort(newval); }
-
-    /**
-     * Returns the HTML page to serve for the URL "/"" of the hub.
-     *
-     * @return a string corresponding to the HTML page to serve for the URL "/"" of the hub
-     *
-     * On failure, throws an exception or returns Y_DEFAULTPAGE_INVALID.
-     */
-    string              get_defaultPage(void);
-
-    inline string       defaultPage(void)
-    { return this->get_defaultPage(); }
-
-    /**
-     * Changes the default HTML page returned by the hub. If not value are set the hub return
-     * "index.html" which is the web interface of the hub. It is possible to change this page
-     * for file that has been uploaded on the hub.
-     *
-     * @param newval : a string corresponding to the default HTML page returned by the hub
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_defaultPage(const string& newval);
-    inline int      setDefaultPage(const string& newval)
-    { return this->set_defaultPage(newval); }
-
-    /**
-     * Returns the activation state of the multicast announce protocols to allow easy
-     * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
-     *
-     * @return either Y_DISCOVERABLE_FALSE or Y_DISCOVERABLE_TRUE, according to the activation state of
-     * the multicast announce protocols to allow easy
-     *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
-     *
-     * On failure, throws an exception or returns Y_DISCOVERABLE_INVALID.
-     */
-    Y_DISCOVERABLE_enum get_discoverable(void);
-
-    inline Y_DISCOVERABLE_enum discoverable(void)
-    { return this->get_discoverable(); }
-
-    /**
-     * Changes the activation state of the multicast announce protocols to allow easy
-     * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
-     *
-     * @param newval : either Y_DISCOVERABLE_FALSE or Y_DISCOVERABLE_TRUE, according to the activation
-     * state of the multicast announce protocols to allow easy
-     *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_discoverable(Y_DISCOVERABLE_enum newval);
-    inline int      setDiscoverable(Y_DISCOVERABLE_enum newval)
-    { return this->set_discoverable(newval); }
-
-    /**
-     * Returns the allowed downtime of the WWW link (in seconds) before triggering an automated
-     * reboot to try to recover Internet connectivity. A zero value disables automated reboot
-     * in case of Internet connectivity loss.
-     *
-     * @return an integer corresponding to the allowed downtime of the WWW link (in seconds) before
-     * triggering an automated
-     *         reboot to try to recover Internet connectivity
-     *
-     * On failure, throws an exception or returns Y_WWWWATCHDOGDELAY_INVALID.
-     */
-    int                 get_wwwWatchdogDelay(void);
-
-    inline int          wwwWatchdogDelay(void)
-    { return this->get_wwwWatchdogDelay(); }
-
-    /**
-     * Changes the allowed downtime of the WWW link (in seconds) before triggering an automated
-     * reboot to try to recover Internet connectivity. A zero value disables automated reboot
-     * in case of Internet connectivity loss. The smallest valid non-zero timeout is
-     * 90 seconds.
-     *
-     * @param newval : an integer corresponding to the allowed downtime of the WWW link (in seconds)
-     * before triggering an automated
-     *         reboot to try to recover Internet connectivity
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_wwwWatchdogDelay(int newval);
-    inline int      setWwwWatchdogDelay(int newval)
-    { return this->set_wwwWatchdogDelay(newval); }
-
-    /**
-     * Returns the callback URL to notify of significant state changes.
-     *
-     * @return a string corresponding to the callback URL to notify of significant state changes
-     *
-     * On failure, throws an exception or returns Y_CALLBACKURL_INVALID.
-     */
-    string              get_callbackUrl(void);
-
-    inline string       callbackUrl(void)
-    { return this->get_callbackUrl(); }
-
-    /**
-     * Changes the callback URL to notify significant state changes. Remember to call the
-     * saveToFlash() method of the module if the modification must be kept.
-     *
-     * @param newval : a string corresponding to the callback URL to notify significant state changes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackUrl(const string& newval);
-    inline int      setCallbackUrl(const string& newval)
-    { return this->set_callbackUrl(newval); }
-
-    /**
-     * Returns the HTTP method used to notify callbacks for significant state changes.
-     *
-     * @return a value among Y_CALLBACKMETHOD_POST, Y_CALLBACKMETHOD_GET and Y_CALLBACKMETHOD_PUT
-     * corresponding to the HTTP method used to notify callbacks for significant state changes
-     *
-     * On failure, throws an exception or returns Y_CALLBACKMETHOD_INVALID.
-     */
-    Y_CALLBACKMETHOD_enum get_callbackMethod(void);
-
-    inline Y_CALLBACKMETHOD_enum callbackMethod(void)
-    { return this->get_callbackMethod(); }
-
-    /**
-     * Changes the HTTP method used to notify callbacks for significant state changes.
-     *
-     * @param newval : a value among Y_CALLBACKMETHOD_POST, Y_CALLBACKMETHOD_GET and Y_CALLBACKMETHOD_PUT
-     * corresponding to the HTTP method used to notify callbacks for significant state changes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackMethod(Y_CALLBACKMETHOD_enum newval);
-    inline int      setCallbackMethod(Y_CALLBACKMETHOD_enum newval)
-    { return this->set_callbackMethod(newval); }
-
-    /**
-     * Returns the encoding standard to use for representing notification values.
-     *
-     * @return a value among Y_CALLBACKENCODING_FORM, Y_CALLBACKENCODING_JSON,
-     * Y_CALLBACKENCODING_JSON_ARRAY, Y_CALLBACKENCODING_CSV, Y_CALLBACKENCODING_YOCTO_API,
-     * Y_CALLBACKENCODING_JSON_NUM, Y_CALLBACKENCODING_EMONCMS, Y_CALLBACKENCODING_AZURE,
-     * Y_CALLBACKENCODING_INFLUXDB, Y_CALLBACKENCODING_MQTT, Y_CALLBACKENCODING_YOCTO_API_JZON and
-     * Y_CALLBACKENCODING_PRTG corresponding to the encoding standard to use for representing notification values
-     *
-     * On failure, throws an exception or returns Y_CALLBACKENCODING_INVALID.
-     */
-    Y_CALLBACKENCODING_enum get_callbackEncoding(void);
-
-    inline Y_CALLBACKENCODING_enum callbackEncoding(void)
-    { return this->get_callbackEncoding(); }
-
-    /**
-     * Changes the encoding standard to use for representing notification values.
-     *
-     * @param newval : a value among Y_CALLBACKENCODING_FORM, Y_CALLBACKENCODING_JSON,
-     * Y_CALLBACKENCODING_JSON_ARRAY, Y_CALLBACKENCODING_CSV, Y_CALLBACKENCODING_YOCTO_API,
-     * Y_CALLBACKENCODING_JSON_NUM, Y_CALLBACKENCODING_EMONCMS, Y_CALLBACKENCODING_AZURE,
-     * Y_CALLBACKENCODING_INFLUXDB, Y_CALLBACKENCODING_MQTT, Y_CALLBACKENCODING_YOCTO_API_JZON and
-     * Y_CALLBACKENCODING_PRTG corresponding to the encoding standard to use for representing notification values
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackEncoding(Y_CALLBACKENCODING_enum newval);
-    inline int      setCallbackEncoding(Y_CALLBACKENCODING_enum newval)
-    { return this->set_callbackEncoding(newval); }
-
-    /**
-     * Returns a hashed version of the notification callback credentials if set,
-     * or an empty string otherwise.
-     *
-     * @return a string corresponding to a hashed version of the notification callback credentials if set,
-     *         or an empty string otherwise
-     *
-     * On failure, throws an exception or returns Y_CALLBACKCREDENTIALS_INVALID.
-     */
-    string              get_callbackCredentials(void);
-
-    inline string       callbackCredentials(void)
-    { return this->get_callbackCredentials(); }
-
-    /**
-     * Changes the credentials required to connect to the callback address. The credentials
-     * must be provided as returned by function get_callbackCredentials,
-     * in the form username:hash. The method used to compute the hash varies according
-     * to the the authentication scheme implemented by the callback, For Basic authentication,
-     * the hash is the MD5 of the string username:password. For Digest authentication,
-     * the hash is the MD5 of the string username:realm:password. For a simpler
-     * way to configure callback credentials, use function callbackLogin instead.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the credentials required to connect to the callback address
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackCredentials(const string& newval);
-    inline int      setCallbackCredentials(const string& newval)
-    { return this->set_callbackCredentials(newval); }
-
-    /**
-     * Connects to the notification callback and saves the credentials required to
-     * log into it. The password is not stored into the module, only a hashed
-     * copy of the credentials are saved. Remember to call the
-     * saveToFlash() method of the module if the modification must be kept.
-     *
-     * @param username : username required to log to the callback
-     * @param password : password required to log to the callback
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             callbackLogin(string username,string password);
-
-    /**
-     * Returns the initial waiting time before first callback notifications, in seconds.
-     *
-     * @return an integer corresponding to the initial waiting time before first callback notifications, in seconds
-     *
-     * On failure, throws an exception or returns Y_CALLBACKINITIALDELAY_INVALID.
-     */
-    int                 get_callbackInitialDelay(void);
-
-    inline int          callbackInitialDelay(void)
-    { return this->get_callbackInitialDelay(); }
-
-    /**
-     * Changes the initial waiting time before first callback notifications, in seconds.
-     *
-     * @param newval : an integer corresponding to the initial waiting time before first callback
-     * notifications, in seconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackInitialDelay(int newval);
-    inline int      setCallbackInitialDelay(int newval)
-    { return this->set_callbackInitialDelay(newval); }
-
-    /**
-     * Returns the HTTP callback schedule strategy, as a text string.
-     *
-     * @return a string corresponding to the HTTP callback schedule strategy, as a text string
-     *
-     * On failure, throws an exception or returns Y_CALLBACKSCHEDULE_INVALID.
-     */
-    string              get_callbackSchedule(void);
-
-    inline string       callbackSchedule(void)
-    { return this->get_callbackSchedule(); }
-
-    /**
-     * Changes the HTTP callback schedule strategy, as a text string.
-     *
-     * @param newval : a string corresponding to the HTTP callback schedule strategy, as a text string
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackSchedule(const string& newval);
-    inline int      setCallbackSchedule(const string& newval)
-    { return this->set_callbackSchedule(newval); }
-
-    /**
-     * Returns the minimum waiting time between two HTTP callbacks, in seconds.
-     *
-     * @return an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
-     *
-     * On failure, throws an exception or returns Y_CALLBACKMINDELAY_INVALID.
-     */
-    int                 get_callbackMinDelay(void);
-
-    inline int          callbackMinDelay(void)
-    { return this->get_callbackMinDelay(); }
-
-    /**
-     * Changes the minimum waiting time between two HTTP callbacks, in seconds.
-     *
-     * @param newval : an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackMinDelay(int newval);
-    inline int      setCallbackMinDelay(int newval)
-    { return this->set_callbackMinDelay(newval); }
-
-    /**
-     * Returns the waiting time between two HTTP callbacks when there is nothing new.
-     *
-     * @return an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new
-     *
-     * On failure, throws an exception or returns Y_CALLBACKMAXDELAY_INVALID.
-     */
-    int                 get_callbackMaxDelay(void);
-
-    inline int          callbackMaxDelay(void)
-    { return this->get_callbackMaxDelay(); }
-
-    /**
-     * Changes the waiting time between two HTTP callbacks when there is nothing new.
-     *
-     * @param newval : an integer corresponding to the waiting time between two HTTP callbacks when there
-     * is nothing new
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_callbackMaxDelay(int newval);
-    inline int      setCallbackMaxDelay(int newval)
-    { return this->set_callbackMaxDelay(newval); }
-
-    /**
-     * Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.
-     * The current consumption is measured after converting PoE source to 5 Volt, and should
-     * never exceed 1800 mA.
-     *
-     * @return an integer corresponding to the current consumed by the module from Power-over-Ethernet
-     * (PoE), in milliamps
-     *
-     * On failure, throws an exception or returns Y_POECURRENT_INVALID.
-     */
-    int                 get_poeCurrent(void);
-
-    inline int          poeCurrent(void)
-    { return this->get_poeCurrent(); }
-
-    /**
-     * Retrieves a network interface for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the network interface is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YNetwork.isOnline() to test if the network interface is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a network interface by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the network interface
-     *
-     * @return a YNetwork object allowing you to drive the network interface.
-     */
-    static YNetwork*    FindNetwork(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YNetworkValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Changes the configuration of the network interface to enable the use of an
-     * IP address received from a DHCP server. Until an address is received from a DHCP
-     * server, the module uses the IP parameters specified to this function.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param fallbackIpAddr : fallback IP address, to be used when no DHCP reply is received
-     * @param fallbackSubnetMaskLen : fallback subnet mask length when no DHCP reply is received, as an
-     *         integer (e.g. 24 means 255.255.255.0)
-     * @param fallbackRouter : fallback router IP address, to be used when no DHCP reply is received
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         useDHCP(string fallbackIpAddr,int fallbackSubnetMaskLen,string fallbackRouter);
-
-    /**
-     * Changes the configuration of the network interface to enable the use of an
-     * IP address received from a DHCP server. Until an address is received from a DHCP
-     * server, the module uses an IP of the network 169.254.0.0/16 (APIPA).
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         useDHCPauto(void);
-
-    /**
-     * Changes the configuration of the network interface to use a static IP address.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param ipAddress : device IP address
-     * @param subnetMaskLen : subnet mask length, as an integer (e.g. 24 means 255.255.255.0)
-     * @param router : router IP address (default gateway)
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         useStaticIP(string ipAddress,int subnetMaskLen,string router);
-
-    /**
-     * Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the
-     * module to the target host. This method returns a string with the result of the
-     * 4 ICMP ECHO_REQUEST requests.
-     *
-     * @param host : the hostname or the IP address of the target
-     *
-     * @return a string with the result of the ping.
-     */
-    virtual string      ping(string host);
-
-    /**
-     * Trigger an HTTP callback quickly. This function can even be called within
-     * an HTTP callback, in which case the next callback will be triggered 5 seconds
-     * after the end of the current callback, regardless if the minimum time between
-     * callbacks configured in the device.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerCallback(void);
-
-    /**
-     * Setup periodic HTTP callbacks (simplified function).
-     *
-     * @param interval : a string representing the callback periodicity, expressed in
-     *         seconds, minutes or hours, eg. "60s", "5m", "1h", "48h".
-     * @param offset : an integer representing the time offset relative to the period
-     *         when the callback should occur. For instance, if the periodicity is
-     *         24h, an offset of 7 will make the callback occur each day at 7AM.
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_periodicCallbackSchedule(string interval,int offset);
-
-
-    inline static YNetwork* Find(string func)
-    { return YNetwork::FindNetwork(func); }
-
-    /**
-     * Continues the enumeration of network interfaces started using yFirstNetwork().
-     * Caution: You can't make any assumption about the returned network interfaces order.
-     * If you want to find a specific a network interface, use Network.findNetwork()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YNetwork object, corresponding to
-     *         a network interface currently online, or a NULL pointer
-     *         if there are no more network interfaces to enumerate.
-     */
-           YNetwork        *nextNetwork(void);
-    inline YNetwork        *next(void)
-    { return this->nextNetwork();}
-
-    /**
-     * Starts the enumeration of network interfaces currently accessible.
-     * Use the method YNetwork.nextNetwork() to iterate on
-     * next network interfaces.
-     *
-     * @return a pointer to a YNetwork object, corresponding to
-     *         the first network interface currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YNetwork* FirstNetwork(void);
-    inline static YNetwork* First(void)
-    { return YNetwork::FirstNetwork();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YNetwork accessors declaration)
-};
-
-//--- (YNetwork functions declaration)
-
-/**
- * Retrieves a network interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the network interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YNetwork.isOnline() to test if the network interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a network interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the network interface
- *
- * @return a YNetwork object allowing you to drive the network interface.
- */
-inline YNetwork* yFindNetwork(const string& func)
-{ return YNetwork::FindNetwork(func);}
-/**
- * Starts the enumeration of network interfaces currently accessible.
- * Use the method YNetwork.nextNetwork() to iterate on
- * next network interfaces.
- *
- * @return a pointer to a YNetwork object, corresponding to
- *         the first network interface currently online, or a NULL pointer
- *         if there are none.
- */
-inline YNetwork* yFirstNetwork(void)
-{ return YNetwork::FirstNetwork();}
-
-//--- (end of YNetwork functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_oscontrol.cpp
+++ /dev/null
@@ -1,253 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_oscontrol.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindOsControl(), the high-level API for OsControl functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_oscontrol.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "oscontrol"
-
-YOsControl::YOsControl(const string& func): YFunction(func)
-//--- (YOsControl initialization)
-    ,_shutdownCountdown(SHUTDOWNCOUNTDOWN_INVALID)
-    ,_valueCallbackOsControl(NULL)
-//--- (end of YOsControl initialization)
-{
-    _className="OsControl";
-}
-
-YOsControl::~YOsControl()
-{
-//--- (YOsControl cleanup)
-//--- (end of YOsControl cleanup)
-}
-//--- (YOsControl implementation)
-// static attributes
-
-int YOsControl::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("shutdownCountdown")) {
-        _shutdownCountdown =  json_val->getInt("shutdownCountdown");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the remaining number of seconds before the OS shutdown, or zero when no
- * shutdown has been scheduled.
- *
- * @return an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no
- *         shutdown has been scheduled
- *
- * On failure, throws an exception or returns Y_SHUTDOWNCOUNTDOWN_INVALID.
- */
-int YOsControl::get_shutdownCountdown(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YOsControl::SHUTDOWNCOUNTDOWN_INVALID;
-                }
-            }
-        }
-        res = _shutdownCountdown;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YOsControl::set_shutdownCountdown(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("shutdownCountdown", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves OS control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the OS control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YOsControl.isOnline() to test if the OS control is
- * indeed online at a given time. In case of ambiguity when looking for
- * OS control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the OS control
- *
- * @return a YOsControl object allowing you to drive the OS control.
- */
-YOsControl* YOsControl::FindOsControl(string func)
-{
-    YOsControl* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YOsControl*) YFunction::_FindFromCache("OsControl", func);
-        if (obj == NULL) {
-            obj = new YOsControl(func);
-            YFunction::_AddToCache("OsControl", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YOsControl::registerValueCallback(YOsControlValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackOsControl = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YOsControl::_invokeValueCallback(string value)
-{
-    if (_valueCallbackOsControl != NULL) {
-        _valueCallbackOsControl(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Schedules an OS shutdown after a given number of seconds.
- *
- * @param secBeforeShutDown : number of seconds before shutdown
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YOsControl::shutdown(int secBeforeShutDown)
-{
-    return this->set_shutdownCountdown(secBeforeShutDown);
-}
-
-YOsControl *YOsControl::nextOsControl(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YOsControl::FindOsControl(hwid);
-}
-
-YOsControl* YOsControl::FirstOsControl(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("OsControl", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YOsControl::FindOsControl(serial+"."+funcId);
-}
-
-//--- (end of YOsControl implementation)
-
-//--- (YOsControl functions)
-//--- (end of YOsControl functions)
--- a/Sources/cpplib/yocto_oscontrol.h
+++ /dev/null
@@ -1,250 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_oscontrol.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindOsControl(), the high-level API for OsControl functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_OSCONTROL_H
-#define YOCTO_OSCONTROL_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YOsControl return codes)
-//--- (end of YOsControl return codes)
-//--- (YOsControl yapiwrapper)
-//--- (end of YOsControl yapiwrapper)
-//--- (YOsControl definitions)
-class YOsControl; // forward declaration
-
-typedef void (*YOsControlValueCallback)(YOsControl *func, const string& functionValue);
-#define Y_SHUTDOWNCOUNTDOWN_INVALID     (YAPI_INVALID_UINT)
-//--- (end of YOsControl definitions)
-
-//--- (YOsControl declaration)
-/**
- * YOsControl Class: OS control
- *
- * The OScontrol object allows some control over the operating system running a VirtualHub.
- * OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub
- * start up with -o option.
- */
-class YOCTO_CLASS_EXPORT YOsControl: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YOsControl declaration)
-protected:
-    //--- (YOsControl attributes)
-    // Attributes (function value cache)
-    int             _shutdownCountdown;
-    YOsControlValueCallback _valueCallbackOsControl;
-
-    friend YOsControl *yFindOsControl(const string& func);
-    friend YOsControl *yFirstOsControl(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindOsControl factory function to instantiate
-    YOsControl(const string& func);
-    //--- (end of YOsControl attributes)
-
-public:
-    virtual ~YOsControl();
-    //--- (YOsControl accessors declaration)
-
-    static const int SHUTDOWNCOUNTDOWN_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the remaining number of seconds before the OS shutdown, or zero when no
-     * shutdown has been scheduled.
-     *
-     * @return an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no
-     *         shutdown has been scheduled
-     *
-     * On failure, throws an exception or returns Y_SHUTDOWNCOUNTDOWN_INVALID.
-     */
-    int                 get_shutdownCountdown(void);
-
-    inline int          shutdownCountdown(void)
-    { return this->get_shutdownCountdown(); }
-
-    int             set_shutdownCountdown(int newval);
-    inline int      setShutdownCountdown(int newval)
-    { return this->set_shutdownCountdown(newval); }
-
-    /**
-     * Retrieves OS control for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the OS control is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YOsControl.isOnline() to test if the OS control is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * OS control by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the OS control
-     *
-     * @return a YOsControl object allowing you to drive the OS control.
-     */
-    static YOsControl*  FindOsControl(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YOsControlValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Schedules an OS shutdown after a given number of seconds.
-     *
-     * @param secBeforeShutDown : number of seconds before shutdown
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         shutdown(int secBeforeShutDown);
-
-
-    inline static YOsControl* Find(string func)
-    { return YOsControl::FindOsControl(func); }
-
-    /**
-     * Continues the enumeration of OS control started using yFirstOsControl().
-     * Caution: You can't make any assumption about the returned OS control order.
-     * If you want to find a specific OS control, use OsControl.findOsControl()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YOsControl object, corresponding to
-     *         OS control currently online, or a NULL pointer
-     *         if there are no more OS control to enumerate.
-     */
-           YOsControl      *nextOsControl(void);
-    inline YOsControl      *next(void)
-    { return this->nextOsControl();}
-
-    /**
-     * Starts the enumeration of OS control currently accessible.
-     * Use the method YOsControl.nextOsControl() to iterate on
-     * next OS control.
-     *
-     * @return a pointer to a YOsControl object, corresponding to
-     *         the first OS control currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YOsControl* FirstOsControl(void);
-    inline static YOsControl* First(void)
-    { return YOsControl::FirstOsControl();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YOsControl accessors declaration)
-};
-
-//--- (YOsControl functions declaration)
-
-/**
- * Retrieves OS control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the OS control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YOsControl.isOnline() to test if the OS control is
- * indeed online at a given time. In case of ambiguity when looking for
- * OS control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the OS control
- *
- * @return a YOsControl object allowing you to drive the OS control.
- */
-inline YOsControl* yFindOsControl(const string& func)
-{ return YOsControl::FindOsControl(func);}
-/**
- * Starts the enumeration of OS control currently accessible.
- * Use the method YOsControl.nextOsControl() to iterate on
- * next OS control.
- *
- * @return a pointer to a YOsControl object, corresponding to
- *         the first OS control currently online, or a NULL pointer
- *         if there are none.
- */
-inline YOsControl* yFirstOsControl(void)
-{ return YOsControl::FirstOsControl();}
-
-//--- (end of YOsControl functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_power.cpp
+++ /dev/null
@@ -1,356 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_power.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindPower(), the high-level API for Power functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_power.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "power"
-
-YPower::YPower(const string& func): YSensor(func)
-//--- (YPower initialization)
-    ,_cosPhi(COSPHI_INVALID)
-    ,_meter(METER_INVALID)
-    ,_meterTimer(METERTIMER_INVALID)
-    ,_valueCallbackPower(NULL)
-    ,_timedReportCallbackPower(NULL)
-//--- (end of YPower initialization)
-{
-    _className="Power";
-}
-
-YPower::~YPower()
-{
-//--- (YPower cleanup)
-//--- (end of YPower cleanup)
-}
-//--- (YPower implementation)
-// static attributes
-const double YPower::COSPHI_INVALID = YAPI_INVALID_DOUBLE;
-const double YPower::METER_INVALID = YAPI_INVALID_DOUBLE;
-
-int YPower::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("cosPhi")) {
-        _cosPhi =  floor(json_val->getDouble("cosPhi") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("meter")) {
-        _meter =  floor(json_val->getDouble("meter") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("meterTimer")) {
-        _meterTimer =  json_val->getInt("meterTimer");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the power factor (the ratio between the real power consumed,
- * measured in W, and the apparent power provided, measured in VA).
- *
- * @return a floating point number corresponding to the power factor (the ratio between the real power consumed,
- *         measured in W, and the apparent power provided, measured in VA)
- *
- * On failure, throws an exception or returns Y_COSPHI_INVALID.
- */
-double YPower::get_cosPhi(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPower::COSPHI_INVALID;
-                }
-            }
-        }
-        res = _cosPhi;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YPower::set_meter(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("meter", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.
- * Note that this counter is reset at each start of the device.
- *
- * @return a floating point number corresponding to the energy counter, maintained by the wattmeter by
- * integrating the power consumption over time
- *
- * On failure, throws an exception or returns Y_METER_INVALID.
- */
-double YPower::get_meter(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPower::METER_INVALID;
-                }
-            }
-        }
-        res = _meter;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the elapsed time since last energy counter reset, in seconds.
- *
- * @return an integer corresponding to the elapsed time since last energy counter reset, in seconds
- *
- * On failure, throws an exception or returns Y_METERTIMER_INVALID.
- */
-int YPower::get_meterTimer(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPower::METERTIMER_INVALID;
-                }
-            }
-        }
-        res = _meterTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a electrical power sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the electrical power sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPower.isOnline() to test if the electrical power sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a electrical power sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the electrical power sensor
- *
- * @return a YPower object allowing you to drive the electrical power sensor.
- */
-YPower* YPower::FindPower(string func)
-{
-    YPower* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPower*) YFunction::_FindFromCache("Power", func);
-        if (obj == NULL) {
-            obj = new YPower(func);
-            YFunction::_AddToCache("Power", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPower::registerValueCallback(YPowerValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPower = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPower::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPower != NULL) {
-        _valueCallbackPower(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YPower::registerTimedReportCallback(YPowerTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackPower = callback;
-    return 0;
-}
-
-int YPower::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackPower != NULL) {
-        _timedReportCallbackPower(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Resets the energy counter.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPower::reset(void)
-{
-    return this->set_meter(0);
-}
-
-YPower *YPower::nextPower(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPower::FindPower(hwid);
-}
-
-YPower* YPower::FirstPower(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Power", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPower::FindPower(serial+"."+funcId);
-}
-
-//--- (end of YPower implementation)
-
-//--- (YPower functions)
-//--- (end of YPower functions)
--- a/Sources/cpplib/yocto_power.h
+++ /dev/null
@@ -1,300 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_power.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindPower(), the high-level API for Power functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_POWER_H
-#define YOCTO_POWER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPower return codes)
-//--- (end of YPower return codes)
-//--- (YPower yapiwrapper)
-//--- (end of YPower yapiwrapper)
-//--- (YPower definitions)
-class YPower; // forward declaration
-
-typedef void (*YPowerValueCallback)(YPower *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YPowerTimedReportCallback)(YPower *func, YMeasure measure);
-#define Y_COSPHI_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_METER_INVALID                 (YAPI_INVALID_DOUBLE)
-#define Y_METERTIMER_INVALID            (YAPI_INVALID_UINT)
-//--- (end of YPower definitions)
-
-//--- (YPower declaration)
-/**
- * YPower Class: Power function interface
- *
- * The Yoctopuce class YPower allows you to read and configure Yoctopuce power
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to access the energy counter and the power factor.
- */
-class YOCTO_CLASS_EXPORT YPower: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPower declaration)
-protected:
-    //--- (YPower attributes)
-    // Attributes (function value cache)
-    double          _cosPhi;
-    double          _meter;
-    int             _meterTimer;
-    YPowerValueCallback _valueCallbackPower;
-    YPowerTimedReportCallback _timedReportCallbackPower;
-
-    friend YPower *yFindPower(const string& func);
-    friend YPower *yFirstPower(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPower factory function to instantiate
-    YPower(const string& func);
-    //--- (end of YPower attributes)
-
-public:
-    virtual ~YPower();
-    //--- (YPower accessors declaration)
-
-    static const double COSPHI_INVALID;
-    static const double METER_INVALID;
-    static const int METERTIMER_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Returns the power factor (the ratio between the real power consumed,
-     * measured in W, and the apparent power provided, measured in VA).
-     *
-     * @return a floating point number corresponding to the power factor (the ratio between the real power consumed,
-     *         measured in W, and the apparent power provided, measured in VA)
-     *
-     * On failure, throws an exception or returns Y_COSPHI_INVALID.
-     */
-    double              get_cosPhi(void);
-
-    inline double       cosPhi(void)
-    { return this->get_cosPhi(); }
-
-    int             set_meter(double newval);
-    inline int      setMeter(double newval)
-    { return this->set_meter(newval); }
-
-    /**
-     * Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.
-     * Note that this counter is reset at each start of the device.
-     *
-     * @return a floating point number corresponding to the energy counter, maintained by the wattmeter by
-     * integrating the power consumption over time
-     *
-     * On failure, throws an exception or returns Y_METER_INVALID.
-     */
-    double              get_meter(void);
-
-    inline double       meter(void)
-    { return this->get_meter(); }
-
-    /**
-     * Returns the elapsed time since last energy counter reset, in seconds.
-     *
-     * @return an integer corresponding to the elapsed time since last energy counter reset, in seconds
-     *
-     * On failure, throws an exception or returns Y_METERTIMER_INVALID.
-     */
-    int                 get_meterTimer(void);
-
-    inline int          meterTimer(void)
-    { return this->get_meterTimer(); }
-
-    /**
-     * Retrieves a electrical power sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the electrical power sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPower.isOnline() to test if the electrical power sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a electrical power sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the electrical power sensor
-     *
-     * @return a YPower object allowing you to drive the electrical power sensor.
-     */
-    static YPower*      FindPower(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPowerValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YPowerTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Resets the energy counter.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-
-    inline static YPower* Find(string func)
-    { return YPower::FindPower(func); }
-
-    /**
-     * Continues the enumeration of electrical power sensors started using yFirstPower().
-     * Caution: You can't make any assumption about the returned electrical power sensors order.
-     * If you want to find a specific a electrical power sensor, use Power.findPower()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPower object, corresponding to
-     *         a electrical power sensor currently online, or a NULL pointer
-     *         if there are no more electrical power sensors to enumerate.
-     */
-           YPower          *nextPower(void);
-    inline YPower          *next(void)
-    { return this->nextPower();}
-
-    /**
-     * Starts the enumeration of electrical power sensors currently accessible.
-     * Use the method YPower.nextPower() to iterate on
-     * next electrical power sensors.
-     *
-     * @return a pointer to a YPower object, corresponding to
-     *         the first electrical power sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPower* FirstPower(void);
-    inline static YPower* First(void)
-    { return YPower::FirstPower();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPower accessors declaration)
-};
-
-//--- (YPower functions declaration)
-
-/**
- * Retrieves a electrical power sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the electrical power sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPower.isOnline() to test if the electrical power sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a electrical power sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the electrical power sensor
- *
- * @return a YPower object allowing you to drive the electrical power sensor.
- */
-inline YPower* yFindPower(const string& func)
-{ return YPower::FindPower(func);}
-/**
- * Starts the enumeration of electrical power sensors currently accessible.
- * Use the method YPower.nextPower() to iterate on
- * next electrical power sensors.
- *
- * @return a pointer to a YPower object, corresponding to
- *         the first electrical power sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPower* yFirstPower(void)
-{ return YPower::FirstPower();}
-
-//--- (end of YPower functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_poweroutput.cpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_poweroutput.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindPowerOutput(), the high-level API for PowerOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_poweroutput.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "poweroutput"
-
-YPowerOutput::YPowerOutput(const string& func): YFunction(func)
-//--- (YPowerOutput initialization)
-    ,_voltage(VOLTAGE_INVALID)
-    ,_valueCallbackPowerOutput(NULL)
-//--- (end of YPowerOutput initialization)
-{
-    _className="PowerOutput";
-}
-
-YPowerOutput::~YPowerOutput()
-{
-//--- (YPowerOutput cleanup)
-//--- (end of YPowerOutput cleanup)
-}
-//--- (YPowerOutput implementation)
-// static attributes
-
-int YPowerOutput::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("voltage")) {
-        _voltage =  (Y_VOLTAGE_enum)json_val->getInt("voltage");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the voltage on the power output featured by the module.
- *
- * @return a value among Y_VOLTAGE_OFF, Y_VOLTAGE_OUT3V3 and Y_VOLTAGE_OUT5V corresponding to the
- * voltage on the power output featured by the module
- *
- * On failure, throws an exception or returns Y_VOLTAGE_INVALID.
- */
-Y_VOLTAGE_enum YPowerOutput::get_voltage(void)
-{
-    Y_VOLTAGE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerOutput::VOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _voltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage on the power output provided by the
- * module. Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a value among Y_VOLTAGE_OFF, Y_VOLTAGE_OUT3V3 and Y_VOLTAGE_OUT5V corresponding to
- * the voltage on the power output provided by the
- *         module
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerOutput::set_voltage(Y_VOLTAGE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("voltage", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a dual power  output control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the power output control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPowerOutput.isOnline() to test if the power output control is
- * indeed online at a given time. In case of ambiguity when looking for
- * a dual power  output control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the power output control
- *
- * @return a YPowerOutput object allowing you to drive the power output control.
- */
-YPowerOutput* YPowerOutput::FindPowerOutput(string func)
-{
-    YPowerOutput* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPowerOutput*) YFunction::_FindFromCache("PowerOutput", func);
-        if (obj == NULL) {
-            obj = new YPowerOutput(func);
-            YFunction::_AddToCache("PowerOutput", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPowerOutput::registerValueCallback(YPowerOutputValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPowerOutput = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPowerOutput::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPowerOutput != NULL) {
-        _valueCallbackPowerOutput(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YPowerOutput *YPowerOutput::nextPowerOutput(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPowerOutput::FindPowerOutput(hwid);
-}
-
-YPowerOutput* YPowerOutput::FirstPowerOutput(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("PowerOutput", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPowerOutput::FindPowerOutput(serial+"."+funcId);
-}
-
-//--- (end of YPowerOutput implementation)
-
-//--- (YPowerOutput functions)
-//--- (end of YPowerOutput functions)
--- a/Sources/cpplib/yocto_poweroutput.h
+++ /dev/null
@@ -1,261 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_poweroutput.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindPowerOutput(), the high-level API for PowerOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_POWEROUTPUT_H
-#define YOCTO_POWEROUTPUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPowerOutput return codes)
-//--- (end of YPowerOutput return codes)
-//--- (YPowerOutput yapiwrapper)
-//--- (end of YPowerOutput yapiwrapper)
-//--- (YPowerOutput definitions)
-class YPowerOutput; // forward declaration
-
-typedef void (*YPowerOutputValueCallback)(YPowerOutput *func, const string& functionValue);
-#ifndef _Y_VOLTAGE_ENUM
-#define _Y_VOLTAGE_ENUM
-typedef enum {
-    Y_VOLTAGE_OFF = 0,
-    Y_VOLTAGE_OUT3V3 = 1,
-    Y_VOLTAGE_OUT5V = 2,
-    Y_VOLTAGE_INVALID = -1,
-} Y_VOLTAGE_enum;
-#endif
-//--- (end of YPowerOutput definitions)
-
-//--- (YPowerOutput declaration)
-/**
- * YPowerOutput Class: External power supply control interface
- *
- * Yoctopuce application programming interface allows you to control
- * the power output featured on some devices such as the Yocto-Serial.
- */
-class YOCTO_CLASS_EXPORT YPowerOutput: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPowerOutput declaration)
-protected:
-    //--- (YPowerOutput attributes)
-    // Attributes (function value cache)
-    Y_VOLTAGE_enum  _voltage;
-    YPowerOutputValueCallback _valueCallbackPowerOutput;
-
-    friend YPowerOutput *yFindPowerOutput(const string& func);
-    friend YPowerOutput *yFirstPowerOutput(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPowerOutput factory function to instantiate
-    YPowerOutput(const string& func);
-    //--- (end of YPowerOutput attributes)
-
-public:
-    virtual ~YPowerOutput();
-    //--- (YPowerOutput accessors declaration)
-
-    static const Y_VOLTAGE_enum VOLTAGE_OFF = Y_VOLTAGE_OFF;
-    static const Y_VOLTAGE_enum VOLTAGE_OUT3V3 = Y_VOLTAGE_OUT3V3;
-    static const Y_VOLTAGE_enum VOLTAGE_OUT5V = Y_VOLTAGE_OUT5V;
-    static const Y_VOLTAGE_enum VOLTAGE_INVALID = Y_VOLTAGE_INVALID;
-
-    /**
-     * Returns the voltage on the power output featured by the module.
-     *
-     * @return a value among Y_VOLTAGE_OFF, Y_VOLTAGE_OUT3V3 and Y_VOLTAGE_OUT5V corresponding to the
-     * voltage on the power output featured by the module
-     *
-     * On failure, throws an exception or returns Y_VOLTAGE_INVALID.
-     */
-    Y_VOLTAGE_enum      get_voltage(void);
-
-    inline Y_VOLTAGE_enum voltage(void)
-    { return this->get_voltage(); }
-
-    /**
-     * Changes the voltage on the power output provided by the
-     * module. Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a value among Y_VOLTAGE_OFF, Y_VOLTAGE_OUT3V3 and Y_VOLTAGE_OUT5V corresponding to
-     * the voltage on the power output provided by the
-     *         module
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltage(Y_VOLTAGE_enum newval);
-    inline int      setVoltage(Y_VOLTAGE_enum newval)
-    { return this->set_voltage(newval); }
-
-    /**
-     * Retrieves a dual power  output control for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the power output control is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPowerOutput.isOnline() to test if the power output control is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a dual power  output control by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the power output control
-     *
-     * @return a YPowerOutput object allowing you to drive the power output control.
-     */
-    static YPowerOutput* FindPowerOutput(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPowerOutputValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YPowerOutput* Find(string func)
-    { return YPowerOutput::FindPowerOutput(func); }
-
-    /**
-     * Continues the enumeration of dual power output controls started using yFirstPowerOutput().
-     * Caution: You can't make any assumption about the returned dual power output controls order.
-     * If you want to find a specific a dual power  output control, use PowerOutput.findPowerOutput()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPowerOutput object, corresponding to
-     *         a dual power  output control currently online, or a NULL pointer
-     *         if there are no more dual power output controls to enumerate.
-     */
-           YPowerOutput    *nextPowerOutput(void);
-    inline YPowerOutput    *next(void)
-    { return this->nextPowerOutput();}
-
-    /**
-     * Starts the enumeration of dual power output controls currently accessible.
-     * Use the method YPowerOutput.nextPowerOutput() to iterate on
-     * next dual power output controls.
-     *
-     * @return a pointer to a YPowerOutput object, corresponding to
-     *         the first dual power output control currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPowerOutput* FirstPowerOutput(void);
-    inline static YPowerOutput* First(void)
-    { return YPowerOutput::FirstPowerOutput();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPowerOutput accessors declaration)
-};
-
-//--- (YPowerOutput functions declaration)
-
-/**
- * Retrieves a dual power  output control for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the power output control is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPowerOutput.isOnline() to test if the power output control is
- * indeed online at a given time. In case of ambiguity when looking for
- * a dual power  output control by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the power output control
- *
- * @return a YPowerOutput object allowing you to drive the power output control.
- */
-inline YPowerOutput* yFindPowerOutput(const string& func)
-{ return YPowerOutput::FindPowerOutput(func);}
-/**
- * Starts the enumeration of dual power output controls currently accessible.
- * Use the method YPowerOutput.nextPowerOutput() to iterate on
- * next dual power output controls.
- *
- * @return a pointer to a YPowerOutput object, corresponding to
- *         the first dual power output control currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPowerOutput* yFirstPowerOutput(void)
-{ return YPowerOutput::FirstPowerOutput();}
-
-//--- (end of YPowerOutput functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_powersupply.cpp
+++ /dev/null
@@ -1,819 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_powersupply.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindPowerSupply(), the high-level API for PowerSupply functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_powersupply.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "powersupply"
-
-YPowerSupply::YPowerSupply(const string& func): YFunction(func)
-//--- (YPowerSupply initialization)
-    ,_voltageSetPoint(VOLTAGESETPOINT_INVALID)
-    ,_currentLimit(CURRENTLIMIT_INVALID)
-    ,_powerOutput(POWEROUTPUT_INVALID)
-    ,_voltageSense(VOLTAGESENSE_INVALID)
-    ,_measuredVoltage(MEASUREDVOLTAGE_INVALID)
-    ,_measuredCurrent(MEASUREDCURRENT_INVALID)
-    ,_inputVoltage(INPUTVOLTAGE_INVALID)
-    ,_vInt(VINT_INVALID)
-    ,_ldoTemperature(LDOTEMPERATURE_INVALID)
-    ,_voltageTransition(VOLTAGETRANSITION_INVALID)
-    ,_voltageAtStartUp(VOLTAGEATSTARTUP_INVALID)
-    ,_currentAtStartUp(CURRENTATSTARTUP_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackPowerSupply(NULL)
-//--- (end of YPowerSupply initialization)
-{
-    _className="PowerSupply";
-}
-
-YPowerSupply::~YPowerSupply()
-{
-//--- (YPowerSupply cleanup)
-//--- (end of YPowerSupply cleanup)
-}
-//--- (YPowerSupply implementation)
-// static attributes
-const double YPowerSupply::VOLTAGESETPOINT_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::CURRENTLIMIT_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::MEASUREDVOLTAGE_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::MEASUREDCURRENT_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::INPUTVOLTAGE_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::VINT_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::LDOTEMPERATURE_INVALID = YAPI_INVALID_DOUBLE;
-const string YPowerSupply::VOLTAGETRANSITION_INVALID = YAPI_INVALID_STRING;
-const double YPowerSupply::VOLTAGEATSTARTUP_INVALID = YAPI_INVALID_DOUBLE;
-const double YPowerSupply::CURRENTATSTARTUP_INVALID = YAPI_INVALID_DOUBLE;
-const string YPowerSupply::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YPowerSupply::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("voltageSetPoint")) {
-        _voltageSetPoint =  floor(json_val->getDouble("voltageSetPoint") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("currentLimit")) {
-        _currentLimit =  floor(json_val->getDouble("currentLimit") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("powerOutput")) {
-        _powerOutput =  (Y_POWEROUTPUT_enum)json_val->getInt("powerOutput");
-    }
-    if(json_val->has("voltageSense")) {
-        _voltageSense =  (Y_VOLTAGESENSE_enum)json_val->getInt("voltageSense");
-    }
-    if(json_val->has("measuredVoltage")) {
-        _measuredVoltage =  floor(json_val->getDouble("measuredVoltage") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("measuredCurrent")) {
-        _measuredCurrent =  floor(json_val->getDouble("measuredCurrent") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("inputVoltage")) {
-        _inputVoltage =  floor(json_val->getDouble("inputVoltage") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("vInt")) {
-        _vInt =  floor(json_val->getDouble("vInt") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("ldoTemperature")) {
-        _ldoTemperature =  floor(json_val->getDouble("ldoTemperature") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("voltageTransition")) {
-        _voltageTransition =  json_val->getString("voltageTransition");
-    }
-    if(json_val->has("voltageAtStartUp")) {
-        _voltageAtStartUp =  floor(json_val->getDouble("voltageAtStartUp") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("currentAtStartUp")) {
-        _currentAtStartUp =  floor(json_val->getDouble("currentAtStartUp") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the voltage set point, in V.
- *
- * @param newval : a floating point number corresponding to the voltage set point, in V
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_voltageSetPoint(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("voltageSetPoint", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the voltage set point, in V.
- *
- * @return a floating point number corresponding to the voltage set point, in V
- *
- * On failure, throws an exception or returns Y_VOLTAGESETPOINT_INVALID.
- */
-double YPowerSupply::get_voltageSetPoint(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::VOLTAGESETPOINT_INVALID;
-                }
-            }
-        }
-        res = _voltageSetPoint;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current limit, in mA.
- *
- * @param newval : a floating point number corresponding to the current limit, in mA
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_currentLimit(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentLimit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current limit, in mA.
- *
- * @return a floating point number corresponding to the current limit, in mA
- *
- * On failure, throws an exception or returns Y_CURRENTLIMIT_INVALID.
- */
-double YPowerSupply::get_currentLimit(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::CURRENTLIMIT_INVALID;
-                }
-            }
-        }
-        res = _currentLimit;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the power supply output switch state.
- *
- * @return either Y_POWEROUTPUT_OFF or Y_POWEROUTPUT_ON, according to the power supply output switch state
- *
- * On failure, throws an exception or returns Y_POWEROUTPUT_INVALID.
- */
-Y_POWEROUTPUT_enum YPowerSupply::get_powerOutput(void)
-{
-    Y_POWEROUTPUT_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::POWEROUTPUT_INVALID;
-                }
-            }
-        }
-        res = _powerOutput;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the power supply output switch state.
- *
- * @param newval : either Y_POWEROUTPUT_OFF or Y_POWEROUTPUT_ON, according to the power supply output switch state
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_powerOutput(Y_POWEROUTPUT_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("powerOutput", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the output voltage control point.
- *
- * @return either Y_VOLTAGESENSE_INT or Y_VOLTAGESENSE_EXT, according to the output voltage control point
- *
- * On failure, throws an exception or returns Y_VOLTAGESENSE_INVALID.
- */
-Y_VOLTAGESENSE_enum YPowerSupply::get_voltageSense(void)
-{
-    Y_VOLTAGESENSE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::VOLTAGESENSE_INVALID;
-                }
-            }
-        }
-        res = _voltageSense;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage control point.
- *
- * @param newval : either Y_VOLTAGESENSE_INT or Y_VOLTAGESENSE_EXT, according to the voltage control point
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_voltageSense(Y_VOLTAGESENSE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("voltageSense", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measured output voltage, in V.
- *
- * @return a floating point number corresponding to the measured output voltage, in V
- *
- * On failure, throws an exception or returns Y_MEASUREDVOLTAGE_INVALID.
- */
-double YPowerSupply::get_measuredVoltage(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::MEASUREDVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _measuredVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measured output current, in mA.
- *
- * @return a floating point number corresponding to the measured output current, in mA
- *
- * On failure, throws an exception or returns Y_MEASUREDCURRENT_INVALID.
- */
-double YPowerSupply::get_measuredCurrent(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::MEASUREDCURRENT_INVALID;
-                }
-            }
-        }
-        res = _measuredCurrent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measured input voltage, in V.
- *
- * @return a floating point number corresponding to the measured input voltage, in V
- *
- * On failure, throws an exception or returns Y_INPUTVOLTAGE_INVALID.
- */
-double YPowerSupply::get_inputVoltage(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::INPUTVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _inputVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the internal voltage, in V.
- *
- * @return a floating point number corresponding to the internal voltage, in V
- *
- * On failure, throws an exception or returns Y_VINT_INVALID.
- */
-double YPowerSupply::get_vInt(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::VINT_INVALID;
-                }
-            }
-        }
-        res = _vInt;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the LDO temperature, in Celsius.
- *
- * @return a floating point number corresponding to the LDO temperature, in Celsius
- *
- * On failure, throws an exception or returns Y_LDOTEMPERATURE_INVALID.
- */
-double YPowerSupply::get_ldoTemperature(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::LDOTEMPERATURE_INVALID;
-                }
-            }
-        }
-        res = _ldoTemperature;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YPowerSupply::get_voltageTransition(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::VOLTAGETRANSITION_INVALID;
-                }
-            }
-        }
-        res = _voltageTransition;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YPowerSupply::set_voltageTransition(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("voltageTransition", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage set point at device start up. Remember to call the matching
- * module saveToFlash() method, otherwise this call has no effect.
- *
- * @param newval : a floating point number corresponding to the voltage set point at device start up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_voltageAtStartUp(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("voltageAtStartUp", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the selected voltage set point at device startup, in V.
- *
- * @return a floating point number corresponding to the selected voltage set point at device startup, in V
- *
- * On failure, throws an exception or returns Y_VOLTAGEATSTARTUP_INVALID.
- */
-double YPowerSupply::get_voltageAtStartUp(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::VOLTAGEATSTARTUP_INVALID;
-                }
-            }
-        }
-        res = _voltageAtStartUp;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current limit at device start up. Remember to call the matching
- * module saveToFlash() method, otherwise this call has no effect.
- *
- * @param newval : a floating point number corresponding to the current limit at device start up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPowerSupply::set_currentAtStartUp(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentAtStartUp", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the selected current limit at device startup, in mA.
- *
- * @return a floating point number corresponding to the selected current limit at device startup, in mA
- *
- * On failure, throws an exception or returns Y_CURRENTATSTARTUP_INVALID.
- */
-double YPowerSupply::get_currentAtStartUp(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::CURRENTATSTARTUP_INVALID;
-                }
-            }
-        }
-        res = _currentAtStartUp;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YPowerSupply::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPowerSupply::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YPowerSupply::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a regulated power supply for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the regulated power supply is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPowerSupply.isOnline() to test if the regulated power supply is
- * indeed online at a given time. In case of ambiguity when looking for
- * a regulated power supply by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the regulated power supply
- *
- * @return a YPowerSupply object allowing you to drive the regulated power supply.
- */
-YPowerSupply* YPowerSupply::FindPowerSupply(string func)
-{
-    YPowerSupply* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPowerSupply*) YFunction::_FindFromCache("PowerSupply", func);
-        if (obj == NULL) {
-            obj = new YPowerSupply(func);
-            YFunction::_AddToCache("PowerSupply", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPowerSupply::registerValueCallback(YPowerSupplyValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPowerSupply = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPowerSupply::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPowerSupply != NULL) {
-        _valueCallbackPowerSupply(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Performs a smooth transistion of output voltage. Any explicit voltage
- * change cancels any ongoing transition process.
- *
- * @param V_target   : new output voltage value at the end of the transition
- *         (floating-point number, representing the end voltage in V)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- */
-int YPowerSupply::voltageMove(double V_target,int ms_duration)
-{
-    string newval;
-    if (V_target < 0.0) {
-        V_target  = 0.0;
-    }
-    newval = YapiWrapper::ysprintf("%d:%d", (int) floor(V_target*65536+0.5),ms_duration);
-
-    return this->set_voltageTransition(newval);
-}
-
-YPowerSupply *YPowerSupply::nextPowerSupply(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPowerSupply::FindPowerSupply(hwid);
-}
-
-YPowerSupply* YPowerSupply::FirstPowerSupply(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("PowerSupply", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPowerSupply::FindPowerSupply(serial+"."+funcId);
-}
-
-//--- (end of YPowerSupply implementation)
-
-//--- (YPowerSupply functions)
-//--- (end of YPowerSupply functions)
--- a/Sources/cpplib/yocto_powersupply.h
+++ /dev/null
@@ -1,516 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_powersupply.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindPowerSupply(), the high-level API for PowerSupply functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_POWERSUPPLY_H
-#define YOCTO_POWERSUPPLY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPowerSupply return codes)
-//--- (end of YPowerSupply return codes)
-//--- (YPowerSupply yapiwrapper)
-//--- (end of YPowerSupply yapiwrapper)
-//--- (YPowerSupply definitions)
-class YPowerSupply; // forward declaration
-
-typedef void (*YPowerSupplyValueCallback)(YPowerSupply *func, const string& functionValue);
-#ifndef _Y_POWEROUTPUT_ENUM
-#define _Y_POWEROUTPUT_ENUM
-typedef enum {
-    Y_POWEROUTPUT_OFF = 0,
-    Y_POWEROUTPUT_ON = 1,
-    Y_POWEROUTPUT_INVALID = -1,
-} Y_POWEROUTPUT_enum;
-#endif
-#ifndef _Y_VOLTAGESENSE_ENUM
-#define _Y_VOLTAGESENSE_ENUM
-typedef enum {
-    Y_VOLTAGESENSE_INT = 0,
-    Y_VOLTAGESENSE_EXT = 1,
-    Y_VOLTAGESENSE_INVALID = -1,
-} Y_VOLTAGESENSE_enum;
-#endif
-#define Y_VOLTAGESETPOINT_INVALID       (YAPI_INVALID_DOUBLE)
-#define Y_CURRENTLIMIT_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_MEASUREDVOLTAGE_INVALID       (YAPI_INVALID_DOUBLE)
-#define Y_MEASUREDCURRENT_INVALID       (YAPI_INVALID_DOUBLE)
-#define Y_INPUTVOLTAGE_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_VINT_INVALID                  (YAPI_INVALID_DOUBLE)
-#define Y_LDOTEMPERATURE_INVALID        (YAPI_INVALID_DOUBLE)
-#define Y_VOLTAGETRANSITION_INVALID     (YAPI_INVALID_STRING)
-#define Y_VOLTAGEATSTARTUP_INVALID      (YAPI_INVALID_DOUBLE)
-#define Y_CURRENTATSTARTUP_INVALID      (YAPI_INVALID_DOUBLE)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YPowerSupply definitions)
-
-//--- (YPowerSupply declaration)
-/**
- * YPowerSupply Class: PowerSupply function interface
- *
- * The Yoctopuce application programming interface allows you to change the voltage set point,
- * the current limit and the enable/disable the output.
- */
-class YOCTO_CLASS_EXPORT YPowerSupply: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPowerSupply declaration)
-protected:
-    //--- (YPowerSupply attributes)
-    // Attributes (function value cache)
-    double          _voltageSetPoint;
-    double          _currentLimit;
-    Y_POWEROUTPUT_enum _powerOutput;
-    Y_VOLTAGESENSE_enum _voltageSense;
-    double          _measuredVoltage;
-    double          _measuredCurrent;
-    double          _inputVoltage;
-    double          _vInt;
-    double          _ldoTemperature;
-    string          _voltageTransition;
-    double          _voltageAtStartUp;
-    double          _currentAtStartUp;
-    string          _command;
-    YPowerSupplyValueCallback _valueCallbackPowerSupply;
-
-    friend YPowerSupply *yFindPowerSupply(const string& func);
-    friend YPowerSupply *yFirstPowerSupply(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPowerSupply factory function to instantiate
-    YPowerSupply(const string& func);
-    //--- (end of YPowerSupply attributes)
-
-public:
-    virtual ~YPowerSupply();
-    //--- (YPowerSupply accessors declaration)
-
-    static const double VOLTAGESETPOINT_INVALID;
-    static const double CURRENTLIMIT_INVALID;
-    static const Y_POWEROUTPUT_enum POWEROUTPUT_OFF = Y_POWEROUTPUT_OFF;
-    static const Y_POWEROUTPUT_enum POWEROUTPUT_ON = Y_POWEROUTPUT_ON;
-    static const Y_POWEROUTPUT_enum POWEROUTPUT_INVALID = Y_POWEROUTPUT_INVALID;
-    static const Y_VOLTAGESENSE_enum VOLTAGESENSE_INT = Y_VOLTAGESENSE_INT;
-    static const Y_VOLTAGESENSE_enum VOLTAGESENSE_EXT = Y_VOLTAGESENSE_EXT;
-    static const Y_VOLTAGESENSE_enum VOLTAGESENSE_INVALID = Y_VOLTAGESENSE_INVALID;
-    static const double MEASUREDVOLTAGE_INVALID;
-    static const double MEASUREDCURRENT_INVALID;
-    static const double INPUTVOLTAGE_INVALID;
-    static const double VINT_INVALID;
-    static const double LDOTEMPERATURE_INVALID;
-    static const string VOLTAGETRANSITION_INVALID;
-    static const double VOLTAGEATSTARTUP_INVALID;
-    static const double CURRENTATSTARTUP_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the voltage set point, in V.
-     *
-     * @param newval : a floating point number corresponding to the voltage set point, in V
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageSetPoint(double newval);
-    inline int      setVoltageSetPoint(double newval)
-    { return this->set_voltageSetPoint(newval); }
-
-    /**
-     * Returns the voltage set point, in V.
-     *
-     * @return a floating point number corresponding to the voltage set point, in V
-     *
-     * On failure, throws an exception or returns Y_VOLTAGESETPOINT_INVALID.
-     */
-    double              get_voltageSetPoint(void);
-
-    inline double       voltageSetPoint(void)
-    { return this->get_voltageSetPoint(); }
-
-    /**
-     * Changes the current limit, in mA.
-     *
-     * @param newval : a floating point number corresponding to the current limit, in mA
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentLimit(double newval);
-    inline int      setCurrentLimit(double newval)
-    { return this->set_currentLimit(newval); }
-
-    /**
-     * Returns the current limit, in mA.
-     *
-     * @return a floating point number corresponding to the current limit, in mA
-     *
-     * On failure, throws an exception or returns Y_CURRENTLIMIT_INVALID.
-     */
-    double              get_currentLimit(void);
-
-    inline double       currentLimit(void)
-    { return this->get_currentLimit(); }
-
-    /**
-     * Returns the power supply output switch state.
-     *
-     * @return either Y_POWEROUTPUT_OFF or Y_POWEROUTPUT_ON, according to the power supply output switch state
-     *
-     * On failure, throws an exception or returns Y_POWEROUTPUT_INVALID.
-     */
-    Y_POWEROUTPUT_enum  get_powerOutput(void);
-
-    inline Y_POWEROUTPUT_enum powerOutput(void)
-    { return this->get_powerOutput(); }
-
-    /**
-     * Changes the power supply output switch state.
-     *
-     * @param newval : either Y_POWEROUTPUT_OFF or Y_POWEROUTPUT_ON, according to the power supply output switch state
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_powerOutput(Y_POWEROUTPUT_enum newval);
-    inline int      setPowerOutput(Y_POWEROUTPUT_enum newval)
-    { return this->set_powerOutput(newval); }
-
-    /**
-     * Returns the output voltage control point.
-     *
-     * @return either Y_VOLTAGESENSE_INT or Y_VOLTAGESENSE_EXT, according to the output voltage control point
-     *
-     * On failure, throws an exception or returns Y_VOLTAGESENSE_INVALID.
-     */
-    Y_VOLTAGESENSE_enum get_voltageSense(void);
-
-    inline Y_VOLTAGESENSE_enum voltageSense(void)
-    { return this->get_voltageSense(); }
-
-    /**
-     * Changes the voltage control point.
-     *
-     * @param newval : either Y_VOLTAGESENSE_INT or Y_VOLTAGESENSE_EXT, according to the voltage control point
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageSense(Y_VOLTAGESENSE_enum newval);
-    inline int      setVoltageSense(Y_VOLTAGESENSE_enum newval)
-    { return this->set_voltageSense(newval); }
-
-    /**
-     * Returns the measured output voltage, in V.
-     *
-     * @return a floating point number corresponding to the measured output voltage, in V
-     *
-     * On failure, throws an exception or returns Y_MEASUREDVOLTAGE_INVALID.
-     */
-    double              get_measuredVoltage(void);
-
-    inline double       measuredVoltage(void)
-    { return this->get_measuredVoltage(); }
-
-    /**
-     * Returns the measured output current, in mA.
-     *
-     * @return a floating point number corresponding to the measured output current, in mA
-     *
-     * On failure, throws an exception or returns Y_MEASUREDCURRENT_INVALID.
-     */
-    double              get_measuredCurrent(void);
-
-    inline double       measuredCurrent(void)
-    { return this->get_measuredCurrent(); }
-
-    /**
-     * Returns the measured input voltage, in V.
-     *
-     * @return a floating point number corresponding to the measured input voltage, in V
-     *
-     * On failure, throws an exception or returns Y_INPUTVOLTAGE_INVALID.
-     */
-    double              get_inputVoltage(void);
-
-    inline double       inputVoltage(void)
-    { return this->get_inputVoltage(); }
-
-    /**
-     * Returns the internal voltage, in V.
-     *
-     * @return a floating point number corresponding to the internal voltage, in V
-     *
-     * On failure, throws an exception or returns Y_VINT_INVALID.
-     */
-    double              get_vInt(void);
-
-    inline double       vInt(void)
-    { return this->get_vInt(); }
-
-    /**
-     * Returns the LDO temperature, in Celsius.
-     *
-     * @return a floating point number corresponding to the LDO temperature, in Celsius
-     *
-     * On failure, throws an exception or returns Y_LDOTEMPERATURE_INVALID.
-     */
-    double              get_ldoTemperature(void);
-
-    inline double       ldoTemperature(void)
-    { return this->get_ldoTemperature(); }
-
-    string              get_voltageTransition(void);
-
-    inline string       voltageTransition(void)
-    { return this->get_voltageTransition(); }
-
-    int             set_voltageTransition(const string& newval);
-    inline int      setVoltageTransition(const string& newval)
-    { return this->set_voltageTransition(newval); }
-
-    /**
-     * Changes the voltage set point at device start up. Remember to call the matching
-     * module saveToFlash() method, otherwise this call has no effect.
-     *
-     * @param newval : a floating point number corresponding to the voltage set point at device start up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageAtStartUp(double newval);
-    inline int      setVoltageAtStartUp(double newval)
-    { return this->set_voltageAtStartUp(newval); }
-
-    /**
-     * Returns the selected voltage set point at device startup, in V.
-     *
-     * @return a floating point number corresponding to the selected voltage set point at device startup, in V
-     *
-     * On failure, throws an exception or returns Y_VOLTAGEATSTARTUP_INVALID.
-     */
-    double              get_voltageAtStartUp(void);
-
-    inline double       voltageAtStartUp(void)
-    { return this->get_voltageAtStartUp(); }
-
-    /**
-     * Changes the current limit at device start up. Remember to call the matching
-     * module saveToFlash() method, otherwise this call has no effect.
-     *
-     * @param newval : a floating point number corresponding to the current limit at device start up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentAtStartUp(double newval);
-    inline int      setCurrentAtStartUp(double newval)
-    { return this->set_currentAtStartUp(newval); }
-
-    /**
-     * Returns the selected current limit at device startup, in mA.
-     *
-     * @return a floating point number corresponding to the selected current limit at device startup, in mA
-     *
-     * On failure, throws an exception or returns Y_CURRENTATSTARTUP_INVALID.
-     */
-    double              get_currentAtStartUp(void);
-
-    inline double       currentAtStartUp(void)
-    { return this->get_currentAtStartUp(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a regulated power supply for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the regulated power supply is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPowerSupply.isOnline() to test if the regulated power supply is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a regulated power supply by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the regulated power supply
-     *
-     * @return a YPowerSupply object allowing you to drive the regulated power supply.
-     */
-    static YPowerSupply* FindPowerSupply(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPowerSupplyValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Performs a smooth transistion of output voltage. Any explicit voltage
-     * change cancels any ongoing transition process.
-     *
-     * @param V_target   : new output voltage value at the end of the transition
-     *         (floating-point number, representing the end voltage in V)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     */
-    virtual int         voltageMove(double V_target,int ms_duration);
-
-
-    inline static YPowerSupply* Find(string func)
-    { return YPowerSupply::FindPowerSupply(func); }
-
-    /**
-     * Continues the enumeration of regulated power supplies started using yFirstPowerSupply().
-     * Caution: You can't make any assumption about the returned regulated power supplies order.
-     * If you want to find a specific a regulated power supply, use PowerSupply.findPowerSupply()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPowerSupply object, corresponding to
-     *         a regulated power supply currently online, or a NULL pointer
-     *         if there are no more regulated power supplies to enumerate.
-     */
-           YPowerSupply    *nextPowerSupply(void);
-    inline YPowerSupply    *next(void)
-    { return this->nextPowerSupply();}
-
-    /**
-     * Starts the enumeration of regulated power supplies currently accessible.
-     * Use the method YPowerSupply.nextPowerSupply() to iterate on
-     * next regulated power supplies.
-     *
-     * @return a pointer to a YPowerSupply object, corresponding to
-     *         the first regulated power supply currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPowerSupply* FirstPowerSupply(void);
-    inline static YPowerSupply* First(void)
-    { return YPowerSupply::FirstPowerSupply();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPowerSupply accessors declaration)
-};
-
-//--- (YPowerSupply functions declaration)
-
-/**
- * Retrieves a regulated power supply for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the regulated power supply is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPowerSupply.isOnline() to test if the regulated power supply is
- * indeed online at a given time. In case of ambiguity when looking for
- * a regulated power supply by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the regulated power supply
- *
- * @return a YPowerSupply object allowing you to drive the regulated power supply.
- */
-inline YPowerSupply* yFindPowerSupply(const string& func)
-{ return YPowerSupply::FindPowerSupply(func);}
-/**
- * Starts the enumeration of regulated power supplies currently accessible.
- * Use the method YPowerSupply.nextPowerSupply() to iterate on
- * next regulated power supplies.
- *
- * @return a pointer to a YPowerSupply object, corresponding to
- *         the first regulated power supply currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPowerSupply* yFirstPowerSupply(void)
-{ return YPowerSupply::FirstPowerSupply();}
-
-//--- (end of YPowerSupply functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_pressure.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pressure.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindPressure(), the high-level API for Pressure functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_pressure.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "pressure"
-
-YPressure::YPressure(const string& func): YSensor(func)
-//--- (YPressure initialization)
-    ,_valueCallbackPressure(NULL)
-    ,_timedReportCallbackPressure(NULL)
-//--- (end of YPressure initialization)
-{
-    _className="Pressure";
-}
-
-YPressure::~YPressure()
-{
-//--- (YPressure cleanup)
-//--- (end of YPressure cleanup)
-}
-//--- (YPressure implementation)
-// static attributes
-
-
-/**
- * Retrieves a pressure sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the pressure sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPressure.isOnline() to test if the pressure sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a pressure sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the pressure sensor
- *
- * @return a YPressure object allowing you to drive the pressure sensor.
- */
-YPressure* YPressure::FindPressure(string func)
-{
-    YPressure* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPressure*) YFunction::_FindFromCache("Pressure", func);
-        if (obj == NULL) {
-            obj = new YPressure(func);
-            YFunction::_AddToCache("Pressure", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPressure::registerValueCallback(YPressureValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPressure = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPressure::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPressure != NULL) {
-        _valueCallbackPressure(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YPressure::registerTimedReportCallback(YPressureTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackPressure = callback;
-    return 0;
-}
-
-int YPressure::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackPressure != NULL) {
-        _timedReportCallbackPressure(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YPressure *YPressure::nextPressure(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPressure::FindPressure(hwid);
-}
-
-YPressure* YPressure::FirstPressure(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Pressure", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPressure::FindPressure(serial+"."+funcId);
-}
-
-//--- (end of YPressure implementation)
-
-//--- (YPressure functions)
-//--- (end of YPressure functions)
--- a/Sources/cpplib/yocto_pressure.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pressure.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindPressure(), the high-level API for Pressure functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_PRESSURE_H
-#define YOCTO_PRESSURE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPressure return codes)
-//--- (end of YPressure return codes)
-//--- (YPressure yapiwrapper)
-//--- (end of YPressure yapiwrapper)
-//--- (YPressure definitions)
-class YPressure; // forward declaration
-
-typedef void (*YPressureValueCallback)(YPressure *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YPressureTimedReportCallback)(YPressure *func, YMeasure measure);
-//--- (end of YPressure definitions)
-
-//--- (YPressure declaration)
-/**
- * YPressure Class: Pressure function interface
- *
- * The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YPressure: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPressure declaration)
-protected:
-    //--- (YPressure attributes)
-    // Attributes (function value cache)
-    YPressureValueCallback _valueCallbackPressure;
-    YPressureTimedReportCallback _timedReportCallbackPressure;
-
-    friend YPressure *yFindPressure(const string& func);
-    friend YPressure *yFirstPressure(void);
-
-    // Constructor is protected, use yFindPressure factory function to instantiate
-    YPressure(const string& func);
-    //--- (end of YPressure attributes)
-
-public:
-    virtual ~YPressure();
-    //--- (YPressure accessors declaration)
-
-
-    /**
-     * Retrieves a pressure sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the pressure sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPressure.isOnline() to test if the pressure sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a pressure sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the pressure sensor
-     *
-     * @return a YPressure object allowing you to drive the pressure sensor.
-     */
-    static YPressure*   FindPressure(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPressureValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YPressureTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YPressure* Find(string func)
-    { return YPressure::FindPressure(func); }
-
-    /**
-     * Continues the enumeration of pressure sensors started using yFirstPressure().
-     * Caution: You can't make any assumption about the returned pressure sensors order.
-     * If you want to find a specific a pressure sensor, use Pressure.findPressure()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPressure object, corresponding to
-     *         a pressure sensor currently online, or a NULL pointer
-     *         if there are no more pressure sensors to enumerate.
-     */
-           YPressure       *nextPressure(void);
-    inline YPressure       *next(void)
-    { return this->nextPressure();}
-
-    /**
-     * Starts the enumeration of pressure sensors currently accessible.
-     * Use the method YPressure.nextPressure() to iterate on
-     * next pressure sensors.
-     *
-     * @return a pointer to a YPressure object, corresponding to
-     *         the first pressure sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPressure* FirstPressure(void);
-    inline static YPressure* First(void)
-    { return YPressure::FirstPressure();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPressure accessors declaration)
-};
-
-//--- (YPressure functions declaration)
-
-/**
- * Retrieves a pressure sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the pressure sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPressure.isOnline() to test if the pressure sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a pressure sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the pressure sensor
- *
- * @return a YPressure object allowing you to drive the pressure sensor.
- */
-inline YPressure* yFindPressure(const string& func)
-{ return YPressure::FindPressure(func);}
-/**
- * Starts the enumeration of pressure sensors currently accessible.
- * Use the method YPressure.nextPressure() to iterate on
- * next pressure sensors.
- *
- * @return a pointer to a YPressure object, corresponding to
- *         the first pressure sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPressure* yFirstPressure(void)
-{ return YPressure::FirstPressure();}
-
-//--- (end of YPressure functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_proximity.cpp
+++ /dev/null
@@ -1,774 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_proximity.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindProximity(), the high-level API for Proximity functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_proximity.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "proximity"
-
-YProximity::YProximity(const string& func): YSensor(func)
-//--- (YProximity initialization)
-    ,_signalValue(SIGNALVALUE_INVALID)
-    ,_detectionThreshold(DETECTIONTHRESHOLD_INVALID)
-    ,_detectionHysteresis(DETECTIONHYSTERESIS_INVALID)
-    ,_presenceMinTime(PRESENCEMINTIME_INVALID)
-    ,_removalMinTime(REMOVALMINTIME_INVALID)
-    ,_isPresent(ISPRESENT_INVALID)
-    ,_lastTimeApproached(LASTTIMEAPPROACHED_INVALID)
-    ,_lastTimeRemoved(LASTTIMEREMOVED_INVALID)
-    ,_pulseCounter(PULSECOUNTER_INVALID)
-    ,_pulseTimer(PULSETIMER_INVALID)
-    ,_proximityReportMode(PROXIMITYREPORTMODE_INVALID)
-    ,_valueCallbackProximity(NULL)
-    ,_timedReportCallbackProximity(NULL)
-//--- (end of YProximity initialization)
-{
-    _className="Proximity";
-}
-
-YProximity::~YProximity()
-{
-//--- (YProximity cleanup)
-//--- (end of YProximity cleanup)
-}
-//--- (YProximity implementation)
-// static attributes
-const double YProximity::SIGNALVALUE_INVALID = YAPI_INVALID_DOUBLE;
-
-int YProximity::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("signalValue")) {
-        _signalValue =  floor(json_val->getDouble("signalValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("detectionThreshold")) {
-        _detectionThreshold =  json_val->getInt("detectionThreshold");
-    }
-    if(json_val->has("detectionHysteresis")) {
-        _detectionHysteresis =  json_val->getInt("detectionHysteresis");
-    }
-    if(json_val->has("presenceMinTime")) {
-        _presenceMinTime =  json_val->getInt("presenceMinTime");
-    }
-    if(json_val->has("removalMinTime")) {
-        _removalMinTime =  json_val->getInt("removalMinTime");
-    }
-    if(json_val->has("isPresent")) {
-        _isPresent =  (Y_ISPRESENT_enum)json_val->getInt("isPresent");
-    }
-    if(json_val->has("lastTimeApproached")) {
-        _lastTimeApproached =  json_val->getLong("lastTimeApproached");
-    }
-    if(json_val->has("lastTimeRemoved")) {
-        _lastTimeRemoved =  json_val->getLong("lastTimeRemoved");
-    }
-    if(json_val->has("pulseCounter")) {
-        _pulseCounter =  json_val->getLong("pulseCounter");
-    }
-    if(json_val->has("pulseTimer")) {
-        _pulseTimer =  json_val->getLong("pulseTimer");
-    }
-    if(json_val->has("proximityReportMode")) {
-        _proximityReportMode =  (Y_PROXIMITYREPORTMODE_enum)json_val->getInt("proximityReportMode");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current value of signal measured by the proximity sensor.
- *
- * @return a floating point number corresponding to the current value of signal measured by the proximity sensor
- *
- * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
- */
-double YProximity::get_signalValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::SIGNALVALUE_INVALID;
-                }
-            }
-        }
-        res = floor(_signalValue * 1000+0.5) / 1000;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the threshold used to determine the logical state of the proximity sensor, when considered
- * as a binary input (on/off).
- *
- * @return an integer corresponding to the threshold used to determine the logical state of the
- * proximity sensor, when considered
- *         as a binary input (on/off)
- *
- * On failure, throws an exception or returns Y_DETECTIONTHRESHOLD_INVALID.
- */
-int YProximity::get_detectionThreshold(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::DETECTIONTHRESHOLD_INVALID;
-                }
-            }
-        }
-        res = _detectionThreshold;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the threshold used to determine the logical state of the proximity sensor, when considered
- * as a binary input (on/off).
- *
- * @param newval : an integer corresponding to the threshold used to determine the logical state of
- * the proximity sensor, when considered
- *         as a binary input (on/off)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::set_detectionThreshold(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("detectionThreshold", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the hysteresis used to determine the logical state of the proximity sensor, when considered
- * as a binary input (on/off).
- *
- * @return an integer corresponding to the hysteresis used to determine the logical state of the
- * proximity sensor, when considered
- *         as a binary input (on/off)
- *
- * On failure, throws an exception or returns Y_DETECTIONHYSTERESIS_INVALID.
- */
-int YProximity::get_detectionHysteresis(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::DETECTIONHYSTERESIS_INVALID;
-                }
-            }
-        }
-        res = _detectionHysteresis;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the hysteresis used to determine the logical state of the proximity sensor, when considered
- * as a binary input (on/off).
- *
- * @param newval : an integer corresponding to the hysteresis used to determine the logical state of
- * the proximity sensor, when considered
- *         as a binary input (on/off)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::set_detectionHysteresis(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("detectionHysteresis", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minimal detection duration before signalling a presence event. Any shorter detection is
- * considered as noise or bounce (false positive) and filtered out.
- *
- * @return an integer corresponding to the minimal detection duration before signalling a presence event
- *
- * On failure, throws an exception or returns Y_PRESENCEMINTIME_INVALID.
- */
-int YProximity::get_presenceMinTime(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::PRESENCEMINTIME_INVALID;
-                }
-            }
-        }
-        res = _presenceMinTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minimal detection duration before signalling a presence event. Any shorter detection is
- * considered as noise or bounce (false positive) and filtered out.
- *
- * @param newval : an integer corresponding to the minimal detection duration before signalling a presence event
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::set_presenceMinTime(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("presenceMinTime", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minimal detection duration before signalling a removal event. Any shorter detection is
- * considered as noise or bounce (false positive) and filtered out.
- *
- * @return an integer corresponding to the minimal detection duration before signalling a removal event
- *
- * On failure, throws an exception or returns Y_REMOVALMINTIME_INVALID.
- */
-int YProximity::get_removalMinTime(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::REMOVALMINTIME_INVALID;
-                }
-            }
-        }
-        res = _removalMinTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minimal detection duration before signalling a removal event. Any shorter detection is
- * considered as noise or bounce (false positive) and filtered out.
- *
- * @param newval : an integer corresponding to the minimal detection duration before signalling a removal event
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::set_removalMinTime(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("removalMinTime", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true if the input (considered as binary) is active (detection value is smaller than the
- * specified threshold), and false otherwise.
- *
- * @return either Y_ISPRESENT_FALSE or Y_ISPRESENT_TRUE, according to true if the input (considered as
- * binary) is active (detection value is smaller than the specified threshold), and false otherwise
- *
- * On failure, throws an exception or returns Y_ISPRESENT_INVALID.
- */
-Y_ISPRESENT_enum YProximity::get_isPresent(void)
-{
-    Y_ISPRESENT_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::ISPRESENT_INVALID;
-                }
-            }
-        }
-        res = _isPresent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of elapsed milliseconds between the module power on and the last observed
- * detection (the input contact transitioned from absent to present).
- *
- * @return an integer corresponding to the number of elapsed milliseconds between the module power on
- * and the last observed
- *         detection (the input contact transitioned from absent to present)
- *
- * On failure, throws an exception or returns Y_LASTTIMEAPPROACHED_INVALID.
- */
-s64 YProximity::get_lastTimeApproached(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::LASTTIMEAPPROACHED_INVALID;
-                }
-            }
-        }
-        res = _lastTimeApproached;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of elapsed milliseconds between the module power on and the last observed
- * detection (the input contact transitioned from present to absent).
- *
- * @return an integer corresponding to the number of elapsed milliseconds between the module power on
- * and the last observed
- *         detection (the input contact transitioned from present to absent)
- *
- * On failure, throws an exception or returns Y_LASTTIMEREMOVED_INVALID.
- */
-s64 YProximity::get_lastTimeRemoved(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::LASTTIMEREMOVED_INVALID;
-                }
-            }
-        }
-        res = _lastTimeRemoved;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the pulse counter value. The value is a 32 bit integer. In case
- * of overflow (>=2^32), the counter will wrap. To reset the counter, just
- * call the resetCounter() method.
- *
- * @return an integer corresponding to the pulse counter value
- *
- * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
- */
-s64 YProximity::get_pulseCounter(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::PULSECOUNTER_INVALID;
-                }
-            }
-        }
-        res = _pulseCounter;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YProximity::set_pulseCounter(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("pulseCounter", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the timer of the pulse counter (ms).
- *
- * @return an integer corresponding to the timer of the pulse counter (ms)
- *
- * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
- */
-s64 YProximity::get_pulseTimer(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::PULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _pulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue
- * function and callbacks.
- *
- * @return a value among Y_PROXIMITYREPORTMODE_NUMERIC, Y_PROXIMITYREPORTMODE_PRESENCE and
- * Y_PROXIMITYREPORTMODE_PULSECOUNT corresponding to the parameter (sensor value, presence or pulse
- * count) returned by the get_currentValue function and callbacks
- *
- * On failure, throws an exception or returns Y_PROXIMITYREPORTMODE_INVALID.
- */
-Y_PROXIMITYREPORTMODE_enum YProximity::get_proximityReportMode(void)
-{
-    Y_PROXIMITYREPORTMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YProximity::PROXIMITYREPORTMODE_INVALID;
-                }
-            }
-        }
-        res = _proximityReportMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the  parameter  type (sensor value, presence or pulse count) returned by the
- * get_currentValue function and callbacks.
- * The edge count value is limited to the 6 lowest digits. For values greater than one million, use
- * get_pulseCounter().
- *
- * @param newval : a value among Y_PROXIMITYREPORTMODE_NUMERIC, Y_PROXIMITYREPORTMODE_PRESENCE and
- * Y_PROXIMITYREPORTMODE_PULSECOUNT corresponding to the  parameter  type (sensor value, presence or
- * pulse count) returned by the get_currentValue function and callbacks
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::set_proximityReportMode(Y_PROXIMITYREPORTMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("proximityReportMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a proximity sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the proximity sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YProximity.isOnline() to test if the proximity sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a proximity sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the proximity sensor
- *
- * @return a YProximity object allowing you to drive the proximity sensor.
- */
-YProximity* YProximity::FindProximity(string func)
-{
-    YProximity* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YProximity*) YFunction::_FindFromCache("Proximity", func);
-        if (obj == NULL) {
-            obj = new YProximity(func);
-            YFunction::_AddToCache("Proximity", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YProximity::registerValueCallback(YProximityValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackProximity = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YProximity::_invokeValueCallback(string value)
-{
-    if (_valueCallbackProximity != NULL) {
-        _valueCallbackProximity(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YProximity::registerTimedReportCallback(YProximityTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackProximity = callback;
-    return 0;
-}
-
-int YProximity::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackProximity != NULL) {
-        _timedReportCallbackProximity(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Resets the pulse counter value as well as its timer.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YProximity::resetCounter(void)
-{
-    return this->set_pulseCounter(0);
-}
-
-YProximity *YProximity::nextProximity(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YProximity::FindProximity(hwid);
-}
-
-YProximity* YProximity::FirstProximity(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Proximity", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YProximity::FindProximity(serial+"."+funcId);
-}
-
-//--- (end of YProximity implementation)
-
-//--- (YProximity functions)
-//--- (end of YProximity functions)
--- a/Sources/cpplib/yocto_proximity.h
+++ /dev/null
@@ -1,536 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_proximity.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindProximity(), the high-level API for Proximity functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_PROXIMITY_H
-#define YOCTO_PROXIMITY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YProximity return codes)
-//--- (end of YProximity return codes)
-//--- (YProximity yapiwrapper)
-//--- (end of YProximity yapiwrapper)
-//--- (YProximity definitions)
-class YProximity; // forward declaration
-
-typedef void (*YProximityValueCallback)(YProximity *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YProximityTimedReportCallback)(YProximity *func, YMeasure measure);
-#ifndef _Y_ISPRESENT_ENUM
-#define _Y_ISPRESENT_ENUM
-typedef enum {
-    Y_ISPRESENT_FALSE = 0,
-    Y_ISPRESENT_TRUE = 1,
-    Y_ISPRESENT_INVALID = -1,
-} Y_ISPRESENT_enum;
-#endif
-#ifndef _Y_PROXIMITYREPORTMODE_ENUM
-#define _Y_PROXIMITYREPORTMODE_ENUM
-typedef enum {
-    Y_PROXIMITYREPORTMODE_NUMERIC = 0,
-    Y_PROXIMITYREPORTMODE_PRESENCE = 1,
-    Y_PROXIMITYREPORTMODE_PULSECOUNT = 2,
-    Y_PROXIMITYREPORTMODE_INVALID = -1,
-} Y_PROXIMITYREPORTMODE_enum;
-#endif
-#define Y_SIGNALVALUE_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_DETECTIONTHRESHOLD_INVALID    (YAPI_INVALID_UINT)
-#define Y_DETECTIONHYSTERESIS_INVALID   (YAPI_INVALID_UINT)
-#define Y_PRESENCEMINTIME_INVALID       (YAPI_INVALID_UINT)
-#define Y_REMOVALMINTIME_INVALID        (YAPI_INVALID_UINT)
-#define Y_LASTTIMEAPPROACHED_INVALID    (YAPI_INVALID_LONG)
-#define Y_LASTTIMEREMOVED_INVALID       (YAPI_INVALID_LONG)
-#define Y_PULSECOUNTER_INVALID          (YAPI_INVALID_LONG)
-#define Y_PULSETIMER_INVALID            (YAPI_INVALID_LONG)
-//--- (end of YProximity definitions)
-
-//--- (YProximity declaration)
-/**
- * YProximity Class: Proximity function interface
- *
- * The Yoctopuce class YProximity allows you to use and configure Yoctopuce proximity
- * sensors. It inherits from the YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to easily perform a one-point linear calibration
- * to compensate the effect of a glass or filter placed in front of the sensor.
- */
-class YOCTO_CLASS_EXPORT YProximity: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YProximity declaration)
-protected:
-    //--- (YProximity attributes)
-    // Attributes (function value cache)
-    double          _signalValue;
-    int             _detectionThreshold;
-    int             _detectionHysteresis;
-    int             _presenceMinTime;
-    int             _removalMinTime;
-    Y_ISPRESENT_enum _isPresent;
-    s64             _lastTimeApproached;
-    s64             _lastTimeRemoved;
-    s64             _pulseCounter;
-    s64             _pulseTimer;
-    Y_PROXIMITYREPORTMODE_enum _proximityReportMode;
-    YProximityValueCallback _valueCallbackProximity;
-    YProximityTimedReportCallback _timedReportCallbackProximity;
-
-    friend YProximity *yFindProximity(const string& func);
-    friend YProximity *yFirstProximity(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindProximity factory function to instantiate
-    YProximity(const string& func);
-    //--- (end of YProximity attributes)
-
-public:
-    virtual ~YProximity();
-    //--- (YProximity accessors declaration)
-
-    static const double SIGNALVALUE_INVALID;
-    static const int DETECTIONTHRESHOLD_INVALID = YAPI_INVALID_UINT;
-    static const int DETECTIONHYSTERESIS_INVALID = YAPI_INVALID_UINT;
-    static const int PRESENCEMINTIME_INVALID = YAPI_INVALID_UINT;
-    static const int REMOVALMINTIME_INVALID = YAPI_INVALID_UINT;
-    static const Y_ISPRESENT_enum ISPRESENT_FALSE = Y_ISPRESENT_FALSE;
-    static const Y_ISPRESENT_enum ISPRESENT_TRUE = Y_ISPRESENT_TRUE;
-    static const Y_ISPRESENT_enum ISPRESENT_INVALID = Y_ISPRESENT_INVALID;
-    static const s64 LASTTIMEAPPROACHED_INVALID = YAPI_INVALID_LONG;
-    static const s64 LASTTIMEREMOVED_INVALID = YAPI_INVALID_LONG;
-    static const s64 PULSECOUNTER_INVALID = YAPI_INVALID_LONG;
-    static const s64 PULSETIMER_INVALID = YAPI_INVALID_LONG;
-    static const Y_PROXIMITYREPORTMODE_enum PROXIMITYREPORTMODE_NUMERIC = Y_PROXIMITYREPORTMODE_NUMERIC;
-    static const Y_PROXIMITYREPORTMODE_enum PROXIMITYREPORTMODE_PRESENCE = Y_PROXIMITYREPORTMODE_PRESENCE;
-    static const Y_PROXIMITYREPORTMODE_enum PROXIMITYREPORTMODE_PULSECOUNT = Y_PROXIMITYREPORTMODE_PULSECOUNT;
-    static const Y_PROXIMITYREPORTMODE_enum PROXIMITYREPORTMODE_INVALID = Y_PROXIMITYREPORTMODE_INVALID;
-
-    /**
-     * Returns the current value of signal measured by the proximity sensor.
-     *
-     * @return a floating point number corresponding to the current value of signal measured by the proximity sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
-     */
-    double              get_signalValue(void);
-
-    inline double       signalValue(void)
-    { return this->get_signalValue(); }
-
-    /**
-     * Returns the threshold used to determine the logical state of the proximity sensor, when considered
-     * as a binary input (on/off).
-     *
-     * @return an integer corresponding to the threshold used to determine the logical state of the
-     * proximity sensor, when considered
-     *         as a binary input (on/off)
-     *
-     * On failure, throws an exception or returns Y_DETECTIONTHRESHOLD_INVALID.
-     */
-    int                 get_detectionThreshold(void);
-
-    inline int          detectionThreshold(void)
-    { return this->get_detectionThreshold(); }
-
-    /**
-     * Changes the threshold used to determine the logical state of the proximity sensor, when considered
-     * as a binary input (on/off).
-     *
-     * @param newval : an integer corresponding to the threshold used to determine the logical state of
-     * the proximity sensor, when considered
-     *         as a binary input (on/off)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_detectionThreshold(int newval);
-    inline int      setDetectionThreshold(int newval)
-    { return this->set_detectionThreshold(newval); }
-
-    /**
-     * Returns the hysteresis used to determine the logical state of the proximity sensor, when considered
-     * as a binary input (on/off).
-     *
-     * @return an integer corresponding to the hysteresis used to determine the logical state of the
-     * proximity sensor, when considered
-     *         as a binary input (on/off)
-     *
-     * On failure, throws an exception or returns Y_DETECTIONHYSTERESIS_INVALID.
-     */
-    int                 get_detectionHysteresis(void);
-
-    inline int          detectionHysteresis(void)
-    { return this->get_detectionHysteresis(); }
-
-    /**
-     * Changes the hysteresis used to determine the logical state of the proximity sensor, when considered
-     * as a binary input (on/off).
-     *
-     * @param newval : an integer corresponding to the hysteresis used to determine the logical state of
-     * the proximity sensor, when considered
-     *         as a binary input (on/off)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_detectionHysteresis(int newval);
-    inline int      setDetectionHysteresis(int newval)
-    { return this->set_detectionHysteresis(newval); }
-
-    /**
-     * Returns the minimal detection duration before signalling a presence event. Any shorter detection is
-     * considered as noise or bounce (false positive) and filtered out.
-     *
-     * @return an integer corresponding to the minimal detection duration before signalling a presence event
-     *
-     * On failure, throws an exception or returns Y_PRESENCEMINTIME_INVALID.
-     */
-    int                 get_presenceMinTime(void);
-
-    inline int          presenceMinTime(void)
-    { return this->get_presenceMinTime(); }
-
-    /**
-     * Changes the minimal detection duration before signalling a presence event. Any shorter detection is
-     * considered as noise or bounce (false positive) and filtered out.
-     *
-     * @param newval : an integer corresponding to the minimal detection duration before signalling a presence event
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_presenceMinTime(int newval);
-    inline int      setPresenceMinTime(int newval)
-    { return this->set_presenceMinTime(newval); }
-
-    /**
-     * Returns the minimal detection duration before signalling a removal event. Any shorter detection is
-     * considered as noise or bounce (false positive) and filtered out.
-     *
-     * @return an integer corresponding to the minimal detection duration before signalling a removal event
-     *
-     * On failure, throws an exception or returns Y_REMOVALMINTIME_INVALID.
-     */
-    int                 get_removalMinTime(void);
-
-    inline int          removalMinTime(void)
-    { return this->get_removalMinTime(); }
-
-    /**
-     * Changes the minimal detection duration before signalling a removal event. Any shorter detection is
-     * considered as noise or bounce (false positive) and filtered out.
-     *
-     * @param newval : an integer corresponding to the minimal detection duration before signalling a removal event
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_removalMinTime(int newval);
-    inline int      setRemovalMinTime(int newval)
-    { return this->set_removalMinTime(newval); }
-
-    /**
-     * Returns true if the input (considered as binary) is active (detection value is smaller than the
-     * specified threshold), and false otherwise.
-     *
-     * @return either Y_ISPRESENT_FALSE or Y_ISPRESENT_TRUE, according to true if the input (considered as
-     * binary) is active (detection value is smaller than the specified threshold), and false otherwise
-     *
-     * On failure, throws an exception or returns Y_ISPRESENT_INVALID.
-     */
-    Y_ISPRESENT_enum    get_isPresent(void);
-
-    inline Y_ISPRESENT_enum isPresent(void)
-    { return this->get_isPresent(); }
-
-    /**
-     * Returns the number of elapsed milliseconds between the module power on and the last observed
-     * detection (the input contact transitioned from absent to present).
-     *
-     * @return an integer corresponding to the number of elapsed milliseconds between the module power on
-     * and the last observed
-     *         detection (the input contact transitioned from absent to present)
-     *
-     * On failure, throws an exception or returns Y_LASTTIMEAPPROACHED_INVALID.
-     */
-    s64                 get_lastTimeApproached(void);
-
-    inline s64          lastTimeApproached(void)
-    { return this->get_lastTimeApproached(); }
-
-    /**
-     * Returns the number of elapsed milliseconds between the module power on and the last observed
-     * detection (the input contact transitioned from present to absent).
-     *
-     * @return an integer corresponding to the number of elapsed milliseconds between the module power on
-     * and the last observed
-     *         detection (the input contact transitioned from present to absent)
-     *
-     * On failure, throws an exception or returns Y_LASTTIMEREMOVED_INVALID.
-     */
-    s64                 get_lastTimeRemoved(void);
-
-    inline s64          lastTimeRemoved(void)
-    { return this->get_lastTimeRemoved(); }
-
-    /**
-     * Returns the pulse counter value. The value is a 32 bit integer. In case
-     * of overflow (>=2^32), the counter will wrap. To reset the counter, just
-     * call the resetCounter() method.
-     *
-     * @return an integer corresponding to the pulse counter value
-     *
-     * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
-     */
-    s64                 get_pulseCounter(void);
-
-    inline s64          pulseCounter(void)
-    { return this->get_pulseCounter(); }
-
-    int             set_pulseCounter(s64 newval);
-    inline int      setPulseCounter(s64 newval)
-    { return this->set_pulseCounter(newval); }
-
-    /**
-     * Returns the timer of the pulse counter (ms).
-     *
-     * @return an integer corresponding to the timer of the pulse counter (ms)
-     *
-     * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
-     */
-    s64                 get_pulseTimer(void);
-
-    inline s64          pulseTimer(void)
-    { return this->get_pulseTimer(); }
-
-    /**
-     * Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue
-     * function and callbacks.
-     *
-     * @return a value among Y_PROXIMITYREPORTMODE_NUMERIC, Y_PROXIMITYREPORTMODE_PRESENCE and
-     * Y_PROXIMITYREPORTMODE_PULSECOUNT corresponding to the parameter (sensor value, presence or pulse
-     * count) returned by the get_currentValue function and callbacks
-     *
-     * On failure, throws an exception or returns Y_PROXIMITYREPORTMODE_INVALID.
-     */
-    Y_PROXIMITYREPORTMODE_enum get_proximityReportMode(void);
-
-    inline Y_PROXIMITYREPORTMODE_enum proximityReportMode(void)
-    { return this->get_proximityReportMode(); }
-
-    /**
-     * Changes the  parameter  type (sensor value, presence or pulse count) returned by the
-     * get_currentValue function and callbacks.
-     * The edge count value is limited to the 6 lowest digits. For values greater than one million, use
-     * get_pulseCounter().
-     *
-     * @param newval : a value among Y_PROXIMITYREPORTMODE_NUMERIC, Y_PROXIMITYREPORTMODE_PRESENCE and
-     * Y_PROXIMITYREPORTMODE_PULSECOUNT corresponding to the  parameter  type (sensor value, presence or
-     * pulse count) returned by the get_currentValue function and callbacks
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_proximityReportMode(Y_PROXIMITYREPORTMODE_enum newval);
-    inline int      setProximityReportMode(Y_PROXIMITYREPORTMODE_enum newval)
-    { return this->set_proximityReportMode(newval); }
-
-    /**
-     * Retrieves a proximity sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the proximity sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YProximity.isOnline() to test if the proximity sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a proximity sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the proximity sensor
-     *
-     * @return a YProximity object allowing you to drive the proximity sensor.
-     */
-    static YProximity*  FindProximity(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YProximityValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YProximityTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Resets the pulse counter value as well as its timer.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetCounter(void);
-
-
-    inline static YProximity* Find(string func)
-    { return YProximity::FindProximity(func); }
-
-    /**
-     * Continues the enumeration of proximity sensors started using yFirstProximity().
-     * Caution: You can't make any assumption about the returned proximity sensors order.
-     * If you want to find a specific a proximity sensor, use Proximity.findProximity()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YProximity object, corresponding to
-     *         a proximity sensor currently online, or a NULL pointer
-     *         if there are no more proximity sensors to enumerate.
-     */
-           YProximity      *nextProximity(void);
-    inline YProximity      *next(void)
-    { return this->nextProximity();}
-
-    /**
-     * Starts the enumeration of proximity sensors currently accessible.
-     * Use the method YProximity.nextProximity() to iterate on
-     * next proximity sensors.
-     *
-     * @return a pointer to a YProximity object, corresponding to
-     *         the first proximity sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YProximity* FirstProximity(void);
-    inline static YProximity* First(void)
-    { return YProximity::FirstProximity();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YProximity accessors declaration)
-};
-
-//--- (YProximity functions declaration)
-
-/**
- * Retrieves a proximity sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the proximity sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YProximity.isOnline() to test if the proximity sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a proximity sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the proximity sensor
- *
- * @return a YProximity object allowing you to drive the proximity sensor.
- */
-inline YProximity* yFindProximity(const string& func)
-{ return YProximity::FindProximity(func);}
-/**
- * Starts the enumeration of proximity sensors currently accessible.
- * Use the method YProximity.nextProximity() to iterate on
- * next proximity sensors.
- *
- * @return a pointer to a YProximity object, corresponding to
- *         the first proximity sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YProximity* yFirstProximity(void)
-{ return YProximity::FirstProximity();}
-
-//--- (end of YProximity functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_pwminput.cpp
+++ /dev/null
@@ -1,612 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwminput.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindPwmInput(), the high-level API for PwmInput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_pwminput.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "pwminput"
-
-YPwmInput::YPwmInput(const string& func): YSensor(func)
-//--- (YPwmInput initialization)
-    ,_dutyCycle(DUTYCYCLE_INVALID)
-    ,_pulseDuration(PULSEDURATION_INVALID)
-    ,_frequency(FREQUENCY_INVALID)
-    ,_period(PERIOD_INVALID)
-    ,_pulseCounter(PULSECOUNTER_INVALID)
-    ,_pulseTimer(PULSETIMER_INVALID)
-    ,_pwmReportMode(PWMREPORTMODE_INVALID)
-    ,_debouncePeriod(DEBOUNCEPERIOD_INVALID)
-    ,_valueCallbackPwmInput(NULL)
-    ,_timedReportCallbackPwmInput(NULL)
-//--- (end of YPwmInput initialization)
-{
-    _className="PwmInput";
-}
-
-YPwmInput::~YPwmInput()
-{
-//--- (YPwmInput cleanup)
-//--- (end of YPwmInput cleanup)
-}
-//--- (YPwmInput implementation)
-// static attributes
-const double YPwmInput::DUTYCYCLE_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmInput::PULSEDURATION_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmInput::FREQUENCY_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmInput::PERIOD_INVALID = YAPI_INVALID_DOUBLE;
-
-int YPwmInput::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("dutyCycle")) {
-        _dutyCycle =  floor(json_val->getDouble("dutyCycle") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("pulseDuration")) {
-        _pulseDuration =  floor(json_val->getDouble("pulseDuration") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("frequency")) {
-        _frequency =  floor(json_val->getDouble("frequency") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("period")) {
-        _period =  floor(json_val->getDouble("period") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("pulseCounter")) {
-        _pulseCounter =  json_val->getLong("pulseCounter");
-    }
-    if(json_val->has("pulseTimer")) {
-        _pulseTimer =  json_val->getLong("pulseTimer");
-    }
-    if(json_val->has("pwmReportMode")) {
-        _pwmReportMode =  (Y_PWMREPORTMODE_enum)json_val->getInt("pwmReportMode");
-    }
-    if(json_val->has("debouncePeriod")) {
-        _debouncePeriod =  json_val->getInt("debouncePeriod");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the measured quantity. That unit
- * is just a string which is automatically initialized each time
- * the measurement mode is changed. But is can be set to an
- * arbitrary value.
- *
- * @param newval : a string corresponding to the measuring unit for the measured quantity
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmInput::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM duty cycle, in per cents.
- *
- * @return a floating point number corresponding to the PWM duty cycle, in per cents
- *
- * On failure, throws an exception or returns Y_DUTYCYCLE_INVALID.
- */
-double YPwmInput::get_dutyCycle(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::DUTYCYCLE_INVALID;
-                }
-            }
-        }
-        res = _dutyCycle;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM pulse length in milliseconds, as a floating point number.
- *
- * @return a floating point number corresponding to the PWM pulse length in milliseconds, as a
- * floating point number
- *
- * On failure, throws an exception or returns Y_PULSEDURATION_INVALID.
- */
-double YPwmInput::get_pulseDuration(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::PULSEDURATION_INVALID;
-                }
-            }
-        }
-        res = _pulseDuration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM frequency in Hz.
- *
- * @return a floating point number corresponding to the PWM frequency in Hz
- *
- * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
- */
-double YPwmInput::get_frequency(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::FREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _frequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM period in milliseconds.
- *
- * @return a floating point number corresponding to the PWM period in milliseconds
- *
- * On failure, throws an exception or returns Y_PERIOD_INVALID.
- */
-double YPwmInput::get_period(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::PERIOD_INVALID;
-                }
-            }
-        }
-        res = _period;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the pulse counter value. Actually that
- * counter is incremented twice per period. That counter is
- * limited  to 1 billion.
- *
- * @return an integer corresponding to the pulse counter value
- *
- * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
- */
-s64 YPwmInput::get_pulseCounter(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::PULSECOUNTER_INVALID;
-                }
-            }
-        }
-        res = _pulseCounter;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YPwmInput::set_pulseCounter(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("pulseCounter", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the timer of the pulses counter (ms).
- *
- * @return an integer corresponding to the timer of the pulses counter (ms)
- *
- * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
- */
-s64 YPwmInput::get_pulseTimer(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::PULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _pulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the
- * get_currentValue function and callbacks. Attention
- *
- * @return a value among Y_PWMREPORTMODE_PWM_DUTYCYCLE, Y_PWMREPORTMODE_PWM_FREQUENCY,
- * Y_PWMREPORTMODE_PWM_PULSEDURATION, Y_PWMREPORTMODE_PWM_EDGECOUNT, Y_PWMREPORTMODE_PWM_PULSECOUNT,
- * Y_PWMREPORTMODE_PWM_CPS, Y_PWMREPORTMODE_PWM_CPM, Y_PWMREPORTMODE_PWM_STATE,
- * Y_PWMREPORTMODE_PWM_FREQ_CPS and Y_PWMREPORTMODE_PWM_FREQ_CPM corresponding to the parameter
- * (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks
- *
- * On failure, throws an exception or returns Y_PWMREPORTMODE_INVALID.
- */
-Y_PWMREPORTMODE_enum YPwmInput::get_pwmReportMode(void)
-{
-    Y_PWMREPORTMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::PWMREPORTMODE_INVALID;
-                }
-            }
-        }
-        res = _pwmReportMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the  parameter  type (frequency/duty cycle, pulse width, or edge count) returned by the
- * get_currentValue function and callbacks.
- * The edge count value is limited to the 6 lowest digits. For values greater than one million, use
- * get_pulseCounter().
- *
- * @param newval : a value among Y_PWMREPORTMODE_PWM_DUTYCYCLE, Y_PWMREPORTMODE_PWM_FREQUENCY,
- * Y_PWMREPORTMODE_PWM_PULSEDURATION, Y_PWMREPORTMODE_PWM_EDGECOUNT, Y_PWMREPORTMODE_PWM_PULSECOUNT,
- * Y_PWMREPORTMODE_PWM_CPS, Y_PWMREPORTMODE_PWM_CPM, Y_PWMREPORTMODE_PWM_STATE,
- * Y_PWMREPORTMODE_PWM_FREQ_CPS and Y_PWMREPORTMODE_PWM_FREQ_CPM corresponding to the  parameter  type
- * (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmInput::set_pwmReportMode(Y_PWMREPORTMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("pwmReportMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).
- *
- * @return an integer corresponding to the shortest expected pulse duration, in ms
- *
- * On failure, throws an exception or returns Y_DEBOUNCEPERIOD_INVALID.
- */
-int YPwmInput::get_debouncePeriod(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmInput::DEBOUNCEPERIOD_INVALID;
-                }
-            }
-        }
-        res = _debouncePeriod;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).
- *
- * @param newval : an integer corresponding to the shortest expected pulse duration, in ms
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmInput::set_debouncePeriod(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("debouncePeriod", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a PWM input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the PWM input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmInput.isOnline() to test if the PWM input is
- * indeed online at a given time. In case of ambiguity when looking for
- * a PWM input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the PWM input
- *
- * @return a YPwmInput object allowing you to drive the PWM input.
- */
-YPwmInput* YPwmInput::FindPwmInput(string func)
-{
-    YPwmInput* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPwmInput*) YFunction::_FindFromCache("PwmInput", func);
-        if (obj == NULL) {
-            obj = new YPwmInput(func);
-            YFunction::_AddToCache("PwmInput", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPwmInput::registerValueCallback(YPwmInputValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPwmInput = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPwmInput::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPwmInput != NULL) {
-        _valueCallbackPwmInput(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YPwmInput::registerTimedReportCallback(YPwmInputTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackPwmInput = callback;
-    return 0;
-}
-
-int YPwmInput::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackPwmInput != NULL) {
-        _timedReportCallbackPwmInput(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Returns the pulse counter value as well as its timer.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmInput::resetCounter(void)
-{
-    return this->set_pulseCounter(0);
-}
-
-YPwmInput *YPwmInput::nextPwmInput(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPwmInput::FindPwmInput(hwid);
-}
-
-YPwmInput* YPwmInput::FirstPwmInput(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("PwmInput", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPwmInput::FindPwmInput(serial+"."+funcId);
-}
-
-//--- (end of YPwmInput implementation)
-
-//--- (YPwmInput functions)
-//--- (end of YPwmInput functions)
--- a/Sources/cpplib/yocto_pwminput.h
+++ /dev/null
@@ -1,454 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwminput.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindPwmInput(), the high-level API for PwmInput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_PWMINPUT_H
-#define YOCTO_PWMINPUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPwmInput return codes)
-//--- (end of YPwmInput return codes)
-//--- (YPwmInput yapiwrapper)
-//--- (end of YPwmInput yapiwrapper)
-//--- (YPwmInput definitions)
-class YPwmInput; // forward declaration
-
-typedef void (*YPwmInputValueCallback)(YPwmInput *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YPwmInputTimedReportCallback)(YPwmInput *func, YMeasure measure);
-#ifndef _Y_PWMREPORTMODE_ENUM
-#define _Y_PWMREPORTMODE_ENUM
-typedef enum {
-    Y_PWMREPORTMODE_PWM_DUTYCYCLE = 0,
-    Y_PWMREPORTMODE_PWM_FREQUENCY = 1,
-    Y_PWMREPORTMODE_PWM_PULSEDURATION = 2,
-    Y_PWMREPORTMODE_PWM_EDGECOUNT = 3,
-    Y_PWMREPORTMODE_PWM_PULSECOUNT = 4,
-    Y_PWMREPORTMODE_PWM_CPS = 5,
-    Y_PWMREPORTMODE_PWM_CPM = 6,
-    Y_PWMREPORTMODE_PWM_STATE = 7,
-    Y_PWMREPORTMODE_PWM_FREQ_CPS = 8,
-    Y_PWMREPORTMODE_PWM_FREQ_CPM = 9,
-    Y_PWMREPORTMODE_INVALID = -1,
-} Y_PWMREPORTMODE_enum;
-#endif
-#define Y_DUTYCYCLE_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_PULSEDURATION_INVALID         (YAPI_INVALID_DOUBLE)
-#define Y_FREQUENCY_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_PERIOD_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_PULSECOUNTER_INVALID          (YAPI_INVALID_LONG)
-#define Y_PULSETIMER_INVALID            (YAPI_INVALID_LONG)
-#define Y_DEBOUNCEPERIOD_INVALID        (YAPI_INVALID_UINT)
-//--- (end of YPwmInput definitions)
-
-//--- (YPwmInput declaration)
-/**
- * YPwmInput Class: PwmInput function interface
- *
- * The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- * This class adds the ability to configure the signal parameter used to transmit
- * information: the duty cycle, the frequency or the pulse width.
- */
-class YOCTO_CLASS_EXPORT YPwmInput: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPwmInput declaration)
-protected:
-    //--- (YPwmInput attributes)
-    // Attributes (function value cache)
-    double          _dutyCycle;
-    double          _pulseDuration;
-    double          _frequency;
-    double          _period;
-    s64             _pulseCounter;
-    s64             _pulseTimer;
-    Y_PWMREPORTMODE_enum _pwmReportMode;
-    int             _debouncePeriod;
-    YPwmInputValueCallback _valueCallbackPwmInput;
-    YPwmInputTimedReportCallback _timedReportCallbackPwmInput;
-
-    friend YPwmInput *yFindPwmInput(const string& func);
-    friend YPwmInput *yFirstPwmInput(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPwmInput factory function to instantiate
-    YPwmInput(const string& func);
-    //--- (end of YPwmInput attributes)
-
-public:
-    virtual ~YPwmInput();
-    //--- (YPwmInput accessors declaration)
-
-    static const double DUTYCYCLE_INVALID;
-    static const double PULSEDURATION_INVALID;
-    static const double FREQUENCY_INVALID;
-    static const double PERIOD_INVALID;
-    static const s64 PULSECOUNTER_INVALID = YAPI_INVALID_LONG;
-    static const s64 PULSETIMER_INVALID = YAPI_INVALID_LONG;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_DUTYCYCLE = Y_PWMREPORTMODE_PWM_DUTYCYCLE;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_FREQUENCY = Y_PWMREPORTMODE_PWM_FREQUENCY;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_PULSEDURATION = Y_PWMREPORTMODE_PWM_PULSEDURATION;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_EDGECOUNT = Y_PWMREPORTMODE_PWM_EDGECOUNT;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_PULSECOUNT = Y_PWMREPORTMODE_PWM_PULSECOUNT;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_CPS = Y_PWMREPORTMODE_PWM_CPS;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_CPM = Y_PWMREPORTMODE_PWM_CPM;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_STATE = Y_PWMREPORTMODE_PWM_STATE;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_FREQ_CPS = Y_PWMREPORTMODE_PWM_FREQ_CPS;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_PWM_FREQ_CPM = Y_PWMREPORTMODE_PWM_FREQ_CPM;
-    static const Y_PWMREPORTMODE_enum PWMREPORTMODE_INVALID = Y_PWMREPORTMODE_INVALID;
-    static const int DEBOUNCEPERIOD_INVALID = YAPI_INVALID_UINT;
-
-    /**
-     * Changes the measuring unit for the measured quantity. That unit
-     * is just a string which is automatically initialized each time
-     * the measurement mode is changed. But is can be set to an
-     * arbitrary value.
-     *
-     * @param newval : a string corresponding to the measuring unit for the measured quantity
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the PWM duty cycle, in per cents.
-     *
-     * @return a floating point number corresponding to the PWM duty cycle, in per cents
-     *
-     * On failure, throws an exception or returns Y_DUTYCYCLE_INVALID.
-     */
-    double              get_dutyCycle(void);
-
-    inline double       dutyCycle(void)
-    { return this->get_dutyCycle(); }
-
-    /**
-     * Returns the PWM pulse length in milliseconds, as a floating point number.
-     *
-     * @return a floating point number corresponding to the PWM pulse length in milliseconds, as a
-     * floating point number
-     *
-     * On failure, throws an exception or returns Y_PULSEDURATION_INVALID.
-     */
-    double              get_pulseDuration(void);
-
-    inline double       pulseDuration(void)
-    { return this->get_pulseDuration(); }
-
-    /**
-     * Returns the PWM frequency in Hz.
-     *
-     * @return a floating point number corresponding to the PWM frequency in Hz
-     *
-     * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
-     */
-    double              get_frequency(void);
-
-    inline double       frequency(void)
-    { return this->get_frequency(); }
-
-    /**
-     * Returns the PWM period in milliseconds.
-     *
-     * @return a floating point number corresponding to the PWM period in milliseconds
-     *
-     * On failure, throws an exception or returns Y_PERIOD_INVALID.
-     */
-    double              get_period(void);
-
-    inline double       period(void)
-    { return this->get_period(); }
-
-    /**
-     * Returns the pulse counter value. Actually that
-     * counter is incremented twice per period. That counter is
-     * limited  to 1 billion.
-     *
-     * @return an integer corresponding to the pulse counter value
-     *
-     * On failure, throws an exception or returns Y_PULSECOUNTER_INVALID.
-     */
-    s64                 get_pulseCounter(void);
-
-    inline s64          pulseCounter(void)
-    { return this->get_pulseCounter(); }
-
-    int             set_pulseCounter(s64 newval);
-    inline int      setPulseCounter(s64 newval)
-    { return this->set_pulseCounter(newval); }
-
-    /**
-     * Returns the timer of the pulses counter (ms).
-     *
-     * @return an integer corresponding to the timer of the pulses counter (ms)
-     *
-     * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
-     */
-    s64                 get_pulseTimer(void);
-
-    inline s64          pulseTimer(void)
-    { return this->get_pulseTimer(); }
-
-    /**
-     * Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the
-     * get_currentValue function and callbacks. Attention
-     *
-     * @return a value among Y_PWMREPORTMODE_PWM_DUTYCYCLE, Y_PWMREPORTMODE_PWM_FREQUENCY,
-     * Y_PWMREPORTMODE_PWM_PULSEDURATION, Y_PWMREPORTMODE_PWM_EDGECOUNT, Y_PWMREPORTMODE_PWM_PULSECOUNT,
-     * Y_PWMREPORTMODE_PWM_CPS, Y_PWMREPORTMODE_PWM_CPM, Y_PWMREPORTMODE_PWM_STATE,
-     * Y_PWMREPORTMODE_PWM_FREQ_CPS and Y_PWMREPORTMODE_PWM_FREQ_CPM corresponding to the parameter
-     * (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks
-     *
-     * On failure, throws an exception or returns Y_PWMREPORTMODE_INVALID.
-     */
-    Y_PWMREPORTMODE_enum get_pwmReportMode(void);
-
-    inline Y_PWMREPORTMODE_enum pwmReportMode(void)
-    { return this->get_pwmReportMode(); }
-
-    /**
-     * Changes the  parameter  type (frequency/duty cycle, pulse width, or edge count) returned by the
-     * get_currentValue function and callbacks.
-     * The edge count value is limited to the 6 lowest digits. For values greater than one million, use
-     * get_pulseCounter().
-     *
-     * @param newval : a value among Y_PWMREPORTMODE_PWM_DUTYCYCLE, Y_PWMREPORTMODE_PWM_FREQUENCY,
-     * Y_PWMREPORTMODE_PWM_PULSEDURATION, Y_PWMREPORTMODE_PWM_EDGECOUNT, Y_PWMREPORTMODE_PWM_PULSECOUNT,
-     * Y_PWMREPORTMODE_PWM_CPS, Y_PWMREPORTMODE_PWM_CPM, Y_PWMREPORTMODE_PWM_STATE,
-     * Y_PWMREPORTMODE_PWM_FREQ_CPS and Y_PWMREPORTMODE_PWM_FREQ_CPM corresponding to the  parameter  type
-     * (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pwmReportMode(Y_PWMREPORTMODE_enum newval);
-    inline int      setPwmReportMode(Y_PWMREPORTMODE_enum newval)
-    { return this->set_pwmReportMode(newval); }
-
-    /**
-     * Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).
-     *
-     * @return an integer corresponding to the shortest expected pulse duration, in ms
-     *
-     * On failure, throws an exception or returns Y_DEBOUNCEPERIOD_INVALID.
-     */
-    int                 get_debouncePeriod(void);
-
-    inline int          debouncePeriod(void)
-    { return this->get_debouncePeriod(); }
-
-    /**
-     * Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).
-     *
-     * @param newval : an integer corresponding to the shortest expected pulse duration, in ms
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_debouncePeriod(int newval);
-    inline int      setDebouncePeriod(int newval)
-    { return this->set_debouncePeriod(newval); }
-
-    /**
-     * Retrieves a PWM input for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the PWM input is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPwmInput.isOnline() to test if the PWM input is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a PWM input by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the PWM input
-     *
-     * @return a YPwmInput object allowing you to drive the PWM input.
-     */
-    static YPwmInput*   FindPwmInput(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPwmInputValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YPwmInputTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Returns the pulse counter value as well as its timer.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetCounter(void);
-
-
-    inline static YPwmInput* Find(string func)
-    { return YPwmInput::FindPwmInput(func); }
-
-    /**
-     * Continues the enumeration of PWM inputs started using yFirstPwmInput().
-     * Caution: You can't make any assumption about the returned PWM inputs order.
-     * If you want to find a specific a PWM input, use PwmInput.findPwmInput()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPwmInput object, corresponding to
-     *         a PWM input currently online, or a NULL pointer
-     *         if there are no more PWM inputs to enumerate.
-     */
-           YPwmInput       *nextPwmInput(void);
-    inline YPwmInput       *next(void)
-    { return this->nextPwmInput();}
-
-    /**
-     * Starts the enumeration of PWM inputs currently accessible.
-     * Use the method YPwmInput.nextPwmInput() to iterate on
-     * next PWM inputs.
-     *
-     * @return a pointer to a YPwmInput object, corresponding to
-     *         the first PWM input currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPwmInput* FirstPwmInput(void);
-    inline static YPwmInput* First(void)
-    { return YPwmInput::FirstPwmInput();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPwmInput accessors declaration)
-};
-
-//--- (YPwmInput functions declaration)
-
-/**
- * Retrieves a PWM input for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the PWM input is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmInput.isOnline() to test if the PWM input is
- * indeed online at a given time. In case of ambiguity when looking for
- * a PWM input by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the PWM input
- *
- * @return a YPwmInput object allowing you to drive the PWM input.
- */
-inline YPwmInput* yFindPwmInput(const string& func)
-{ return YPwmInput::FindPwmInput(func);}
-/**
- * Starts the enumeration of PWM inputs currently accessible.
- * Use the method YPwmInput.nextPwmInput() to iterate on
- * next PWM inputs.
- *
- * @return a pointer to a YPwmInput object, corresponding to
- *         the first PWM input currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPwmInput* yFirstPwmInput(void)
-{ return YPwmInput::FirstPwmInput();}
-
-//--- (end of YPwmInput functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_pwmoutput.cpp
+++ /dev/null
@@ -1,824 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwmoutput.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindPwmOutput(), the high-level API for PwmOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_pwmoutput.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "pwmoutput"
-
-YPwmOutput::YPwmOutput(const string& func): YFunction(func)
-//--- (YPwmOutput initialization)
-    ,_enabled(ENABLED_INVALID)
-    ,_frequency(FREQUENCY_INVALID)
-    ,_period(PERIOD_INVALID)
-    ,_dutyCycle(DUTYCYCLE_INVALID)
-    ,_pulseDuration(PULSEDURATION_INVALID)
-    ,_pwmTransition(PWMTRANSITION_INVALID)
-    ,_enabledAtPowerOn(ENABLEDATPOWERON_INVALID)
-    ,_dutyCycleAtPowerOn(DUTYCYCLEATPOWERON_INVALID)
-    ,_valueCallbackPwmOutput(NULL)
-//--- (end of YPwmOutput initialization)
-{
-    _className="PwmOutput";
-}
-
-YPwmOutput::~YPwmOutput()
-{
-//--- (YPwmOutput cleanup)
-//--- (end of YPwmOutput cleanup)
-}
-//--- (YPwmOutput implementation)
-// static attributes
-const double YPwmOutput::FREQUENCY_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmOutput::PERIOD_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmOutput::DUTYCYCLE_INVALID = YAPI_INVALID_DOUBLE;
-const double YPwmOutput::PULSEDURATION_INVALID = YAPI_INVALID_DOUBLE;
-const string YPwmOutput::PWMTRANSITION_INVALID = YAPI_INVALID_STRING;
-const double YPwmOutput::DUTYCYCLEATPOWERON_INVALID = YAPI_INVALID_DOUBLE;
-
-int YPwmOutput::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    if(json_val->has("frequency")) {
-        _frequency =  floor(json_val->getDouble("frequency") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("period")) {
-        _period =  floor(json_val->getDouble("period") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("dutyCycle")) {
-        _dutyCycle =  floor(json_val->getDouble("dutyCycle") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("pulseDuration")) {
-        _pulseDuration =  floor(json_val->getDouble("pulseDuration") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("pwmTransition")) {
-        _pwmTransition =  json_val->getString("pwmTransition");
-    }
-    if(json_val->has("enabledAtPowerOn")) {
-        _enabledAtPowerOn =  (Y_ENABLEDATPOWERON_enum)json_val->getInt("enabledAtPowerOn");
-    }
-    if(json_val->has("dutyCycleAtPowerOn")) {
-        _dutyCycleAtPowerOn =  floor(json_val->getDouble("dutyCycleAtPowerOn") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the state of the PWMs.
- *
- * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the state of the PWMs
- *
- * On failure, throws an exception or returns Y_ENABLED_INVALID.
- */
-Y_ENABLED_enum YPwmOutput::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Stops or starts the PWM.
- *
- * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM frequency. The duty cycle is kept unchanged thanks to an
- * automatic pulse width change, in other words, the change will not be applied
- * before the end of the current period. This can significantly affect reaction
- * time at low frequencies.
- * To stop the PWM signal, do not set the frequency to zero, use the set_enabled()
- * method instead.
- *
- * @param newval : a floating point number corresponding to the PWM frequency
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_frequency(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("frequency", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM frequency in Hz.
- *
- * @return a floating point number corresponding to the PWM frequency in Hz
- *
- * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
- */
-double YPwmOutput::get_frequency(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::FREQUENCY_INVALID;
-                }
-            }
-        }
-        res = _frequency;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM period in milliseconds. Caution: in order to avoid  random truncation of
- * the current pulse, the change will not be applied
- * before the end of the current period. This can significantly affect reaction
- * time at low frequencies.
- *
- * @param newval : a floating point number corresponding to the PWM period in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_period(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("period", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM period in milliseconds.
- *
- * @return a floating point number corresponding to the PWM period in milliseconds
- *
- * On failure, throws an exception or returns Y_PERIOD_INVALID.
- */
-double YPwmOutput::get_period(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::PERIOD_INVALID;
-                }
-            }
-        }
-        res = _period;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM duty cycle, in per cents.
- *
- * @param newval : a floating point number corresponding to the PWM duty cycle, in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_dutyCycle(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("dutyCycle", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM duty cycle, in per cents.
- *
- * @return a floating point number corresponding to the PWM duty cycle, in per cents
- *
- * On failure, throws an exception or returns Y_DUTYCYCLE_INVALID.
- */
-double YPwmOutput::get_dutyCycle(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::DUTYCYCLE_INVALID;
-                }
-            }
-        }
-        res = _dutyCycle;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period,
- * otherwise it is truncated.
- *
- * @param newval : a floating point number corresponding to the PWM pulse length, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_pulseDuration(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("pulseDuration", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWM pulse length in milliseconds, as a floating point number.
- *
- * @return a floating point number corresponding to the PWM pulse length in milliseconds, as a
- * floating point number
- *
- * On failure, throws an exception or returns Y_PULSEDURATION_INVALID.
- */
-double YPwmOutput::get_pulseDuration(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::PULSEDURATION_INVALID;
-                }
-            }
-        }
-        res = _pulseDuration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YPwmOutput::get_pwmTransition(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::PWMTRANSITION_INVALID;
-                }
-            }
-        }
-        res = _pwmTransition;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YPwmOutput::set_pwmTransition(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("pwmTransition", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the PWM at device power on.
- *
- * @return either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the state of the
- * PWM at device power on
- *
- * On failure, throws an exception or returns Y_ENABLEDATPOWERON_INVALID.
- */
-Y_ENABLEDATPOWERON_enum YPwmOutput::get_enabledAtPowerOn(void)
-{
-    Y_ENABLEDATPOWERON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::ENABLEDATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _enabledAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the PWM at device power on. Remember to call the matching module saveToFlash()
- * method, otherwise this call will have no effect.
- *
- * @param newval : either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the state
- * of the PWM at device power on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabledAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the PWM duty cycle at device power on. Remember to call the matching
- * module saveToFlash() method, otherwise this call will have no effect.
- *
- * @param newval : a floating point number corresponding to the PWM duty cycle at device power on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::set_dutyCycleAtPowerOn(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("dutyCycleAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.
- *
- * @return a floating point number corresponding to the PWMs duty cycle at device power on as a
- * floating point number between 0 and 100
- *
- * On failure, throws an exception or returns Y_DUTYCYCLEATPOWERON_INVALID.
- */
-double YPwmOutput::get_dutyCycleAtPowerOn(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmOutput::DUTYCYCLEATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _dutyCycleAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a PWM for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the PWM is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmOutput.isOnline() to test if the PWM is
- * indeed online at a given time. In case of ambiguity when looking for
- * a PWM by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the PWM
- *
- * @return a YPwmOutput object allowing you to drive the PWM.
- */
-YPwmOutput* YPwmOutput::FindPwmOutput(string func)
-{
-    YPwmOutput* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPwmOutput*) YFunction::_FindFromCache("PwmOutput", func);
-        if (obj == NULL) {
-            obj = new YPwmOutput(func);
-            YFunction::_AddToCache("PwmOutput", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPwmOutput::registerValueCallback(YPwmOutputValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPwmOutput = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPwmOutput::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPwmOutput != NULL) {
-        _valueCallbackPwmOutput(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Performs a smooth transition of the pulse duration toward a given value.
- * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
- *
- * @param ms_target   : new pulse duration at the end of the transition
- *         (floating-point number, representing the pulse duration in milliseconds)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::pulseDurationMove(double ms_target,int ms_duration)
-{
-    string newval;
-    if (ms_target < 0.0) {
-        ms_target = 0.0;
-    }
-    newval = YapiWrapper::ysprintf("%dms:%d", (int) floor(ms_target*65536+0.5),ms_duration);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Performs a smooth change of the duty cycle toward a given value.
- * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
- *
- * @param target      : new duty cycle at the end of the transition
- *         (percentage, floating-point number between 0 and 100)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::dutyCycleMove(double target,int ms_duration)
-{
-    string newval;
-    if (target < 0.0) {
-        target = 0.0;
-    }
-    if (target > 100.0) {
-        target = 100.0;
-    }
-    newval = YapiWrapper::ysprintf("%d:%d", (int) floor(target*65536+0.5),ms_duration);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Performs a smooth frequency change toward a given value.
- * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
- *
- * @param target      : new frequency at the end of the transition (floating-point number)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::frequencyMove(double target,int ms_duration)
-{
-    string newval;
-    if (target < 0.001) {
-        target = 0.001;
-    }
-    newval = YapiWrapper::ysprintf("%gHz:%d", target,ms_duration);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Performs a smooth transition toward a specified value of the phase shift between this channel
- * and the other channel. The phase shift is executed by slightly changing the frequency
- * temporarily during the specified duration. This function only makes sense when both channels
- * are running, either at the same frequency, or at a multiple of the channel frequency.
- * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
- *
- * @param target      : phase shift at the end of the transition, in milliseconds (floating-point number)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::phaseMove(double target,int ms_duration)
-{
-    string newval;
-    newval = YapiWrapper::ysprintf("%gps:%d", target,ms_duration);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Trigger a given number of pulses of specified duration, at current frequency.
- * At the end of the pulse train, revert to the original state of the PWM generator.
- *
- * @param ms_target : desired pulse duration
- *         (floating-point number, representing the pulse duration in milliseconds)
- * @param n_pulses  : desired pulse count
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::triggerPulsesByDuration(double ms_target,int n_pulses)
-{
-    string newval;
-    if (ms_target < 0.0) {
-        ms_target = 0.0;
-    }
-    newval = YapiWrapper::ysprintf("%dms*%d", (int) floor(ms_target*65536+0.5),n_pulses);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Trigger a given number of pulses of specified duration, at current frequency.
- * At the end of the pulse train, revert to the original state of the PWM generator.
- *
- * @param target   : desired duty cycle for the generated pulses
- *         (percentage, floating-point number between 0 and 100)
- * @param n_pulses : desired pulse count
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::triggerPulsesByDutyCycle(double target,int n_pulses)
-{
-    string newval;
-    if (target < 0.0) {
-        target = 0.0;
-    }
-    if (target > 100.0) {
-        target = 100.0;
-    }
-    newval = YapiWrapper::ysprintf("%d*%d", (int) floor(target*65536+0.5),n_pulses);
-    return this->set_pwmTransition(newval);
-}
-
-/**
- * Trigger a given number of pulses at the specified frequency, using current duty cycle.
- * At the end of the pulse train, revert to the original state of the PWM generator.
- *
- * @param target   : desired frequency for the generated pulses (floating-point number)
- * @param n_pulses : desired pulse count
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmOutput::triggerPulsesByFrequency(double target,int n_pulses)
-{
-    string newval;
-    if (target < 0.001) {
-        target = 0.001;
-    }
-    newval = YapiWrapper::ysprintf("%gHz*%d", target,n_pulses);
-    return this->set_pwmTransition(newval);
-}
-
-int YPwmOutput::markForRepeat(void)
-{
-    return this->set_pwmTransition(":");
-}
-
-int YPwmOutput::repeatFromMark(void)
-{
-    return this->set_pwmTransition("R");
-}
-
-YPwmOutput *YPwmOutput::nextPwmOutput(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPwmOutput::FindPwmOutput(hwid);
-}
-
-YPwmOutput* YPwmOutput::FirstPwmOutput(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("PwmOutput", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPwmOutput::FindPwmOutput(serial+"."+funcId);
-}
-
-//--- (end of YPwmOutput implementation)
-
-//--- (YPwmOutput functions)
-//--- (end of YPwmOutput functions)
--- a/Sources/cpplib/yocto_pwmoutput.h
+++ /dev/null
@@ -1,559 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwmoutput.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindPwmOutput(), the high-level API for PwmOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_PWMOUTPUT_H
-#define YOCTO_PWMOUTPUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPwmOutput return codes)
-//--- (end of YPwmOutput return codes)
-//--- (YPwmOutput yapiwrapper)
-//--- (end of YPwmOutput yapiwrapper)
-//--- (YPwmOutput definitions)
-class YPwmOutput; // forward declaration
-
-typedef void (*YPwmOutputValueCallback)(YPwmOutput *func, const string& functionValue);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-#ifndef _Y_ENABLEDATPOWERON_ENUM
-#define _Y_ENABLEDATPOWERON_ENUM
-typedef enum {
-    Y_ENABLEDATPOWERON_FALSE = 0,
-    Y_ENABLEDATPOWERON_TRUE = 1,
-    Y_ENABLEDATPOWERON_INVALID = -1,
-} Y_ENABLEDATPOWERON_enum;
-#endif
-#define Y_FREQUENCY_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_PERIOD_INVALID                (YAPI_INVALID_DOUBLE)
-#define Y_DUTYCYCLE_INVALID             (YAPI_INVALID_DOUBLE)
-#define Y_PULSEDURATION_INVALID         (YAPI_INVALID_DOUBLE)
-#define Y_PWMTRANSITION_INVALID         (YAPI_INVALID_STRING)
-#define Y_DUTYCYCLEATPOWERON_INVALID    (YAPI_INVALID_DOUBLE)
-//--- (end of YPwmOutput definitions)
-
-//--- (YPwmOutput declaration)
-/**
- * YPwmOutput Class: PwmOutput function interface
- *
- * The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.
- */
-class YOCTO_CLASS_EXPORT YPwmOutput: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPwmOutput declaration)
-protected:
-    //--- (YPwmOutput attributes)
-    // Attributes (function value cache)
-    Y_ENABLED_enum  _enabled;
-    double          _frequency;
-    double          _period;
-    double          _dutyCycle;
-    double          _pulseDuration;
-    string          _pwmTransition;
-    Y_ENABLEDATPOWERON_enum _enabledAtPowerOn;
-    double          _dutyCycleAtPowerOn;
-    YPwmOutputValueCallback _valueCallbackPwmOutput;
-
-    friend YPwmOutput *yFindPwmOutput(const string& func);
-    friend YPwmOutput *yFirstPwmOutput(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPwmOutput factory function to instantiate
-    YPwmOutput(const string& func);
-    //--- (end of YPwmOutput attributes)
-
-public:
-    virtual ~YPwmOutput();
-    //--- (YPwmOutput accessors declaration)
-
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-    static const double FREQUENCY_INVALID;
-    static const double PERIOD_INVALID;
-    static const double DUTYCYCLE_INVALID;
-    static const double PULSEDURATION_INVALID;
-    static const string PWMTRANSITION_INVALID;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_FALSE = Y_ENABLEDATPOWERON_FALSE;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_TRUE = Y_ENABLEDATPOWERON_TRUE;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_INVALID = Y_ENABLEDATPOWERON_INVALID;
-    static const double DUTYCYCLEATPOWERON_INVALID;
-
-    /**
-     * Returns the state of the PWMs.
-     *
-     * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the state of the PWMs
-     *
-     * On failure, throws an exception or returns Y_ENABLED_INVALID.
-     */
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    /**
-     * Stops or starts the PWM.
-     *
-     * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Changes the PWM frequency. The duty cycle is kept unchanged thanks to an
-     * automatic pulse width change, in other words, the change will not be applied
-     * before the end of the current period. This can significantly affect reaction
-     * time at low frequencies.
-     * To stop the PWM signal, do not set the frequency to zero, use the set_enabled()
-     * method instead.
-     *
-     * @param newval : a floating point number corresponding to the PWM frequency
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_frequency(double newval);
-    inline int      setFrequency(double newval)
-    { return this->set_frequency(newval); }
-
-    /**
-     * Returns the PWM frequency in Hz.
-     *
-     * @return a floating point number corresponding to the PWM frequency in Hz
-     *
-     * On failure, throws an exception or returns Y_FREQUENCY_INVALID.
-     */
-    double              get_frequency(void);
-
-    inline double       frequency(void)
-    { return this->get_frequency(); }
-
-    /**
-     * Changes the PWM period in milliseconds. Caution: in order to avoid  random truncation of
-     * the current pulse, the change will not be applied
-     * before the end of the current period. This can significantly affect reaction
-     * time at low frequencies.
-     *
-     * @param newval : a floating point number corresponding to the PWM period in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_period(double newval);
-    inline int      setPeriod(double newval)
-    { return this->set_period(newval); }
-
-    /**
-     * Returns the PWM period in milliseconds.
-     *
-     * @return a floating point number corresponding to the PWM period in milliseconds
-     *
-     * On failure, throws an exception or returns Y_PERIOD_INVALID.
-     */
-    double              get_period(void);
-
-    inline double       period(void)
-    { return this->get_period(); }
-
-    /**
-     * Changes the PWM duty cycle, in per cents.
-     *
-     * @param newval : a floating point number corresponding to the PWM duty cycle, in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_dutyCycle(double newval);
-    inline int      setDutyCycle(double newval)
-    { return this->set_dutyCycle(newval); }
-
-    /**
-     * Returns the PWM duty cycle, in per cents.
-     *
-     * @return a floating point number corresponding to the PWM duty cycle, in per cents
-     *
-     * On failure, throws an exception or returns Y_DUTYCYCLE_INVALID.
-     */
-    double              get_dutyCycle(void);
-
-    inline double       dutyCycle(void)
-    { return this->get_dutyCycle(); }
-
-    /**
-     * Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period,
-     * otherwise it is truncated.
-     *
-     * @param newval : a floating point number corresponding to the PWM pulse length, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pulseDuration(double newval);
-    inline int      setPulseDuration(double newval)
-    { return this->set_pulseDuration(newval); }
-
-    /**
-     * Returns the PWM pulse length in milliseconds, as a floating point number.
-     *
-     * @return a floating point number corresponding to the PWM pulse length in milliseconds, as a
-     * floating point number
-     *
-     * On failure, throws an exception or returns Y_PULSEDURATION_INVALID.
-     */
-    double              get_pulseDuration(void);
-
-    inline double       pulseDuration(void)
-    { return this->get_pulseDuration(); }
-
-    string              get_pwmTransition(void);
-
-    inline string       pwmTransition(void)
-    { return this->get_pwmTransition(); }
-
-    int             set_pwmTransition(const string& newval);
-    inline int      setPwmTransition(const string& newval)
-    { return this->set_pwmTransition(newval); }
-
-    /**
-     * Returns the state of the PWM at device power on.
-     *
-     * @return either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the state of the
-     * PWM at device power on
-     *
-     * On failure, throws an exception or returns Y_ENABLEDATPOWERON_INVALID.
-     */
-    Y_ENABLEDATPOWERON_enum get_enabledAtPowerOn(void);
-
-    inline Y_ENABLEDATPOWERON_enum enabledAtPowerOn(void)
-    { return this->get_enabledAtPowerOn(); }
-
-    /**
-     * Changes the state of the PWM at device power on. Remember to call the matching module saveToFlash()
-     * method, otherwise this call will have no effect.
-     *
-     * @param newval : either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the state
-     * of the PWM at device power on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval);
-    inline int      setEnabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval)
-    { return this->set_enabledAtPowerOn(newval); }
-
-    /**
-     * Changes the PWM duty cycle at device power on. Remember to call the matching
-     * module saveToFlash() method, otherwise this call will have no effect.
-     *
-     * @param newval : a floating point number corresponding to the PWM duty cycle at device power on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_dutyCycleAtPowerOn(double newval);
-    inline int      setDutyCycleAtPowerOn(double newval)
-    { return this->set_dutyCycleAtPowerOn(newval); }
-
-    /**
-     * Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.
-     *
-     * @return a floating point number corresponding to the PWMs duty cycle at device power on as a
-     * floating point number between 0 and 100
-     *
-     * On failure, throws an exception or returns Y_DUTYCYCLEATPOWERON_INVALID.
-     */
-    double              get_dutyCycleAtPowerOn(void);
-
-    inline double       dutyCycleAtPowerOn(void)
-    { return this->get_dutyCycleAtPowerOn(); }
-
-    /**
-     * Retrieves a PWM for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the PWM is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPwmOutput.isOnline() to test if the PWM is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a PWM by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the PWM
-     *
-     * @return a YPwmOutput object allowing you to drive the PWM.
-     */
-    static YPwmOutput*  FindPwmOutput(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPwmOutputValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Performs a smooth transition of the pulse duration toward a given value.
-     * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
-     *
-     * @param ms_target   : new pulse duration at the end of the transition
-     *         (floating-point number, representing the pulse duration in milliseconds)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pulseDurationMove(double ms_target,int ms_duration);
-
-    /**
-     * Performs a smooth change of the duty cycle toward a given value.
-     * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
-     *
-     * @param target      : new duty cycle at the end of the transition
-     *         (percentage, floating-point number between 0 and 100)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         dutyCycleMove(double target,int ms_duration);
-
-    /**
-     * Performs a smooth frequency change toward a given value.
-     * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
-     *
-     * @param target      : new frequency at the end of the transition (floating-point number)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         frequencyMove(double target,int ms_duration);
-
-    /**
-     * Performs a smooth transition toward a specified value of the phase shift between this channel
-     * and the other channel. The phase shift is executed by slightly changing the frequency
-     * temporarily during the specified duration. This function only makes sense when both channels
-     * are running, either at the same frequency, or at a multiple of the channel frequency.
-     * Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.
-     *
-     * @param target      : phase shift at the end of the transition, in milliseconds (floating-point number)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         phaseMove(double target,int ms_duration);
-
-    /**
-     * Trigger a given number of pulses of specified duration, at current frequency.
-     * At the end of the pulse train, revert to the original state of the PWM generator.
-     *
-     * @param ms_target : desired pulse duration
-     *         (floating-point number, representing the pulse duration in milliseconds)
-     * @param n_pulses  : desired pulse count
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerPulsesByDuration(double ms_target,int n_pulses);
-
-    /**
-     * Trigger a given number of pulses of specified duration, at current frequency.
-     * At the end of the pulse train, revert to the original state of the PWM generator.
-     *
-     * @param target   : desired duty cycle for the generated pulses
-     *         (percentage, floating-point number between 0 and 100)
-     * @param n_pulses : desired pulse count
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerPulsesByDutyCycle(double target,int n_pulses);
-
-    /**
-     * Trigger a given number of pulses at the specified frequency, using current duty cycle.
-     * At the end of the pulse train, revert to the original state of the PWM generator.
-     *
-     * @param target   : desired frequency for the generated pulses (floating-point number)
-     * @param n_pulses : desired pulse count
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerPulsesByFrequency(double target,int n_pulses);
-
-    virtual int         markForRepeat(void);
-
-    virtual int         repeatFromMark(void);
-
-
-    inline static YPwmOutput* Find(string func)
-    { return YPwmOutput::FindPwmOutput(func); }
-
-    /**
-     * Continues the enumeration of PWMs started using yFirstPwmOutput().
-     * Caution: You can't make any assumption about the returned PWMs order.
-     * If you want to find a specific a PWM, use PwmOutput.findPwmOutput()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPwmOutput object, corresponding to
-     *         a PWM currently online, or a NULL pointer
-     *         if there are no more PWMs to enumerate.
-     */
-           YPwmOutput      *nextPwmOutput(void);
-    inline YPwmOutput      *next(void)
-    { return this->nextPwmOutput();}
-
-    /**
-     * Starts the enumeration of PWMs currently accessible.
-     * Use the method YPwmOutput.nextPwmOutput() to iterate on
-     * next PWMs.
-     *
-     * @return a pointer to a YPwmOutput object, corresponding to
-     *         the first PWM currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPwmOutput* FirstPwmOutput(void);
-    inline static YPwmOutput* First(void)
-    { return YPwmOutput::FirstPwmOutput();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPwmOutput accessors declaration)
-};
-
-//--- (YPwmOutput functions declaration)
-
-/**
- * Retrieves a PWM for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the PWM is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmOutput.isOnline() to test if the PWM is
- * indeed online at a given time. In case of ambiguity when looking for
- * a PWM by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the PWM
- *
- * @return a YPwmOutput object allowing you to drive the PWM.
- */
-inline YPwmOutput* yFindPwmOutput(const string& func)
-{ return YPwmOutput::FindPwmOutput(func);}
-/**
- * Starts the enumeration of PWMs currently accessible.
- * Use the method YPwmOutput.nextPwmOutput() to iterate on
- * next PWMs.
- *
- * @return a pointer to a YPwmOutput object, corresponding to
- *         the first PWM currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPwmOutput* yFirstPwmOutput(void)
-{ return YPwmOutput::FirstPwmOutput();}
-
-//--- (end of YPwmOutput functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_pwmpowersource.cpp
+++ /dev/null
@@ -1,254 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwmpowersource.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindPwmPowerSource(), the high-level API for PwmPowerSource functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_pwmpowersource.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "pwmpowersource"
-
-YPwmPowerSource::YPwmPowerSource(const string& func): YFunction(func)
-//--- (YPwmPowerSource initialization)
-    ,_powerMode(POWERMODE_INVALID)
-    ,_valueCallbackPwmPowerSource(NULL)
-//--- (end of YPwmPowerSource initialization)
-{
-    _className="PwmPowerSource";
-}
-
-YPwmPowerSource::~YPwmPowerSource()
-{
-//--- (YPwmPowerSource cleanup)
-//--- (end of YPwmPowerSource cleanup)
-}
-//--- (YPwmPowerSource implementation)
-// static attributes
-
-int YPwmPowerSource::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("powerMode")) {
-        _powerMode =  (Y_POWERMODE_enum)json_val->getInt("powerMode");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the selected power source for the PWM on the same device.
- *
- * @return a value among Y_POWERMODE_USB_5V, Y_POWERMODE_USB_3V, Y_POWERMODE_EXT_V and
- * Y_POWERMODE_OPNDRN corresponding to the selected power source for the PWM on the same device
- *
- * On failure, throws an exception or returns Y_POWERMODE_INVALID.
- */
-Y_POWERMODE_enum YPwmPowerSource::get_powerMode(void)
-{
-    Y_POWERMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YPwmPowerSource::POWERMODE_INVALID;
-                }
-            }
-        }
-        res = _powerMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes  the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or
- * voltage from an external power source. The PWM can also work in open drain  mode. In that
- * mode, the PWM actively pulls the line down.
- * Warning: this setting is common to all PWM on the same device. If you change that parameter,
- * all PWM located on the same device are  affected.
- * If you want the change to be kept after a device reboot, make sure  to call the matching
- * module saveToFlash().
- *
- * @param newval : a value among Y_POWERMODE_USB_5V, Y_POWERMODE_USB_3V, Y_POWERMODE_EXT_V and
- * Y_POWERMODE_OPNDRN corresponding to  the PWM power source
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YPwmPowerSource::set_powerMode(Y_POWERMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("powerMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a voltage source for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage source is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmPowerSource.isOnline() to test if the voltage source is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage source by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage source
- *
- * @return a YPwmPowerSource object allowing you to drive the voltage source.
- */
-YPwmPowerSource* YPwmPowerSource::FindPwmPowerSource(string func)
-{
-    YPwmPowerSource* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YPwmPowerSource*) YFunction::_FindFromCache("PwmPowerSource", func);
-        if (obj == NULL) {
-            obj = new YPwmPowerSource(func);
-            YFunction::_AddToCache("PwmPowerSource", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YPwmPowerSource::registerValueCallback(YPwmPowerSourceValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackPwmPowerSource = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YPwmPowerSource::_invokeValueCallback(string value)
-{
-    if (_valueCallbackPwmPowerSource != NULL) {
-        _valueCallbackPwmPowerSource(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YPwmPowerSource *YPwmPowerSource::nextPwmPowerSource(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YPwmPowerSource::FindPwmPowerSource(hwid);
-}
-
-YPwmPowerSource* YPwmPowerSource::FirstPwmPowerSource(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("PwmPowerSource", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YPwmPowerSource::FindPwmPowerSource(serial+"."+funcId);
-}
-
-//--- (end of YPwmPowerSource implementation)
-
-//--- (YPwmPowerSource functions)
-//--- (end of YPwmPowerSource functions)
--- a/Sources/cpplib/yocto_pwmpowersource.h
+++ /dev/null
@@ -1,266 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_pwmpowersource.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindPwmPowerSource(), the high-level API for PwmPowerSource functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_PWMPOWERSOURCE_H
-#define YOCTO_PWMPOWERSOURCE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YPwmPowerSource return codes)
-//--- (end of YPwmPowerSource return codes)
-//--- (YPwmPowerSource yapiwrapper)
-//--- (end of YPwmPowerSource yapiwrapper)
-//--- (YPwmPowerSource definitions)
-class YPwmPowerSource; // forward declaration
-
-typedef void (*YPwmPowerSourceValueCallback)(YPwmPowerSource *func, const string& functionValue);
-#ifndef _Y_POWERMODE_ENUM
-#define _Y_POWERMODE_ENUM
-typedef enum {
-    Y_POWERMODE_USB_5V = 0,
-    Y_POWERMODE_USB_3V = 1,
-    Y_POWERMODE_EXT_V = 2,
-    Y_POWERMODE_OPNDRN = 3,
-    Y_POWERMODE_INVALID = -1,
-} Y_POWERMODE_enum;
-#endif
-//--- (end of YPwmPowerSource definitions)
-
-//--- (YPwmPowerSource declaration)
-/**
- * YPwmPowerSource Class: PwmPowerSource function interface
- *
- * The Yoctopuce application programming interface allows you to configure
- * the voltage source used by all PWM on the same device.
- */
-class YOCTO_CLASS_EXPORT YPwmPowerSource: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YPwmPowerSource declaration)
-protected:
-    //--- (YPwmPowerSource attributes)
-    // Attributes (function value cache)
-    Y_POWERMODE_enum _powerMode;
-    YPwmPowerSourceValueCallback _valueCallbackPwmPowerSource;
-
-    friend YPwmPowerSource *yFindPwmPowerSource(const string& func);
-    friend YPwmPowerSource *yFirstPwmPowerSource(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindPwmPowerSource factory function to instantiate
-    YPwmPowerSource(const string& func);
-    //--- (end of YPwmPowerSource attributes)
-
-public:
-    virtual ~YPwmPowerSource();
-    //--- (YPwmPowerSource accessors declaration)
-
-    static const Y_POWERMODE_enum POWERMODE_USB_5V = Y_POWERMODE_USB_5V;
-    static const Y_POWERMODE_enum POWERMODE_USB_3V = Y_POWERMODE_USB_3V;
-    static const Y_POWERMODE_enum POWERMODE_EXT_V = Y_POWERMODE_EXT_V;
-    static const Y_POWERMODE_enum POWERMODE_OPNDRN = Y_POWERMODE_OPNDRN;
-    static const Y_POWERMODE_enum POWERMODE_INVALID = Y_POWERMODE_INVALID;
-
-    /**
-     * Returns the selected power source for the PWM on the same device.
-     *
-     * @return a value among Y_POWERMODE_USB_5V, Y_POWERMODE_USB_3V, Y_POWERMODE_EXT_V and
-     * Y_POWERMODE_OPNDRN corresponding to the selected power source for the PWM on the same device
-     *
-     * On failure, throws an exception or returns Y_POWERMODE_INVALID.
-     */
-    Y_POWERMODE_enum    get_powerMode(void);
-
-    inline Y_POWERMODE_enum powerMode(void)
-    { return this->get_powerMode(); }
-
-    /**
-     * Changes  the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or
-     * voltage from an external power source. The PWM can also work in open drain  mode. In that
-     * mode, the PWM actively pulls the line down.
-     * Warning: this setting is common to all PWM on the same device. If you change that parameter,
-     * all PWM located on the same device are  affected.
-     * If you want the change to be kept after a device reboot, make sure  to call the matching
-     * module saveToFlash().
-     *
-     * @param newval : a value among Y_POWERMODE_USB_5V, Y_POWERMODE_USB_3V, Y_POWERMODE_EXT_V and
-     * Y_POWERMODE_OPNDRN corresponding to  the PWM power source
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_powerMode(Y_POWERMODE_enum newval);
-    inline int      setPowerMode(Y_POWERMODE_enum newval)
-    { return this->set_powerMode(newval); }
-
-    /**
-     * Retrieves a voltage source for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the voltage source is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YPwmPowerSource.isOnline() to test if the voltage source is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a voltage source by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the voltage source
-     *
-     * @return a YPwmPowerSource object allowing you to drive the voltage source.
-     */
-    static YPwmPowerSource* FindPwmPowerSource(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YPwmPowerSourceValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YPwmPowerSource* Find(string func)
-    { return YPwmPowerSource::FindPwmPowerSource(func); }
-
-    /**
-     * Continues the enumeration of Voltage sources started using yFirstPwmPowerSource().
-     * Caution: You can't make any assumption about the returned Voltage sources order.
-     * If you want to find a specific a voltage source, use PwmPowerSource.findPwmPowerSource()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YPwmPowerSource object, corresponding to
-     *         a voltage source currently online, or a NULL pointer
-     *         if there are no more Voltage sources to enumerate.
-     */
-           YPwmPowerSource *nextPwmPowerSource(void);
-    inline YPwmPowerSource *next(void)
-    { return this->nextPwmPowerSource();}
-
-    /**
-     * Starts the enumeration of Voltage sources currently accessible.
-     * Use the method YPwmPowerSource.nextPwmPowerSource() to iterate on
-     * next Voltage sources.
-     *
-     * @return a pointer to a YPwmPowerSource object, corresponding to
-     *         the first source currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YPwmPowerSource* FirstPwmPowerSource(void);
-    inline static YPwmPowerSource* First(void)
-    { return YPwmPowerSource::FirstPwmPowerSource();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YPwmPowerSource accessors declaration)
-};
-
-//--- (YPwmPowerSource functions declaration)
-
-/**
- * Retrieves a voltage source for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage source is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YPwmPowerSource.isOnline() to test if the voltage source is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage source by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage source
- *
- * @return a YPwmPowerSource object allowing you to drive the voltage source.
- */
-inline YPwmPowerSource* yFindPwmPowerSource(const string& func)
-{ return YPwmPowerSource::FindPwmPowerSource(func);}
-/**
- * Starts the enumeration of Voltage sources currently accessible.
- * Use the method YPwmPowerSource.nextPwmPowerSource() to iterate on
- * next Voltage sources.
- *
- * @return a pointer to a YPwmPowerSource object, corresponding to
- *         the first source currently online, or a NULL pointer
- *         if there are none.
- */
-inline YPwmPowerSource* yFirstPwmPowerSource(void)
-{ return YPwmPowerSource::FirstPwmPowerSource();}
-
-//--- (end of YPwmPowerSource functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_quadraturedecoder.cpp
+++ /dev/null
@@ -1,343 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_quadraturedecoder.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindQuadratureDecoder(), the high-level API for QuadratureDecoder functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_quadraturedecoder.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "quadraturedecoder"
-
-YQuadratureDecoder::YQuadratureDecoder(const string& func): YSensor(func)
-//--- (YQuadratureDecoder initialization)
-    ,_speed(SPEED_INVALID)
-    ,_decoding(DECODING_INVALID)
-    ,_valueCallbackQuadratureDecoder(NULL)
-    ,_timedReportCallbackQuadratureDecoder(NULL)
-//--- (end of YQuadratureDecoder initialization)
-{
-    _className="QuadratureDecoder";
-}
-
-YQuadratureDecoder::~YQuadratureDecoder()
-{
-//--- (YQuadratureDecoder cleanup)
-//--- (end of YQuadratureDecoder cleanup)
-}
-//--- (YQuadratureDecoder implementation)
-// static attributes
-const double YQuadratureDecoder::SPEED_INVALID = YAPI_INVALID_DOUBLE;
-
-int YQuadratureDecoder::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("speed")) {
-        _speed =  floor(json_val->getDouble("speed") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("decoding")) {
-        _decoding =  (Y_DECODING_enum)json_val->getInt("decoding");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the current expected position of the quadrature decoder.
- * Invoking this function implicitly activates the quadrature decoder.
- *
- * @param newval : a floating point number corresponding to the current expected position of the quadrature decoder
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YQuadratureDecoder::set_currentValue(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentValue", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the increments frequency, in Hz.
- *
- * @return a floating point number corresponding to the increments frequency, in Hz
- *
- * On failure, throws an exception or returns Y_SPEED_INVALID.
- */
-double YQuadratureDecoder::get_speed(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YQuadratureDecoder::SPEED_INVALID;
-                }
-            }
-        }
-        res = _speed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current activation state of the quadrature decoder.
- *
- * @return either Y_DECODING_OFF or Y_DECODING_ON, according to the current activation state of the
- * quadrature decoder
- *
- * On failure, throws an exception or returns Y_DECODING_INVALID.
- */
-Y_DECODING_enum YQuadratureDecoder::get_decoding(void)
-{
-    Y_DECODING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YQuadratureDecoder::DECODING_INVALID;
-                }
-            }
-        }
-        res = _decoding;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the activation state of the quadrature decoder.
- *
- * @param newval : either Y_DECODING_OFF or Y_DECODING_ON, according to the activation state of the
- * quadrature decoder
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YQuadratureDecoder::set_decoding(Y_DECODING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("decoding", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a quadrature decoder for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the quadrature decoder is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YQuadratureDecoder.isOnline() to test if the quadrature decoder is
- * indeed online at a given time. In case of ambiguity when looking for
- * a quadrature decoder by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the quadrature decoder
- *
- * @return a YQuadratureDecoder object allowing you to drive the quadrature decoder.
- */
-YQuadratureDecoder* YQuadratureDecoder::FindQuadratureDecoder(string func)
-{
-    YQuadratureDecoder* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YQuadratureDecoder*) YFunction::_FindFromCache("QuadratureDecoder", func);
-        if (obj == NULL) {
-            obj = new YQuadratureDecoder(func);
-            YFunction::_AddToCache("QuadratureDecoder", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YQuadratureDecoder::registerValueCallback(YQuadratureDecoderValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackQuadratureDecoder = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YQuadratureDecoder::_invokeValueCallback(string value)
-{
-    if (_valueCallbackQuadratureDecoder != NULL) {
-        _valueCallbackQuadratureDecoder(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YQuadratureDecoder::registerTimedReportCallback(YQuadratureDecoderTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackQuadratureDecoder = callback;
-    return 0;
-}
-
-int YQuadratureDecoder::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackQuadratureDecoder != NULL) {
-        _timedReportCallbackQuadratureDecoder(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YQuadratureDecoder *YQuadratureDecoder::nextQuadratureDecoder(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YQuadratureDecoder::FindQuadratureDecoder(hwid);
-}
-
-YQuadratureDecoder* YQuadratureDecoder::FirstQuadratureDecoder(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("QuadratureDecoder", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YQuadratureDecoder::FindQuadratureDecoder(serial+"."+funcId);
-}
-
-//--- (end of YQuadratureDecoder implementation)
-
-//--- (YQuadratureDecoder functions)
-//--- (end of YQuadratureDecoder functions)
--- a/Sources/cpplib/yocto_quadraturedecoder.h
+++ /dev/null
@@ -1,305 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_quadraturedecoder.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindQuadratureDecoder(), the high-level API for QuadratureDecoder functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_QUADRATUREDECODER_H
-#define YOCTO_QUADRATUREDECODER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YQuadratureDecoder return codes)
-//--- (end of YQuadratureDecoder return codes)
-//--- (YQuadratureDecoder yapiwrapper)
-//--- (end of YQuadratureDecoder yapiwrapper)
-//--- (YQuadratureDecoder definitions)
-class YQuadratureDecoder; // forward declaration
-
-typedef void (*YQuadratureDecoderValueCallback)(YQuadratureDecoder *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YQuadratureDecoderTimedReportCallback)(YQuadratureDecoder *func, YMeasure measure);
-#ifndef _Y_DECODING_ENUM
-#define _Y_DECODING_ENUM
-typedef enum {
-    Y_DECODING_OFF = 0,
-    Y_DECODING_ON = 1,
-    Y_DECODING_INVALID = -1,
-} Y_DECODING_enum;
-#endif
-#define Y_SPEED_INVALID                 (YAPI_INVALID_DOUBLE)
-//--- (end of YQuadratureDecoder definitions)
-
-//--- (YQuadratureDecoder declaration)
-/**
- * YQuadratureDecoder Class: QuadratureDecoder function interface
- *
- * The class YQuadratureDecoder allows you to decode a two-wire signal produced by a
- * quadrature encoder. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YQuadratureDecoder: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YQuadratureDecoder declaration)
-protected:
-    //--- (YQuadratureDecoder attributes)
-    // Attributes (function value cache)
-    double          _speed;
-    Y_DECODING_enum _decoding;
-    YQuadratureDecoderValueCallback _valueCallbackQuadratureDecoder;
-    YQuadratureDecoderTimedReportCallback _timedReportCallbackQuadratureDecoder;
-
-    friend YQuadratureDecoder *yFindQuadratureDecoder(const string& func);
-    friend YQuadratureDecoder *yFirstQuadratureDecoder(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindQuadratureDecoder factory function to instantiate
-    YQuadratureDecoder(const string& func);
-    //--- (end of YQuadratureDecoder attributes)
-
-public:
-    virtual ~YQuadratureDecoder();
-    //--- (YQuadratureDecoder accessors declaration)
-
-    static const double SPEED_INVALID;
-    static const Y_DECODING_enum DECODING_OFF = Y_DECODING_OFF;
-    static const Y_DECODING_enum DECODING_ON = Y_DECODING_ON;
-    static const Y_DECODING_enum DECODING_INVALID = Y_DECODING_INVALID;
-
-    /**
-     * Changes the current expected position of the quadrature decoder.
-     * Invoking this function implicitly activates the quadrature decoder.
-     *
-     * @param newval : a floating point number corresponding to the current expected position of the quadrature decoder
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentValue(double newval);
-    inline int      setCurrentValue(double newval)
-    { return this->set_currentValue(newval); }
-
-    /**
-     * Returns the increments frequency, in Hz.
-     *
-     * @return a floating point number corresponding to the increments frequency, in Hz
-     *
-     * On failure, throws an exception or returns Y_SPEED_INVALID.
-     */
-    double              get_speed(void);
-
-    inline double       speed(void)
-    { return this->get_speed(); }
-
-    /**
-     * Returns the current activation state of the quadrature decoder.
-     *
-     * @return either Y_DECODING_OFF or Y_DECODING_ON, according to the current activation state of the
-     * quadrature decoder
-     *
-     * On failure, throws an exception or returns Y_DECODING_INVALID.
-     */
-    Y_DECODING_enum     get_decoding(void);
-
-    inline Y_DECODING_enum decoding(void)
-    { return this->get_decoding(); }
-
-    /**
-     * Changes the activation state of the quadrature decoder.
-     *
-     * @param newval : either Y_DECODING_OFF or Y_DECODING_ON, according to the activation state of the
-     * quadrature decoder
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_decoding(Y_DECODING_enum newval);
-    inline int      setDecoding(Y_DECODING_enum newval)
-    { return this->set_decoding(newval); }
-
-    /**
-     * Retrieves a quadrature decoder for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the quadrature decoder is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YQuadratureDecoder.isOnline() to test if the quadrature decoder is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a quadrature decoder by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the quadrature decoder
-     *
-     * @return a YQuadratureDecoder object allowing you to drive the quadrature decoder.
-     */
-    static YQuadratureDecoder* FindQuadratureDecoder(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YQuadratureDecoderValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YQuadratureDecoderTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YQuadratureDecoder* Find(string func)
-    { return YQuadratureDecoder::FindQuadratureDecoder(func); }
-
-    /**
-     * Continues the enumeration of quadrature decoders started using yFirstQuadratureDecoder().
-     * Caution: You can't make any assumption about the returned quadrature decoders order.
-     * If you want to find a specific a quadrature decoder, use QuadratureDecoder.findQuadratureDecoder()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YQuadratureDecoder object, corresponding to
-     *         a quadrature decoder currently online, or a NULL pointer
-     *         if there are no more quadrature decoders to enumerate.
-     */
-           YQuadratureDecoder *nextQuadratureDecoder(void);
-    inline YQuadratureDecoder *next(void)
-    { return this->nextQuadratureDecoder();}
-
-    /**
-     * Starts the enumeration of quadrature decoders currently accessible.
-     * Use the method YQuadratureDecoder.nextQuadratureDecoder() to iterate on
-     * next quadrature decoders.
-     *
-     * @return a pointer to a YQuadratureDecoder object, corresponding to
-     *         the first quadrature decoder currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YQuadratureDecoder* FirstQuadratureDecoder(void);
-    inline static YQuadratureDecoder* First(void)
-    { return YQuadratureDecoder::FirstQuadratureDecoder();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YQuadratureDecoder accessors declaration)
-};
-
-//--- (YQuadratureDecoder functions declaration)
-
-/**
- * Retrieves a quadrature decoder for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the quadrature decoder is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YQuadratureDecoder.isOnline() to test if the quadrature decoder is
- * indeed online at a given time. In case of ambiguity when looking for
- * a quadrature decoder by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the quadrature decoder
- *
- * @return a YQuadratureDecoder object allowing you to drive the quadrature decoder.
- */
-inline YQuadratureDecoder* yFindQuadratureDecoder(const string& func)
-{ return YQuadratureDecoder::FindQuadratureDecoder(func);}
-/**
- * Starts the enumeration of quadrature decoders currently accessible.
- * Use the method YQuadratureDecoder.nextQuadratureDecoder() to iterate on
- * next quadrature decoders.
- *
- * @return a pointer to a YQuadratureDecoder object, corresponding to
- *         the first quadrature decoder currently online, or a NULL pointer
- *         if there are none.
- */
-inline YQuadratureDecoder* yFirstQuadratureDecoder(void)
-{ return YQuadratureDecoder::FirstQuadratureDecoder();}
-
-//--- (end of YQuadratureDecoder functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_rangefinder.cpp
+++ /dev/null
@@ -1,541 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_rangefinder.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindRangeFinder(), the high-level API for RangeFinder functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_rangefinder.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "rangefinder"
-
-YRangeFinder::YRangeFinder(const string& func): YSensor(func)
-//--- (YRangeFinder initialization)
-    ,_rangeFinderMode(RANGEFINDERMODE_INVALID)
-    ,_hardwareCalibration(HARDWARECALIBRATION_INVALID)
-    ,_currentTemperature(CURRENTTEMPERATURE_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackRangeFinder(NULL)
-    ,_timedReportCallbackRangeFinder(NULL)
-//--- (end of YRangeFinder initialization)
-{
-    _className="RangeFinder";
-}
-
-YRangeFinder::~YRangeFinder()
-{
-//--- (YRangeFinder cleanup)
-//--- (end of YRangeFinder cleanup)
-}
-//--- (YRangeFinder implementation)
-// static attributes
-const string YRangeFinder::HARDWARECALIBRATION_INVALID = YAPI_INVALID_STRING;
-const double YRangeFinder::CURRENTTEMPERATURE_INVALID = YAPI_INVALID_DOUBLE;
-const string YRangeFinder::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YRangeFinder::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("rangeFinderMode")) {
-        _rangeFinderMode =  (Y_RANGEFINDERMODE_enum)json_val->getInt("rangeFinderMode");
-    }
-    if(json_val->has("hardwareCalibration")) {
-        _hardwareCalibration =  json_val->getString("hardwareCalibration");
-    }
-    if(json_val->has("currentTemperature")) {
-        _currentTemperature =  floor(json_val->getDouble("currentTemperature") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the measured range. That unit is a string.
- * String value can be " or mm. Any other value is ignored.
- * Remember to call the saveToFlash() method of the module if the modification must be kept.
- * WARNING: if a specific calibration is defined for the rangeFinder function, a
- * unit system change will probably break it.
- *
- * @param newval : a string corresponding to the measuring unit for the measured range
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the range finder running mode. The rangefinder running mode
- * allows you to put priority on precision, speed or maximum range.
- *
- * @return a value among Y_RANGEFINDERMODE_DEFAULT, Y_RANGEFINDERMODE_LONG_RANGE,
- * Y_RANGEFINDERMODE_HIGH_ACCURACY and Y_RANGEFINDERMODE_HIGH_SPEED corresponding to the range finder running mode
- *
- * On failure, throws an exception or returns Y_RANGEFINDERMODE_INVALID.
- */
-Y_RANGEFINDERMODE_enum YRangeFinder::get_rangeFinderMode(void)
-{
-    Y_RANGEFINDERMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRangeFinder::RANGEFINDERMODE_INVALID;
-                }
-            }
-        }
-        res = _rangeFinderMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the rangefinder running mode, allowing you to put priority on
- * precision, speed or maximum range.
- *
- * @param newval : a value among Y_RANGEFINDERMODE_DEFAULT, Y_RANGEFINDERMODE_LONG_RANGE,
- * Y_RANGEFINDERMODE_HIGH_ACCURACY and Y_RANGEFINDERMODE_HIGH_SPEED corresponding to the rangefinder
- * running mode, allowing you to put priority on
- *         precision, speed or maximum range
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::set_rangeFinderMode(Y_RANGEFINDERMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("rangeFinderMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YRangeFinder::get_hardwareCalibration(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRangeFinder::HARDWARECALIBRATION_INVALID;
-                }
-            }
-        }
-        res = _hardwareCalibration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRangeFinder::set_hardwareCalibration(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("hardwareCalibration", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current sensor temperature, as a floating point number.
- *
- * @return a floating point number corresponding to the current sensor temperature, as a floating point number
- *
- * On failure, throws an exception or returns Y_CURRENTTEMPERATURE_INVALID.
- */
-double YRangeFinder::get_currentTemperature(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRangeFinder::CURRENTTEMPERATURE_INVALID;
-                }
-            }
-        }
-        res = _currentTemperature;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YRangeFinder::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRangeFinder::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRangeFinder::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a range finder for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the range finder is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRangeFinder.isOnline() to test if the range finder is
- * indeed online at a given time. In case of ambiguity when looking for
- * a range finder by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the range finder
- *
- * @return a YRangeFinder object allowing you to drive the range finder.
- */
-YRangeFinder* YRangeFinder::FindRangeFinder(string func)
-{
-    YRangeFinder* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YRangeFinder*) YFunction::_FindFromCache("RangeFinder", func);
-        if (obj == NULL) {
-            obj = new YRangeFinder(func);
-            YFunction::_AddToCache("RangeFinder", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YRangeFinder::registerValueCallback(YRangeFinderValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackRangeFinder = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YRangeFinder::_invokeValueCallback(string value)
-{
-    if (_valueCallbackRangeFinder != NULL) {
-        _valueCallbackRangeFinder(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YRangeFinder::registerTimedReportCallback(YRangeFinderTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackRangeFinder = callback;
-    return 0;
-}
-
-int YRangeFinder::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackRangeFinder != NULL) {
-        _timedReportCallbackRangeFinder(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Returns the temperature at the time when the latest calibration was performed.
- * This function can be used to determine if a new calibration for ambient temperature
- * is required.
- *
- * @return a temperature, as a floating point number.
- *         On failure, throws an exception or return YAPI_INVALID_DOUBLE.
- */
-double YRangeFinder::get_hardwareCalibrationTemperature(void)
-{
-    string hwcal;
-    hwcal = this->get_hardwareCalibration();
-    if (!((hwcal).substr(0, 1) == "@")) {
-        return YAPI_INVALID_DOUBLE;
-    }
-    return atoi(((hwcal).substr(1, (int)(hwcal).length())).c_str());
-}
-
-/**
- * Triggers a sensor calibration according to the current ambient temperature. That
- * calibration process needs no physical interaction with the sensor. It is performed
- * automatically at device startup, but it is recommended to start it again when the
- * temperature delta since the latest calibration exceeds 8°C.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::triggerTemperatureCalibration(void)
-{
-    return this->set_command("T");
-}
-
-/**
- * Triggers the photon detector hardware calibration.
- * This function is part of the calibration procedure to compensate for the the effect
- * of a cover glass. Make sure to read the chapter about hardware calibration for details
- * on the calibration procedure for proper results.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::triggerSpadCalibration(void)
-{
-    return this->set_command("S");
-}
-
-/**
- * Triggers the hardware offset calibration of the distance sensor.
- * This function is part of the calibration procedure to compensate for the the effect
- * of a cover glass. Make sure to read the chapter about hardware calibration for details
- * on the calibration procedure for proper results.
- *
- * @param targetDist : true distance of the calibration target, in mm or inches, depending
- *         on the unit selected in the device
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::triggerOffsetCalibration(double targetDist)
-{
-    int distmm = 0;
-    if (this->get_unit() == "\"") {
-        distmm = (int) floor(targetDist * 25.4+0.5);
-    } else {
-        distmm = (int) floor(targetDist+0.5);
-    }
-    return this->set_command(YapiWrapper::ysprintf("O%d",distmm));
-}
-
-/**
- * Triggers the hardware cross-talk calibration of the distance sensor.
- * This function is part of the calibration procedure to compensate for the the effect
- * of a cover glass. Make sure to read the chapter about hardware calibration for details
- * on the calibration procedure for proper results.
- *
- * @param targetDist : true distance of the calibration target, in mm or inches, depending
- *         on the unit selected in the device
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::triggerXTalkCalibration(double targetDist)
-{
-    int distmm = 0;
-    if (this->get_unit() == "\"") {
-        distmm = (int) floor(targetDist * 25.4+0.5);
-    } else {
-        distmm = (int) floor(targetDist+0.5);
-    }
-    return this->set_command(YapiWrapper::ysprintf("X%d",distmm));
-}
-
-/**
- * Cancels the effect of previous hardware calibration procedures to compensate
- * for cover glass, and restores factory settings.
- * Remember to call the saveToFlash() method of the module if the modification must be kept.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YRangeFinder::cancelCoverGlassCalibrations(void)
-{
-    return this->set_hardwareCalibration("");
-}
-
-YRangeFinder *YRangeFinder::nextRangeFinder(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YRangeFinder::FindRangeFinder(hwid);
-}
-
-YRangeFinder* YRangeFinder::FirstRangeFinder(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("RangeFinder", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YRangeFinder::FindRangeFinder(serial+"."+funcId);
-}
-
-//--- (end of YRangeFinder implementation)
-
-//--- (YRangeFinder functions)
-//--- (end of YRangeFinder functions)
--- a/Sources/cpplib/yocto_rangefinder.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_rangefinder.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindRangeFinder(), the high-level API for RangeFinder functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_RANGEFINDER_H
-#define YOCTO_RANGEFINDER_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YRangeFinder return codes)
-//--- (end of YRangeFinder return codes)
-//--- (YRangeFinder yapiwrapper)
-//--- (end of YRangeFinder yapiwrapper)
-//--- (YRangeFinder definitions)
-class YRangeFinder; // forward declaration
-
-typedef void (*YRangeFinderValueCallback)(YRangeFinder *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YRangeFinderTimedReportCallback)(YRangeFinder *func, YMeasure measure);
-#ifndef _Y_RANGEFINDERMODE_ENUM
-#define _Y_RANGEFINDERMODE_ENUM
-typedef enum {
-    Y_RANGEFINDERMODE_DEFAULT = 0,
-    Y_RANGEFINDERMODE_LONG_RANGE = 1,
-    Y_RANGEFINDERMODE_HIGH_ACCURACY = 2,
-    Y_RANGEFINDERMODE_HIGH_SPEED = 3,
-    Y_RANGEFINDERMODE_INVALID = -1,
-} Y_RANGEFINDERMODE_enum;
-#endif
-#define Y_HARDWARECALIBRATION_INVALID   (YAPI_INVALID_STRING)
-#define Y_CURRENTTEMPERATURE_INVALID    (YAPI_INVALID_DOUBLE)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YRangeFinder definitions)
-
-//--- (YRangeFinder declaration)
-/**
- * YRangeFinder Class: RangeFinder function interface
- *
- * The Yoctopuce class YRangeFinder allows you to use and configure Yoctopuce range finder
- * sensors. It inherits from the YSensor class the core functions to read measurements,
- * register callback functions, access the autonomous datalogger.
- * This class adds the ability to easily perform a one-point linear calibration
- * to compensate the effect of a glass or filter placed in front of the sensor.
- */
-class YOCTO_CLASS_EXPORT YRangeFinder: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YRangeFinder declaration)
-protected:
-    //--- (YRangeFinder attributes)
-    // Attributes (function value cache)
-    Y_RANGEFINDERMODE_enum _rangeFinderMode;
-    string          _hardwareCalibration;
-    double          _currentTemperature;
-    string          _command;
-    YRangeFinderValueCallback _valueCallbackRangeFinder;
-    YRangeFinderTimedReportCallback _timedReportCallbackRangeFinder;
-
-    friend YRangeFinder *yFindRangeFinder(const string& func);
-    friend YRangeFinder *yFirstRangeFinder(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindRangeFinder factory function to instantiate
-    YRangeFinder(const string& func);
-    //--- (end of YRangeFinder attributes)
-
-public:
-    virtual ~YRangeFinder();
-    //--- (YRangeFinder accessors declaration)
-
-    static const Y_RANGEFINDERMODE_enum RANGEFINDERMODE_DEFAULT = Y_RANGEFINDERMODE_DEFAULT;
-    static const Y_RANGEFINDERMODE_enum RANGEFINDERMODE_LONG_RANGE = Y_RANGEFINDERMODE_LONG_RANGE;
-    static const Y_RANGEFINDERMODE_enum RANGEFINDERMODE_HIGH_ACCURACY = Y_RANGEFINDERMODE_HIGH_ACCURACY;
-    static const Y_RANGEFINDERMODE_enum RANGEFINDERMODE_HIGH_SPEED = Y_RANGEFINDERMODE_HIGH_SPEED;
-    static const Y_RANGEFINDERMODE_enum RANGEFINDERMODE_INVALID = Y_RANGEFINDERMODE_INVALID;
-    static const string HARDWARECALIBRATION_INVALID;
-    static const double CURRENTTEMPERATURE_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the measuring unit for the measured range. That unit is a string.
-     * String value can be " or mm. Any other value is ignored.
-     * Remember to call the saveToFlash() method of the module if the modification must be kept.
-     * WARNING: if a specific calibration is defined for the rangeFinder function, a
-     * unit system change will probably break it.
-     *
-     * @param newval : a string corresponding to the measuring unit for the measured range
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the range finder running mode. The rangefinder running mode
-     * allows you to put priority on precision, speed or maximum range.
-     *
-     * @return a value among Y_RANGEFINDERMODE_DEFAULT, Y_RANGEFINDERMODE_LONG_RANGE,
-     * Y_RANGEFINDERMODE_HIGH_ACCURACY and Y_RANGEFINDERMODE_HIGH_SPEED corresponding to the range finder running mode
-     *
-     * On failure, throws an exception or returns Y_RANGEFINDERMODE_INVALID.
-     */
-    Y_RANGEFINDERMODE_enum get_rangeFinderMode(void);
-
-    inline Y_RANGEFINDERMODE_enum rangeFinderMode(void)
-    { return this->get_rangeFinderMode(); }
-
-    /**
-     * Changes the rangefinder running mode, allowing you to put priority on
-     * precision, speed or maximum range.
-     *
-     * @param newval : a value among Y_RANGEFINDERMODE_DEFAULT, Y_RANGEFINDERMODE_LONG_RANGE,
-     * Y_RANGEFINDERMODE_HIGH_ACCURACY and Y_RANGEFINDERMODE_HIGH_SPEED corresponding to the rangefinder
-     * running mode, allowing you to put priority on
-     *         precision, speed or maximum range
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_rangeFinderMode(Y_RANGEFINDERMODE_enum newval);
-    inline int      setRangeFinderMode(Y_RANGEFINDERMODE_enum newval)
-    { return this->set_rangeFinderMode(newval); }
-
-    string              get_hardwareCalibration(void);
-
-    inline string       hardwareCalibration(void)
-    { return this->get_hardwareCalibration(); }
-
-    int             set_hardwareCalibration(const string& newval);
-    inline int      setHardwareCalibration(const string& newval)
-    { return this->set_hardwareCalibration(newval); }
-
-    /**
-     * Returns the current sensor temperature, as a floating point number.
-     *
-     * @return a floating point number corresponding to the current sensor temperature, as a floating point number
-     *
-     * On failure, throws an exception or returns Y_CURRENTTEMPERATURE_INVALID.
-     */
-    double              get_currentTemperature(void);
-
-    inline double       currentTemperature(void)
-    { return this->get_currentTemperature(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a range finder for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the range finder is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YRangeFinder.isOnline() to test if the range finder is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a range finder by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the range finder
-     *
-     * @return a YRangeFinder object allowing you to drive the range finder.
-     */
-    static YRangeFinder* FindRangeFinder(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YRangeFinderValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YRangeFinderTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Returns the temperature at the time when the latest calibration was performed.
-     * This function can be used to determine if a new calibration for ambient temperature
-     * is required.
-     *
-     * @return a temperature, as a floating point number.
-     *         On failure, throws an exception or return YAPI_INVALID_DOUBLE.
-     */
-    virtual double      get_hardwareCalibrationTemperature(void);
-
-    /**
-     * Triggers a sensor calibration according to the current ambient temperature. That
-     * calibration process needs no physical interaction with the sensor. It is performed
-     * automatically at device startup, but it is recommended to start it again when the
-     * temperature delta since the latest calibration exceeds 8°C.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerTemperatureCalibration(void);
-
-    /**
-     * Triggers the photon detector hardware calibration.
-     * This function is part of the calibration procedure to compensate for the the effect
-     * of a cover glass. Make sure to read the chapter about hardware calibration for details
-     * on the calibration procedure for proper results.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerSpadCalibration(void);
-
-    /**
-     * Triggers the hardware offset calibration of the distance sensor.
-     * This function is part of the calibration procedure to compensate for the the effect
-     * of a cover glass. Make sure to read the chapter about hardware calibration for details
-     * on the calibration procedure for proper results.
-     *
-     * @param targetDist : true distance of the calibration target, in mm or inches, depending
-     *         on the unit selected in the device
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerOffsetCalibration(double targetDist);
-
-    /**
-     * Triggers the hardware cross-talk calibration of the distance sensor.
-     * This function is part of the calibration procedure to compensate for the the effect
-     * of a cover glass. Make sure to read the chapter about hardware calibration for details
-     * on the calibration procedure for proper results.
-     *
-     * @param targetDist : true distance of the calibration target, in mm or inches, depending
-     *         on the unit selected in the device
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         triggerXTalkCalibration(double targetDist);
-
-    /**
-     * Cancels the effect of previous hardware calibration procedures to compensate
-     * for cover glass, and restores factory settings.
-     * Remember to call the saveToFlash() method of the module if the modification must be kept.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         cancelCoverGlassCalibrations(void);
-
-
-    inline static YRangeFinder* Find(string func)
-    { return YRangeFinder::FindRangeFinder(func); }
-
-    /**
-     * Continues the enumeration of range finders started using yFirstRangeFinder().
-     * Caution: You can't make any assumption about the returned range finders order.
-     * If you want to find a specific a range finder, use RangeFinder.findRangeFinder()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YRangeFinder object, corresponding to
-     *         a range finder currently online, or a NULL pointer
-     *         if there are no more range finders to enumerate.
-     */
-           YRangeFinder    *nextRangeFinder(void);
-    inline YRangeFinder    *next(void)
-    { return this->nextRangeFinder();}
-
-    /**
-     * Starts the enumeration of range finders currently accessible.
-     * Use the method YRangeFinder.nextRangeFinder() to iterate on
-     * next range finders.
-     *
-     * @return a pointer to a YRangeFinder object, corresponding to
-     *         the first range finder currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YRangeFinder* FirstRangeFinder(void);
-    inline static YRangeFinder* First(void)
-    { return YRangeFinder::FirstRangeFinder();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YRangeFinder accessors declaration)
-};
-
-//--- (YRangeFinder functions declaration)
-
-/**
- * Retrieves a range finder for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the range finder is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRangeFinder.isOnline() to test if the range finder is
- * indeed online at a given time. In case of ambiguity when looking for
- * a range finder by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the range finder
- *
- * @return a YRangeFinder object allowing you to drive the range finder.
- */
-inline YRangeFinder* yFindRangeFinder(const string& func)
-{ return YRangeFinder::FindRangeFinder(func);}
-/**
- * Starts the enumeration of range finders currently accessible.
- * Use the method YRangeFinder.nextRangeFinder() to iterate on
- * next range finders.
- *
- * @return a pointer to a YRangeFinder object, corresponding to
- *         the first range finder currently online, or a NULL pointer
- *         if there are none.
- */
-inline YRangeFinder* yFirstRangeFinder(void)
-{ return YRangeFinder::FirstRangeFinder();}
-
-//--- (end of YRangeFinder functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_realtimeclock.cpp
+++ /dev/null
@@ -1,374 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_realtimeclock.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindRealTimeClock(), the high-level API for RealTimeClock functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_realtimeclock.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "realtimeclock"
-
-YRealTimeClock::YRealTimeClock(const string& func): YFunction(func)
-//--- (YRealTimeClock initialization)
-    ,_unixTime(UNIXTIME_INVALID)
-    ,_dateTime(DATETIME_INVALID)
-    ,_utcOffset(UTCOFFSET_INVALID)
-    ,_timeSet(TIMESET_INVALID)
-    ,_valueCallbackRealTimeClock(NULL)
-//--- (end of YRealTimeClock initialization)
-{
-    _className="RealTimeClock";
-}
-
-YRealTimeClock::~YRealTimeClock()
-{
-//--- (YRealTimeClock cleanup)
-//--- (end of YRealTimeClock cleanup)
-}
-//--- (YRealTimeClock implementation)
-// static attributes
-const string YRealTimeClock::DATETIME_INVALID = YAPI_INVALID_STRING;
-
-int YRealTimeClock::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("unixTime")) {
-        _unixTime =  json_val->getLong("unixTime");
-    }
-    if(json_val->has("dateTime")) {
-        _dateTime =  json_val->getString("dateTime");
-    }
-    if(json_val->has("utcOffset")) {
-        _utcOffset =  json_val->getInt("utcOffset");
-    }
-    if(json_val->has("timeSet")) {
-        _timeSet =  (Y_TIMESET_enum)json_val->getInt("timeSet");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).
- *
- * @return an integer corresponding to the current time in Unix format (number of elapsed seconds
- * since Jan 1st, 1970)
- *
- * On failure, throws an exception or returns Y_UNIXTIME_INVALID.
- */
-s64 YRealTimeClock::get_unixTime(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRealTimeClock::UNIXTIME_INVALID;
-                }
-            }
-        }
-        res = _unixTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).
- *
- * @param newval : an integer corresponding to the current time
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRealTimeClock::set_unixTime(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("unixTime", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current time in the form "YYYY/MM/DD hh:mm:ss".
- *
- * @return a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
- *
- * On failure, throws an exception or returns Y_DATETIME_INVALID.
- */
-string YRealTimeClock::get_dateTime(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRealTimeClock::DATETIME_INVALID;
-                }
-            }
-        }
-        res = _dateTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of seconds between current time and UTC time (time zone).
- *
- * @return an integer corresponding to the number of seconds between current time and UTC time (time zone)
- *
- * On failure, throws an exception or returns Y_UTCOFFSET_INVALID.
- */
-int YRealTimeClock::get_utcOffset(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRealTimeClock::UTCOFFSET_INVALID;
-                }
-            }
-        }
-        res = _utcOffset;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the number of seconds between current time and UTC time (time zone).
- * The timezone is automatically rounded to the nearest multiple of 15 minutes.
- *
- * @param newval : an integer corresponding to the number of seconds between current time and UTC time (time zone)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRealTimeClock::set_utcOffset(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("utcOffset", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true if the clock has been set, and false otherwise.
- *
- * @return either Y_TIMESET_FALSE or Y_TIMESET_TRUE, according to true if the clock has been set, and
- * false otherwise
- *
- * On failure, throws an exception or returns Y_TIMESET_INVALID.
- */
-Y_TIMESET_enum YRealTimeClock::get_timeSet(void)
-{
-    Y_TIMESET_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRealTimeClock::TIMESET_INVALID;
-                }
-            }
-        }
-        res = _timeSet;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a clock for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the clock is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRealTimeClock.isOnline() to test if the clock is
- * indeed online at a given time. In case of ambiguity when looking for
- * a clock by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the clock
- *
- * @return a YRealTimeClock object allowing you to drive the clock.
- */
-YRealTimeClock* YRealTimeClock::FindRealTimeClock(string func)
-{
-    YRealTimeClock* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YRealTimeClock*) YFunction::_FindFromCache("RealTimeClock", func);
-        if (obj == NULL) {
-            obj = new YRealTimeClock(func);
-            YFunction::_AddToCache("RealTimeClock", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YRealTimeClock::registerValueCallback(YRealTimeClockValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackRealTimeClock = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YRealTimeClock::_invokeValueCallback(string value)
-{
-    if (_valueCallbackRealTimeClock != NULL) {
-        _valueCallbackRealTimeClock(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YRealTimeClock *YRealTimeClock::nextRealTimeClock(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YRealTimeClock::FindRealTimeClock(hwid);
-}
-
-YRealTimeClock* YRealTimeClock::FirstRealTimeClock(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("RealTimeClock", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YRealTimeClock::FindRealTimeClock(serial+"."+funcId);
-}
-
-//--- (end of YRealTimeClock implementation)
-
-//--- (YRealTimeClock functions)
-//--- (end of YRealTimeClock functions)
--- a/Sources/cpplib/yocto_realtimeclock.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_realtimeclock.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindRealTimeClock(), the high-level API for RealTimeClock functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_REALTIMECLOCK_H
-#define YOCTO_REALTIMECLOCK_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YRealTimeClock return codes)
-//--- (end of YRealTimeClock return codes)
-//--- (YRealTimeClock yapiwrapper)
-//--- (end of YRealTimeClock yapiwrapper)
-//--- (YRealTimeClock definitions)
-class YRealTimeClock; // forward declaration
-
-typedef void (*YRealTimeClockValueCallback)(YRealTimeClock *func, const string& functionValue);
-#ifndef _Y_TIMESET_ENUM
-#define _Y_TIMESET_ENUM
-typedef enum {
-    Y_TIMESET_FALSE = 0,
-    Y_TIMESET_TRUE = 1,
-    Y_TIMESET_INVALID = -1,
-} Y_TIMESET_enum;
-#endif
-#define Y_UNIXTIME_INVALID              (YAPI_INVALID_LONG)
-#define Y_DATETIME_INVALID              (YAPI_INVALID_STRING)
-#define Y_UTCOFFSET_INVALID             (YAPI_INVALID_INT)
-//--- (end of YRealTimeClock definitions)
-
-//--- (YRealTimeClock declaration)
-/**
- * YRealTimeClock Class: Real Time Clock function interface
- *
- * The RealTimeClock function maintains and provides current date and time, even accross power cut
- * lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler.
- * The current time may represent a local time as well as an UTC time, but no automatic time change
- * will occur to account for daylight saving time.
- */
-class YOCTO_CLASS_EXPORT YRealTimeClock: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YRealTimeClock declaration)
-protected:
-    //--- (YRealTimeClock attributes)
-    // Attributes (function value cache)
-    s64             _unixTime;
-    string          _dateTime;
-    int             _utcOffset;
-    Y_TIMESET_enum  _timeSet;
-    YRealTimeClockValueCallback _valueCallbackRealTimeClock;
-
-    friend YRealTimeClock *yFindRealTimeClock(const string& func);
-    friend YRealTimeClock *yFirstRealTimeClock(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindRealTimeClock factory function to instantiate
-    YRealTimeClock(const string& func);
-    //--- (end of YRealTimeClock attributes)
-
-public:
-    virtual ~YRealTimeClock();
-    //--- (YRealTimeClock accessors declaration)
-
-    static const s64 UNIXTIME_INVALID = YAPI_INVALID_LONG;
-    static const string DATETIME_INVALID;
-    static const int UTCOFFSET_INVALID = YAPI_INVALID_INT;
-    static const Y_TIMESET_enum TIMESET_FALSE = Y_TIMESET_FALSE;
-    static const Y_TIMESET_enum TIMESET_TRUE = Y_TIMESET_TRUE;
-    static const Y_TIMESET_enum TIMESET_INVALID = Y_TIMESET_INVALID;
-
-    /**
-     * Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).
-     *
-     * @return an integer corresponding to the current time in Unix format (number of elapsed seconds
-     * since Jan 1st, 1970)
-     *
-     * On failure, throws an exception or returns Y_UNIXTIME_INVALID.
-     */
-    s64                 get_unixTime(void);
-
-    inline s64          unixTime(void)
-    { return this->get_unixTime(); }
-
-    /**
-     * Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).
-     *
-     * @param newval : an integer corresponding to the current time
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unixTime(s64 newval);
-    inline int      setUnixTime(s64 newval)
-    { return this->set_unixTime(newval); }
-
-    /**
-     * Returns the current time in the form "YYYY/MM/DD hh:mm:ss".
-     *
-     * @return a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
-     *
-     * On failure, throws an exception or returns Y_DATETIME_INVALID.
-     */
-    string              get_dateTime(void);
-
-    inline string       dateTime(void)
-    { return this->get_dateTime(); }
-
-    /**
-     * Returns the number of seconds between current time and UTC time (time zone).
-     *
-     * @return an integer corresponding to the number of seconds between current time and UTC time (time zone)
-     *
-     * On failure, throws an exception or returns Y_UTCOFFSET_INVALID.
-     */
-    int                 get_utcOffset(void);
-
-    inline int          utcOffset(void)
-    { return this->get_utcOffset(); }
-
-    /**
-     * Changes the number of seconds between current time and UTC time (time zone).
-     * The timezone is automatically rounded to the nearest multiple of 15 minutes.
-     *
-     * @param newval : an integer corresponding to the number of seconds between current time and UTC time (time zone)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_utcOffset(int newval);
-    inline int      setUtcOffset(int newval)
-    { return this->set_utcOffset(newval); }
-
-    /**
-     * Returns true if the clock has been set, and false otherwise.
-     *
-     * @return either Y_TIMESET_FALSE or Y_TIMESET_TRUE, according to true if the clock has been set, and
-     * false otherwise
-     *
-     * On failure, throws an exception or returns Y_TIMESET_INVALID.
-     */
-    Y_TIMESET_enum      get_timeSet(void);
-
-    inline Y_TIMESET_enum timeSet(void)
-    { return this->get_timeSet(); }
-
-    /**
-     * Retrieves a clock for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the clock is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YRealTimeClock.isOnline() to test if the clock is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a clock by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the clock
-     *
-     * @return a YRealTimeClock object allowing you to drive the clock.
-     */
-    static YRealTimeClock* FindRealTimeClock(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YRealTimeClockValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YRealTimeClock* Find(string func)
-    { return YRealTimeClock::FindRealTimeClock(func); }
-
-    /**
-     * Continues the enumeration of clocks started using yFirstRealTimeClock().
-     * Caution: You can't make any assumption about the returned clocks order.
-     * If you want to find a specific a clock, use RealTimeClock.findRealTimeClock()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YRealTimeClock object, corresponding to
-     *         a clock currently online, or a NULL pointer
-     *         if there are no more clocks to enumerate.
-     */
-           YRealTimeClock  *nextRealTimeClock(void);
-    inline YRealTimeClock  *next(void)
-    { return this->nextRealTimeClock();}
-
-    /**
-     * Starts the enumeration of clocks currently accessible.
-     * Use the method YRealTimeClock.nextRealTimeClock() to iterate on
-     * next clocks.
-     *
-     * @return a pointer to a YRealTimeClock object, corresponding to
-     *         the first clock currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YRealTimeClock* FirstRealTimeClock(void);
-    inline static YRealTimeClock* First(void)
-    { return YRealTimeClock::FirstRealTimeClock();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YRealTimeClock accessors declaration)
-};
-
-//--- (YRealTimeClock functions declaration)
-
-/**
- * Retrieves a clock for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the clock is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRealTimeClock.isOnline() to test if the clock is
- * indeed online at a given time. In case of ambiguity when looking for
- * a clock by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the clock
- *
- * @return a YRealTimeClock object allowing you to drive the clock.
- */
-inline YRealTimeClock* yFindRealTimeClock(const string& func)
-{ return YRealTimeClock::FindRealTimeClock(func);}
-/**
- * Starts the enumeration of clocks currently accessible.
- * Use the method YRealTimeClock.nextRealTimeClock() to iterate on
- * next clocks.
- *
- * @return a pointer to a YRealTimeClock object, corresponding to
- *         the first clock currently online, or a NULL pointer
- *         if there are none.
- */
-inline YRealTimeClock* yFirstRealTimeClock(void)
-{ return YRealTimeClock::FirstRealTimeClock();}
-
-//--- (end of YRealTimeClock functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_refframe.cpp
+++ /dev/null
@@ -1,1063 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_refframe.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindRefFrame(), the high-level API for RefFrame functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_refframe.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "refframe"
-
-YRefFrame::YRefFrame(const string& func): YFunction(func)
-//--- (YRefFrame initialization)
-    ,_mountPos(MOUNTPOS_INVALID)
-    ,_bearing(BEARING_INVALID)
-    ,_calibrationParam(CALIBRATIONPARAM_INVALID)
-    ,_fusionMode(FUSIONMODE_INVALID)
-    ,_valueCallbackRefFrame(NULL)
-    ,_calibV2(0)
-    ,_calibStage(0)
-    ,_calibStageProgress(0)
-    ,_calibProgress(0)
-    ,_calibCount(0)
-    ,_calibInternalPos(0)
-    ,_calibPrevTick(0)
-    ,_calibAccXOfs(0.0)
-    ,_calibAccYOfs(0.0)
-    ,_calibAccZOfs(0.0)
-    ,_calibAccXScale(0.0)
-    ,_calibAccYScale(0.0)
-    ,_calibAccZScale(0.0)
-//--- (end of YRefFrame initialization)
-{
-    _className="RefFrame";
-}
-
-YRefFrame::~YRefFrame()
-{
-//--- (YRefFrame cleanup)
-//--- (end of YRefFrame cleanup)
-}
-//--- (YRefFrame implementation)
-// static attributes
-const double YRefFrame::BEARING_INVALID = YAPI_INVALID_DOUBLE;
-const string YRefFrame::CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
-
-int YRefFrame::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("mountPos")) {
-        _mountPos =  json_val->getInt("mountPos");
-    }
-    if(json_val->has("bearing")) {
-        _bearing =  floor(json_val->getDouble("bearing") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("calibrationParam")) {
-        _calibrationParam =  json_val->getString("calibrationParam");
-    }
-    if(json_val->has("fusionMode")) {
-        _fusionMode =  (Y_FUSIONMODE_enum)json_val->getInt("fusionMode");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-int YRefFrame::get_mountPos(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRefFrame::MOUNTPOS_INVALID;
-                }
-            }
-        }
-        res = _mountPos;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRefFrame::set_mountPos(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("mountPos", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the reference bearing used by the compass. The relative bearing
- * indicated by the compass is the difference between the measured magnetic
- * heading and the reference bearing indicated here.
- *
- * For instance, if you setup as reference bearing the value of the earth
- * magnetic declination, the compass will provide the orientation relative
- * to the geographic North.
- *
- * Similarly, when the sensor is not mounted along the standard directions
- * because it has an additional yaw angle, you can set this angle in the reference
- * bearing so that the compass provides the expected natural direction.
- *
- * Remember to call the saveToFlash()
- * method of the module if the modification must be kept.
- *
- * @param newval : a floating point number corresponding to the reference bearing used by the compass
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::set_bearing(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("bearing", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the reference bearing used by the compass. The relative bearing
- * indicated by the compass is the difference between the measured magnetic
- * heading and the reference bearing indicated here.
- *
- * @return a floating point number corresponding to the reference bearing used by the compass
- *
- * On failure, throws an exception or returns Y_BEARING_INVALID.
- */
-double YRefFrame::get_bearing(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRefFrame::BEARING_INVALID;
-                }
-            }
-        }
-        res = _bearing;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YRefFrame::get_calibrationParam(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRefFrame::CALIBRATIONPARAM_INVALID;
-                }
-            }
-        }
-        res = _calibrationParam;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRefFrame::set_calibrationParam(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("calibrationParam", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_FUSIONMODE_enum YRefFrame::get_fusionMode(void)
-{
-    Y_FUSIONMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRefFrame::FUSIONMODE_INVALID;
-                }
-            }
-        }
-        res = _fusionMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRefFrame::set_fusionMode(Y_FUSIONMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("fusionMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a reference frame for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the reference frame is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRefFrame.isOnline() to test if the reference frame is
- * indeed online at a given time. In case of ambiguity when looking for
- * a reference frame by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the reference frame
- *
- * @return a YRefFrame object allowing you to drive the reference frame.
- */
-YRefFrame* YRefFrame::FindRefFrame(string func)
-{
-    YRefFrame* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YRefFrame*) YFunction::_FindFromCache("RefFrame", func);
-        if (obj == NULL) {
-            obj = new YRefFrame(func);
-            YFunction::_AddToCache("RefFrame", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YRefFrame::registerValueCallback(YRefFrameValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackRefFrame = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YRefFrame::_invokeValueCallback(string value)
-{
-    if (_valueCallbackRefFrame != NULL) {
-        _valueCallbackRefFrame(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Returns the installation position of the device, as configured
- * in order to define the reference frame for the compass and the
- * pitch/roll tilt sensors.
- *
- * @return a value among the Y_MOUNTPOSITION enumeration
- *         (Y_MOUNTPOSITION_BOTTOM,   Y_MOUNTPOSITION_TOP,
- *         Y_MOUNTPOSITION_FRONT,    Y_MOUNTPOSITION_RIGHT,
- *         Y_MOUNTPOSITION_REAR,     Y_MOUNTPOSITION_LEFT),
- *         corresponding to the installation in a box, on one of the six faces.
- *
- * On failure, throws an exception or returns Y_MOUNTPOSITION_INVALID.
- */
-Y_MOUNTPOSITION YRefFrame::get_mountPosition(void)
-{
-    int position = 0;
-    position = this->get_mountPos();
-    if (position < 0) {
-        return Y_MOUNTPOSITION_INVALID;
-    }
-    return (Y_MOUNTPOSITION) ((position) >> (2));
-}
-
-/**
- * Returns the installation orientation of the device, as configured
- * in order to define the reference frame for the compass and the
- * pitch/roll tilt sensors.
- *
- * @return a value among the enumeration Y_MOUNTORIENTATION
- *         (Y_MOUNTORIENTATION_TWELVE, Y_MOUNTORIENTATION_THREE,
- *         Y_MOUNTORIENTATION_SIX,     Y_MOUNTORIENTATION_NINE)
- *         corresponding to the orientation of the "X" arrow on the device,
- *         as on a clock dial seen from an observer in the center of the box.
- *         On the bottom face, the 12H orientation points to the front, while
- *         on the top face, the 12H orientation points to the rear.
- *
- * On failure, throws an exception or returns Y_MOUNTORIENTATION_INVALID.
- */
-Y_MOUNTORIENTATION YRefFrame::get_mountOrientation(void)
-{
-    int position = 0;
-    position = this->get_mountPos();
-    if (position < 0) {
-        return Y_MOUNTORIENTATION_INVALID;
-    }
-    return (Y_MOUNTORIENTATION) ((position) & (3));
-}
-
-/**
- * Changes the compass and tilt sensor frame of reference. The magnetic compass
- * and the tilt sensors (pitch and roll) naturally work in the plane
- * parallel to the earth surface. In case the device is not installed upright
- * and horizontally, you must select its reference orientation (parallel to
- * the earth surface) so that the measures are made relative to this position.
- *
- * @param position : a value among the Y_MOUNTPOSITION enumeration
- *         (Y_MOUNTPOSITION_BOTTOM,   Y_MOUNTPOSITION_TOP,
- *         Y_MOUNTPOSITION_FRONT,    Y_MOUNTPOSITION_RIGHT,
- *         Y_MOUNTPOSITION_REAR,     Y_MOUNTPOSITION_LEFT),
- *         corresponding to the installation in a box, on one of the six faces.
- * @param orientation : a value among the enumeration Y_MOUNTORIENTATION
- *         (Y_MOUNTORIENTATION_TWELVE, Y_MOUNTORIENTATION_THREE,
- *         Y_MOUNTORIENTATION_SIX,     Y_MOUNTORIENTATION_NINE)
- *         corresponding to the orientation of the "X" arrow on the device,
- *         as on a clock dial seen from an observer in the center of the box.
- *         On the bottom face, the 12H orientation points to the front, while
- *         on the top face, the 12H orientation points to the rear.
- *
- * Remember to call the saveToFlash()
- * method of the module if the modification must be kept.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::set_mountPosition(Y_MOUNTPOSITION position,Y_MOUNTORIENTATION orientation)
-{
-    int mixedPos = 0;
-    mixedPos = ((position) << (2)) + orientation;
-    return this->set_mountPos(mixedPos);
-}
-
-/**
- * Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns
- * an integer representing the calibration state of the 3 inertial sensors of
- * the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state
- * of the accelerometer, tenths show the calibration state of the magnetometer while
- * units show the calibration state of the gyroscope. For each sensor, the value 0
- * means no calibration and the value 3 means full calibration.
- *
- * @return an integer representing the calibration state of Yocto-3D-V2:
- *         333 when fully calibrated, 0 when not calibrated at all.
- *
- * On failure, throws an exception or returns a negative error code.
- * For the Yocto-3D (V1), this function always return -3 (unsupported function).
- */
-int YRefFrame::get_calibrationState(void)
-{
-    string calibParam;
-    vector<int> iCalib;
-    int caltyp = 0;
-    int res = 0;
-
-    calibParam = this->get_calibrationParam();
-    iCalib = YAPI::_decodeFloats(calibParam);
-    caltyp = ((iCalib[0]) / (1000));
-    if (caltyp != 33) {
-        return YAPI_NOT_SUPPORTED;
-    }
-    res = ((iCalib[1]) / (1000));
-    return res;
-}
-
-/**
- * Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns
- * an integer between 0 and 3 representing the degree of confidence of the position
- * estimate. When the value is 3, the estimation is reliable. Below 3, one should
- * expect sudden corrections, in particular for heading (compass function).
- * The most frequent causes for values below 3 are magnetic interferences, and
- * accelerations or rotations beyond the sensor range.
- *
- * @return an integer between 0 and 3 (3 when the measure is reliable)
- *
- * On failure, throws an exception or returns a negative error code.
- * For the Yocto-3D (V1), this function always return -3 (unsupported function).
- */
-int YRefFrame::get_measureQuality(void)
-{
-    string calibParam;
-    vector<int> iCalib;
-    int caltyp = 0;
-    int res = 0;
-
-    calibParam = this->get_calibrationParam();
-    iCalib = YAPI::_decodeFloats(calibParam);
-    caltyp = ((iCalib[0]) / (1000));
-    if (caltyp != 33) {
-        return YAPI_NOT_SUPPORTED;
-    }
-    res = ((iCalib[2]) / (1000));
-    return res;
-}
-
-int YRefFrame::_calibSort(int start,int stopidx)
-{
-    int idx = 0;
-    int changed = 0;
-    double a = 0.0;
-    double b = 0.0;
-    double xa = 0.0;
-    double xb = 0.0;
-    // bubble sort is good since we will re-sort again after offset adjustment
-    changed = 1;
-    while (changed > 0) {
-        changed = 0;
-        a = _calibDataAcc[start];
-        idx = start + 1;
-        while (idx < stopidx) {
-            b = _calibDataAcc[idx];
-            if (a > b) {
-                _calibDataAcc[idx-1] = b;
-                _calibDataAcc[idx] = a;
-                xa = _calibDataAccX[idx-1];
-                xb = _calibDataAccX[idx];
-                _calibDataAccX[idx-1] = xb;
-                _calibDataAccX[idx] = xa;
-                xa = _calibDataAccY[idx-1];
-                xb = _calibDataAccY[idx];
-                _calibDataAccY[idx-1] = xb;
-                _calibDataAccY[idx] = xa;
-                xa = _calibDataAccZ[idx-1];
-                xb = _calibDataAccZ[idx];
-                _calibDataAccZ[idx-1] = xb;
-                _calibDataAccZ[idx] = xa;
-                changed = changed + 1;
-            } else {
-                a = b;
-            }
-            idx = idx + 1;
-        }
-    }
-    return 0;
-}
-
-/**
- * Initiates the sensors tridimensional calibration process.
- * This calibration is used at low level for inertial position estimation
- * and to enhance the precision of the tilt sensors.
- *
- * After calling this method, the device should be moved according to the
- * instructions provided by method get_3DCalibrationHint,
- * and more3DCalibration should be invoked about 5 times per second.
- * The calibration procedure is completed when the method
- * get_3DCalibrationProgress returns 100. At this point,
- * the computed calibration parameters can be applied using method
- * save3DCalibration. The calibration process can be cancelled
- * at any time using method cancel3DCalibration.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::start3DCalibration(void)
-{
-    if (!(this->isOnline())) {
-        return YAPI_DEVICE_NOT_FOUND;
-    }
-    if (_calibStage != 0) {
-        this->cancel3DCalibration();
-    }
-    _calibSavedParams = this->get_calibrationParam();
-    _calibV2 = (atoi((_calibSavedParams).c_str()) == 33);
-    this->set_calibrationParam("0");
-    _calibCount = 50;
-    _calibStage = 1;
-    _calibStageHint = "Set down the device on a steady horizontal surface";
-    _calibStageProgress = 0;
-    _calibProgress = 1;
-    _calibInternalPos = 0;
-    _calibPrevTick = (int) ((YAPI::GetTickCount()) & (0x7FFFFFFF));
-    _calibOrient.clear();
-    _calibDataAccX.clear();
-    _calibDataAccY.clear();
-    _calibDataAccZ.clear();
-    _calibDataAcc.clear();
-    return YAPI_SUCCESS;
-}
-
-/**
- * Continues the sensors tridimensional calibration process previously
- * initiated using method start3DCalibration.
- * This method should be called approximately 5 times per second, while
- * positioning the device according to the instructions provided by method
- * get_3DCalibrationHint. Note that the instructions change during
- * the calibration process.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::more3DCalibration(void)
-{
-    if (_calibV2) {
-        return this->more3DCalibrationV2();
-    }
-    return this->more3DCalibrationV1();
-}
-
-int YRefFrame::more3DCalibrationV1(void)
-{
-    int currTick = 0;
-    string jsonData;
-    double xVal = 0.0;
-    double yVal = 0.0;
-    double zVal = 0.0;
-    double xSq = 0.0;
-    double ySq = 0.0;
-    double zSq = 0.0;
-    double norm = 0.0;
-    int orient = 0;
-    int idx = 0;
-    int intpos = 0;
-    int err = 0;
-    // make sure calibration has been started
-    if (_calibStage == 0) {
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (_calibProgress == 100) {
-        return YAPI_SUCCESS;
-    }
-    // make sure we leave at least 160 ms between samples
-    currTick =  (int) ((YAPI::GetTickCount()) & (0x7FFFFFFF));
-    if (((currTick - _calibPrevTick) & (0x7FFFFFFF)) < 160) {
-        return YAPI_SUCCESS;
-    }
-    // load current accelerometer values, make sure we are on a straight angle
-    // (default timeout to 0,5 sec without reading measure when out of range)
-    _calibStageHint = "Set down the device on a steady horizontal surface";
-    _calibPrevTick = ((currTick + 500) & (0x7FFFFFFF));
-    jsonData = this->_download("api/accelerometer.json");
-    xVal = atoi((this->_json_get_key(jsonData, "xValue")).c_str()) / 65536.0;
-    yVal = atoi((this->_json_get_key(jsonData, "yValue")).c_str()) / 65536.0;
-    zVal = atoi((this->_json_get_key(jsonData, "zValue")).c_str()) / 65536.0;
-    xSq = xVal * xVal;
-    if (xSq >= 0.04 && xSq < 0.64) {
-        return YAPI_SUCCESS;
-    }
-    if (xSq >= 1.44) {
-        return YAPI_SUCCESS;
-    }
-    ySq = yVal * yVal;
-    if (ySq >= 0.04 && ySq < 0.64) {
-        return YAPI_SUCCESS;
-    }
-    if (ySq >= 1.44) {
-        return YAPI_SUCCESS;
-    }
-    zSq = zVal * zVal;
-    if (zSq >= 0.04 && zSq < 0.64) {
-        return YAPI_SUCCESS;
-    }
-    if (zSq >= 1.44) {
-        return YAPI_SUCCESS;
-    }
-    norm = sqrt(xSq + ySq + zSq);
-    if (norm < 0.8 || norm > 1.2) {
-        return YAPI_SUCCESS;
-    }
-    _calibPrevTick = currTick;
-    // Determine the device orientation index
-    orient = 0;
-    if (zSq > 0.5) {
-        if (zVal > 0) {
-            orient = 0;
-        } else {
-            orient = 1;
-        }
-    }
-    if (xSq > 0.5) {
-        if (xVal > 0) {
-            orient = 2;
-        } else {
-            orient = 3;
-        }
-    }
-    if (ySq > 0.5) {
-        if (yVal > 0) {
-            orient = 4;
-        } else {
-            orient = 5;
-        }
-    }
-    // Discard measures that are not in the proper orientation
-    if (_calibStageProgress == 0) {
-        // New stage, check that this orientation is not yet done
-        idx = 0;
-        err = 0;
-        while (idx + 1 < _calibStage) {
-            if (_calibOrient[idx] == orient) {
-                err = 1;
-            }
-            idx = idx + 1;
-        }
-        if (err != 0) {
-            _calibStageHint = "Turn the device on another face";
-            return YAPI_SUCCESS;
-        }
-        _calibOrient.push_back(orient);
-    } else {
-        // Make sure device is not turned before stage is completed
-        if (orient != _calibOrient[_calibStage-1]) {
-            _calibStageHint = "Not yet done, please move back to the previous face";
-            return YAPI_SUCCESS;
-        }
-    }
-    // Save measure
-    _calibStageHint = "calibrating...";
-    _calibDataAccX.push_back(xVal);
-    _calibDataAccY.push_back(yVal);
-    _calibDataAccZ.push_back(zVal);
-    _calibDataAcc.push_back(norm);
-    _calibInternalPos = _calibInternalPos + 1;
-    _calibProgress = 1 + 16 * (_calibStage - 1) + ((16 * _calibInternalPos) / (_calibCount));
-    if (_calibInternalPos < _calibCount) {
-        _calibStageProgress = 1 + ((99 * _calibInternalPos) / (_calibCount));
-        return YAPI_SUCCESS;
-    }
-    // Stage done, compute preliminary result
-    intpos = (_calibStage - 1) * _calibCount;
-    this->_calibSort(intpos, intpos + _calibCount);
-    intpos = intpos + ((_calibCount) / (2));
-    _calibLogMsg = YapiWrapper::ysprintf("Stage %d: median is %d,%d,%d", _calibStage,
-    (int) floor(1000*_calibDataAccX[intpos]+0.5),
-    (int) floor(1000*_calibDataAccY[intpos]+0.5),(int) floor(1000*_calibDataAccZ[intpos]+0.5));
-    // move to next stage
-    _calibStage = _calibStage + 1;
-    if (_calibStage < 7) {
-        _calibStageHint = "Turn the device on another face";
-        _calibPrevTick = ((currTick + 500) & (0x7FFFFFFF));
-        _calibStageProgress = 0;
-        _calibInternalPos = 0;
-        return YAPI_SUCCESS;
-    }
-    // Data collection completed, compute accelerometer shift
-    xVal = 0;
-    yVal = 0;
-    zVal = 0;
-    idx = 0;
-    while (idx < 6) {
-        intpos = idx * _calibCount + ((_calibCount) / (2));
-        orient = _calibOrient[idx];
-        if (orient == 0 || orient == 1) {
-            zVal = zVal + _calibDataAccZ[intpos];
-        }
-        if (orient == 2 || orient == 3) {
-            xVal = xVal + _calibDataAccX[intpos];
-        }
-        if (orient == 4 || orient == 5) {
-            yVal = yVal + _calibDataAccY[intpos];
-        }
-        idx = idx + 1;
-    }
-    _calibAccXOfs = xVal / 2.0;
-    _calibAccYOfs = yVal / 2.0;
-    _calibAccZOfs = zVal / 2.0;
-    // Recompute all norms, taking into account the computed shift, and re-sort
-    intpos = 0;
-    while (intpos < (int)_calibDataAcc.size()) {
-        xVal = _calibDataAccX[intpos] - _calibAccXOfs;
-        yVal = _calibDataAccY[intpos] - _calibAccYOfs;
-        zVal = _calibDataAccZ[intpos] - _calibAccZOfs;
-        norm = sqrt(xVal * xVal + yVal * yVal + zVal * zVal);
-        _calibDataAcc[intpos] = norm;
-        intpos = intpos + 1;
-    }
-    idx = 0;
-    while (idx < 6) {
-        intpos = idx * _calibCount;
-        this->_calibSort(intpos, intpos + _calibCount);
-        idx = idx + 1;
-    }
-    // Compute the scaling factor for each axis
-    xVal = 0;
-    yVal = 0;
-    zVal = 0;
-    idx = 0;
-    while (idx < 6) {
-        intpos = idx * _calibCount + ((_calibCount) / (2));
-        orient = _calibOrient[idx];
-        if (orient == 0 || orient == 1) {
-            zVal = zVal + _calibDataAcc[intpos];
-        }
-        if (orient == 2 || orient == 3) {
-            xVal = xVal + _calibDataAcc[intpos];
-        }
-        if (orient == 4 || orient == 5) {
-            yVal = yVal + _calibDataAcc[intpos];
-        }
-        idx = idx + 1;
-    }
-    _calibAccXScale = xVal / 2.0;
-    _calibAccYScale = yVal / 2.0;
-    _calibAccZScale = zVal / 2.0;
-    // Report completion
-    _calibProgress = 100;
-    _calibStageHint = "Calibration data ready for saving";
-    return YAPI_SUCCESS;
-}
-
-int YRefFrame::more3DCalibrationV2(void)
-{
-    int currTick = 0;
-    string calibParam;
-    vector<int> iCalib;
-    int cal3 = 0;
-    int calAcc = 0;
-    int calMag = 0;
-    int calGyr = 0;
-    // make sure calibration has been started
-    if (_calibStage == 0) {
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (_calibProgress == 100) {
-        return YAPI_SUCCESS;
-    }
-    // make sure we don't start before previous calibration is cleared
-    if (_calibStage == 1) {
-        currTick = (int) ((YAPI::GetTickCount()) & (0x7FFFFFFF));
-        currTick = ((currTick - _calibPrevTick) & (0x7FFFFFFF));
-        if (currTick < 1600) {
-            _calibStageHint = "Set down the device on a steady horizontal surface";
-            _calibStageProgress = ((currTick) / (40));
-            _calibProgress = 1;
-            return YAPI_SUCCESS;
-        }
-    }
-
-    calibParam = this->_download("api/refFrame/calibrationParam.txt");
-    iCalib = YAPI::_decodeFloats(calibParam);
-    cal3 = ((iCalib[1]) / (1000));
-    calAcc = ((cal3) / (100));
-    calMag = ((cal3) / (10)) - 10*calAcc;
-    calGyr = ((cal3) % (10));
-    if (calGyr < 3) {
-        _calibStageHint = "Set down the device on a steady horizontal surface";
-        _calibStageProgress = 40 + calGyr*20;
-        _calibProgress = 4 + calGyr*2;
-    } else {
-        _calibStage = 2;
-        if (calMag < 3) {
-            _calibStageHint = "Slowly draw '8' shapes along the 3 axis";
-            _calibStageProgress = 1 + calMag*33;
-            _calibProgress = 10 + calMag*5;
-        } else {
-            _calibStage = 3;
-            if (calAcc < 3) {
-                _calibStageHint = "Slowly turn the device, stopping at each 90 degrees";
-                _calibStageProgress = 1 + calAcc*33;
-                _calibProgress = 25 + calAcc*25;
-            } else {
-                _calibStageProgress = 99;
-                _calibProgress = 100;
-            }
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns instructions to proceed to the tridimensional calibration initiated with
- * method start3DCalibration.
- *
- * @return a character string.
- */
-string YRefFrame::get_3DCalibrationHint(void)
-{
-    return _calibStageHint;
-}
-
-/**
- * Returns the global process indicator for the tridimensional calibration
- * initiated with method start3DCalibration.
- *
- * @return an integer between 0 (not started) and 100 (stage completed).
- */
-int YRefFrame::get_3DCalibrationProgress(void)
-{
-    return _calibProgress;
-}
-
-/**
- * Returns index of the current stage of the calibration
- * initiated with method start3DCalibration.
- *
- * @return an integer, growing each time a calibration stage is completed.
- */
-int YRefFrame::get_3DCalibrationStage(void)
-{
-    return _calibStage;
-}
-
-/**
- * Returns the process indicator for the current stage of the calibration
- * initiated with method start3DCalibration.
- *
- * @return an integer between 0 (not started) and 100 (stage completed).
- */
-int YRefFrame::get_3DCalibrationStageProgress(void)
-{
-    return _calibStageProgress;
-}
-
-/**
- * Returns the latest log message from the calibration process.
- * When no new message is available, returns an empty string.
- *
- * @return a character string.
- */
-string YRefFrame::get_3DCalibrationLogMsg(void)
-{
-    string msg;
-    msg = _calibLogMsg;
-    _calibLogMsg = "";
-    return msg;
-}
-
-/**
- * Applies the sensors tridimensional calibration parameters that have just been computed.
- * Remember to call the saveToFlash()  method of the module if the changes
- * must be kept when the device is restarted.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::save3DCalibration(void)
-{
-    if (_calibV2) {
-        return this->save3DCalibrationV2();
-    }
-    return this->save3DCalibrationV1();
-}
-
-int YRefFrame::save3DCalibrationV1(void)
-{
-    int shiftX = 0;
-    int shiftY = 0;
-    int shiftZ = 0;
-    int scaleExp = 0;
-    int scaleX = 0;
-    int scaleY = 0;
-    int scaleZ = 0;
-    int scaleLo = 0;
-    int scaleHi = 0;
-    string newcalib;
-    if (_calibProgress != 100) {
-        return YAPI_INVALID_ARGUMENT;
-    }
-    // Compute integer values (correction unit is 732ug/count)
-    shiftX = -(int) floor(_calibAccXOfs / 0.000732+0.5);
-    if (shiftX < 0) {
-        shiftX = shiftX + 65536;
-    }
-    shiftY = -(int) floor(_calibAccYOfs / 0.000732+0.5);
-    if (shiftY < 0) {
-        shiftY = shiftY + 65536;
-    }
-    shiftZ = -(int) floor(_calibAccZOfs / 0.000732+0.5);
-    if (shiftZ < 0) {
-        shiftZ = shiftZ + 65536;
-    }
-    scaleX = (int) floor(2048.0 / _calibAccXScale+0.5) - 2048;
-    scaleY = (int) floor(2048.0 / _calibAccYScale+0.5) - 2048;
-    scaleZ = (int) floor(2048.0 / _calibAccZScale+0.5) - 2048;
-    if (scaleX < -2048 || scaleX >= 2048 || scaleY < -2048 || scaleY >= 2048 || scaleZ < -2048 || scaleZ >= 2048) {
-        scaleExp = 3;
-    } else {
-        if (scaleX < -1024 || scaleX >= 1024 || scaleY < -1024 || scaleY >= 1024 || scaleZ < -1024 || scaleZ >= 1024) {
-            scaleExp = 2;
-        } else {
-            if (scaleX < -512 || scaleX >= 512 || scaleY < -512 || scaleY >= 512 || scaleZ < -512 || scaleZ >= 512) {
-                scaleExp = 1;
-            } else {
-                scaleExp = 0;
-            }
-        }
-    }
-    if (scaleExp > 0) {
-        scaleX = ((scaleX) >> (scaleExp));
-        scaleY = ((scaleY) >> (scaleExp));
-        scaleZ = ((scaleZ) >> (scaleExp));
-    }
-    if (scaleX < 0) {
-        scaleX = scaleX + 1024;
-    }
-    if (scaleY < 0) {
-        scaleY = scaleY + 1024;
-    }
-    if (scaleZ < 0) {
-        scaleZ = scaleZ + 1024;
-    }
-    scaleLo = ((((scaleY) & (15))) << (12)) + ((scaleX) << (2)) + scaleExp;
-    scaleHi = ((scaleZ) << (6)) + ((scaleY) >> (4));
-    // Save calibration parameters
-    newcalib = YapiWrapper::ysprintf("5,%d,%d,%d,%d,%d", shiftX, shiftY, shiftZ, scaleLo,scaleHi);
-    _calibStage = 0;
-    return this->set_calibrationParam(newcalib);
-}
-
-int YRefFrame::save3DCalibrationV2(void)
-{
-    return this->set_calibrationParam("5,5,5,5,5,5");
-}
-
-/**
- * Aborts the sensors tridimensional calibration process et restores normal settings.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRefFrame::cancel3DCalibration(void)
-{
-    if (_calibStage == 0) {
-        return YAPI_SUCCESS;
-    }
-
-    _calibStage = 0;
-    return this->set_calibrationParam(_calibSavedParams);
-}
-
-YRefFrame *YRefFrame::nextRefFrame(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YRefFrame::FindRefFrame(hwid);
-}
-
-YRefFrame* YRefFrame::FirstRefFrame(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("RefFrame", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YRefFrame::FindRefFrame(serial+"."+funcId);
-}
-
-//--- (end of YRefFrame implementation)
-
-//--- (YRefFrame functions)
-//--- (end of YRefFrame functions)
--- a/Sources/cpplib/yocto_refframe.h
+++ /dev/null
@@ -1,557 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_refframe.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindRefFrame(), the high-level API for RefFrame functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_REFFRAME_H
-#define YOCTO_REFFRAME_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YRefFrame return codes)
-//--- (end of YRefFrame return codes)
-//--- (YRefFrame yapiwrapper)
-//--- (end of YRefFrame yapiwrapper)
-//--- (YRefFrame definitions)
-class YRefFrame; // forward declaration
-
-typedef void (*YRefFrameValueCallback)(YRefFrame *func, const string& functionValue);
-#ifndef _Y_FUSIONMODE_ENUM
-#define _Y_FUSIONMODE_ENUM
-typedef enum {
-    Y_FUSIONMODE_NDOF = 0,
-    Y_FUSIONMODE_NDOF_FMC_OFF = 1,
-    Y_FUSIONMODE_M4G = 2,
-    Y_FUSIONMODE_COMPASS = 3,
-    Y_FUSIONMODE_IMU = 4,
-    Y_FUSIONMODE_INVALID = -1,
-} Y_FUSIONMODE_enum;
-#endif
-    #ifndef _Y_MOUNTPOSITION
-    #define _Y_MOUNTPOSITION
-    typedef enum {
-        Y_MOUNTPOSITION_BOTTOM = 0 ,
-        Y_MOUNTPOSITION_TOP = 1 ,
-        Y_MOUNTPOSITION_FRONT = 2 ,
-        Y_MOUNTPOSITION_REAR = 3 ,
-        Y_MOUNTPOSITION_RIGHT = 4 ,
-        Y_MOUNTPOSITION_LEFT = 5 ,
-        Y_MOUNTPOSITION_INVALID = 6
-    } Y_MOUNTPOSITION;
-    #endif
-
-    #ifndef _Y_MOUNTORIENTATION
-    #define _Y_MOUNTORIENTATION
-    typedef enum {
-        Y_MOUNTORIENTATION_TWELVE = 0 ,
-        Y_MOUNTORIENTATION_THREE = 1 ,
-        Y_MOUNTORIENTATION_SIX = 2 ,
-        Y_MOUNTORIENTATION_NINE = 3 ,
-        Y_MOUNTORIENTATION_INVALID = 4
-    } Y_MOUNTORIENTATION;
-    #endif
-
-#define Y_MOUNTPOS_INVALID              (YAPI_INVALID_UINT)
-#define Y_BEARING_INVALID               (YAPI_INVALID_DOUBLE)
-#define Y_CALIBRATIONPARAM_INVALID      (YAPI_INVALID_STRING)
-//--- (end of YRefFrame definitions)
-
-//--- (YRefFrame declaration)
-/**
- * YRefFrame Class: Reference frame configuration
- *
- * This class is used to setup the base orientation of the Yocto-3D, so that
- * the orientation functions, relative to the earth surface plane, use
- * the proper reference frame. The class also implements a tridimensional
- * sensor calibration process, which can compensate for local variations
- * of standard gravity and improve the precision of the tilt sensors.
- */
-class YOCTO_CLASS_EXPORT YRefFrame: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YRefFrame declaration)
-protected:
-    //--- (YRefFrame attributes)
-    // Attributes (function value cache)
-    int             _mountPos;
-    double          _bearing;
-    string          _calibrationParam;
-    Y_FUSIONMODE_enum _fusionMode;
-    YRefFrameValueCallback _valueCallbackRefFrame;
-    bool            _calibV2;
-    int             _calibStage;
-    string          _calibStageHint;
-    int             _calibStageProgress;
-    int             _calibProgress;
-    string          _calibLogMsg;
-    string          _calibSavedParams;
-    int             _calibCount;
-    int             _calibInternalPos;
-    int             _calibPrevTick;
-    vector<int>     _calibOrient;
-    vector<double>  _calibDataAccX;
-    vector<double>  _calibDataAccY;
-    vector<double>  _calibDataAccZ;
-    vector<double>  _calibDataAcc;
-    double          _calibAccXOfs;
-    double          _calibAccYOfs;
-    double          _calibAccZOfs;
-    double          _calibAccXScale;
-    double          _calibAccYScale;
-    double          _calibAccZScale;
-
-    friend YRefFrame *yFindRefFrame(const string& func);
-    friend YRefFrame *yFirstRefFrame(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindRefFrame factory function to instantiate
-    YRefFrame(const string& func);
-    //--- (end of YRefFrame attributes)
-
-public:
-    virtual ~YRefFrame();
-    //--- (YRefFrame accessors declaration)
-
-    static const int MOUNTPOS_INVALID = YAPI_INVALID_UINT;
-    static const double BEARING_INVALID;
-    static const string CALIBRATIONPARAM_INVALID;
-    static const Y_FUSIONMODE_enum FUSIONMODE_NDOF = Y_FUSIONMODE_NDOF;
-    static const Y_FUSIONMODE_enum FUSIONMODE_NDOF_FMC_OFF = Y_FUSIONMODE_NDOF_FMC_OFF;
-    static const Y_FUSIONMODE_enum FUSIONMODE_M4G = Y_FUSIONMODE_M4G;
-    static const Y_FUSIONMODE_enum FUSIONMODE_COMPASS = Y_FUSIONMODE_COMPASS;
-    static const Y_FUSIONMODE_enum FUSIONMODE_IMU = Y_FUSIONMODE_IMU;
-    static const Y_FUSIONMODE_enum FUSIONMODE_INVALID = Y_FUSIONMODE_INVALID;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_BOTTOM = Y_MOUNTPOSITION_BOTTOM;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_TOP = Y_MOUNTPOSITION_TOP;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_FRONT = Y_MOUNTPOSITION_FRONT;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_REAR = Y_MOUNTPOSITION_REAR;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_RIGHT = Y_MOUNTPOSITION_RIGHT;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_LEFT = Y_MOUNTPOSITION_LEFT;
-    static const Y_MOUNTPOSITION MOUNTPOSITION_INVALID = Y_MOUNTPOSITION_INVALID;
-    static const Y_MOUNTORIENTATION MOUNTORIENTATION_TWELVE = Y_MOUNTORIENTATION_TWELVE;
-    static const Y_MOUNTORIENTATION MOUNTORIENTATION_THREE = Y_MOUNTORIENTATION_THREE;
-    static const Y_MOUNTORIENTATION MOUNTORIENTATION_SIX = Y_MOUNTORIENTATION_SIX;
-    static const Y_MOUNTORIENTATION MOUNTORIENTATION_NINE = Y_MOUNTORIENTATION_NINE;
-    static const Y_MOUNTORIENTATION MOUNTORIENTATION_INVALID = Y_MOUNTORIENTATION_INVALID;
-
-    int                 get_mountPos(void);
-
-    inline int          mountPos(void)
-    { return this->get_mountPos(); }
-
-    int             set_mountPos(int newval);
-    inline int      setMountPos(int newval)
-    { return this->set_mountPos(newval); }
-
-    /**
-     * Changes the reference bearing used by the compass. The relative bearing
-     * indicated by the compass is the difference between the measured magnetic
-     * heading and the reference bearing indicated here.
-     *
-     * For instance, if you setup as reference bearing the value of the earth
-     * magnetic declination, the compass will provide the orientation relative
-     * to the geographic North.
-     *
-     * Similarly, when the sensor is not mounted along the standard directions
-     * because it has an additional yaw angle, you can set this angle in the reference
-     * bearing so that the compass provides the expected natural direction.
-     *
-     * Remember to call the saveToFlash()
-     * method of the module if the modification must be kept.
-     *
-     * @param newval : a floating point number corresponding to the reference bearing used by the compass
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bearing(double newval);
-    inline int      setBearing(double newval)
-    { return this->set_bearing(newval); }
-
-    /**
-     * Returns the reference bearing used by the compass. The relative bearing
-     * indicated by the compass is the difference between the measured magnetic
-     * heading and the reference bearing indicated here.
-     *
-     * @return a floating point number corresponding to the reference bearing used by the compass
-     *
-     * On failure, throws an exception or returns Y_BEARING_INVALID.
-     */
-    double              get_bearing(void);
-
-    inline double       bearing(void)
-    { return this->get_bearing(); }
-
-    string              get_calibrationParam(void);
-
-    inline string       calibrationParam(void)
-    { return this->get_calibrationParam(); }
-
-    int             set_calibrationParam(const string& newval);
-    inline int      setCalibrationParam(const string& newval)
-    { return this->set_calibrationParam(newval); }
-
-    Y_FUSIONMODE_enum   get_fusionMode(void);
-
-    inline Y_FUSIONMODE_enum fusionMode(void)
-    { return this->get_fusionMode(); }
-
-    int             set_fusionMode(Y_FUSIONMODE_enum newval);
-    inline int      setFusionMode(Y_FUSIONMODE_enum newval)
-    { return this->set_fusionMode(newval); }
-
-    /**
-     * Retrieves a reference frame for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the reference frame is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YRefFrame.isOnline() to test if the reference frame is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a reference frame by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the reference frame
-     *
-     * @return a YRefFrame object allowing you to drive the reference frame.
-     */
-    static YRefFrame*   FindRefFrame(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YRefFrameValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Returns the installation position of the device, as configured
-     * in order to define the reference frame for the compass and the
-     * pitch/roll tilt sensors.
-     *
-     * @return a value among the Y_MOUNTPOSITION enumeration
-     *         (Y_MOUNTPOSITION_BOTTOM,   Y_MOUNTPOSITION_TOP,
-     *         Y_MOUNTPOSITION_FRONT,    Y_MOUNTPOSITION_RIGHT,
-     *         Y_MOUNTPOSITION_REAR,     Y_MOUNTPOSITION_LEFT),
-     *         corresponding to the installation in a box, on one of the six faces.
-     *
-     * On failure, throws an exception or returns Y_MOUNTPOSITION_INVALID.
-     */
-    virtual Y_MOUNTPOSITION get_mountPosition(void);
-
-    /**
-     * Returns the installation orientation of the device, as configured
-     * in order to define the reference frame for the compass and the
-     * pitch/roll tilt sensors.
-     *
-     * @return a value among the enumeration Y_MOUNTORIENTATION
-     *         (Y_MOUNTORIENTATION_TWELVE, Y_MOUNTORIENTATION_THREE,
-     *         Y_MOUNTORIENTATION_SIX,     Y_MOUNTORIENTATION_NINE)
-     *         corresponding to the orientation of the "X" arrow on the device,
-     *         as on a clock dial seen from an observer in the center of the box.
-     *         On the bottom face, the 12H orientation points to the front, while
-     *         on the top face, the 12H orientation points to the rear.
-     *
-     * On failure, throws an exception or returns Y_MOUNTORIENTATION_INVALID.
-     */
-    virtual Y_MOUNTORIENTATION get_mountOrientation(void);
-
-    /**
-     * Changes the compass and tilt sensor frame of reference. The magnetic compass
-     * and the tilt sensors (pitch and roll) naturally work in the plane
-     * parallel to the earth surface. In case the device is not installed upright
-     * and horizontally, you must select its reference orientation (parallel to
-     * the earth surface) so that the measures are made relative to this position.
-     *
-     * @param position : a value among the Y_MOUNTPOSITION enumeration
-     *         (Y_MOUNTPOSITION_BOTTOM,   Y_MOUNTPOSITION_TOP,
-     *         Y_MOUNTPOSITION_FRONT,    Y_MOUNTPOSITION_RIGHT,
-     *         Y_MOUNTPOSITION_REAR,     Y_MOUNTPOSITION_LEFT),
-     *         corresponding to the installation in a box, on one of the six faces.
-     * @param orientation : a value among the enumeration Y_MOUNTORIENTATION
-     *         (Y_MOUNTORIENTATION_TWELVE, Y_MOUNTORIENTATION_THREE,
-     *         Y_MOUNTORIENTATION_SIX,     Y_MOUNTORIENTATION_NINE)
-     *         corresponding to the orientation of the "X" arrow on the device,
-     *         as on a clock dial seen from an observer in the center of the box.
-     *         On the bottom face, the 12H orientation points to the front, while
-     *         on the top face, the 12H orientation points to the rear.
-     *
-     * Remember to call the saveToFlash()
-     * method of the module if the modification must be kept.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_mountPosition(Y_MOUNTPOSITION position,Y_MOUNTORIENTATION orientation);
-
-    /**
-     * Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns
-     * an integer representing the calibration state of the 3 inertial sensors of
-     * the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state
-     * of the accelerometer, tenths show the calibration state of the magnetometer while
-     * units show the calibration state of the gyroscope. For each sensor, the value 0
-     * means no calibration and the value 3 means full calibration.
-     *
-     * @return an integer representing the calibration state of Yocto-3D-V2:
-     *         333 when fully calibrated, 0 when not calibrated at all.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     * For the Yocto-3D (V1), this function always return -3 (unsupported function).
-     */
-    virtual int         get_calibrationState(void);
-
-    /**
-     * Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns
-     * an integer between 0 and 3 representing the degree of confidence of the position
-     * estimate. When the value is 3, the estimation is reliable. Below 3, one should
-     * expect sudden corrections, in particular for heading (compass function).
-     * The most frequent causes for values below 3 are magnetic interferences, and
-     * accelerations or rotations beyond the sensor range.
-     *
-     * @return an integer between 0 and 3 (3 when the measure is reliable)
-     *
-     * On failure, throws an exception or returns a negative error code.
-     * For the Yocto-3D (V1), this function always return -3 (unsupported function).
-     */
-    virtual int         get_measureQuality(void);
-
-    virtual int         _calibSort(int start,int stopidx);
-
-    /**
-     * Initiates the sensors tridimensional calibration process.
-     * This calibration is used at low level for inertial position estimation
-     * and to enhance the precision of the tilt sensors.
-     *
-     * After calling this method, the device should be moved according to the
-     * instructions provided by method get_3DCalibrationHint,
-     * and more3DCalibration should be invoked about 5 times per second.
-     * The calibration procedure is completed when the method
-     * get_3DCalibrationProgress returns 100. At this point,
-     * the computed calibration parameters can be applied using method
-     * save3DCalibration. The calibration process can be cancelled
-     * at any time using method cancel3DCalibration.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         start3DCalibration(void);
-
-    /**
-     * Continues the sensors tridimensional calibration process previously
-     * initiated using method start3DCalibration.
-     * This method should be called approximately 5 times per second, while
-     * positioning the device according to the instructions provided by method
-     * get_3DCalibrationHint. Note that the instructions change during
-     * the calibration process.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         more3DCalibration(void);
-
-    virtual int         more3DCalibrationV1(void);
-
-    virtual int         more3DCalibrationV2(void);
-
-    /**
-     * Returns instructions to proceed to the tridimensional calibration initiated with
-     * method start3DCalibration.
-     *
-     * @return a character string.
-     */
-    virtual string      get_3DCalibrationHint(void);
-
-    /**
-     * Returns the global process indicator for the tridimensional calibration
-     * initiated with method start3DCalibration.
-     *
-     * @return an integer between 0 (not started) and 100 (stage completed).
-     */
-    virtual int         get_3DCalibrationProgress(void);
-
-    /**
-     * Returns index of the current stage of the calibration
-     * initiated with method start3DCalibration.
-     *
-     * @return an integer, growing each time a calibration stage is completed.
-     */
-    virtual int         get_3DCalibrationStage(void);
-
-    /**
-     * Returns the process indicator for the current stage of the calibration
-     * initiated with method start3DCalibration.
-     *
-     * @return an integer between 0 (not started) and 100 (stage completed).
-     */
-    virtual int         get_3DCalibrationStageProgress(void);
-
-    /**
-     * Returns the latest log message from the calibration process.
-     * When no new message is available, returns an empty string.
-     *
-     * @return a character string.
-     */
-    virtual string      get_3DCalibrationLogMsg(void);
-
-    /**
-     * Applies the sensors tridimensional calibration parameters that have just been computed.
-     * Remember to call the saveToFlash()  method of the module if the changes
-     * must be kept when the device is restarted.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         save3DCalibration(void);
-
-    virtual int         save3DCalibrationV1(void);
-
-    virtual int         save3DCalibrationV2(void);
-
-    /**
-     * Aborts the sensors tridimensional calibration process et restores normal settings.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         cancel3DCalibration(void);
-
-
-    inline static YRefFrame* Find(string func)
-    { return YRefFrame::FindRefFrame(func); }
-
-    /**
-     * Continues the enumeration of reference frames started using yFirstRefFrame().
-     * Caution: You can't make any assumption about the returned reference frames order.
-     * If you want to find a specific a reference frame, use RefFrame.findRefFrame()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YRefFrame object, corresponding to
-     *         a reference frame currently online, or a NULL pointer
-     *         if there are no more reference frames to enumerate.
-     */
-           YRefFrame       *nextRefFrame(void);
-    inline YRefFrame       *next(void)
-    { return this->nextRefFrame();}
-
-    /**
-     * Starts the enumeration of reference frames currently accessible.
-     * Use the method YRefFrame.nextRefFrame() to iterate on
-     * next reference frames.
-     *
-     * @return a pointer to a YRefFrame object, corresponding to
-     *         the first reference frame currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YRefFrame* FirstRefFrame(void);
-    inline static YRefFrame* First(void)
-    { return YRefFrame::FirstRefFrame();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YRefFrame accessors declaration)
-};
-
-//--- (YRefFrame functions declaration)
-
-/**
- * Retrieves a reference frame for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the reference frame is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRefFrame.isOnline() to test if the reference frame is
- * indeed online at a given time. In case of ambiguity when looking for
- * a reference frame by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the reference frame
- *
- * @return a YRefFrame object allowing you to drive the reference frame.
- */
-inline YRefFrame* yFindRefFrame(const string& func)
-{ return YRefFrame::FindRefFrame(func);}
-/**
- * Starts the enumeration of reference frames currently accessible.
- * Use the method YRefFrame.nextRefFrame() to iterate on
- * next reference frames.
- *
- * @return a pointer to a YRefFrame object, corresponding to
- *         the first reference frame currently online, or a NULL pointer
- *         if there are none.
- */
-inline YRefFrame* yFirstRefFrame(void)
-{ return YRefFrame::FirstRefFrame();}
-
-//--- (end of YRefFrame functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_relay.cpp
+++ /dev/null
@@ -1,664 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_relay.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindRelay(), the high-level API for Relay functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_relay.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "relay"
-
-YRelay::YRelay(const string& func): YFunction(func)
-//--- (YRelay initialization)
-    ,_state(STATE_INVALID)
-    ,_stateAtPowerOn(STATEATPOWERON_INVALID)
-    ,_maxTimeOnStateA(MAXTIMEONSTATEA_INVALID)
-    ,_maxTimeOnStateB(MAXTIMEONSTATEB_INVALID)
-    ,_output(OUTPUT_INVALID)
-    ,_pulseTimer(PULSETIMER_INVALID)
-    ,_delayedPulseTimer(DELAYEDPULSETIMER_INVALID)
-    ,_countdown(COUNTDOWN_INVALID)
-    ,_valueCallbackRelay(NULL)
-//--- (end of YRelay initialization)
-{
-    _className="Relay";
-}
-
-YRelay::~YRelay()
-{
-//--- (YRelay cleanup)
-//--- (end of YRelay cleanup)
-}
-//--- (YRelay implementation)
-// static attributes
-const YDelayedPulse YRelay::DELAYEDPULSETIMER_INVALID = YDelayedPulse();
-
-int YRelay::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("state")) {
-        _state =  (Y_STATE_enum)json_val->getInt("state");
-    }
-    if(json_val->has("stateAtPowerOn")) {
-        _stateAtPowerOn =  (Y_STATEATPOWERON_enum)json_val->getInt("stateAtPowerOn");
-    }
-    if(json_val->has("maxTimeOnStateA")) {
-        _maxTimeOnStateA =  json_val->getLong("maxTimeOnStateA");
-    }
-    if(json_val->has("maxTimeOnStateB")) {
-        _maxTimeOnStateB =  json_val->getLong("maxTimeOnStateB");
-    }
-    if(json_val->has("output")) {
-        _output =  (Y_OUTPUT_enum)json_val->getInt("output");
-    }
-    if(json_val->has("pulseTimer")) {
-        _pulseTimer =  json_val->getLong("pulseTimer");
-    }
-    if(json_val->has("delayedPulseTimer")) {
-        YJSONObject* subjson = json_val->getYJSONObject("delayedPulseTimer");
-        if (subjson->has("moving")) {
-            _delayedPulseTimer.moving = subjson->getInt("moving");
-        }
-        if (subjson->has("target")) {
-            _delayedPulseTimer.target = subjson->getInt("target");
-        }
-        if (subjson->has("ms")) {
-            _delayedPulseTimer.ms = subjson->getInt("ms");
-        }
-    }
-    if(json_val->has("countdown")) {
-        _countdown =  json_val->getLong("countdown");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the state of the relays (A for the idle position, B for the active position).
- *
- * @return either Y_STATE_A or Y_STATE_B, according to the state of the relays (A for the idle
- * position, B for the active position)
- *
- * On failure, throws an exception or returns Y_STATE_INVALID.
- */
-Y_STATE_enum YRelay::get_state(void)
-{
-    Y_STATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::STATE_INVALID;
-                }
-            }
-        }
-        res = _state;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the relays (A for the idle position, B for the active position).
- *
- * @param newval : either Y_STATE_A or Y_STATE_B, according to the state of the relays (A for the idle
- * position, B for the active position)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::set_state(Y_STATE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("state", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the relays at device startup (A for the idle position, B for the active
- * position, UNCHANGED for no change).
- *
- * @return a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
- * corresponding to the state of the relays at device startup (A for the idle position, B for the
- * active position, UNCHANGED for no change)
- *
- * On failure, throws an exception or returns Y_STATEATPOWERON_INVALID.
- */
-Y_STATEATPOWERON_enum YRelay::get_stateAtPowerOn(void)
-{
-    Y_STATEATPOWERON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::STATEATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _stateAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Preset the state of the relays at device startup (A for the idle position,
- * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
- * method, otherwise this call will have no effect.
- *
- * @param newval : a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::set_stateAtPowerOn(Y_STATEATPOWERON_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("stateAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
- * switching back in to B state. Zero means no maximum time.
- *
- * @return an integer
- *
- * On failure, throws an exception or returns Y_MAXTIMEONSTATEA_INVALID.
- */
-s64 YRelay::get_maxTimeOnStateA(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::MAXTIMEONSTATEA_INVALID;
-                }
-            }
-        }
-        res = _maxTimeOnStateA;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
- * switching back in to B state. Use zero for no maximum time.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::set_maxTimeOnStateA(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("maxTimeOnStateA", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
- * switching back in to A state. Zero means no maximum time.
- *
- * @return an integer
- *
- * On failure, throws an exception or returns Y_MAXTIMEONSTATEB_INVALID.
- */
-s64 YRelay::get_maxTimeOnStateB(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::MAXTIMEONSTATEB_INVALID;
-                }
-            }
-        }
-        res = _maxTimeOnStateB;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
- * switching back in to A state. Use zero for no maximum time.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::set_maxTimeOnStateB(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("maxTimeOnStateB", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the output state of the relays, when used as a simple switch (single throw).
- *
- * @return either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the relays, when used
- * as a simple switch (single throw)
- *
- * On failure, throws an exception or returns Y_OUTPUT_INVALID.
- */
-Y_OUTPUT_enum YRelay::get_output(void)
-{
-    Y_OUTPUT_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::OUTPUT_INVALID;
-                }
-            }
-        }
-        res = _output;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the output state of the relays, when used as a simple switch (single throw).
- *
- * @param newval : either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the relays,
- * when used as a simple switch (single throw)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::set_output(Y_OUTPUT_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("output", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of milliseconds remaining before the relays is returned to idle position
- * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
- *
- * @return an integer corresponding to the number of milliseconds remaining before the relays is
- * returned to idle position
- *         (state A), during a measured pulse generation
- *
- * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
- */
-s64 YRelay::get_pulseTimer(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::PULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _pulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRelay::set_pulseTimer(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("pulseTimer", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the relay to output B (active) for a specified duration, then brings it
- * automatically back to output A (idle state).
- *
- * @param ms_duration : pulse duration, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::pulse(int ms_duration)
-{
-    string rest_val;
-    char buf[32]; sprintf(buf, "%u", (u32)ms_duration); rest_val = string(buf);
-    return _setAttr("pulseTimer", rest_val);
-}
-
-YDelayedPulse YRelay::get_delayedPulseTimer(void)
-{
-    YDelayedPulse res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::DELAYEDPULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _delayedPulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YRelay::set_delayedPulseTimer(YDelayedPulse newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buff[64]; sprintf(buff,"%d:%d",newval.target,newval.ms); rest_val = string(buff);
-        res = _setAttr("delayedPulseTimer", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Schedules a pulse.
- *
- * @param ms_delay : waiting time before the pulse, in milliseconds
- * @param ms_duration : pulse duration, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YRelay::delayedPulse(int ms_delay,int ms_duration)
-{
-    string rest_val;
-    char buff[64]; sprintf(buff,"%d:%d",ms_delay,ms_duration); rest_val = string(buff);
-    return _setAttr("delayedPulseTimer", rest_val);
-}
-
-/**
- * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
- * When there is no scheduled pulse, returns zero.
- *
- * @return an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call)
- *         When there is no scheduled pulse, returns zero
- *
- * On failure, throws an exception or returns Y_COUNTDOWN_INVALID.
- */
-s64 YRelay::get_countdown(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YRelay::COUNTDOWN_INVALID;
-                }
-            }
-        }
-        res = _countdown;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a relay for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the relay is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRelay.isOnline() to test if the relay is
- * indeed online at a given time. In case of ambiguity when looking for
- * a relay by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the relay
- *
- * @return a YRelay object allowing you to drive the relay.
- */
-YRelay* YRelay::FindRelay(string func)
-{
-    YRelay* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YRelay*) YFunction::_FindFromCache("Relay", func);
-        if (obj == NULL) {
-            obj = new YRelay(func);
-            YFunction::_AddToCache("Relay", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YRelay::registerValueCallback(YRelayValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackRelay = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YRelay::_invokeValueCallback(string value)
-{
-    if (_valueCallbackRelay != NULL) {
-        _valueCallbackRelay(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YRelay *YRelay::nextRelay(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YRelay::FindRelay(hwid);
-}
-
-YRelay* YRelay::FirstRelay(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Relay", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YRelay::FindRelay(serial+"."+funcId);
-}
-
-//--- (end of YRelay implementation)
-
-//--- (YRelay functions)
-//--- (end of YRelay functions)
--- a/Sources/cpplib/yocto_relay.h
+++ /dev/null
@@ -1,495 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_relay.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindRelay(), the high-level API for Relay functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_RELAY_H
-#define YOCTO_RELAY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YRelay return codes)
-//--- (end of YRelay return codes)
-//--- (YRelay yapiwrapper)
-//--- (end of YRelay yapiwrapper)
-//--- (YRelay definitions)
-class YRelay; // forward declaration
-
-typedef void (*YRelayValueCallback)(YRelay *func, const string& functionValue);
-#ifndef _Y_STATE_ENUM
-#define _Y_STATE_ENUM
-typedef enum {
-    Y_STATE_A = 0,
-    Y_STATE_B = 1,
-    Y_STATE_INVALID = -1,
-} Y_STATE_enum;
-#endif
-#ifndef _Y_STATEATPOWERON_ENUM
-#define _Y_STATEATPOWERON_ENUM
-typedef enum {
-    Y_STATEATPOWERON_UNCHANGED = 0,
-    Y_STATEATPOWERON_A = 1,
-    Y_STATEATPOWERON_B = 2,
-    Y_STATEATPOWERON_INVALID = -1,
-} Y_STATEATPOWERON_enum;
-#endif
-#ifndef _Y_OUTPUT_ENUM
-#define _Y_OUTPUT_ENUM
-typedef enum {
-    Y_OUTPUT_OFF = 0,
-    Y_OUTPUT_ON = 1,
-    Y_OUTPUT_INVALID = -1,
-} Y_OUTPUT_enum;
-#endif
-#ifndef _CLASS_YDELAYEDPULSE
-#define _CLASS_YDELAYEDPULSE
-class YOCTO_CLASS_EXPORT YDelayedPulse {
-public:
-    int             target;
-    int             ms;
-    int             moving;
-
-    YDelayedPulse()
-        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
-    {}
-
-    bool operator==(const YDelayedPulse& o) const {
-         return (target == o.target) && (ms == o.ms) && (moving == o.moving);
-    }
-};
-#endif
-#define Y_MAXTIMEONSTATEA_INVALID       (YAPI_INVALID_LONG)
-#define Y_MAXTIMEONSTATEB_INVALID       (YAPI_INVALID_LONG)
-#define Y_PULSETIMER_INVALID            (YAPI_INVALID_LONG)
-#define Y_COUNTDOWN_INVALID             (YAPI_INVALID_LONG)
-//--- (end of YRelay definitions)
-
-//--- (YRelay declaration)
-/**
- * YRelay Class: Relay function interface
- *
- * The Yoctopuce application programming interface allows you to switch the relay state.
- * This change is not persistent: the relay will automatically return to its idle position
- * whenever power is lost or if the module is restarted.
- * The library can also generate automatically short pulses of determined duration.
- * On devices with two output for each relay (double throw), the two outputs are named A and B,
- * with output A corresponding to the idle position (at power off) and the output B corresponding to the
- * active state. If you prefer the alternate default state, simply switch your cables on the board.
- */
-class YOCTO_CLASS_EXPORT YRelay: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YRelay declaration)
-protected:
-    //--- (YRelay attributes)
-    // Attributes (function value cache)
-    Y_STATE_enum    _state;
-    Y_STATEATPOWERON_enum _stateAtPowerOn;
-    s64             _maxTimeOnStateA;
-    s64             _maxTimeOnStateB;
-    Y_OUTPUT_enum   _output;
-    s64             _pulseTimer;
-    YDelayedPulse   _delayedPulseTimer;
-    s64             _countdown;
-    YRelayValueCallback _valueCallbackRelay;
-
-    friend YRelay *yFindRelay(const string& func);
-    friend YRelay *yFirstRelay(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindRelay factory function to instantiate
-    YRelay(const string& func);
-    //--- (end of YRelay attributes)
-
-public:
-    virtual ~YRelay();
-    //--- (YRelay accessors declaration)
-
-    static const Y_STATE_enum STATE_A = Y_STATE_A;
-    static const Y_STATE_enum STATE_B = Y_STATE_B;
-    static const Y_STATE_enum STATE_INVALID = Y_STATE_INVALID;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_UNCHANGED = Y_STATEATPOWERON_UNCHANGED;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_A = Y_STATEATPOWERON_A;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_B = Y_STATEATPOWERON_B;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_INVALID = Y_STATEATPOWERON_INVALID;
-    static const s64 MAXTIMEONSTATEA_INVALID = YAPI_INVALID_LONG;
-    static const s64 MAXTIMEONSTATEB_INVALID = YAPI_INVALID_LONG;
-    static const Y_OUTPUT_enum OUTPUT_OFF = Y_OUTPUT_OFF;
-    static const Y_OUTPUT_enum OUTPUT_ON = Y_OUTPUT_ON;
-    static const Y_OUTPUT_enum OUTPUT_INVALID = Y_OUTPUT_INVALID;
-    static const s64 PULSETIMER_INVALID = YAPI_INVALID_LONG;
-    static const YDelayedPulse DELAYEDPULSETIMER_INVALID;
-    static const s64 COUNTDOWN_INVALID = YAPI_INVALID_LONG;
-
-    /**
-     * Returns the state of the relays (A for the idle position, B for the active position).
-     *
-     * @return either Y_STATE_A or Y_STATE_B, according to the state of the relays (A for the idle
-     * position, B for the active position)
-     *
-     * On failure, throws an exception or returns Y_STATE_INVALID.
-     */
-    Y_STATE_enum        get_state(void);
-
-    inline Y_STATE_enum state(void)
-    { return this->get_state(); }
-
-    /**
-     * Changes the state of the relays (A for the idle position, B for the active position).
-     *
-     * @param newval : either Y_STATE_A or Y_STATE_B, according to the state of the relays (A for the idle
-     * position, B for the active position)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_state(Y_STATE_enum newval);
-    inline int      setState(Y_STATE_enum newval)
-    { return this->set_state(newval); }
-
-    /**
-     * Returns the state of the relays at device startup (A for the idle position, B for the active
-     * position, UNCHANGED for no change).
-     *
-     * @return a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
-     * corresponding to the state of the relays at device startup (A for the idle position, B for the
-     * active position, UNCHANGED for no change)
-     *
-     * On failure, throws an exception or returns Y_STATEATPOWERON_INVALID.
-     */
-    Y_STATEATPOWERON_enum get_stateAtPowerOn(void);
-
-    inline Y_STATEATPOWERON_enum stateAtPowerOn(void)
-    { return this->get_stateAtPowerOn(); }
-
-    /**
-     * Preset the state of the relays at device startup (A for the idle position,
-     * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
-     * method, otherwise this call will have no effect.
-     *
-     * @param newval : a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_stateAtPowerOn(Y_STATEATPOWERON_enum newval);
-    inline int      setStateAtPowerOn(Y_STATEATPOWERON_enum newval)
-    { return this->set_stateAtPowerOn(newval); }
-
-    /**
-     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
-     * switching back in to B state. Zero means no maximum time.
-     *
-     * @return an integer
-     *
-     * On failure, throws an exception or returns Y_MAXTIMEONSTATEA_INVALID.
-     */
-    s64                 get_maxTimeOnStateA(void);
-
-    inline s64          maxTimeOnStateA(void)
-    { return this->get_maxTimeOnStateA(); }
-
-    /**
-     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
-     * switching back in to B state. Use zero for no maximum time.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxTimeOnStateA(s64 newval);
-    inline int      setMaxTimeOnStateA(s64 newval)
-    { return this->set_maxTimeOnStateA(newval); }
-
-    /**
-     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
-     * switching back in to A state. Zero means no maximum time.
-     *
-     * @return an integer
-     *
-     * On failure, throws an exception or returns Y_MAXTIMEONSTATEB_INVALID.
-     */
-    s64                 get_maxTimeOnStateB(void);
-
-    inline s64          maxTimeOnStateB(void)
-    { return this->get_maxTimeOnStateB(); }
-
-    /**
-     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
-     * switching back in to A state. Use zero for no maximum time.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxTimeOnStateB(s64 newval);
-    inline int      setMaxTimeOnStateB(s64 newval)
-    { return this->set_maxTimeOnStateB(newval); }
-
-    /**
-     * Returns the output state of the relays, when used as a simple switch (single throw).
-     *
-     * @return either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the relays, when used
-     * as a simple switch (single throw)
-     *
-     * On failure, throws an exception or returns Y_OUTPUT_INVALID.
-     */
-    Y_OUTPUT_enum       get_output(void);
-
-    inline Y_OUTPUT_enum output(void)
-    { return this->get_output(); }
-
-    /**
-     * Changes the output state of the relays, when used as a simple switch (single throw).
-     *
-     * @param newval : either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the relays,
-     * when used as a simple switch (single throw)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_output(Y_OUTPUT_enum newval);
-    inline int      setOutput(Y_OUTPUT_enum newval)
-    { return this->set_output(newval); }
-
-    /**
-     * Returns the number of milliseconds remaining before the relays is returned to idle position
-     * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
-     *
-     * @return an integer corresponding to the number of milliseconds remaining before the relays is
-     * returned to idle position
-     *         (state A), during a measured pulse generation
-     *
-     * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
-     */
-    s64                 get_pulseTimer(void);
-
-    inline s64          pulseTimer(void)
-    { return this->get_pulseTimer(); }
-
-    int             set_pulseTimer(s64 newval);
-    inline int      setPulseTimer(s64 newval)
-    { return this->set_pulseTimer(newval); }
-
-    /**
-     * Sets the relay to output B (active) for a specified duration, then brings it
-     * automatically back to output A (idle state).
-     *
-     * @param ms_duration : pulse duration, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             pulse(int ms_duration);
-
-    YDelayedPulse       get_delayedPulseTimer(void);
-
-    inline YDelayedPulse delayedPulseTimer(void)
-    { return this->get_delayedPulseTimer(); }
-
-    int             set_delayedPulseTimer(YDelayedPulse newval);
-    inline int      setDelayedPulseTimer(YDelayedPulse newval)
-    { return this->set_delayedPulseTimer(newval); }
-
-    /**
-     * Schedules a pulse.
-     *
-     * @param ms_delay : waiting time before the pulse, in milliseconds
-     * @param ms_duration : pulse duration, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             delayedPulse(int ms_delay,int ms_duration);
-
-    /**
-     * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
-     * When there is no scheduled pulse, returns zero.
-     *
-     * @return an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call)
-     *         When there is no scheduled pulse, returns zero
-     *
-     * On failure, throws an exception or returns Y_COUNTDOWN_INVALID.
-     */
-    s64                 get_countdown(void);
-
-    inline s64          countdown(void)
-    { return this->get_countdown(); }
-
-    /**
-     * Retrieves a relay for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the relay is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YRelay.isOnline() to test if the relay is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a relay by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the relay
-     *
-     * @return a YRelay object allowing you to drive the relay.
-     */
-    static YRelay*      FindRelay(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YRelayValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YRelay* Find(string func)
-    { return YRelay::FindRelay(func); }
-
-    /**
-     * Continues the enumeration of relays started using yFirstRelay().
-     * Caution: You can't make any assumption about the returned relays order.
-     * If you want to find a specific a relay, use Relay.findRelay()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YRelay object, corresponding to
-     *         a relay currently online, or a NULL pointer
-     *         if there are no more relays to enumerate.
-     */
-           YRelay          *nextRelay(void);
-    inline YRelay          *next(void)
-    { return this->nextRelay();}
-
-    /**
-     * Starts the enumeration of relays currently accessible.
-     * Use the method YRelay.nextRelay() to iterate on
-     * next relays.
-     *
-     * @return a pointer to a YRelay object, corresponding to
-     *         the first relay currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YRelay* FirstRelay(void);
-    inline static YRelay* First(void)
-    { return YRelay::FirstRelay();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YRelay accessors declaration)
-};
-
-//--- (YRelay functions declaration)
-
-/**
- * Retrieves a relay for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the relay is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YRelay.isOnline() to test if the relay is
- * indeed online at a given time. In case of ambiguity when looking for
- * a relay by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the relay
- *
- * @return a YRelay object allowing you to drive the relay.
- */
-inline YRelay* yFindRelay(const string& func)
-{ return YRelay::FindRelay(func);}
-/**
- * Starts the enumeration of relays currently accessible.
- * Use the method YRelay.nextRelay() to iterate on
- * next relays.
- *
- * @return a pointer to a YRelay object, corresponding to
- *         the first relay currently online, or a NULL pointer
- *         if there are none.
- */
-inline YRelay* yFirstRelay(void)
-{ return YRelay::FirstRelay();}
-
-//--- (end of YRelay functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_segmenteddisplay.cpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_segmenteddisplay.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindSegmentedDisplay(), the high-level API for SegmentedDisplay functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_segmenteddisplay.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "segmenteddisplay"
-
-YSegmentedDisplay::YSegmentedDisplay(const string& func): YFunction(func)
-//--- (YSegmentedDisplay initialization)
-    ,_displayedText(DISPLAYEDTEXT_INVALID)
-    ,_displayMode(DISPLAYMODE_INVALID)
-    ,_valueCallbackSegmentedDisplay(NULL)
-//--- (end of YSegmentedDisplay initialization)
-{
-    _className="SegmentedDisplay";
-}
-
-YSegmentedDisplay::~YSegmentedDisplay()
-{
-//--- (YSegmentedDisplay cleanup)
-//--- (end of YSegmentedDisplay cleanup)
-}
-//--- (YSegmentedDisplay implementation)
-// static attributes
-const string YSegmentedDisplay::DISPLAYEDTEXT_INVALID = YAPI_INVALID_STRING;
-
-int YSegmentedDisplay::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("displayedText")) {
-        _displayedText =  json_val->getString("displayedText");
-    }
-    if(json_val->has("displayMode")) {
-        _displayMode =  (Y_DISPLAYMODE_enum)json_val->getInt("displayMode");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the text currently displayed on the screen.
- *
- * @return a string corresponding to the text currently displayed on the screen
- *
- * On failure, throws an exception or returns Y_DISPLAYEDTEXT_INVALID.
- */
-string YSegmentedDisplay::get_displayedText(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSegmentedDisplay::DISPLAYEDTEXT_INVALID;
-                }
-            }
-        }
-        res = _displayedText;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the text currently displayed on the screen.
- *
- * @param newval : a string corresponding to the text currently displayed on the screen
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSegmentedDisplay::set_displayedText(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("displayedText", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_DISPLAYMODE_enum YSegmentedDisplay::get_displayMode(void)
-{
-    Y_DISPLAYMODE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSegmentedDisplay::DISPLAYMODE_INVALID;
-                }
-            }
-        }
-        res = _displayMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YSegmentedDisplay::set_displayMode(Y_DISPLAYMODE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("displayMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a segmented display for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the segmented displays is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSegmentedDisplay.isOnline() to test if the segmented displays is
- * indeed online at a given time. In case of ambiguity when looking for
- * a segmented display by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the segmented displays
- *
- * @return a YSegmentedDisplay object allowing you to drive the segmented displays.
- */
-YSegmentedDisplay* YSegmentedDisplay::FindSegmentedDisplay(string func)
-{
-    YSegmentedDisplay* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YSegmentedDisplay*) YFunction::_FindFromCache("SegmentedDisplay", func);
-        if (obj == NULL) {
-            obj = new YSegmentedDisplay(func);
-            YFunction::_AddToCache("SegmentedDisplay", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YSegmentedDisplay::registerValueCallback(YSegmentedDisplayValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackSegmentedDisplay = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YSegmentedDisplay::_invokeValueCallback(string value)
-{
-    if (_valueCallbackSegmentedDisplay != NULL) {
-        _valueCallbackSegmentedDisplay(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YSegmentedDisplay *YSegmentedDisplay::nextSegmentedDisplay(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YSegmentedDisplay::FindSegmentedDisplay(hwid);
-}
-
-YSegmentedDisplay* YSegmentedDisplay::FirstSegmentedDisplay(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("SegmentedDisplay", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YSegmentedDisplay::FindSegmentedDisplay(serial+"."+funcId);
-}
-
-//--- (end of YSegmentedDisplay implementation)
-
-//--- (YSegmentedDisplay functions)
-//--- (end of YSegmentedDisplay functions)
--- a/Sources/cpplib/yocto_segmenteddisplay.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_segmenteddisplay.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindSegmentedDisplay(), the high-level API for SegmentedDisplay functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_SEGMENTEDDISPLAY_H
-#define YOCTO_SEGMENTEDDISPLAY_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YSegmentedDisplay return codes)
-//--- (end of YSegmentedDisplay return codes)
-//--- (YSegmentedDisplay yapiwrapper)
-//--- (end of YSegmentedDisplay yapiwrapper)
-//--- (YSegmentedDisplay definitions)
-class YSegmentedDisplay; // forward declaration
-
-typedef void (*YSegmentedDisplayValueCallback)(YSegmentedDisplay *func, const string& functionValue);
-#ifndef _Y_DISPLAYMODE_ENUM
-#define _Y_DISPLAYMODE_ENUM
-typedef enum {
-    Y_DISPLAYMODE_DISCONNECTED = 0,
-    Y_DISPLAYMODE_MANUAL = 1,
-    Y_DISPLAYMODE_AUTO1 = 2,
-    Y_DISPLAYMODE_AUTO60 = 3,
-    Y_DISPLAYMODE_INVALID = -1,
-} Y_DISPLAYMODE_enum;
-#endif
-#define Y_DISPLAYEDTEXT_INVALID         (YAPI_INVALID_STRING)
-//--- (end of YSegmentedDisplay definitions)
-
-//--- (YSegmentedDisplay declaration)
-/**
- * YSegmentedDisplay Class: SegmentedDisplay function interface
- *
- * The SegmentedDisplay class allows you to drive segmented displays.
- */
-class YOCTO_CLASS_EXPORT YSegmentedDisplay: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YSegmentedDisplay declaration)
-protected:
-    //--- (YSegmentedDisplay attributes)
-    // Attributes (function value cache)
-    string          _displayedText;
-    Y_DISPLAYMODE_enum _displayMode;
-    YSegmentedDisplayValueCallback _valueCallbackSegmentedDisplay;
-
-    friend YSegmentedDisplay *yFindSegmentedDisplay(const string& func);
-    friend YSegmentedDisplay *yFirstSegmentedDisplay(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindSegmentedDisplay factory function to instantiate
-    YSegmentedDisplay(const string& func);
-    //--- (end of YSegmentedDisplay attributes)
-
-public:
-    virtual ~YSegmentedDisplay();
-    //--- (YSegmentedDisplay accessors declaration)
-
-    static const string DISPLAYEDTEXT_INVALID;
-    static const Y_DISPLAYMODE_enum DISPLAYMODE_DISCONNECTED = Y_DISPLAYMODE_DISCONNECTED;
-    static const Y_DISPLAYMODE_enum DISPLAYMODE_MANUAL = Y_DISPLAYMODE_MANUAL;
-    static const Y_DISPLAYMODE_enum DISPLAYMODE_AUTO1 = Y_DISPLAYMODE_AUTO1;
-    static const Y_DISPLAYMODE_enum DISPLAYMODE_AUTO60 = Y_DISPLAYMODE_AUTO60;
-    static const Y_DISPLAYMODE_enum DISPLAYMODE_INVALID = Y_DISPLAYMODE_INVALID;
-
-    /**
-     * Returns the text currently displayed on the screen.
-     *
-     * @return a string corresponding to the text currently displayed on the screen
-     *
-     * On failure, throws an exception or returns Y_DISPLAYEDTEXT_INVALID.
-     */
-    string              get_displayedText(void);
-
-    inline string       displayedText(void)
-    { return this->get_displayedText(); }
-
-    /**
-     * Changes the text currently displayed on the screen.
-     *
-     * @param newval : a string corresponding to the text currently displayed on the screen
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_displayedText(const string& newval);
-    inline int      setDisplayedText(const string& newval)
-    { return this->set_displayedText(newval); }
-
-    Y_DISPLAYMODE_enum  get_displayMode(void);
-
-    inline Y_DISPLAYMODE_enum displayMode(void)
-    { return this->get_displayMode(); }
-
-    int             set_displayMode(Y_DISPLAYMODE_enum newval);
-    inline int      setDisplayMode(Y_DISPLAYMODE_enum newval)
-    { return this->set_displayMode(newval); }
-
-    /**
-     * Retrieves a segmented display for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the segmented displays is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YSegmentedDisplay.isOnline() to test if the segmented displays is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a segmented display by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the segmented displays
-     *
-     * @return a YSegmentedDisplay object allowing you to drive the segmented displays.
-     */
-    static YSegmentedDisplay* FindSegmentedDisplay(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YSegmentedDisplayValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YSegmentedDisplay* Find(string func)
-    { return YSegmentedDisplay::FindSegmentedDisplay(func); }
-
-    /**
-     * Continues the enumeration of segmented displays started using yFirstSegmentedDisplay().
-     * Caution: You can't make any assumption about the returned segmented displays order.
-     * If you want to find a specific a segmented display, use SegmentedDisplay.findSegmentedDisplay()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YSegmentedDisplay object, corresponding to
-     *         a segmented display currently online, or a NULL pointer
-     *         if there are no more segmented displays to enumerate.
-     */
-           YSegmentedDisplay *nextSegmentedDisplay(void);
-    inline YSegmentedDisplay *next(void)
-    { return this->nextSegmentedDisplay();}
-
-    /**
-     * Starts the enumeration of segmented displays currently accessible.
-     * Use the method YSegmentedDisplay.nextSegmentedDisplay() to iterate on
-     * next segmented displays.
-     *
-     * @return a pointer to a YSegmentedDisplay object, corresponding to
-     *         the first segmented displays currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YSegmentedDisplay* FirstSegmentedDisplay(void);
-    inline static YSegmentedDisplay* First(void)
-    { return YSegmentedDisplay::FirstSegmentedDisplay();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YSegmentedDisplay accessors declaration)
-};
-
-//--- (YSegmentedDisplay functions declaration)
-
-/**
- * Retrieves a segmented display for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the segmented displays is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSegmentedDisplay.isOnline() to test if the segmented displays is
- * indeed online at a given time. In case of ambiguity when looking for
- * a segmented display by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the segmented displays
- *
- * @return a YSegmentedDisplay object allowing you to drive the segmented displays.
- */
-inline YSegmentedDisplay* yFindSegmentedDisplay(const string& func)
-{ return YSegmentedDisplay::FindSegmentedDisplay(func);}
-/**
- * Starts the enumeration of segmented displays currently accessible.
- * Use the method YSegmentedDisplay.nextSegmentedDisplay() to iterate on
- * next segmented displays.
- *
- * @return a pointer to a YSegmentedDisplay object, corresponding to
- *         the first segmented displays currently online, or a NULL pointer
- *         if there are none.
- */
-inline YSegmentedDisplay* yFirstSegmentedDisplay(void)
-{ return YSegmentedDisplay::FirstSegmentedDisplay();}
-
-//--- (end of YSegmentedDisplay functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_serialport.cpp
+++ /dev/null
@@ -1,2077 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_serialport.cpp 31375 2018-07-26 14:03:37Z seb $
- *
- * Implements yFindSerialPort(), the high-level API for SerialPort functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_serialport.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "serialport"
-
-
-YSnoopingRecord::YSnoopingRecord(const string& json):
-//--- (generated code: YSnoopingRecord initialization)
-    _tim(0)
-    ,_dir(0)
-//--- (end of generated code: YSnoopingRecord initialization)
-{
-    yJsonStateMachine j;
-    // Parse JSON data
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if(yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return ;
-    }
-    while(yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "m")) {
-            string tmp;
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return ;
-            }
-            tmp = (string)j.token;
-            while(j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-                tmp +=(string)j.token;
-            }
-            _dir = (tmp[0] == '<' ? 1 : 0);
-            _msg = tmp.substr(1);
-        } else if(!strcmp(j.token, "t")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return;
-            }
-            _tim = atoi(j.token);;
-        } else {
-            yJsonSkip(&j, 1);
-        }
-    }
-}
-
-//--- (generated code: YSnoopingRecord implementation)
-// static attributes
-
-
-int YSnoopingRecord::get_time(void)
-{
-    return _tim;
-}
-
-int YSnoopingRecord::get_direction(void)
-{
-    return _dir;
-}
-
-string YSnoopingRecord::get_message(void)
-{
-    return _msg;
-}
-//--- (end of generated code: YSnoopingRecord implementation)
-
-
-YSerialPort::YSerialPort(const string& func): YFunction(func)
-//--- (generated code: YSerialPort initialization)
-    ,_rxCount(RXCOUNT_INVALID)
-    ,_txCount(TXCOUNT_INVALID)
-    ,_errCount(ERRCOUNT_INVALID)
-    ,_rxMsgCount(RXMSGCOUNT_INVALID)
-    ,_txMsgCount(TXMSGCOUNT_INVALID)
-    ,_lastMsg(LASTMSG_INVALID)
-    ,_currentJob(CURRENTJOB_INVALID)
-    ,_startupJob(STARTUPJOB_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_voltageLevel(VOLTAGELEVEL_INVALID)
-    ,_protocol(PROTOCOL_INVALID)
-    ,_serialMode(SERIALMODE_INVALID)
-    ,_valueCallbackSerialPort(NULL)
-    ,_rxptr(0)
-    ,_rxbuffptr(0)
-//--- (end of generated code: YSerialPort initialization)
-{
-    _className="SerialPort";
-}
-
-YSerialPort::~YSerialPort()
-{
-//--- (generated code: YSerialPort cleanup)
-//--- (end of generated code: YSerialPort cleanup)
-}
-//--- (generated code: YSerialPort implementation)
-// static attributes
-const string YSerialPort::LASTMSG_INVALID = YAPI_INVALID_STRING;
-const string YSerialPort::CURRENTJOB_INVALID = YAPI_INVALID_STRING;
-const string YSerialPort::STARTUPJOB_INVALID = YAPI_INVALID_STRING;
-const string YSerialPort::COMMAND_INVALID = YAPI_INVALID_STRING;
-const string YSerialPort::PROTOCOL_INVALID = YAPI_INVALID_STRING;
-const string YSerialPort::SERIALMODE_INVALID = YAPI_INVALID_STRING;
-
-int YSerialPort::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("rxCount")) {
-        _rxCount =  json_val->getInt("rxCount");
-    }
-    if(json_val->has("txCount")) {
-        _txCount =  json_val->getInt("txCount");
-    }
-    if(json_val->has("errCount")) {
-        _errCount =  json_val->getInt("errCount");
-    }
-    if(json_val->has("rxMsgCount")) {
-        _rxMsgCount =  json_val->getInt("rxMsgCount");
-    }
-    if(json_val->has("txMsgCount")) {
-        _txMsgCount =  json_val->getInt("txMsgCount");
-    }
-    if(json_val->has("lastMsg")) {
-        _lastMsg =  json_val->getString("lastMsg");
-    }
-    if(json_val->has("currentJob")) {
-        _currentJob =  json_val->getString("currentJob");
-    }
-    if(json_val->has("startupJob")) {
-        _startupJob =  json_val->getString("startupJob");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    if(json_val->has("voltageLevel")) {
-        _voltageLevel =  (Y_VOLTAGELEVEL_enum)json_val->getInt("voltageLevel");
-    }
-    if(json_val->has("protocol")) {
-        _protocol =  json_val->getString("protocol");
-    }
-    if(json_val->has("serialMode")) {
-        _serialMode =  json_val->getString("serialMode");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the total number of bytes received since last reset.
- *
- * @return an integer corresponding to the total number of bytes received since last reset
- *
- * On failure, throws an exception or returns Y_RXCOUNT_INVALID.
- */
-int YSerialPort::get_rxCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::RXCOUNT_INVALID;
-                }
-            }
-        }
-        res = _rxCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of bytes transmitted since last reset.
- *
- * @return an integer corresponding to the total number of bytes transmitted since last reset
- *
- * On failure, throws an exception or returns Y_TXCOUNT_INVALID.
- */
-int YSerialPort::get_txCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::TXCOUNT_INVALID;
-                }
-            }
-        }
-        res = _txCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of communication errors detected since last reset.
- *
- * @return an integer corresponding to the total number of communication errors detected since last reset
- *
- * On failure, throws an exception or returns Y_ERRCOUNT_INVALID.
- */
-int YSerialPort::get_errCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::ERRCOUNT_INVALID;
-                }
-            }
-        }
-        res = _errCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of messages received since last reset.
- *
- * @return an integer corresponding to the total number of messages received since last reset
- *
- * On failure, throws an exception or returns Y_RXMSGCOUNT_INVALID.
- */
-int YSerialPort::get_rxMsgCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::RXMSGCOUNT_INVALID;
-                }
-            }
-        }
-        res = _rxMsgCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of messages send since last reset.
- *
- * @return an integer corresponding to the total number of messages send since last reset
- *
- * On failure, throws an exception or returns Y_TXMSGCOUNT_INVALID.
- */
-int YSerialPort::get_txMsgCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::TXMSGCOUNT_INVALID;
-                }
-            }
-        }
-        res = _txMsgCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the latest message fully received (for Line, Frame and Modbus protocols).
- *
- * @return a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)
- *
- * On failure, throws an exception or returns Y_LASTMSG_INVALID.
- */
-string YSerialPort::get_lastMsg(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::LASTMSG_INVALID;
-                }
-            }
-        }
-        res = _lastMsg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the name of the job file currently in use.
- *
- * @return a string corresponding to the name of the job file currently in use
- *
- * On failure, throws an exception or returns Y_CURRENTJOB_INVALID.
- */
-string YSerialPort::get_currentJob(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::CURRENTJOB_INVALID;
-                }
-            }
-        }
-        res = _currentJob;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the job to use when the device is powered on.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the job to use when the device is powered on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_currentJob(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("currentJob", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the job file to use when the device is powered on.
- *
- * @return a string corresponding to the job file to use when the device is powered on
- *
- * On failure, throws an exception or returns Y_STARTUPJOB_INVALID.
- */
-string YSerialPort::get_startupJob(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::STARTUPJOB_INVALID;
-                }
-            }
-        }
-        res = _startupJob;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the job to use when the device is powered on.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the job to use when the device is powered on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_startupJob(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("startupJob", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YSerialPort::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YSerialPort::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the voltage level used on the serial line.
- *
- * @return a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
- * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
- * corresponding to the voltage level used on the serial line
- *
- * On failure, throws an exception or returns Y_VOLTAGELEVEL_INVALID.
- */
-Y_VOLTAGELEVEL_enum YSerialPort::get_voltageLevel(void)
-{
-    Y_VOLTAGELEVEL_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::VOLTAGELEVEL_INVALID;
-                }
-            }
-        }
-        res = _voltageLevel;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage type used on the serial line. Valid
- * values  will depend on the Yoctopuce device model featuring
- * the serial port feature.  Check your device documentation
- * to find out which values are valid for that specific model.
- * Trying to set an invalid value will have no effect.
- *
- * @param newval : a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
- * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
- * corresponding to the voltage type used on the serial line
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_voltageLevel(Y_VOLTAGELEVEL_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("voltageLevel", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the type of protocol used over the serial line, as a string.
- * Possible values are "Line" for ASCII messages separated by CR and/or LF,
- * "Frame:[timeout]ms" for binary messages separated by a delay time,
- * "Modbus-ASCII" for MODBUS messages in ASCII mode,
- * "Modbus-RTU" for MODBUS messages in RTU mode,
- * "Wiegand-ASCII" for Wiegand messages in ASCII mode,
- * "Wiegand-26","Wiegand-34", etc for Wiegand messages in byte mode,
- * "Char" for a continuous ASCII stream or
- * "Byte" for a continuous binary stream.
- *
- * @return a string corresponding to the type of protocol used over the serial line, as a string
- *
- * On failure, throws an exception or returns Y_PROTOCOL_INVALID.
- */
-string YSerialPort::get_protocol(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::PROTOCOL_INVALID;
-                }
-            }
-        }
-        res = _protocol;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the type of protocol used over the serial line.
- * Possible values are "Line" for ASCII messages separated by CR and/or LF,
- * "Frame:[timeout]ms" for binary messages separated by a delay time,
- * "Modbus-ASCII" for MODBUS messages in ASCII mode,
- * "Modbus-RTU" for MODBUS messages in RTU mode,
- * "Wiegand-ASCII" for Wiegand messages in ASCII mode,
- * "Wiegand-26","Wiegand-34", etc for Wiegand messages in byte mode,
- * "Char" for a continuous ASCII stream or
- * "Byte" for a continuous binary stream.
- * The suffix "/[wait]ms" can be added to reduce the transmit rate so that there
- * is always at lest the specified number of milliseconds between each bytes sent.
- *
- * @param newval : a string corresponding to the type of protocol used over the serial line
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_protocol(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("protocol", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the serial port communication parameters, as a string such as
- * "9600,8N1". The string includes the baud rate, the number of data bits,
- * the parity, and the number of stop bits. An optional suffix is included
- * if flow control is active: "CtsRts" for hardware handshake, "XOnXOff"
- * for logical flow control and "Simplex" for acquiring a shared bus using
- * the RTS line (as used by some RS485 adapters for instance).
- *
- * @return a string corresponding to the serial port communication parameters, as a string such as
- *         "9600,8N1"
- *
- * On failure, throws an exception or returns Y_SERIALMODE_INVALID.
- */
-string YSerialPort::get_serialMode(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSerialPort::SERIALMODE_INVALID;
-                }
-            }
-        }
-        res = _serialMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the serial port communication parameters, with a string such as
- * "9600,8N1". The string includes the baud rate, the number of data bits,
- * the parity, and the number of stop bits. An optional suffix can be added
- * to enable flow control: "CtsRts" for hardware handshake, "XOnXOff"
- * for logical flow control and "Simplex" for acquiring a shared bus using
- * the RTS line (as used by some RS485 adapters for instance).
- *
- * @param newval : a string corresponding to the serial port communication parameters, with a string such as
- *         "9600,8N1"
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_serialMode(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("serialMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a serial port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the serial port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSerialPort.isOnline() to test if the serial port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a serial port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the serial port
- *
- * @return a YSerialPort object allowing you to drive the serial port.
- */
-YSerialPort* YSerialPort::FindSerialPort(string func)
-{
-    YSerialPort* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YSerialPort*) YFunction::_FindFromCache("SerialPort", func);
-        if (obj == NULL) {
-            obj = new YSerialPort(func);
-            YFunction::_AddToCache("SerialPort", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YSerialPort::registerValueCallback(YSerialPortValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackSerialPort = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YSerialPort::_invokeValueCallback(string value)
-{
-    if (_valueCallbackSerialPort != NULL) {
-        _valueCallbackSerialPort(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YSerialPort::sendCommand(string text)
-{
-    return this->set_command(text);
-}
-
-/**
- * Clears the serial port buffer and resets counters to zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::reset(void)
-{
-    _rxptr = 0;
-    _rxbuffptr = 0;
-    _rxbuff = string(0, (char)0);
-
-    return this->sendCommand("Z");
-}
-
-/**
- * Sends a single byte to the serial port.
- *
- * @param code : the byte to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeByte(int code)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("$%02X",code));
-}
-
-/**
- * Sends an ASCII string to the serial port, as is.
- *
- * @param text : the text string to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeStr(string text)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int ch = 0;
-    buff = text;
-    bufflen = (int)(buff).size();
-    if (bufflen < 100) {
-        // if string is pure text, we can send it as a simple command (faster)
-        ch = 0x20;
-        idx = 0;
-        while ((idx < bufflen) && (ch != 0)) {
-            ch = ((u8)buff[idx]);
-            if ((ch >= 0x20) && (ch < 0x7f)) {
-                idx = idx + 1;
-            } else {
-                ch = 0;
-            }
-        }
-        if (idx >= bufflen) {
-            return this->sendCommand(YapiWrapper::ysprintf("+%s",text.c_str()));
-        }
-    }
-    // send string using file upload
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Sends a binary buffer to the serial port, as is.
- *
- * @param buff : the binary buffer to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeBin(string buff)
-{
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Sends a byte sequence (provided as a list of bytes) to the serial port.
- *
- * @param byteList : a list of byte codes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeArray(vector<int> byteList)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int hexb = 0;
-    int res = 0;
-    bufflen = (int)byteList.size();
-    buff = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        hexb = byteList[idx];
-        buff[idx] = (char)(hexb);
-        idx = idx + 1;
-    }
-
-    res = this->_upload("txdata", buff);
-    return res;
-}
-
-/**
- * Sends a byte sequence (provided as a hexadecimal string) to the serial port.
- *
- * @param hexString : a string of hexadecimal byte codes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeHex(string hexString)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int hexb = 0;
-    int res = 0;
-    bufflen = (int)(hexString).length();
-    if (bufflen < 100) {
-        return this->sendCommand(YapiWrapper::ysprintf("$%s",hexString.c_str()));
-    }
-    bufflen = ((bufflen) >> (1));
-    buff = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        hexb = (int)strtoul((hexString).substr( 2 * idx, 2).c_str(), NULL, 16);
-        buff[idx] = (char)(hexb);
-        idx = idx + 1;
-    }
-
-    res = this->_upload("txdata", buff);
-    return res;
-}
-
-/**
- * Sends an ASCII string to the serial port, followed by a line break (CR LF).
- *
- * @param text : the text string to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeLine(string text)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int ch = 0;
-    buff = YapiWrapper::ysprintf("%s\r\n",text.c_str());
-    bufflen = (int)(buff).size()-2;
-    if (bufflen < 100) {
-        // if string is pure text, we can send it as a simple command (faster)
-        ch = 0x20;
-        idx = 0;
-        while ((idx < bufflen) && (ch != 0)) {
-            ch = ((u8)buff[idx]);
-            if ((ch >= 0x20) && (ch < 0x7f)) {
-                idx = idx + 1;
-            } else {
-                ch = 0;
-            }
-        }
-        if (idx >= bufflen) {
-            return this->sendCommand(YapiWrapper::ysprintf("!%s",text.c_str()));
-        }
-    }
-    // send string using file upload
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Reads one byte from the receive buffer, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer,
- * or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.
- *
- * @return the next byte
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::readByte(void)
-{
-    int currpos = 0;
-    int reqlen = 0;
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int res = 0;
-    // first check if we have the requested character in the look-ahead buffer
-    bufflen = (int)(_rxbuff).size();
-    if ((_rxptr >= _rxbuffptr) && (_rxptr < _rxbuffptr+bufflen)) {
-        res = ((u8)_rxbuff[_rxptr-_rxbuffptr]);
-        _rxptr = _rxptr + 1;
-        return res;
-    }
-    // try to preload more than one byte to speed-up byte-per-byte access
-    currpos = _rxptr;
-    reqlen = 1024;
-    buff = this->readBin(reqlen);
-    bufflen = (int)(buff).size();
-    if (_rxptr == currpos+bufflen) {
-        res = ((u8)buff[0]);
-        _rxptr = currpos+1;
-        _rxbuffptr = currpos;
-        _rxbuff = buff;
-        return res;
-    }
-    // mixed bidirectional data, retry with a smaller block
-    _rxptr = currpos;
-    reqlen = 16;
-    buff = this->readBin(reqlen);
-    bufflen = (int)(buff).size();
-    if (_rxptr == currpos+bufflen) {
-        res = ((u8)buff[0]);
-        _rxptr = currpos+1;
-        _rxbuffptr = currpos;
-        _rxbuff = buff;
-        return res;
-    }
-    // still mixed, need to process character by character
-    _rxptr = currpos;
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=1",_rxptr));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    if (bufflen == 0) {
-        return YAPI_NO_MORE_DATA;
-    }
-    res = ((u8)buff[0]);
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a string, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of characters to read
- *
- * @return a string with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSerialPort::readStr(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    string res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = (buff).substr( 0, bufflen);
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a binary buffer, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of bytes to read
- *
- * @return a binary object with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSerialPort::readBin(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int idx = 0;
-    string res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        res[idx] = (char)(((u8)buff[idx]));
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a list of bytes, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of bytes to read
- *
- * @return a sequence of bytes with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-vector<int> YSerialPort::readArray(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int idx = 0;
-    int b = 0;
-    vector<int> res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res.clear();
-    idx = 0;
-    while (idx < bufflen) {
-        b = ((u8)buff[idx]);
-        res.push_back(b);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a hexadecimal string, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nBytes : the maximum number of bytes to read
- *
- * @return a string with receive buffer contents, encoded in hexadecimal
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSerialPort::readHex(int nBytes)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int ofs = 0;
-    string res;
-    if (nBytes > 65535) {
-        nBytes = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nBytes));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = "";
-    ofs = 0;
-    while (ofs + 3 < bufflen) {
-        res = YapiWrapper::ysprintf("%s%02X%02X%02X%02X", res.c_str(), ((u8)buff[ofs]), ((u8)buff[ofs + 1]), ((u8)buff[ofs + 2]),((u8)buff[ofs + 3]));
-        ofs = ofs + 4;
-    }
-    while (ofs < bufflen) {
-        res = YapiWrapper::ysprintf("%s%02X", res.c_str(),((u8)buff[ofs]));
-        ofs = ofs + 1;
-    }
-    return res;
-}
-
-/**
- * Reads a single line (or message) from the receive buffer, starting at current stream position.
- * This function is intended to be used when the serial port is configured for a message protocol,
- * such as 'Line' mode or frame protocols.
- *
- * If data at current stream position is not available anymore in the receive buffer,
- * the function returns the oldest available line and moves the stream position just after.
- * If no new full line is received, the function returns an empty line.
- *
- * @return a string with a single line of text
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSerialPort::readLine(void)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    string res;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?pos=%d&len=1&maxw=1",_rxptr);
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return "";
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    if (msglen == 0) {
-        return "";
-    }
-    res = this->_json_get_string(msgarr[0]);
-    return res;
-}
-
-/**
- * Searches for incoming messages in the serial port receive buffer matching a given pattern,
- * starting at current position. This function will only compare and return printable characters
- * in the message strings. Binary protocols are handled as hexadecimal strings.
- *
- * The search returns all messages matching the expression provided as argument in the buffer.
- * If no matching message is found, the search waits for one up to the specified maximum timeout
- * (in milliseconds).
- *
- * @param pattern : a limited regular expression describing the expected message format,
- *         or an empty string if all messages should be returned (no filtering).
- *         When using binary protocols, the format applies to the hexadecimal
- *         representation of the message.
- * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
- *         in the receive buffer.
- *
- * @return an array of strings containing the messages found, if any.
- *         Binary messages are converted to hexadecimal representation.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<string> YSerialPort::readMessages(string pattern,int maxWait)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    vector<string> res;
-    int idx = 0;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?pos=%d&maxw=%d&pat=%s", _rxptr, maxWait,pattern.c_str());
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return res;
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    idx = 0;
-    while (idx < msglen) {
-        res.push_back(this->_json_get_string(msgarr[idx]));
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Changes the current internal stream position to the specified value. This function
- * does not affect the device, it only changes the value stored in the API object
- * for the next read operations.
- *
- * @param absPos : the absolute position index for next read operations.
- *
- * @return nothing.
- */
-int YSerialPort::read_seek(int absPos)
-{
-    _rxptr = absPos;
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns the current absolute stream position pointer of the API object.
- *
- * @return the absolute position index for next read operations.
- */
-int YSerialPort::read_tell(void)
-{
-    return _rxptr;
-}
-
-/**
- * Returns the number of bytes available to read in the input buffer starting from the
- * current absolute stream position pointer of the API object.
- *
- * @return the number of bytes available to read
- */
-int YSerialPort::read_avail(void)
-{
-    string buff;
-    int bufflen = 0;
-    int res = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rxcnt.bin?pos=%d",_rxptr));
-    bufflen = (int)(buff).size() - 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        bufflen = bufflen - 1;
-    }
-    res = atoi(((buff).substr( 0, bufflen)).c_str());
-    return res;
-}
-
-/**
- * Sends a text line query to the serial port, and reads the reply, if any.
- * This function is intended to be used when the serial port is configured for 'Line' protocol.
- *
- * @param query : the line query to send (without CR/LF)
- * @param maxWait : the maximum number of milliseconds to wait for a reply.
- *
- * @return the next text line received after sending the text query, as a string.
- *         Additional lines can be obtained by calling readLine or readMessages.
- *
- * On failure, throws an exception or returns an empty array.
- */
-string YSerialPort::queryLine(string query,int maxWait)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    string res;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?len=1&maxw=%d&cmd=!%s", maxWait,query.c_str());
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return "";
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    if (msglen == 0) {
-        return "";
-    }
-    res = this->_json_get_string(msgarr[0]);
-    return res;
-}
-
-/**
- * Saves the job definition string (JSON data) into a job file.
- * The job file can be later enabled using selectJob().
- *
- * @param jobfile : name of the job file to save on the device filesystem
- * @param jsonDef : a string containing a JSON definition of the job
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::uploadJob(string jobfile,string jsonDef)
-{
-    this->_upload(jobfile, jsonDef);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Load and start processing the specified job file. The file must have
- * been previously created using the user interface or uploaded on the
- * device filesystem using the uploadJob() function.
- *
- * @param jobfile : name of the job file (on the device filesystem)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::selectJob(string jobfile)
-{
-    return this->set_currentJob(jobfile);
-}
-
-/**
- * Manually sets the state of the RTS line. This function has no effect when
- * hardware handshake is enabled, as the RTS line is driven automatically.
- *
- * @param val : 1 to turn RTS on, 0 to turn RTS off
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::set_RTS(int val)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("R%d",val));
-}
-
-/**
- * Reads the level of the CTS line. The CTS line is usually driven by
- * the RTS signal of the connected serial device.
- *
- * @return 1 if the CTS line is high, 0 if the CTS line is low.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::get_CTS(void)
-{
-    string buff;
-    int res = 0;
-
-    buff = this->_download("cts.txt");
-    if (!((int)(buff).size() == 1)) {
-        _throw(YAPI_IO_ERROR,"invalid CTS reply");
-        return YAPI_IO_ERROR;
-    }
-    res = ((u8)buff[0]) - 48;
-    return res;
-}
-
-/**
- * Retrieves messages (both direction) in the serial port buffer, starting at current position.
- * This function will only compare and return printable characters in the message strings.
- * Binary protocols are handled as hexadecimal strings.
- *
- * If no message is found, the search waits for one up to the specified maximum timeout
- * (in milliseconds).
- *
- * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
- *         in the receive buffer.
- *
- * @return an array of YSnoopingRecord objects containing the messages found, if any.
- *         Binary messages are converted to hexadecimal representation.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<YSnoopingRecord> YSerialPort::snoopMessages(int maxWait)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    vector<YSnoopingRecord> res;
-    int idx = 0;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?pos=%d&maxw=%d&t=0", _rxptr,maxWait);
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return res;
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    idx = 0;
-    while (idx < msglen) {
-        res.push_back(YSnoopingRecord(msgarr[idx]));
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Sends a MODBUS message (provided as a hexadecimal string) to the serial port.
- * The message must start with the slave address. The MODBUS CRC/LRC is
- * automatically added by the function. This function does not wait for a reply.
- *
- * @param hexString : a hexadecimal message string, including device address but no CRC/LRC
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSerialPort::writeMODBUS(string hexString)
-{
-    return this->sendCommand(YapiWrapper::ysprintf(":%s",hexString.c_str()));
-}
-
-/**
- * Sends a message to a specified MODBUS slave connected to the serial port, and reads the
- * reply, if any. The message is the PDU, provided as a vector of bytes.
- *
- * @param slaveNo : the address of the slave MODBUS device to query
- * @param pduBytes : the message to send (PDU), as a vector of bytes. The first byte of the
- *         PDU is the MODBUS function code.
- *
- * @return the received reply, as a vector of bytes.
- *
- * On failure, throws an exception or returns an empty array (or a MODBUS error reply).
- */
-vector<int> YSerialPort::queryMODBUS(int slaveNo,vector<int> pduBytes)
-{
-    int funCode = 0;
-    int nib = 0;
-    int i = 0;
-    string cmd;
-    string url;
-    string pat;
-    string msgs;
-    vector<string> reps;
-    string rep;
-    vector<int> res;
-    int replen = 0;
-    int hexb = 0;
-    funCode = pduBytes[0];
-    nib = ((funCode) >> (4));
-    pat = YapiWrapper::ysprintf("%02X[%X%X]%X.*", slaveNo, nib, (nib+8),((funCode) & (15)));
-    cmd = YapiWrapper::ysprintf("%02X%02X", slaveNo,funCode);
-    i = 1;
-    while (i < (int)pduBytes.size()) {
-        cmd = YapiWrapper::ysprintf("%s%02X", cmd.c_str(),((pduBytes[i]) & (0xff)));
-        i = i + 1;
-    }
-
-    url = YapiWrapper::ysprintf("rxmsg.json?cmd=:%s&pat=:%s", cmd.c_str(),pat.c_str());
-    msgs = this->_download(url);
-    reps = this->_json_get_array(msgs);
-    if (!((int)reps.size() > 1)) {
-        _throw(YAPI_IO_ERROR,"no reply from slave");
-        return res;
-    }
-    if ((int)reps.size() > 1) {
-        rep = this->_json_get_string(reps[0]);
-        replen = (((int)(rep).length() - 3) >> (1));
-        i = 0;
-        while (i < replen) {
-            hexb = (int)strtoul((rep).substr(2 * i + 3, 2).c_str(), NULL, 16);
-            res.push_back(hexb);
-            i = i + 1;
-        }
-        if (res[0] != funCode) {
-            i = res[1];
-            if (!(i > 1)) {
-                _throw(YAPI_NOT_SUPPORTED,"MODBUS error: unsupported function code");
-                return res;
-            }
-            if (!(i > 2)) {
-                _throw(YAPI_INVALID_ARGUMENT,"MODBUS error: illegal data address");
-                return res;
-            }
-            if (!(i > 3)) {
-                _throw(YAPI_INVALID_ARGUMENT,"MODBUS error: illegal data value");
-                return res;
-            }
-            if (!(i > 4)) {
-                _throw(YAPI_INVALID_ARGUMENT,"MODBUS error: failed to execute function");
-                return res;
-            }
-        }
-    }
-    return res;
-}
-
-/**
- * Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.
- * This method uses the MODBUS function code 0x01 (Read Coils).
- *
- * @param slaveNo : the address of the slave MODBUS device to query
- * @param pduAddr : the relative address of the first bit/coil to read (zero-based)
- * @param nBits : the number of bits/coils to read
- *
- * @return a vector of integers, each corresponding to one bit.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YSerialPort::modbusReadBits(int slaveNo,int pduAddr,int nBits)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    vector<int> res;
-    int bitpos = 0;
-    int idx = 0;
-    int val = 0;
-    int mask = 0;
-    pdu.push_back(0x01);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nBits) >> (8)));
-    pdu.push_back(((nBits) & (0xff)));
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    bitpos = 0;
-    idx = 2;
-    val = reply[idx];
-    mask = 1;
-    while (bitpos < nBits) {
-        if (((val) & (mask)) == 0) {
-            res.push_back(0);
-        } else {
-            res.push_back(1);
-        }
-        bitpos = bitpos + 1;
-        if (mask == 0x80) {
-            idx = idx + 1;
-            val = reply[idx];
-            mask = 1;
-        } else {
-            mask = ((mask) << (1));
-        }
-    }
-    return res;
-}
-
-/**
- * Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.
- * This method uses the MODBUS function code 0x02 (Read Discrete Inputs).
- *
- * @param slaveNo : the address of the slave MODBUS device to query
- * @param pduAddr : the relative address of the first bit/input to read (zero-based)
- * @param nBits : the number of bits/inputs to read
- *
- * @return a vector of integers, each corresponding to one bit.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YSerialPort::modbusReadInputBits(int slaveNo,int pduAddr,int nBits)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    vector<int> res;
-    int bitpos = 0;
-    int idx = 0;
-    int val = 0;
-    int mask = 0;
-    pdu.push_back(0x02);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nBits) >> (8)));
-    pdu.push_back(((nBits) & (0xff)));
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    bitpos = 0;
-    idx = 2;
-    val = reply[idx];
-    mask = 1;
-    while (bitpos < nBits) {
-        if (((val) & (mask)) == 0) {
-            res.push_back(0);
-        } else {
-            res.push_back(1);
-        }
-        bitpos = bitpos + 1;
-        if (mask == 0x80) {
-            idx = idx + 1;
-            val = reply[idx];
-            mask = 1;
-        } else {
-            mask = ((mask) << (1));
-        }
-    }
-    return res;
-}
-
-/**
- * Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.
- * This method uses the MODBUS function code 0x03 (Read Holding Registers).
- *
- * @param slaveNo : the address of the slave MODBUS device to query
- * @param pduAddr : the relative address of the first holding register to read (zero-based)
- * @param nWords : the number of holding registers to read
- *
- * @return a vector of integers, each corresponding to one 16-bit register value.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YSerialPort::modbusReadRegisters(int slaveNo,int pduAddr,int nWords)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    vector<int> res;
-    int regpos = 0;
-    int idx = 0;
-    int val = 0;
-    pdu.push_back(0x03);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nWords) >> (8)));
-    pdu.push_back(((nWords) & (0xff)));
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    regpos = 0;
-    idx = 2;
-    while (regpos < nWords) {
-        val = ((reply[idx]) << (8));
-        idx = idx + 1;
-        val = val + reply[idx];
-        idx = idx + 1;
-        res.push_back(val);
-        regpos = regpos + 1;
-    }
-    return res;
-}
-
-/**
- * Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.
- * This method uses the MODBUS function code 0x04 (Read Input Registers).
- *
- * @param slaveNo : the address of the slave MODBUS device to query
- * @param pduAddr : the relative address of the first input register to read (zero-based)
- * @param nWords : the number of input registers to read
- *
- * @return a vector of integers, each corresponding to one 16-bit input value.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YSerialPort::modbusReadInputRegisters(int slaveNo,int pduAddr,int nWords)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    vector<int> res;
-    int regpos = 0;
-    int idx = 0;
-    int val = 0;
-    pdu.push_back(0x04);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nWords) >> (8)));
-    pdu.push_back(((nWords) & (0xff)));
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    regpos = 0;
-    idx = 2;
-    while (regpos < nWords) {
-        val = ((reply[idx]) << (8));
-        idx = idx + 1;
-        val = val + reply[idx];
-        idx = idx + 1;
-        res.push_back(val);
-        regpos = regpos + 1;
-    }
-    return res;
-}
-
-/**
- * Sets a single internal bit (or coil) on a MODBUS serial device.
- * This method uses the MODBUS function code 0x05 (Write Single Coil).
- *
- * @param slaveNo : the address of the slave MODBUS device to drive
- * @param pduAddr : the relative address of the bit/coil to set (zero-based)
- * @param value : the value to set (0 for OFF state, non-zero for ON state)
- *
- * @return the number of bits/coils affected on the device (1)
- *
- * On failure, throws an exception or returns zero.
- */
-int YSerialPort::modbusWriteBit(int slaveNo,int pduAddr,int value)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    int res = 0;
-    res = 0;
-    if (value != 0) {
-        value = 0xff;
-    }
-    pdu.push_back(0x05);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(value);
-    pdu.push_back(0x00);
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    res = 1;
-    return res;
-}
-
-/**
- * Sets several contiguous internal bits (or coils) on a MODBUS serial device.
- * This method uses the MODBUS function code 0x0f (Write Multiple Coils).
- *
- * @param slaveNo : the address of the slave MODBUS device to drive
- * @param pduAddr : the relative address of the first bit/coil to set (zero-based)
- * @param bits : the vector of bits to be set (one integer per bit)
- *
- * @return the number of bits/coils affected on the device
- *
- * On failure, throws an exception or returns zero.
- */
-int YSerialPort::modbusWriteBits(int slaveNo,int pduAddr,vector<int> bits)
-{
-    int nBits = 0;
-    int nBytes = 0;
-    int bitpos = 0;
-    int val = 0;
-    int mask = 0;
-    vector<int> pdu;
-    vector<int> reply;
-    int res = 0;
-    res = 0;
-    nBits = (int)bits.size();
-    nBytes = (((nBits + 7)) >> (3));
-    pdu.push_back(0x0f);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nBits) >> (8)));
-    pdu.push_back(((nBits) & (0xff)));
-    pdu.push_back(nBytes);
-    bitpos = 0;
-    val = 0;
-    mask = 1;
-    while (bitpos < nBits) {
-        if (bits[bitpos] != 0) {
-            val = ((val) | (mask));
-        }
-        bitpos = bitpos + 1;
-        if (mask == 0x80) {
-            pdu.push_back(val);
-            val = 0;
-            mask = 1;
-        } else {
-            mask = ((mask) << (1));
-        }
-    }
-    if (mask != 1) {
-        pdu.push_back(val);
-    }
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    res = ((reply[3]) << (8));
-    res = res + reply[4];
-    return res;
-}
-
-/**
- * Sets a single internal register (or holding register) on a MODBUS serial device.
- * This method uses the MODBUS function code 0x06 (Write Single Register).
- *
- * @param slaveNo : the address of the slave MODBUS device to drive
- * @param pduAddr : the relative address of the register to set (zero-based)
- * @param value : the 16 bit value to set
- *
- * @return the number of registers affected on the device (1)
- *
- * On failure, throws an exception or returns zero.
- */
-int YSerialPort::modbusWriteRegister(int slaveNo,int pduAddr,int value)
-{
-    vector<int> pdu;
-    vector<int> reply;
-    int res = 0;
-    res = 0;
-    pdu.push_back(0x06);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((value) >> (8)));
-    pdu.push_back(((value) & (0xff)));
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    res = 1;
-    return res;
-}
-
-/**
- * Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.
- * This method uses the MODBUS function code 0x10 (Write Multiple Registers).
- *
- * @param slaveNo : the address of the slave MODBUS device to drive
- * @param pduAddr : the relative address of the first internal register to set (zero-based)
- * @param values : the vector of 16 bit values to set
- *
- * @return the number of registers affected on the device
- *
- * On failure, throws an exception or returns zero.
- */
-int YSerialPort::modbusWriteRegisters(int slaveNo,int pduAddr,vector<int> values)
-{
-    int nWords = 0;
-    int nBytes = 0;
-    int regpos = 0;
-    int val = 0;
-    vector<int> pdu;
-    vector<int> reply;
-    int res = 0;
-    res = 0;
-    nWords = (int)values.size();
-    nBytes = 2 * nWords;
-    pdu.push_back(0x10);
-    pdu.push_back(((pduAddr) >> (8)));
-    pdu.push_back(((pduAddr) & (0xff)));
-    pdu.push_back(((nWords) >> (8)));
-    pdu.push_back(((nWords) & (0xff)));
-    pdu.push_back(nBytes);
-    regpos = 0;
-    while (regpos < nWords) {
-        val = values[regpos];
-        pdu.push_back(((val) >> (8)));
-        pdu.push_back(((val) & (0xff)));
-        regpos = regpos + 1;
-    }
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    res = ((reply[3]) << (8));
-    res = res + reply[4];
-    return res;
-}
-
-/**
- * Sets several contiguous internal registers (holding registers) on a MODBUS serial device,
- * then performs a contiguous read of a set of (possibly different) internal registers.
- * This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).
- *
- * @param slaveNo : the address of the slave MODBUS device to drive
- * @param pduWriteAddr : the relative address of the first internal register to set (zero-based)
- * @param values : the vector of 16 bit values to set
- * @param pduReadAddr : the relative address of the first internal register to read (zero-based)
- * @param nReadWords : the number of 16 bit values to read
- *
- * @return a vector of integers, each corresponding to one 16-bit register value read.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<int> YSerialPort::modbusWriteAndReadRegisters(int slaveNo,int pduWriteAddr,vector<int> values,int pduReadAddr,int nReadWords)
-{
-    int nWriteWords = 0;
-    int nBytes = 0;
-    int regpos = 0;
-    int val = 0;
-    int idx = 0;
-    vector<int> pdu;
-    vector<int> reply;
-    vector<int> res;
-    nWriteWords = (int)values.size();
-    nBytes = 2 * nWriteWords;
-    pdu.push_back(0x17);
-    pdu.push_back(((pduReadAddr) >> (8)));
-    pdu.push_back(((pduReadAddr) & (0xff)));
-    pdu.push_back(((nReadWords) >> (8)));
-    pdu.push_back(((nReadWords) & (0xff)));
-    pdu.push_back(((pduWriteAddr) >> (8)));
-    pdu.push_back(((pduWriteAddr) & (0xff)));
-    pdu.push_back(((nWriteWords) >> (8)));
-    pdu.push_back(((nWriteWords) & (0xff)));
-    pdu.push_back(nBytes);
-    regpos = 0;
-    while (regpos < nWriteWords) {
-        val = values[regpos];
-        pdu.push_back(((val) >> (8)));
-        pdu.push_back(((val) & (0xff)));
-        regpos = regpos + 1;
-    }
-
-    reply = this->queryMODBUS(slaveNo, pdu);
-    if ((int)reply.size() == 0) {
-        return res;
-    }
-    if (reply[0] != pdu[0]) {
-        return res;
-    }
-    regpos = 0;
-    idx = 2;
-    while (regpos < nReadWords) {
-        val = ((reply[idx]) << (8));
-        idx = idx + 1;
-        val = val + reply[idx];
-        idx = idx + 1;
-        res.push_back(val);
-        regpos = regpos + 1;
-    }
-    return res;
-}
-
-YSerialPort *YSerialPort::nextSerialPort(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YSerialPort::FindSerialPort(hwid);
-}
-
-YSerialPort* YSerialPort::FirstSerialPort(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("SerialPort", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YSerialPort::FindSerialPort(serial+"."+funcId);
-}
-
-//--- (end of generated code: YSerialPort implementation)
-
-//--- (generated code: YSerialPort functions)
-//--- (end of generated code: YSerialPort functions)
--- a/Sources/cpplib/yocto_serialport.h
+++ /dev/null
@@ -1,1014 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_serialport.h 32901 2018-11-02 10:13:09Z seb $
- *
- * Declares yFindSerialPort(), the high-level API for SerialPort functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_SERIALPORT_H
-#define YOCTO_SERIALPORT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (generated code: YSerialPort return codes)
-//--- (end of generated code: YSerialPort return codes)
-//--- (generated code: YSerialPort definitions)
-class YSerialPort; // forward declaration
-
-typedef void (*YSerialPortValueCallback)(YSerialPort *func, const string& functionValue);
-#ifndef _Y_VOLTAGELEVEL_ENUM
-#define _Y_VOLTAGELEVEL_ENUM
-typedef enum {
-    Y_VOLTAGELEVEL_OFF = 0,
-    Y_VOLTAGELEVEL_TTL3V = 1,
-    Y_VOLTAGELEVEL_TTL3VR = 2,
-    Y_VOLTAGELEVEL_TTL5V = 3,
-    Y_VOLTAGELEVEL_TTL5VR = 4,
-    Y_VOLTAGELEVEL_RS232 = 5,
-    Y_VOLTAGELEVEL_RS485 = 6,
-    Y_VOLTAGELEVEL_INVALID = -1,
-} Y_VOLTAGELEVEL_enum;
-#endif
-#define Y_RXCOUNT_INVALID               (YAPI_INVALID_UINT)
-#define Y_TXCOUNT_INVALID               (YAPI_INVALID_UINT)
-#define Y_ERRCOUNT_INVALID              (YAPI_INVALID_UINT)
-#define Y_RXMSGCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_TXMSGCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_LASTMSG_INVALID               (YAPI_INVALID_STRING)
-#define Y_CURRENTJOB_INVALID            (YAPI_INVALID_STRING)
-#define Y_STARTUPJOB_INVALID            (YAPI_INVALID_STRING)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-#define Y_PROTOCOL_INVALID              (YAPI_INVALID_STRING)
-#define Y_SERIALMODE_INVALID            (YAPI_INVALID_STRING)
-//--- (end of generated code: YSerialPort definitions)
-
-
-//--- (generated code: YSnoopingRecord definitions)
-//--- (end of generated code: YSnoopingRecord definitions)
-
-//--- (generated code: YSnoopingRecord declaration)
-/**
- * YSnoopingRecord Class: Description of a message intercepted
- *
- *
- */
-class YOCTO_CLASS_EXPORT YSnoopingRecord {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YSnoopingRecord declaration)
-    //--- (generated code: YSnoopingRecord attributes)
-    // Attributes (function value cache)
-    int             _tim;
-    int             _dir;
-    string          _msg;
-    //--- (end of generated code: YSnoopingRecord attributes)
-    //--- (generated code: YSnoopingRecord constructor)
-
-    //--- (end of generated code: YSnoopingRecord constructor)
-    //--- (generated code: YSnoopingRecord initialization)
-    //--- (end of generated code: YSnoopingRecord initialization)
-
-public:
-    YSnoopingRecord(const string& json);
-    virtual ~YSnoopingRecord(){};
-
-    //--- (generated code: YSnoopingRecord accessors declaration)
-
-
-    virtual int         get_time(void);
-
-    virtual int         get_direction(void);
-
-    virtual string      get_message(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YSnoopingRecord accessors declaration)
-};
-
-
-
-
-
-//--- (generated code: YSerialPort declaration)
-/**
- * YSerialPort Class: SerialPort function interface
- *
- * The SerialPort function interface allows you to fully drive a Yoctopuce
- * serial port, to send and receive data, and to configure communication
- * parameters (baud rate, bit count, parity, flow control and protocol).
- * Note that Yoctopuce serial ports are not exposed as virtual COM ports.
- * They are meant to be used in the same way as all Yoctopuce devices.
- */
-class YOCTO_CLASS_EXPORT YSerialPort: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YSerialPort declaration)
-protected:
-    //--- (generated code: YSerialPort attributes)
-    // Attributes (function value cache)
-    int             _rxCount;
-    int             _txCount;
-    int             _errCount;
-    int             _rxMsgCount;
-    int             _txMsgCount;
-    string          _lastMsg;
-    string          _currentJob;
-    string          _startupJob;
-    string          _command;
-    Y_VOLTAGELEVEL_enum _voltageLevel;
-    string          _protocol;
-    string          _serialMode;
-    YSerialPortValueCallback _valueCallbackSerialPort;
-    int             _rxptr;
-    string          _rxbuff;
-    int             _rxbuffptr;
-
-    friend YSerialPort *yFindSerialPort(const string& func);
-    friend YSerialPort *yFirstSerialPort(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindSerialPort factory function to instantiate
-    YSerialPort(const string& func);
-    //--- (end of generated code: YSerialPort attributes)
-
-public:
-    ~YSerialPort();
-    //--- (generated code: YSerialPort accessors declaration)
-
-    static const int RXCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int TXCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int ERRCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int RXMSGCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int TXMSGCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const string LASTMSG_INVALID;
-    static const string CURRENTJOB_INVALID;
-    static const string STARTUPJOB_INVALID;
-    static const string COMMAND_INVALID;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_OFF = Y_VOLTAGELEVEL_OFF;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL3V = Y_VOLTAGELEVEL_TTL3V;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL3VR = Y_VOLTAGELEVEL_TTL3VR;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL5V = Y_VOLTAGELEVEL_TTL5V;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL5VR = Y_VOLTAGELEVEL_TTL5VR;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_RS232 = Y_VOLTAGELEVEL_RS232;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_RS485 = Y_VOLTAGELEVEL_RS485;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_INVALID = Y_VOLTAGELEVEL_INVALID;
-    static const string PROTOCOL_INVALID;
-    static const string SERIALMODE_INVALID;
-
-    /**
-     * Returns the total number of bytes received since last reset.
-     *
-     * @return an integer corresponding to the total number of bytes received since last reset
-     *
-     * On failure, throws an exception or returns Y_RXCOUNT_INVALID.
-     */
-    int                 get_rxCount(void);
-
-    inline int          rxCount(void)
-    { return this->get_rxCount(); }
-
-    /**
-     * Returns the total number of bytes transmitted since last reset.
-     *
-     * @return an integer corresponding to the total number of bytes transmitted since last reset
-     *
-     * On failure, throws an exception or returns Y_TXCOUNT_INVALID.
-     */
-    int                 get_txCount(void);
-
-    inline int          txCount(void)
-    { return this->get_txCount(); }
-
-    /**
-     * Returns the total number of communication errors detected since last reset.
-     *
-     * @return an integer corresponding to the total number of communication errors detected since last reset
-     *
-     * On failure, throws an exception or returns Y_ERRCOUNT_INVALID.
-     */
-    int                 get_errCount(void);
-
-    inline int          errCount(void)
-    { return this->get_errCount(); }
-
-    /**
-     * Returns the total number of messages received since last reset.
-     *
-     * @return an integer corresponding to the total number of messages received since last reset
-     *
-     * On failure, throws an exception or returns Y_RXMSGCOUNT_INVALID.
-     */
-    int                 get_rxMsgCount(void);
-
-    inline int          rxMsgCount(void)
-    { return this->get_rxMsgCount(); }
-
-    /**
-     * Returns the total number of messages send since last reset.
-     *
-     * @return an integer corresponding to the total number of messages send since last reset
-     *
-     * On failure, throws an exception or returns Y_TXMSGCOUNT_INVALID.
-     */
-    int                 get_txMsgCount(void);
-
-    inline int          txMsgCount(void)
-    { return this->get_txMsgCount(); }
-
-    /**
-     * Returns the latest message fully received (for Line, Frame and Modbus protocols).
-     *
-     * @return a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)
-     *
-     * On failure, throws an exception or returns Y_LASTMSG_INVALID.
-     */
-    string              get_lastMsg(void);
-
-    inline string       lastMsg(void)
-    { return this->get_lastMsg(); }
-
-    /**
-     * Returns the name of the job file currently in use.
-     *
-     * @return a string corresponding to the name of the job file currently in use
-     *
-     * On failure, throws an exception or returns Y_CURRENTJOB_INVALID.
-     */
-    string              get_currentJob(void);
-
-    inline string       currentJob(void)
-    { return this->get_currentJob(); }
-
-    /**
-     * Changes the job to use when the device is powered on.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the job to use when the device is powered on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentJob(const string& newval);
-    inline int      setCurrentJob(const string& newval)
-    { return this->set_currentJob(newval); }
-
-    /**
-     * Returns the job file to use when the device is powered on.
-     *
-     * @return a string corresponding to the job file to use when the device is powered on
-     *
-     * On failure, throws an exception or returns Y_STARTUPJOB_INVALID.
-     */
-    string              get_startupJob(void);
-
-    inline string       startupJob(void)
-    { return this->get_startupJob(); }
-
-    /**
-     * Changes the job to use when the device is powered on.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the job to use when the device is powered on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_startupJob(const string& newval);
-    inline int      setStartupJob(const string& newval)
-    { return this->set_startupJob(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Returns the voltage level used on the serial line.
-     *
-     * @return a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
-     * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
-     * corresponding to the voltage level used on the serial line
-     *
-     * On failure, throws an exception or returns Y_VOLTAGELEVEL_INVALID.
-     */
-    Y_VOLTAGELEVEL_enum get_voltageLevel(void);
-
-    inline Y_VOLTAGELEVEL_enum voltageLevel(void)
-    { return this->get_voltageLevel(); }
-
-    /**
-     * Changes the voltage type used on the serial line. Valid
-     * values  will depend on the Yoctopuce device model featuring
-     * the serial port feature.  Check your device documentation
-     * to find out which values are valid for that specific model.
-     * Trying to set an invalid value will have no effect.
-     *
-     * @param newval : a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
-     * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
-     * corresponding to the voltage type used on the serial line
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageLevel(Y_VOLTAGELEVEL_enum newval);
-    inline int      setVoltageLevel(Y_VOLTAGELEVEL_enum newval)
-    { return this->set_voltageLevel(newval); }
-
-    /**
-     * Returns the type of protocol used over the serial line, as a string.
-     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
-     * "Frame:[timeout]ms" for binary messages separated by a delay time,
-     * "Modbus-ASCII" for MODBUS messages in ASCII mode,
-     * "Modbus-RTU" for MODBUS messages in RTU mode,
-     * "Wiegand-ASCII" for Wiegand messages in ASCII mode,
-     * "Wiegand-26","Wiegand-34", etc for Wiegand messages in byte mode,
-     * "Char" for a continuous ASCII stream or
-     * "Byte" for a continuous binary stream.
-     *
-     * @return a string corresponding to the type of protocol used over the serial line, as a string
-     *
-     * On failure, throws an exception or returns Y_PROTOCOL_INVALID.
-     */
-    string              get_protocol(void);
-
-    inline string       protocol(void)
-    { return this->get_protocol(); }
-
-    /**
-     * Changes the type of protocol used over the serial line.
-     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
-     * "Frame:[timeout]ms" for binary messages separated by a delay time,
-     * "Modbus-ASCII" for MODBUS messages in ASCII mode,
-     * "Modbus-RTU" for MODBUS messages in RTU mode,
-     * "Wiegand-ASCII" for Wiegand messages in ASCII mode,
-     * "Wiegand-26","Wiegand-34", etc for Wiegand messages in byte mode,
-     * "Char" for a continuous ASCII stream or
-     * "Byte" for a continuous binary stream.
-     * The suffix "/[wait]ms" can be added to reduce the transmit rate so that there
-     * is always at lest the specified number of milliseconds between each bytes sent.
-     *
-     * @param newval : a string corresponding to the type of protocol used over the serial line
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_protocol(const string& newval);
-    inline int      setProtocol(const string& newval)
-    { return this->set_protocol(newval); }
-
-    /**
-     * Returns the serial port communication parameters, as a string such as
-     * "9600,8N1". The string includes the baud rate, the number of data bits,
-     * the parity, and the number of stop bits. An optional suffix is included
-     * if flow control is active: "CtsRts" for hardware handshake, "XOnXOff"
-     * for logical flow control and "Simplex" for acquiring a shared bus using
-     * the RTS line (as used by some RS485 adapters for instance).
-     *
-     * @return a string corresponding to the serial port communication parameters, as a string such as
-     *         "9600,8N1"
-     *
-     * On failure, throws an exception or returns Y_SERIALMODE_INVALID.
-     */
-    string              get_serialMode(void);
-
-    inline string       serialMode(void)
-    { return this->get_serialMode(); }
-
-    /**
-     * Changes the serial port communication parameters, with a string such as
-     * "9600,8N1". The string includes the baud rate, the number of data bits,
-     * the parity, and the number of stop bits. An optional suffix can be added
-     * to enable flow control: "CtsRts" for hardware handshake, "XOnXOff"
-     * for logical flow control and "Simplex" for acquiring a shared bus using
-     * the RTS line (as used by some RS485 adapters for instance).
-     *
-     * @param newval : a string corresponding to the serial port communication parameters, with a string such as
-     *         "9600,8N1"
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_serialMode(const string& newval);
-    inline int      setSerialMode(const string& newval)
-    { return this->set_serialMode(newval); }
-
-    /**
-     * Retrieves a serial port for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the serial port is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YSerialPort.isOnline() to test if the serial port is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a serial port by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the serial port
-     *
-     * @return a YSerialPort object allowing you to drive the serial port.
-     */
-    static YSerialPort* FindSerialPort(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YSerialPortValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string text);
-
-    /**
-     * Clears the serial port buffer and resets counters to zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-    /**
-     * Sends a single byte to the serial port.
-     *
-     * @param code : the byte to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeByte(int code);
-
-    /**
-     * Sends an ASCII string to the serial port, as is.
-     *
-     * @param text : the text string to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeStr(string text);
-
-    /**
-     * Sends a binary buffer to the serial port, as is.
-     *
-     * @param buff : the binary buffer to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeBin(string buff);
-
-    /**
-     * Sends a byte sequence (provided as a list of bytes) to the serial port.
-     *
-     * @param byteList : a list of byte codes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeArray(vector<int> byteList);
-
-    /**
-     * Sends a byte sequence (provided as a hexadecimal string) to the serial port.
-     *
-     * @param hexString : a string of hexadecimal byte codes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeHex(string hexString);
-
-    /**
-     * Sends an ASCII string to the serial port, followed by a line break (CR LF).
-     *
-     * @param text : the text string to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeLine(string text);
-
-    /**
-     * Reads one byte from the receive buffer, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer,
-     * or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.
-     *
-     * @return the next byte
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         readByte(void);
-
-    /**
-     * Reads data from the receive buffer as a string, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of characters to read
-     *
-     * @return a string with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readStr(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a binary buffer, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of bytes to read
-     *
-     * @return a binary object with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readBin(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a list of bytes, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of bytes to read
-     *
-     * @return a sequence of bytes with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual vector<int> readArray(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a hexadecimal string, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nBytes : the maximum number of bytes to read
-     *
-     * @return a string with receive buffer contents, encoded in hexadecimal
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readHex(int nBytes);
-
-    /**
-     * Reads a single line (or message) from the receive buffer, starting at current stream position.
-     * This function is intended to be used when the serial port is configured for a message protocol,
-     * such as 'Line' mode or frame protocols.
-     *
-     * If data at current stream position is not available anymore in the receive buffer,
-     * the function returns the oldest available line and moves the stream position just after.
-     * If no new full line is received, the function returns an empty line.
-     *
-     * @return a string with a single line of text
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readLine(void);
-
-    /**
-     * Searches for incoming messages in the serial port receive buffer matching a given pattern,
-     * starting at current position. This function will only compare and return printable characters
-     * in the message strings. Binary protocols are handled as hexadecimal strings.
-     *
-     * The search returns all messages matching the expression provided as argument in the buffer.
-     * If no matching message is found, the search waits for one up to the specified maximum timeout
-     * (in milliseconds).
-     *
-     * @param pattern : a limited regular expression describing the expected message format,
-     *         or an empty string if all messages should be returned (no filtering).
-     *         When using binary protocols, the format applies to the hexadecimal
-     *         representation of the message.
-     * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
-     *         in the receive buffer.
-     *
-     * @return an array of strings containing the messages found, if any.
-     *         Binary messages are converted to hexadecimal representation.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<string> readMessages(string pattern,int maxWait);
-
-    /**
-     * Changes the current internal stream position to the specified value. This function
-     * does not affect the device, it only changes the value stored in the API object
-     * for the next read operations.
-     *
-     * @param absPos : the absolute position index for next read operations.
-     *
-     * @return nothing.
-     */
-    virtual int         read_seek(int absPos);
-
-    /**
-     * Returns the current absolute stream position pointer of the API object.
-     *
-     * @return the absolute position index for next read operations.
-     */
-    virtual int         read_tell(void);
-
-    /**
-     * Returns the number of bytes available to read in the input buffer starting from the
-     * current absolute stream position pointer of the API object.
-     *
-     * @return the number of bytes available to read
-     */
-    virtual int         read_avail(void);
-
-    /**
-     * Sends a text line query to the serial port, and reads the reply, if any.
-     * This function is intended to be used when the serial port is configured for 'Line' protocol.
-     *
-     * @param query : the line query to send (without CR/LF)
-     * @param maxWait : the maximum number of milliseconds to wait for a reply.
-     *
-     * @return the next text line received after sending the text query, as a string.
-     *         Additional lines can be obtained by calling readLine or readMessages.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual string      queryLine(string query,int maxWait);
-
-    /**
-     * Saves the job definition string (JSON data) into a job file.
-     * The job file can be later enabled using selectJob().
-     *
-     * @param jobfile : name of the job file to save on the device filesystem
-     * @param jsonDef : a string containing a JSON definition of the job
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         uploadJob(string jobfile,string jsonDef);
-
-    /**
-     * Load and start processing the specified job file. The file must have
-     * been previously created using the user interface or uploaded on the
-     * device filesystem using the uploadJob() function.
-     *
-     * @param jobfile : name of the job file (on the device filesystem)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectJob(string jobfile);
-
-    /**
-     * Manually sets the state of the RTS line. This function has no effect when
-     * hardware handshake is enabled, as the RTS line is driven automatically.
-     *
-     * @param val : 1 to turn RTS on, 0 to turn RTS off
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_RTS(int val);
-
-    /**
-     * Reads the level of the CTS line. The CTS line is usually driven by
-     * the RTS signal of the connected serial device.
-     *
-     * @return 1 if the CTS line is high, 0 if the CTS line is low.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         get_CTS(void);
-
-    /**
-     * Retrieves messages (both direction) in the serial port buffer, starting at current position.
-     * This function will only compare and return printable characters in the message strings.
-     * Binary protocols are handled as hexadecimal strings.
-     *
-     * If no message is found, the search waits for one up to the specified maximum timeout
-     * (in milliseconds).
-     *
-     * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
-     *         in the receive buffer.
-     *
-     * @return an array of YSnoopingRecord objects containing the messages found, if any.
-     *         Binary messages are converted to hexadecimal representation.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<YSnoopingRecord> snoopMessages(int maxWait);
-
-    /**
-     * Sends a MODBUS message (provided as a hexadecimal string) to the serial port.
-     * The message must start with the slave address. The MODBUS CRC/LRC is
-     * automatically added by the function. This function does not wait for a reply.
-     *
-     * @param hexString : a hexadecimal message string, including device address but no CRC/LRC
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeMODBUS(string hexString);
-
-    /**
-     * Sends a message to a specified MODBUS slave connected to the serial port, and reads the
-     * reply, if any. The message is the PDU, provided as a vector of bytes.
-     *
-     * @param slaveNo : the address of the slave MODBUS device to query
-     * @param pduBytes : the message to send (PDU), as a vector of bytes. The first byte of the
-     *         PDU is the MODBUS function code.
-     *
-     * @return the received reply, as a vector of bytes.
-     *
-     * On failure, throws an exception or returns an empty array (or a MODBUS error reply).
-     */
-    virtual vector<int> queryMODBUS(int slaveNo,vector<int> pduBytes);
-
-    /**
-     * Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.
-     * This method uses the MODBUS function code 0x01 (Read Coils).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to query
-     * @param pduAddr : the relative address of the first bit/coil to read (zero-based)
-     * @param nBits : the number of bits/coils to read
-     *
-     * @return a vector of integers, each corresponding to one bit.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> modbusReadBits(int slaveNo,int pduAddr,int nBits);
-
-    /**
-     * Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.
-     * This method uses the MODBUS function code 0x02 (Read Discrete Inputs).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to query
-     * @param pduAddr : the relative address of the first bit/input to read (zero-based)
-     * @param nBits : the number of bits/inputs to read
-     *
-     * @return a vector of integers, each corresponding to one bit.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> modbusReadInputBits(int slaveNo,int pduAddr,int nBits);
-
-    /**
-     * Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.
-     * This method uses the MODBUS function code 0x03 (Read Holding Registers).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to query
-     * @param pduAddr : the relative address of the first holding register to read (zero-based)
-     * @param nWords : the number of holding registers to read
-     *
-     * @return a vector of integers, each corresponding to one 16-bit register value.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> modbusReadRegisters(int slaveNo,int pduAddr,int nWords);
-
-    /**
-     * Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.
-     * This method uses the MODBUS function code 0x04 (Read Input Registers).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to query
-     * @param pduAddr : the relative address of the first input register to read (zero-based)
-     * @param nWords : the number of input registers to read
-     *
-     * @return a vector of integers, each corresponding to one 16-bit input value.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> modbusReadInputRegisters(int slaveNo,int pduAddr,int nWords);
-
-    /**
-     * Sets a single internal bit (or coil) on a MODBUS serial device.
-     * This method uses the MODBUS function code 0x05 (Write Single Coil).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to drive
-     * @param pduAddr : the relative address of the bit/coil to set (zero-based)
-     * @param value : the value to set (0 for OFF state, non-zero for ON state)
-     *
-     * @return the number of bits/coils affected on the device (1)
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         modbusWriteBit(int slaveNo,int pduAddr,int value);
-
-    /**
-     * Sets several contiguous internal bits (or coils) on a MODBUS serial device.
-     * This method uses the MODBUS function code 0x0f (Write Multiple Coils).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to drive
-     * @param pduAddr : the relative address of the first bit/coil to set (zero-based)
-     * @param bits : the vector of bits to be set (one integer per bit)
-     *
-     * @return the number of bits/coils affected on the device
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         modbusWriteBits(int slaveNo,int pduAddr,vector<int> bits);
-
-    /**
-     * Sets a single internal register (or holding register) on a MODBUS serial device.
-     * This method uses the MODBUS function code 0x06 (Write Single Register).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to drive
-     * @param pduAddr : the relative address of the register to set (zero-based)
-     * @param value : the 16 bit value to set
-     *
-     * @return the number of registers affected on the device (1)
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         modbusWriteRegister(int slaveNo,int pduAddr,int value);
-
-    /**
-     * Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.
-     * This method uses the MODBUS function code 0x10 (Write Multiple Registers).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to drive
-     * @param pduAddr : the relative address of the first internal register to set (zero-based)
-     * @param values : the vector of 16 bit values to set
-     *
-     * @return the number of registers affected on the device
-     *
-     * On failure, throws an exception or returns zero.
-     */
-    virtual int         modbusWriteRegisters(int slaveNo,int pduAddr,vector<int> values);
-
-    /**
-     * Sets several contiguous internal registers (holding registers) on a MODBUS serial device,
-     * then performs a contiguous read of a set of (possibly different) internal registers.
-     * This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).
-     *
-     * @param slaveNo : the address of the slave MODBUS device to drive
-     * @param pduWriteAddr : the relative address of the first internal register to set (zero-based)
-     * @param values : the vector of 16 bit values to set
-     * @param pduReadAddr : the relative address of the first internal register to read (zero-based)
-     * @param nReadWords : the number of 16 bit values to read
-     *
-     * @return a vector of integers, each corresponding to one 16-bit register value read.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<int> modbusWriteAndReadRegisters(int slaveNo,int pduWriteAddr,vector<int> values,int pduReadAddr,int nReadWords);
-
-
-    inline static YSerialPort* Find(string func)
-    { return YSerialPort::FindSerialPort(func); }
-
-    /**
-     * Continues the enumeration of serial ports started using yFirstSerialPort().
-     * Caution: You can't make any assumption about the returned serial ports order.
-     * If you want to find a specific a serial port, use SerialPort.findSerialPort()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YSerialPort object, corresponding to
-     *         a serial port currently online, or a NULL pointer
-     *         if there are no more serial ports to enumerate.
-     */
-           YSerialPort     *nextSerialPort(void);
-    inline YSerialPort     *next(void)
-    { return this->nextSerialPort();}
-
-    /**
-     * Starts the enumeration of serial ports currently accessible.
-     * Use the method YSerialPort.nextSerialPort() to iterate on
-     * next serial ports.
-     *
-     * @return a pointer to a YSerialPort object, corresponding to
-     *         the first serial port currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YSerialPort* FirstSerialPort(void);
-    inline static YSerialPort* First(void)
-    { return YSerialPort::FirstSerialPort();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YSerialPort accessors declaration)
-};
-
-//--- (generated code: YSerialPort functions declaration)
-
-/**
- * Retrieves a serial port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the serial port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSerialPort.isOnline() to test if the serial port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a serial port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the serial port
- *
- * @return a YSerialPort object allowing you to drive the serial port.
- */
-inline YSerialPort* yFindSerialPort(const string& func)
-{ return YSerialPort::FindSerialPort(func);}
-/**
- * Starts the enumeration of serial ports currently accessible.
- * Use the method YSerialPort.nextSerialPort() to iterate on
- * next serial ports.
- *
- * @return a pointer to a YSerialPort object, corresponding to
- *         the first serial port currently online, or a NULL pointer
- *         if there are none.
- */
-inline YSerialPort* yFirstSerialPort(void)
-{ return YSerialPort::FirstSerialPort();}
-
-//--- (end of generated code: YSerialPort functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_servo.cpp
+++ /dev/null
@@ -1,620 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_servo.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindServo(), the high-level API for Servo functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_servo.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "servo"
-
-YServo::YServo(const string& func): YFunction(func)
-//--- (YServo initialization)
-    ,_position(POSITION_INVALID)
-    ,_enabled(ENABLED_INVALID)
-    ,_range(RANGE_INVALID)
-    ,_neutral(NEUTRAL_INVALID)
-    ,_move(MOVE_INVALID)
-    ,_positionAtPowerOn(POSITIONATPOWERON_INVALID)
-    ,_enabledAtPowerOn(ENABLEDATPOWERON_INVALID)
-    ,_valueCallbackServo(NULL)
-//--- (end of YServo initialization)
-{
-    _className="Servo";
-}
-
-YServo::~YServo()
-{
-//--- (YServo cleanup)
-//--- (end of YServo cleanup)
-}
-//--- (YServo implementation)
-// static attributes
-const YMove YServo::MOVE_INVALID = YMove();
-
-int YServo::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("position")) {
-        _position =  json_val->getInt("position");
-    }
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    if(json_val->has("range")) {
-        _range =  json_val->getInt("range");
-    }
-    if(json_val->has("neutral")) {
-        _neutral =  json_val->getInt("neutral");
-    }
-    if(json_val->has("move")) {
-        YJSONObject* subjson = json_val->getYJSONObject("move");
-        if (subjson->has("moving")) {
-            _move.moving = subjson->getInt("moving");
-        }
-        if (subjson->has("target")) {
-            _move.target = subjson->getInt("target");
-        }
-        if (subjson->has("ms")) {
-            _move.ms = subjson->getInt("ms");
-        }
-    }
-    if(json_val->has("positionAtPowerOn")) {
-        _positionAtPowerOn =  json_val->getInt("positionAtPowerOn");
-    }
-    if(json_val->has("enabledAtPowerOn")) {
-        _enabledAtPowerOn =  (Y_ENABLEDATPOWERON_enum)json_val->getInt("enabledAtPowerOn");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the current servo position.
- *
- * @return an integer corresponding to the current servo position
- *
- * On failure, throws an exception or returns Y_POSITION_INVALID.
- */
-int YServo::get_position(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::POSITION_INVALID;
-                }
-            }
-        }
-        res = _position;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes immediately the servo driving position.
- *
- * @param newval : an integer corresponding to immediately the servo driving position
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_position(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("position", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the servos.
- *
- * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the state of the servos
- *
- * On failure, throws an exception or returns Y_ENABLED_INVALID.
- */
-Y_ENABLED_enum YServo::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Stops or starts the servo.
- *
- * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current range of use of the servo.
- *
- * @return an integer corresponding to the current range of use of the servo
- *
- * On failure, throws an exception or returns Y_RANGE_INVALID.
- */
-int YServo::get_range(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::RANGE_INVALID;
-                }
-            }
-        }
-        res = _range;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the range of use of the servo, specified in per cents.
- * A range of 100% corresponds to a standard control signal, that varies
- * from 1 [ms] to 2 [ms], When using a servo that supports a double range,
- * from 0.5 [ms] to 2.5 [ms], you can select a range of 200%.
- * Be aware that using a range higher than what is supported by the servo
- * is likely to damage the servo. Remember to call the matching module
- * saveToFlash() method, otherwise this call will have no effect.
- *
- * @param newval : an integer corresponding to the range of use of the servo, specified in per cents
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_range(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("range", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the duration in microseconds of a neutral pulse for the servo.
- *
- * @return an integer corresponding to the duration in microseconds of a neutral pulse for the servo
- *
- * On failure, throws an exception or returns Y_NEUTRAL_INVALID.
- */
-int YServo::get_neutral(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::NEUTRAL_INVALID;
-                }
-            }
-        }
-        res = _neutral;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the duration of the pulse corresponding to the neutral position of the servo.
- * The duration is specified in microseconds, and the standard value is 1500 [us].
- * This setting makes it possible to shift the range of use of the servo.
- * Be aware that using a range higher than what is supported by the servo is
- * likely to damage the servo. Remember to call the matching module
- * saveToFlash() method, otherwise this call will have no effect.
- *
- * @param newval : an integer corresponding to the duration of the pulse corresponding to the neutral
- * position of the servo
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_neutral(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("neutral", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-YMove YServo::get_move(void)
-{
-    YMove res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::MOVE_INVALID;
-                }
-            }
-        }
-        res = _move;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YServo::set_move(YMove newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buff[64]; sprintf(buff,"%d:%d",newval.target,newval.ms); rest_val = string(buff);
-        res = _setAttr("move", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Performs a smooth move at constant speed toward a given position.
- *
- * @param target      : new position at the end of the move
- * @param ms_duration : total duration of the move, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::move(int target,int ms_duration)
-{
-    string rest_val;
-    char buff[64]; sprintf(buff,"%d:%d",target,ms_duration); rest_val = string(buff);
-    return _setAttr("move", rest_val);
-}
-
-/**
- * Returns the servo position at device power up.
- *
- * @return an integer corresponding to the servo position at device power up
- *
- * On failure, throws an exception or returns Y_POSITIONATPOWERON_INVALID.
- */
-int YServo::get_positionAtPowerOn(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::POSITIONATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _positionAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Configure the servo position at device power up. Remember to call the matching
- * module saveToFlash() method, otherwise this call will have no effect.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_positionAtPowerOn(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("positionAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the servo signal generator state at power up.
- *
- * @return either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the servo signal
- * generator state at power up
- *
- * On failure, throws an exception or returns Y_ENABLEDATPOWERON_INVALID.
- */
-Y_ENABLEDATPOWERON_enum YServo::get_enabledAtPowerOn(void)
-{
-    Y_ENABLEDATPOWERON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YServo::ENABLEDATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _enabledAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Configure the servo signal generator state at power up. Remember to call the matching module saveToFlash()
- * method, otherwise this call will have no effect.
- *
- * @param newval : either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YServo::set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabledAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a servo for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the servo is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YServo.isOnline() to test if the servo is
- * indeed online at a given time. In case of ambiguity when looking for
- * a servo by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the servo
- *
- * @return a YServo object allowing you to drive the servo.
- */
-YServo* YServo::FindServo(string func)
-{
-    YServo* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YServo*) YFunction::_FindFromCache("Servo", func);
-        if (obj == NULL) {
-            obj = new YServo(func);
-            YFunction::_AddToCache("Servo", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YServo::registerValueCallback(YServoValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackServo = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YServo::_invokeValueCallback(string value)
-{
-    if (_valueCallbackServo != NULL) {
-        _valueCallbackServo(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YServo *YServo::nextServo(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YServo::FindServo(hwid);
-}
-
-YServo* YServo::FirstServo(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Servo", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YServo::FindServo(serial+"."+funcId);
-}
-
-//--- (end of YServo implementation)
-
-//--- (YServo functions)
-//--- (end of YServo functions)
--- a/Sources/cpplib/yocto_servo.h
+++ /dev/null
@@ -1,460 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_servo.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindServo(), the high-level API for Servo functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_SERVO_H
-#define YOCTO_SERVO_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YServo return codes)
-//--- (end of YServo return codes)
-//--- (YServo yapiwrapper)
-//--- (end of YServo yapiwrapper)
-//--- (YServo definitions)
-class YServo; // forward declaration
-
-typedef void (*YServoValueCallback)(YServo *func, const string& functionValue);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-#ifndef _CLASS_YMOVE
-#define _CLASS_YMOVE
-class YOCTO_CLASS_EXPORT YMove {
-public:
-    int             target;
-    int             ms;
-    int             moving;
-
-    YMove()
-        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
-    {}
-
-    bool operator==(const YMove& o) const {
-         return (target == o.target) && (ms == o.ms) && (moving == o.moving);
-    }
-};
-#endif
-#ifndef _Y_ENABLEDATPOWERON_ENUM
-#define _Y_ENABLEDATPOWERON_ENUM
-typedef enum {
-    Y_ENABLEDATPOWERON_FALSE = 0,
-    Y_ENABLEDATPOWERON_TRUE = 1,
-    Y_ENABLEDATPOWERON_INVALID = -1,
-} Y_ENABLEDATPOWERON_enum;
-#endif
-#define Y_POSITION_INVALID              (YAPI_INVALID_INT)
-#define Y_RANGE_INVALID                 (YAPI_INVALID_UINT)
-#define Y_NEUTRAL_INVALID               (YAPI_INVALID_UINT)
-#define Y_POSITIONATPOWERON_INVALID     (YAPI_INVALID_INT)
-//--- (end of YServo definitions)
-
-//--- (YServo declaration)
-/**
- * YServo Class: Servo function interface
- *
- * Yoctopuce application programming interface allows you not only to move
- * a servo to a given position, but also to specify the time interval
- * in which the move should be performed. This makes it possible to
- * synchronize two servos involved in a same move.
- */
-class YOCTO_CLASS_EXPORT YServo: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YServo declaration)
-protected:
-    //--- (YServo attributes)
-    // Attributes (function value cache)
-    int             _position;
-    Y_ENABLED_enum  _enabled;
-    int             _range;
-    int             _neutral;
-    YMove           _move;
-    int             _positionAtPowerOn;
-    Y_ENABLEDATPOWERON_enum _enabledAtPowerOn;
-    YServoValueCallback _valueCallbackServo;
-
-    friend YServo *yFindServo(const string& func);
-    friend YServo *yFirstServo(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindServo factory function to instantiate
-    YServo(const string& func);
-    //--- (end of YServo attributes)
-
-public:
-    virtual ~YServo();
-    //--- (YServo accessors declaration)
-
-    static const int POSITION_INVALID = YAPI_INVALID_INT;
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-    static const int RANGE_INVALID = YAPI_INVALID_UINT;
-    static const int NEUTRAL_INVALID = YAPI_INVALID_UINT;
-    static const YMove MOVE_INVALID;
-    static const int POSITIONATPOWERON_INVALID = YAPI_INVALID_INT;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_FALSE = Y_ENABLEDATPOWERON_FALSE;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_TRUE = Y_ENABLEDATPOWERON_TRUE;
-    static const Y_ENABLEDATPOWERON_enum ENABLEDATPOWERON_INVALID = Y_ENABLEDATPOWERON_INVALID;
-
-    /**
-     * Returns the current servo position.
-     *
-     * @return an integer corresponding to the current servo position
-     *
-     * On failure, throws an exception or returns Y_POSITION_INVALID.
-     */
-    int                 get_position(void);
-
-    inline int          position(void)
-    { return this->get_position(); }
-
-    /**
-     * Changes immediately the servo driving position.
-     *
-     * @param newval : an integer corresponding to immediately the servo driving position
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_position(int newval);
-    inline int      setPosition(int newval)
-    { return this->set_position(newval); }
-
-    /**
-     * Returns the state of the servos.
-     *
-     * @return either Y_ENABLED_FALSE or Y_ENABLED_TRUE, according to the state of the servos
-     *
-     * On failure, throws an exception or returns Y_ENABLED_INVALID.
-     */
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    /**
-     * Stops or starts the servo.
-     *
-     * @param newval : either Y_ENABLED_FALSE or Y_ENABLED_TRUE
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Returns the current range of use of the servo.
-     *
-     * @return an integer corresponding to the current range of use of the servo
-     *
-     * On failure, throws an exception or returns Y_RANGE_INVALID.
-     */
-    int                 get_range(void);
-
-    inline int          range(void)
-    { return this->get_range(); }
-
-    /**
-     * Changes the range of use of the servo, specified in per cents.
-     * A range of 100% corresponds to a standard control signal, that varies
-     * from 1 [ms] to 2 [ms], When using a servo that supports a double range,
-     * from 0.5 [ms] to 2.5 [ms], you can select a range of 200%.
-     * Be aware that using a range higher than what is supported by the servo
-     * is likely to damage the servo. Remember to call the matching module
-     * saveToFlash() method, otherwise this call will have no effect.
-     *
-     * @param newval : an integer corresponding to the range of use of the servo, specified in per cents
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_range(int newval);
-    inline int      setRange(int newval)
-    { return this->set_range(newval); }
-
-    /**
-     * Returns the duration in microseconds of a neutral pulse for the servo.
-     *
-     * @return an integer corresponding to the duration in microseconds of a neutral pulse for the servo
-     *
-     * On failure, throws an exception or returns Y_NEUTRAL_INVALID.
-     */
-    int                 get_neutral(void);
-
-    inline int          neutral(void)
-    { return this->get_neutral(); }
-
-    /**
-     * Changes the duration of the pulse corresponding to the neutral position of the servo.
-     * The duration is specified in microseconds, and the standard value is 1500 [us].
-     * This setting makes it possible to shift the range of use of the servo.
-     * Be aware that using a range higher than what is supported by the servo is
-     * likely to damage the servo. Remember to call the matching module
-     * saveToFlash() method, otherwise this call will have no effect.
-     *
-     * @param newval : an integer corresponding to the duration of the pulse corresponding to the neutral
-     * position of the servo
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_neutral(int newval);
-    inline int      setNeutral(int newval)
-    { return this->set_neutral(newval); }
-
-    YMove               get_move(void);
-
-    inline YMove        move(void)
-    { return this->get_move(); }
-
-    int             set_move(YMove newval);
-    inline int      setMove(YMove newval)
-    { return this->set_move(newval); }
-
-    /**
-     * Performs a smooth move at constant speed toward a given position.
-     *
-     * @param target      : new position at the end of the move
-     * @param ms_duration : total duration of the move, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             move(int target,int ms_duration);
-
-    /**
-     * Returns the servo position at device power up.
-     *
-     * @return an integer corresponding to the servo position at device power up
-     *
-     * On failure, throws an exception or returns Y_POSITIONATPOWERON_INVALID.
-     */
-    int                 get_positionAtPowerOn(void);
-
-    inline int          positionAtPowerOn(void)
-    { return this->get_positionAtPowerOn(); }
-
-    /**
-     * Configure the servo position at device power up. Remember to call the matching
-     * module saveToFlash() method, otherwise this call will have no effect.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_positionAtPowerOn(int newval);
-    inline int      setPositionAtPowerOn(int newval)
-    { return this->set_positionAtPowerOn(newval); }
-
-    /**
-     * Returns the servo signal generator state at power up.
-     *
-     * @return either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE, according to the servo signal
-     * generator state at power up
-     *
-     * On failure, throws an exception or returns Y_ENABLEDATPOWERON_INVALID.
-     */
-    Y_ENABLEDATPOWERON_enum get_enabledAtPowerOn(void);
-
-    inline Y_ENABLEDATPOWERON_enum enabledAtPowerOn(void)
-    { return this->get_enabledAtPowerOn(); }
-
-    /**
-     * Configure the servo signal generator state at power up. Remember to call the matching module saveToFlash()
-     * method, otherwise this call will have no effect.
-     *
-     * @param newval : either Y_ENABLEDATPOWERON_FALSE or Y_ENABLEDATPOWERON_TRUE
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval);
-    inline int      setEnabledAtPowerOn(Y_ENABLEDATPOWERON_enum newval)
-    { return this->set_enabledAtPowerOn(newval); }
-
-    /**
-     * Retrieves a servo for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the servo is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YServo.isOnline() to test if the servo is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a servo by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the servo
-     *
-     * @return a YServo object allowing you to drive the servo.
-     */
-    static YServo*      FindServo(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YServoValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YServo* Find(string func)
-    { return YServo::FindServo(func); }
-
-    /**
-     * Continues the enumeration of servos started using yFirstServo().
-     * Caution: You can't make any assumption about the returned servos order.
-     * If you want to find a specific a servo, use Servo.findServo()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YServo object, corresponding to
-     *         a servo currently online, or a NULL pointer
-     *         if there are no more servos to enumerate.
-     */
-           YServo          *nextServo(void);
-    inline YServo          *next(void)
-    { return this->nextServo();}
-
-    /**
-     * Starts the enumeration of servos currently accessible.
-     * Use the method YServo.nextServo() to iterate on
-     * next servos.
-     *
-     * @return a pointer to a YServo object, corresponding to
-     *         the first servo currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YServo* FirstServo(void);
-    inline static YServo* First(void)
-    { return YServo::FirstServo();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YServo accessors declaration)
-};
-
-//--- (YServo functions declaration)
-
-/**
- * Retrieves a servo for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the servo is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YServo.isOnline() to test if the servo is
- * indeed online at a given time. In case of ambiguity when looking for
- * a servo by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the servo
- *
- * @return a YServo object allowing you to drive the servo.
- */
-inline YServo* yFindServo(const string& func)
-{ return YServo::FindServo(func);}
-/**
- * Starts the enumeration of servos currently accessible.
- * Use the method YServo.nextServo() to iterate on
- * next servos.
- *
- * @return a pointer to a YServo object, corresponding to
- *         the first servo currently online, or a NULL pointer
- *         if there are none.
- */
-inline YServo* yFirstServo(void)
-{ return YServo::FirstServo();}
-
-//--- (end of YServo functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_spiport.cpp
+++ /dev/null
@@ -1,1512 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_spiport.cpp 33722 2018-12-14 15:04:43Z seb $
- *
- *  Implements yFindSpiPort(), the high-level API for SpiPort functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_spiport.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "spiport"
-
-YSpiPort::YSpiPort(const string& func): YFunction(func)
-//--- (YSpiPort initialization)
-    ,_rxCount(RXCOUNT_INVALID)
-    ,_txCount(TXCOUNT_INVALID)
-    ,_errCount(ERRCOUNT_INVALID)
-    ,_rxMsgCount(RXMSGCOUNT_INVALID)
-    ,_txMsgCount(TXMSGCOUNT_INVALID)
-    ,_lastMsg(LASTMSG_INVALID)
-    ,_currentJob(CURRENTJOB_INVALID)
-    ,_startupJob(STARTUPJOB_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_voltageLevel(VOLTAGELEVEL_INVALID)
-    ,_protocol(PROTOCOL_INVALID)
-    ,_spiMode(SPIMODE_INVALID)
-    ,_ssPolarity(SSPOLARITY_INVALID)
-    ,_shiftSampling(SHIFTSAMPLING_INVALID)
-    ,_valueCallbackSpiPort(NULL)
-    ,_rxptr(0)
-    ,_rxbuffptr(0)
-//--- (end of YSpiPort initialization)
-{
-    _className="SpiPort";
-}
-
-YSpiPort::~YSpiPort()
-{
-//--- (YSpiPort cleanup)
-//--- (end of YSpiPort cleanup)
-}
-//--- (YSpiPort implementation)
-// static attributes
-const string YSpiPort::LASTMSG_INVALID = YAPI_INVALID_STRING;
-const string YSpiPort::CURRENTJOB_INVALID = YAPI_INVALID_STRING;
-const string YSpiPort::STARTUPJOB_INVALID = YAPI_INVALID_STRING;
-const string YSpiPort::COMMAND_INVALID = YAPI_INVALID_STRING;
-const string YSpiPort::PROTOCOL_INVALID = YAPI_INVALID_STRING;
-const string YSpiPort::SPIMODE_INVALID = YAPI_INVALID_STRING;
-
-int YSpiPort::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("rxCount")) {
-        _rxCount =  json_val->getInt("rxCount");
-    }
-    if(json_val->has("txCount")) {
-        _txCount =  json_val->getInt("txCount");
-    }
-    if(json_val->has("errCount")) {
-        _errCount =  json_val->getInt("errCount");
-    }
-    if(json_val->has("rxMsgCount")) {
-        _rxMsgCount =  json_val->getInt("rxMsgCount");
-    }
-    if(json_val->has("txMsgCount")) {
-        _txMsgCount =  json_val->getInt("txMsgCount");
-    }
-    if(json_val->has("lastMsg")) {
-        _lastMsg =  json_val->getString("lastMsg");
-    }
-    if(json_val->has("currentJob")) {
-        _currentJob =  json_val->getString("currentJob");
-    }
-    if(json_val->has("startupJob")) {
-        _startupJob =  json_val->getString("startupJob");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    if(json_val->has("voltageLevel")) {
-        _voltageLevel =  (Y_VOLTAGELEVEL_enum)json_val->getInt("voltageLevel");
-    }
-    if(json_val->has("protocol")) {
-        _protocol =  json_val->getString("protocol");
-    }
-    if(json_val->has("spiMode")) {
-        _spiMode =  json_val->getString("spiMode");
-    }
-    if(json_val->has("ssPolarity")) {
-        _ssPolarity =  (Y_SSPOLARITY_enum)json_val->getInt("ssPolarity");
-    }
-    if(json_val->has("shiftSampling")) {
-        _shiftSampling =  (Y_SHIFTSAMPLING_enum)json_val->getInt("shiftSampling");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the total number of bytes received since last reset.
- *
- * @return an integer corresponding to the total number of bytes received since last reset
- *
- * On failure, throws an exception or returns Y_RXCOUNT_INVALID.
- */
-int YSpiPort::get_rxCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::RXCOUNT_INVALID;
-                }
-            }
-        }
-        res = _rxCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of bytes transmitted since last reset.
- *
- * @return an integer corresponding to the total number of bytes transmitted since last reset
- *
- * On failure, throws an exception or returns Y_TXCOUNT_INVALID.
- */
-int YSpiPort::get_txCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::TXCOUNT_INVALID;
-                }
-            }
-        }
-        res = _txCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of communication errors detected since last reset.
- *
- * @return an integer corresponding to the total number of communication errors detected since last reset
- *
- * On failure, throws an exception or returns Y_ERRCOUNT_INVALID.
- */
-int YSpiPort::get_errCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::ERRCOUNT_INVALID;
-                }
-            }
-        }
-        res = _errCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of messages received since last reset.
- *
- * @return an integer corresponding to the total number of messages received since last reset
- *
- * On failure, throws an exception or returns Y_RXMSGCOUNT_INVALID.
- */
-int YSpiPort::get_rxMsgCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::RXMSGCOUNT_INVALID;
-                }
-            }
-        }
-        res = _rxMsgCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the total number of messages send since last reset.
- *
- * @return an integer corresponding to the total number of messages send since last reset
- *
- * On failure, throws an exception or returns Y_TXMSGCOUNT_INVALID.
- */
-int YSpiPort::get_txMsgCount(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::TXMSGCOUNT_INVALID;
-                }
-            }
-        }
-        res = _txMsgCount;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the latest message fully received (for Line and Frame protocols).
- *
- * @return a string corresponding to the latest message fully received (for Line and Frame protocols)
- *
- * On failure, throws an exception or returns Y_LASTMSG_INVALID.
- */
-string YSpiPort::get_lastMsg(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::LASTMSG_INVALID;
-                }
-            }
-        }
-        res = _lastMsg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the name of the job file currently in use.
- *
- * @return a string corresponding to the name of the job file currently in use
- *
- * On failure, throws an exception or returns Y_CURRENTJOB_INVALID.
- */
-string YSpiPort::get_currentJob(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::CURRENTJOB_INVALID;
-                }
-            }
-        }
-        res = _currentJob;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the job to use when the device is powered on.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the job to use when the device is powered on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_currentJob(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("currentJob", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the job file to use when the device is powered on.
- *
- * @return a string corresponding to the job file to use when the device is powered on
- *
- * On failure, throws an exception or returns Y_STARTUPJOB_INVALID.
- */
-string YSpiPort::get_startupJob(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::STARTUPJOB_INVALID;
-                }
-            }
-        }
-        res = _startupJob;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the job to use when the device is powered on.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the job to use when the device is powered on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_startupJob(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("startupJob", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YSpiPort::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YSpiPort::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the voltage level used on the serial line.
- *
- * @return a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
- * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
- * corresponding to the voltage level used on the serial line
- *
- * On failure, throws an exception or returns Y_VOLTAGELEVEL_INVALID.
- */
-Y_VOLTAGELEVEL_enum YSpiPort::get_voltageLevel(void)
-{
-    Y_VOLTAGELEVEL_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::VOLTAGELEVEL_INVALID;
-                }
-            }
-        }
-        res = _voltageLevel;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the voltage type used on the serial line. Valid
- * values  will depend on the Yoctopuce device model featuring
- * the serial port feature.  Check your device documentation
- * to find out which values are valid for that specific model.
- * Trying to set an invalid value will have no effect.
- *
- * @param newval : a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
- * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
- * corresponding to the voltage type used on the serial line
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_voltageLevel(Y_VOLTAGELEVEL_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("voltageLevel", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the type of protocol used over the serial line, as a string.
- * Possible values are "Line" for ASCII messages separated by CR and/or LF,
- * "Frame:[timeout]ms" for binary messages separated by a delay time,
- * "Char" for a continuous ASCII stream or
- * "Byte" for a continuous binary stream.
- *
- * @return a string corresponding to the type of protocol used over the serial line, as a string
- *
- * On failure, throws an exception or returns Y_PROTOCOL_INVALID.
- */
-string YSpiPort::get_protocol(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::PROTOCOL_INVALID;
-                }
-            }
-        }
-        res = _protocol;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the type of protocol used over the serial line.
- * Possible values are "Line" for ASCII messages separated by CR and/or LF,
- * "Frame:[timeout]ms" for binary messages separated by a delay time,
- * "Char" for a continuous ASCII stream or
- * "Byte" for a continuous binary stream.
- * The suffix "/[wait]ms" can be added to reduce the transmit rate so that there
- * is always at lest the specified number of milliseconds between each bytes sent.
- *
- * @param newval : a string corresponding to the type of protocol used over the serial line
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_protocol(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("protocol", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the SPI port communication parameters, as a string such as
- * "125000,0,msb". The string includes the baud rate, the SPI mode (between
- * 0 and 3) and the bit order.
- *
- * @return a string corresponding to the SPI port communication parameters, as a string such as
- *         "125000,0,msb"
- *
- * On failure, throws an exception or returns Y_SPIMODE_INVALID.
- */
-string YSpiPort::get_spiMode(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::SPIMODE_INVALID;
-                }
-            }
-        }
-        res = _spiMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the SPI port communication parameters, with a string such as
- * "125000,0,msb". The string includes the baud rate, the SPI mode (between
- * 0 and 3) and the bit order.
- *
- * @param newval : a string corresponding to the SPI port communication parameters, with a string such as
- *         "125000,0,msb"
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_spiMode(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("spiMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the SS line polarity.
- *
- * @return either Y_SSPOLARITY_ACTIVE_LOW or Y_SSPOLARITY_ACTIVE_HIGH, according to the SS line polarity
- *
- * On failure, throws an exception or returns Y_SSPOLARITY_INVALID.
- */
-Y_SSPOLARITY_enum YSpiPort::get_ssPolarity(void)
-{
-    Y_SSPOLARITY_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::SSPOLARITY_INVALID;
-                }
-            }
-        }
-        res = _ssPolarity;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the SS line polarity.
- *
- * @param newval : either Y_SSPOLARITY_ACTIVE_LOW or Y_SSPOLARITY_ACTIVE_HIGH, according to the SS line polarity
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_ssPolarity(Y_SSPOLARITY_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("ssPolarity", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns true when the SDI line phase is shifted with regards to the SDO line.
- *
- * @return either Y_SHIFTSAMPLING_OFF or Y_SHIFTSAMPLING_ON, according to true when the SDI line phase
- * is shifted with regards to the SDO line
- *
- * On failure, throws an exception or returns Y_SHIFTSAMPLING_INVALID.
- */
-Y_SHIFTSAMPLING_enum YSpiPort::get_shiftSampling(void)
-{
-    Y_SHIFTSAMPLING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YSpiPort::SHIFTSAMPLING_INVALID;
-                }
-            }
-        }
-        res = _shiftSampling;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the SDI line sampling shift. When disabled, SDI line is
- * sampled in the middle of data output time. When enabled, SDI line is
- * samples at the end of data output time.
- *
- * @param newval : either Y_SHIFTSAMPLING_OFF or Y_SHIFTSAMPLING_ON, according to the SDI line sampling shift
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_shiftSampling(Y_SHIFTSAMPLING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("shiftSampling", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a SPI port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the SPI port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSpiPort.isOnline() to test if the SPI port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a SPI port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the SPI port
- *
- * @return a YSpiPort object allowing you to drive the SPI port.
- */
-YSpiPort* YSpiPort::FindSpiPort(string func)
-{
-    YSpiPort* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YSpiPort*) YFunction::_FindFromCache("SpiPort", func);
-        if (obj == NULL) {
-            obj = new YSpiPort(func);
-            YFunction::_AddToCache("SpiPort", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YSpiPort::registerValueCallback(YSpiPortValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackSpiPort = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YSpiPort::_invokeValueCallback(string value)
-{
-    if (_valueCallbackSpiPort != NULL) {
-        _valueCallbackSpiPort(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YSpiPort::sendCommand(string text)
-{
-    return this->set_command(text);
-}
-
-/**
- * Clears the serial port buffer and resets counters to zero.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::reset(void)
-{
-    _rxptr = 0;
-    _rxbuffptr = 0;
-    _rxbuff = string(0, (char)0);
-
-    return this->sendCommand("Z");
-}
-
-/**
- * Sends a single byte to the serial port.
- *
- * @param code : the byte to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeByte(int code)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("$%02X",code));
-}
-
-/**
- * Sends an ASCII string to the serial port, as is.
- *
- * @param text : the text string to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeStr(string text)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int ch = 0;
-    buff = text;
-    bufflen = (int)(buff).size();
-    if (bufflen < 100) {
-        // if string is pure text, we can send it as a simple command (faster)
-        ch = 0x20;
-        idx = 0;
-        while ((idx < bufflen) && (ch != 0)) {
-            ch = ((u8)buff[idx]);
-            if ((ch >= 0x20) && (ch < 0x7f)) {
-                idx = idx + 1;
-            } else {
-                ch = 0;
-            }
-        }
-        if (idx >= bufflen) {
-            return this->sendCommand(YapiWrapper::ysprintf("+%s",text.c_str()));
-        }
-    }
-    // send string using file upload
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Sends a binary buffer to the serial port, as is.
- *
- * @param buff : the binary buffer to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeBin(string buff)
-{
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Sends a byte sequence (provided as a list of bytes) to the serial port.
- *
- * @param byteList : a list of byte codes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeArray(vector<int> byteList)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int hexb = 0;
-    int res = 0;
-    bufflen = (int)byteList.size();
-    buff = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        hexb = byteList[idx];
-        buff[idx] = (char)(hexb);
-        idx = idx + 1;
-    }
-
-    res = this->_upload("txdata", buff);
-    return res;
-}
-
-/**
- * Sends a byte sequence (provided as a hexadecimal string) to the serial port.
- *
- * @param hexString : a string of hexadecimal byte codes
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeHex(string hexString)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int hexb = 0;
-    int res = 0;
-    bufflen = (int)(hexString).length();
-    if (bufflen < 100) {
-        return this->sendCommand(YapiWrapper::ysprintf("$%s",hexString.c_str()));
-    }
-    bufflen = ((bufflen) >> (1));
-    buff = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        hexb = (int)strtoul((hexString).substr( 2 * idx, 2).c_str(), NULL, 16);
-        buff[idx] = (char)(hexb);
-        idx = idx + 1;
-    }
-
-    res = this->_upload("txdata", buff);
-    return res;
-}
-
-/**
- * Sends an ASCII string to the serial port, followed by a line break (CR LF).
- *
- * @param text : the text string to send
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::writeLine(string text)
-{
-    string buff;
-    int bufflen = 0;
-    int idx = 0;
-    int ch = 0;
-    buff = YapiWrapper::ysprintf("%s\r\n",text.c_str());
-    bufflen = (int)(buff).size()-2;
-    if (bufflen < 100) {
-        // if string is pure text, we can send it as a simple command (faster)
-        ch = 0x20;
-        idx = 0;
-        while ((idx < bufflen) && (ch != 0)) {
-            ch = ((u8)buff[idx]);
-            if ((ch >= 0x20) && (ch < 0x7f)) {
-                idx = idx + 1;
-            } else {
-                ch = 0;
-            }
-        }
-        if (idx >= bufflen) {
-            return this->sendCommand(YapiWrapper::ysprintf("!%s",text.c_str()));
-        }
-    }
-    // send string using file upload
-    return this->_upload("txdata", buff);
-}
-
-/**
- * Reads one byte from the receive buffer, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer,
- * or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.
- *
- * @return the next byte
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::readByte(void)
-{
-    int currpos = 0;
-    int reqlen = 0;
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int res = 0;
-    // first check if we have the requested character in the look-ahead buffer
-    bufflen = (int)(_rxbuff).size();
-    if ((_rxptr >= _rxbuffptr) && (_rxptr < _rxbuffptr+bufflen)) {
-        res = ((u8)_rxbuff[_rxptr-_rxbuffptr]);
-        _rxptr = _rxptr + 1;
-        return res;
-    }
-    // try to preload more than one byte to speed-up byte-per-byte access
-    currpos = _rxptr;
-    reqlen = 1024;
-    buff = this->readBin(reqlen);
-    bufflen = (int)(buff).size();
-    if (_rxptr == currpos+bufflen) {
-        res = ((u8)buff[0]);
-        _rxptr = currpos+1;
-        _rxbuffptr = currpos;
-        _rxbuff = buff;
-        return res;
-    }
-    // mixed bidirectional data, retry with a smaller block
-    _rxptr = currpos;
-    reqlen = 16;
-    buff = this->readBin(reqlen);
-    bufflen = (int)(buff).size();
-    if (_rxptr == currpos+bufflen) {
-        res = ((u8)buff[0]);
-        _rxptr = currpos+1;
-        _rxbuffptr = currpos;
-        _rxbuff = buff;
-        return res;
-    }
-    // still mixed, need to process character by character
-    _rxptr = currpos;
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=1",_rxptr));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    if (bufflen == 0) {
-        return YAPI_NO_MORE_DATA;
-    }
-    res = ((u8)buff[0]);
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a string, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of characters to read
- *
- * @return a string with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSpiPort::readStr(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    string res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = (buff).substr( 0, bufflen);
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a binary buffer, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of bytes to read
- *
- * @return a binary object with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSpiPort::readBin(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int idx = 0;
-    string res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = string(bufflen, (char)0);
-    idx = 0;
-    while (idx < bufflen) {
-        res[idx] = (char)(((u8)buff[idx]));
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a list of bytes, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nChars : the maximum number of bytes to read
- *
- * @return a sequence of bytes with receive buffer contents
- *
- * On failure, throws an exception or returns a negative error code.
- */
-vector<int> YSpiPort::readArray(int nChars)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int idx = 0;
-    int b = 0;
-    vector<int> res;
-    if (nChars > 65535) {
-        nChars = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nChars));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res.clear();
-    idx = 0;
-    while (idx < bufflen) {
-        b = ((u8)buff[idx]);
-        res.push_back(b);
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Reads data from the receive buffer as a hexadecimal string, starting at current stream position.
- * If data at current stream position is not available anymore in the receive buffer, the
- * function performs a short read.
- *
- * @param nBytes : the maximum number of bytes to read
- *
- * @return a string with receive buffer contents, encoded in hexadecimal
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSpiPort::readHex(int nBytes)
-{
-    string buff;
-    int bufflen = 0;
-    int mult = 0;
-    int endpos = 0;
-    int ofs = 0;
-    string res;
-    if (nBytes > 65535) {
-        nBytes = 65535;
-    }
-
-    buff = this->_download(YapiWrapper::ysprintf("rxdata.bin?pos=%d&len=%d", _rxptr,nBytes));
-    bufflen = (int)(buff).size() - 1;
-    endpos = 0;
-    mult = 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        endpos = endpos + mult * (((u8)buff[bufflen]) - 48);
-        mult = mult * 10;
-        bufflen = bufflen - 1;
-    }
-    _rxptr = endpos;
-    res = "";
-    ofs = 0;
-    while (ofs + 3 < bufflen) {
-        res = YapiWrapper::ysprintf("%s%02X%02X%02X%02X", res.c_str(), ((u8)buff[ofs]), ((u8)buff[ofs + 1]), ((u8)buff[ofs + 2]),((u8)buff[ofs + 3]));
-        ofs = ofs + 4;
-    }
-    while (ofs < bufflen) {
-        res = YapiWrapper::ysprintf("%s%02X", res.c_str(),((u8)buff[ofs]));
-        ofs = ofs + 1;
-    }
-    return res;
-}
-
-/**
- * Reads a single line (or message) from the receive buffer, starting at current stream position.
- * This function is intended to be used when the serial port is configured for a message protocol,
- * such as 'Line' mode or frame protocols.
- *
- * If data at current stream position is not available anymore in the receive buffer,
- * the function returns the oldest available line and moves the stream position just after.
- * If no new full line is received, the function returns an empty line.
- *
- * @return a string with a single line of text
- *
- * On failure, throws an exception or returns a negative error code.
- */
-string YSpiPort::readLine(void)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    string res;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?pos=%d&len=1&maxw=1",_rxptr);
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return "";
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    if (msglen == 0) {
-        return "";
-    }
-    res = this->_json_get_string(msgarr[0]);
-    return res;
-}
-
-/**
- * Searches for incoming messages in the serial port receive buffer matching a given pattern,
- * starting at current position. This function will only compare and return printable characters
- * in the message strings. Binary protocols are handled as hexadecimal strings.
- *
- * The search returns all messages matching the expression provided as argument in the buffer.
- * If no matching message is found, the search waits for one up to the specified maximum timeout
- * (in milliseconds).
- *
- * @param pattern : a limited regular expression describing the expected message format,
- *         or an empty string if all messages should be returned (no filtering).
- *         When using binary protocols, the format applies to the hexadecimal
- *         representation of the message.
- * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
- *         in the receive buffer.
- *
- * @return an array of strings containing the messages found, if any.
- *         Binary messages are converted to hexadecimal representation.
- *
- * On failure, throws an exception or returns an empty array.
- */
-vector<string> YSpiPort::readMessages(string pattern,int maxWait)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    vector<string> res;
-    int idx = 0;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?pos=%d&maxw=%d&pat=%s", _rxptr, maxWait,pattern.c_str());
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return res;
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    idx = 0;
-    while (idx < msglen) {
-        res.push_back(this->_json_get_string(msgarr[idx]));
-        idx = idx + 1;
-    }
-    return res;
-}
-
-/**
- * Changes the current internal stream position to the specified value. This function
- * does not affect the device, it only changes the value stored in the API object
- * for the next read operations.
- *
- * @param absPos : the absolute position index for next read operations.
- *
- * @return nothing.
- */
-int YSpiPort::read_seek(int absPos)
-{
-    _rxptr = absPos;
-    return YAPI_SUCCESS;
-}
-
-/**
- * Returns the current absolute stream position pointer of the API object.
- *
- * @return the absolute position index for next read operations.
- */
-int YSpiPort::read_tell(void)
-{
-    return _rxptr;
-}
-
-/**
- * Returns the number of bytes available to read in the input buffer starting from the
- * current absolute stream position pointer of the API object.
- *
- * @return the number of bytes available to read
- */
-int YSpiPort::read_avail(void)
-{
-    string buff;
-    int bufflen = 0;
-    int res = 0;
-
-    buff = this->_download(YapiWrapper::ysprintf("rxcnt.bin?pos=%d",_rxptr));
-    bufflen = (int)(buff).size() - 1;
-    while ((bufflen > 0) && (((u8)buff[bufflen]) != 64)) {
-        bufflen = bufflen - 1;
-    }
-    res = atoi(((buff).substr( 0, bufflen)).c_str());
-    return res;
-}
-
-/**
- * Sends a text line query to the serial port, and reads the reply, if any.
- * This function is intended to be used when the serial port is configured for 'Line' protocol.
- *
- * @param query : the line query to send (without CR/LF)
- * @param maxWait : the maximum number of milliseconds to wait for a reply.
- *
- * @return the next text line received after sending the text query, as a string.
- *         Additional lines can be obtained by calling readLine or readMessages.
- *
- * On failure, throws an exception or returns an empty array.
- */
-string YSpiPort::queryLine(string query,int maxWait)
-{
-    string url;
-    string msgbin;
-    vector<string> msgarr;
-    int msglen = 0;
-    string res;
-
-    url = YapiWrapper::ysprintf("rxmsg.json?len=1&maxw=%d&cmd=!%s", maxWait,query.c_str());
-    msgbin = this->_download(url);
-    msgarr = this->_json_get_array(msgbin);
-    msglen = (int)msgarr.size();
-    if (msglen == 0) {
-        return "";
-    }
-    // last element of array is the new position
-    msglen = msglen - 1;
-    _rxptr = atoi((msgarr[msglen]).c_str());
-    if (msglen == 0) {
-        return "";
-    }
-    res = this->_json_get_string(msgarr[0]);
-    return res;
-}
-
-/**
- * Saves the job definition string (JSON data) into a job file.
- * The job file can be later enabled using selectJob().
- *
- * @param jobfile : name of the job file to save on the device filesystem
- * @param jsonDef : a string containing a JSON definition of the job
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::uploadJob(string jobfile,string jsonDef)
-{
-    this->_upload(jobfile, jsonDef);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Load and start processing the specified job file. The file must have
- * been previously created using the user interface or uploaded on the
- * device filesystem using the uploadJob() function.
- *
- * @param jobfile : name of the job file (on the device filesystem)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::selectJob(string jobfile)
-{
-    return this->set_currentJob(jobfile);
-}
-
-/**
- * Manually sets the state of the SS line. This function has no effect when
- * the SS line is handled automatically.
- *
- * @param val : 1 to turn SS active, 0 to release SS.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YSpiPort::set_SS(int val)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("S%d",val));
-}
-
-YSpiPort *YSpiPort::nextSpiPort(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YSpiPort::FindSpiPort(hwid);
-}
-
-YSpiPort* YSpiPort::FirstSpiPort(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("SpiPort", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YSpiPort::FindSpiPort(serial+"."+funcId);
-}
-
-//--- (end of YSpiPort implementation)
-
-//--- (YSpiPort functions)
-//--- (end of YSpiPort functions)
--- a/Sources/cpplib/yocto_spiport.h
+++ /dev/null
@@ -1,845 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_spiport.h 33722 2018-12-14 15:04:43Z seb $
- *
- *  Declares yFindSpiPort(), the high-level API for SpiPort functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_SPIPORT_H
-#define YOCTO_SPIPORT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YSpiPort return codes)
-//--- (end of YSpiPort return codes)
-//--- (YSpiPort yapiwrapper)
-//--- (end of YSpiPort yapiwrapper)
-//--- (YSpiPort definitions)
-class YSpiPort; // forward declaration
-
-typedef void (*YSpiPortValueCallback)(YSpiPort *func, const string& functionValue);
-#ifndef _Y_VOLTAGELEVEL_ENUM
-#define _Y_VOLTAGELEVEL_ENUM
-typedef enum {
-    Y_VOLTAGELEVEL_OFF = 0,
-    Y_VOLTAGELEVEL_TTL3V = 1,
-    Y_VOLTAGELEVEL_TTL3VR = 2,
-    Y_VOLTAGELEVEL_TTL5V = 3,
-    Y_VOLTAGELEVEL_TTL5VR = 4,
-    Y_VOLTAGELEVEL_RS232 = 5,
-    Y_VOLTAGELEVEL_RS485 = 6,
-    Y_VOLTAGELEVEL_INVALID = -1,
-} Y_VOLTAGELEVEL_enum;
-#endif
-#ifndef _Y_SSPOLARITY_ENUM
-#define _Y_SSPOLARITY_ENUM
-typedef enum {
-    Y_SSPOLARITY_ACTIVE_LOW = 0,
-    Y_SSPOLARITY_ACTIVE_HIGH = 1,
-    Y_SSPOLARITY_INVALID = -1,
-} Y_SSPOLARITY_enum;
-#endif
-#ifndef _Y_SHIFTSAMPLING_ENUM
-#define _Y_SHIFTSAMPLING_ENUM
-typedef enum {
-    Y_SHIFTSAMPLING_OFF = 0,
-    Y_SHIFTSAMPLING_ON = 1,
-    Y_SHIFTSAMPLING_INVALID = -1,
-} Y_SHIFTSAMPLING_enum;
-#endif
-#define Y_RXCOUNT_INVALID               (YAPI_INVALID_UINT)
-#define Y_TXCOUNT_INVALID               (YAPI_INVALID_UINT)
-#define Y_ERRCOUNT_INVALID              (YAPI_INVALID_UINT)
-#define Y_RXMSGCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_TXMSGCOUNT_INVALID            (YAPI_INVALID_UINT)
-#define Y_LASTMSG_INVALID               (YAPI_INVALID_STRING)
-#define Y_CURRENTJOB_INVALID            (YAPI_INVALID_STRING)
-#define Y_STARTUPJOB_INVALID            (YAPI_INVALID_STRING)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-#define Y_PROTOCOL_INVALID              (YAPI_INVALID_STRING)
-#define Y_SPIMODE_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YSpiPort definitions)
-
-//--- (YSpiPort declaration)
-/**
- * YSpiPort Class: SPI Port function interface
- *
- * The SpiPort function interface allows you to fully drive a Yoctopuce
- * SPI port, to send and receive data, and to configure communication
- * parameters (baud rate, bit count, parity, flow control and protocol).
- * Note that Yoctopuce SPI ports are not exposed as virtual COM ports.
- * They are meant to be used in the same way as all Yoctopuce devices.
- */
-class YOCTO_CLASS_EXPORT YSpiPort: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YSpiPort declaration)
-protected:
-    //--- (YSpiPort attributes)
-    // Attributes (function value cache)
-    int             _rxCount;
-    int             _txCount;
-    int             _errCount;
-    int             _rxMsgCount;
-    int             _txMsgCount;
-    string          _lastMsg;
-    string          _currentJob;
-    string          _startupJob;
-    string          _command;
-    Y_VOLTAGELEVEL_enum _voltageLevel;
-    string          _protocol;
-    string          _spiMode;
-    Y_SSPOLARITY_enum _ssPolarity;
-    Y_SHIFTSAMPLING_enum _shiftSampling;
-    YSpiPortValueCallback _valueCallbackSpiPort;
-    int             _rxptr;
-    string          _rxbuff;
-    int             _rxbuffptr;
-
-    friend YSpiPort *yFindSpiPort(const string& func);
-    friend YSpiPort *yFirstSpiPort(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindSpiPort factory function to instantiate
-    YSpiPort(const string& func);
-    //--- (end of YSpiPort attributes)
-
-public:
-    virtual ~YSpiPort();
-    //--- (YSpiPort accessors declaration)
-
-    static const int RXCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int TXCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int ERRCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int RXMSGCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const int TXMSGCOUNT_INVALID = YAPI_INVALID_UINT;
-    static const string LASTMSG_INVALID;
-    static const string CURRENTJOB_INVALID;
-    static const string STARTUPJOB_INVALID;
-    static const string COMMAND_INVALID;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_OFF = Y_VOLTAGELEVEL_OFF;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL3V = Y_VOLTAGELEVEL_TTL3V;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL3VR = Y_VOLTAGELEVEL_TTL3VR;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL5V = Y_VOLTAGELEVEL_TTL5V;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_TTL5VR = Y_VOLTAGELEVEL_TTL5VR;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_RS232 = Y_VOLTAGELEVEL_RS232;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_RS485 = Y_VOLTAGELEVEL_RS485;
-    static const Y_VOLTAGELEVEL_enum VOLTAGELEVEL_INVALID = Y_VOLTAGELEVEL_INVALID;
-    static const string PROTOCOL_INVALID;
-    static const string SPIMODE_INVALID;
-    static const Y_SSPOLARITY_enum SSPOLARITY_ACTIVE_LOW = Y_SSPOLARITY_ACTIVE_LOW;
-    static const Y_SSPOLARITY_enum SSPOLARITY_ACTIVE_HIGH = Y_SSPOLARITY_ACTIVE_HIGH;
-    static const Y_SSPOLARITY_enum SSPOLARITY_INVALID = Y_SSPOLARITY_INVALID;
-    static const Y_SHIFTSAMPLING_enum SHIFTSAMPLING_OFF = Y_SHIFTSAMPLING_OFF;
-    static const Y_SHIFTSAMPLING_enum SHIFTSAMPLING_ON = Y_SHIFTSAMPLING_ON;
-    static const Y_SHIFTSAMPLING_enum SHIFTSAMPLING_INVALID = Y_SHIFTSAMPLING_INVALID;
-
-    /**
-     * Returns the total number of bytes received since last reset.
-     *
-     * @return an integer corresponding to the total number of bytes received since last reset
-     *
-     * On failure, throws an exception or returns Y_RXCOUNT_INVALID.
-     */
-    int                 get_rxCount(void);
-
-    inline int          rxCount(void)
-    { return this->get_rxCount(); }
-
-    /**
-     * Returns the total number of bytes transmitted since last reset.
-     *
-     * @return an integer corresponding to the total number of bytes transmitted since last reset
-     *
-     * On failure, throws an exception or returns Y_TXCOUNT_INVALID.
-     */
-    int                 get_txCount(void);
-
-    inline int          txCount(void)
-    { return this->get_txCount(); }
-
-    /**
-     * Returns the total number of communication errors detected since last reset.
-     *
-     * @return an integer corresponding to the total number of communication errors detected since last reset
-     *
-     * On failure, throws an exception or returns Y_ERRCOUNT_INVALID.
-     */
-    int                 get_errCount(void);
-
-    inline int          errCount(void)
-    { return this->get_errCount(); }
-
-    /**
-     * Returns the total number of messages received since last reset.
-     *
-     * @return an integer corresponding to the total number of messages received since last reset
-     *
-     * On failure, throws an exception or returns Y_RXMSGCOUNT_INVALID.
-     */
-    int                 get_rxMsgCount(void);
-
-    inline int          rxMsgCount(void)
-    { return this->get_rxMsgCount(); }
-
-    /**
-     * Returns the total number of messages send since last reset.
-     *
-     * @return an integer corresponding to the total number of messages send since last reset
-     *
-     * On failure, throws an exception or returns Y_TXMSGCOUNT_INVALID.
-     */
-    int                 get_txMsgCount(void);
-
-    inline int          txMsgCount(void)
-    { return this->get_txMsgCount(); }
-
-    /**
-     * Returns the latest message fully received (for Line and Frame protocols).
-     *
-     * @return a string corresponding to the latest message fully received (for Line and Frame protocols)
-     *
-     * On failure, throws an exception or returns Y_LASTMSG_INVALID.
-     */
-    string              get_lastMsg(void);
-
-    inline string       lastMsg(void)
-    { return this->get_lastMsg(); }
-
-    /**
-     * Returns the name of the job file currently in use.
-     *
-     * @return a string corresponding to the name of the job file currently in use
-     *
-     * On failure, throws an exception or returns Y_CURRENTJOB_INVALID.
-     */
-    string              get_currentJob(void);
-
-    inline string       currentJob(void)
-    { return this->get_currentJob(); }
-
-    /**
-     * Changes the job to use when the device is powered on.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the job to use when the device is powered on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentJob(const string& newval);
-    inline int      setCurrentJob(const string& newval)
-    { return this->set_currentJob(newval); }
-
-    /**
-     * Returns the job file to use when the device is powered on.
-     *
-     * @return a string corresponding to the job file to use when the device is powered on
-     *
-     * On failure, throws an exception or returns Y_STARTUPJOB_INVALID.
-     */
-    string              get_startupJob(void);
-
-    inline string       startupJob(void)
-    { return this->get_startupJob(); }
-
-    /**
-     * Changes the job to use when the device is powered on.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the job to use when the device is powered on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_startupJob(const string& newval);
-    inline int      setStartupJob(const string& newval)
-    { return this->set_startupJob(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Returns the voltage level used on the serial line.
-     *
-     * @return a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
-     * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
-     * corresponding to the voltage level used on the serial line
-     *
-     * On failure, throws an exception or returns Y_VOLTAGELEVEL_INVALID.
-     */
-    Y_VOLTAGELEVEL_enum get_voltageLevel(void);
-
-    inline Y_VOLTAGELEVEL_enum voltageLevel(void)
-    { return this->get_voltageLevel(); }
-
-    /**
-     * Changes the voltage type used on the serial line. Valid
-     * values  will depend on the Yoctopuce device model featuring
-     * the serial port feature.  Check your device documentation
-     * to find out which values are valid for that specific model.
-     * Trying to set an invalid value will have no effect.
-     *
-     * @param newval : a value among Y_VOLTAGELEVEL_OFF, Y_VOLTAGELEVEL_TTL3V, Y_VOLTAGELEVEL_TTL3VR,
-     * Y_VOLTAGELEVEL_TTL5V, Y_VOLTAGELEVEL_TTL5VR, Y_VOLTAGELEVEL_RS232 and Y_VOLTAGELEVEL_RS485
-     * corresponding to the voltage type used on the serial line
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageLevel(Y_VOLTAGELEVEL_enum newval);
-    inline int      setVoltageLevel(Y_VOLTAGELEVEL_enum newval)
-    { return this->set_voltageLevel(newval); }
-
-    /**
-     * Returns the type of protocol used over the serial line, as a string.
-     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
-     * "Frame:[timeout]ms" for binary messages separated by a delay time,
-     * "Char" for a continuous ASCII stream or
-     * "Byte" for a continuous binary stream.
-     *
-     * @return a string corresponding to the type of protocol used over the serial line, as a string
-     *
-     * On failure, throws an exception or returns Y_PROTOCOL_INVALID.
-     */
-    string              get_protocol(void);
-
-    inline string       protocol(void)
-    { return this->get_protocol(); }
-
-    /**
-     * Changes the type of protocol used over the serial line.
-     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
-     * "Frame:[timeout]ms" for binary messages separated by a delay time,
-     * "Char" for a continuous ASCII stream or
-     * "Byte" for a continuous binary stream.
-     * The suffix "/[wait]ms" can be added to reduce the transmit rate so that there
-     * is always at lest the specified number of milliseconds between each bytes sent.
-     *
-     * @param newval : a string corresponding to the type of protocol used over the serial line
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_protocol(const string& newval);
-    inline int      setProtocol(const string& newval)
-    { return this->set_protocol(newval); }
-
-    /**
-     * Returns the SPI port communication parameters, as a string such as
-     * "125000,0,msb". The string includes the baud rate, the SPI mode (between
-     * 0 and 3) and the bit order.
-     *
-     * @return a string corresponding to the SPI port communication parameters, as a string such as
-     *         "125000,0,msb"
-     *
-     * On failure, throws an exception or returns Y_SPIMODE_INVALID.
-     */
-    string              get_spiMode(void);
-
-    inline string       spiMode(void)
-    { return this->get_spiMode(); }
-
-    /**
-     * Changes the SPI port communication parameters, with a string such as
-     * "125000,0,msb". The string includes the baud rate, the SPI mode (between
-     * 0 and 3) and the bit order.
-     *
-     * @param newval : a string corresponding to the SPI port communication parameters, with a string such as
-     *         "125000,0,msb"
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_spiMode(const string& newval);
-    inline int      setSpiMode(const string& newval)
-    { return this->set_spiMode(newval); }
-
-    /**
-     * Returns the SS line polarity.
-     *
-     * @return either Y_SSPOLARITY_ACTIVE_LOW or Y_SSPOLARITY_ACTIVE_HIGH, according to the SS line polarity
-     *
-     * On failure, throws an exception or returns Y_SSPOLARITY_INVALID.
-     */
-    Y_SSPOLARITY_enum   get_ssPolarity(void);
-
-    inline Y_SSPOLARITY_enum ssPolarity(void)
-    { return this->get_ssPolarity(); }
-
-    /**
-     * Changes the SS line polarity.
-     *
-     * @param newval : either Y_SSPOLARITY_ACTIVE_LOW or Y_SSPOLARITY_ACTIVE_HIGH, according to the SS line polarity
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_ssPolarity(Y_SSPOLARITY_enum newval);
-    inline int      setSsPolarity(Y_SSPOLARITY_enum newval)
-    { return this->set_ssPolarity(newval); }
-
-    /**
-     * Returns true when the SDI line phase is shifted with regards to the SDO line.
-     *
-     * @return either Y_SHIFTSAMPLING_OFF or Y_SHIFTSAMPLING_ON, according to true when the SDI line phase
-     * is shifted with regards to the SDO line
-     *
-     * On failure, throws an exception or returns Y_SHIFTSAMPLING_INVALID.
-     */
-    Y_SHIFTSAMPLING_enum get_shiftSampling(void);
-
-    inline Y_SHIFTSAMPLING_enum shiftSampling(void)
-    { return this->get_shiftSampling(); }
-
-    /**
-     * Changes the SDI line sampling shift. When disabled, SDI line is
-     * sampled in the middle of data output time. When enabled, SDI line is
-     * samples at the end of data output time.
-     *
-     * @param newval : either Y_SHIFTSAMPLING_OFF or Y_SHIFTSAMPLING_ON, according to the SDI line sampling shift
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_shiftSampling(Y_SHIFTSAMPLING_enum newval);
-    inline int      setShiftSampling(Y_SHIFTSAMPLING_enum newval)
-    { return this->set_shiftSampling(newval); }
-
-    /**
-     * Retrieves a SPI port for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the SPI port is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YSpiPort.isOnline() to test if the SPI port is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a SPI port by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the SPI port
-     *
-     * @return a YSpiPort object allowing you to drive the SPI port.
-     */
-    static YSpiPort*    FindSpiPort(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YSpiPortValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string text);
-
-    /**
-     * Clears the serial port buffer and resets counters to zero.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-    /**
-     * Sends a single byte to the serial port.
-     *
-     * @param code : the byte to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeByte(int code);
-
-    /**
-     * Sends an ASCII string to the serial port, as is.
-     *
-     * @param text : the text string to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeStr(string text);
-
-    /**
-     * Sends a binary buffer to the serial port, as is.
-     *
-     * @param buff : the binary buffer to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeBin(string buff);
-
-    /**
-     * Sends a byte sequence (provided as a list of bytes) to the serial port.
-     *
-     * @param byteList : a list of byte codes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeArray(vector<int> byteList);
-
-    /**
-     * Sends a byte sequence (provided as a hexadecimal string) to the serial port.
-     *
-     * @param hexString : a string of hexadecimal byte codes
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeHex(string hexString);
-
-    /**
-     * Sends an ASCII string to the serial port, followed by a line break (CR LF).
-     *
-     * @param text : the text string to send
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         writeLine(string text);
-
-    /**
-     * Reads one byte from the receive buffer, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer,
-     * or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.
-     *
-     * @return the next byte
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         readByte(void);
-
-    /**
-     * Reads data from the receive buffer as a string, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of characters to read
-     *
-     * @return a string with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readStr(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a binary buffer, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of bytes to read
-     *
-     * @return a binary object with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readBin(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a list of bytes, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nChars : the maximum number of bytes to read
-     *
-     * @return a sequence of bytes with receive buffer contents
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual vector<int> readArray(int nChars);
-
-    /**
-     * Reads data from the receive buffer as a hexadecimal string, starting at current stream position.
-     * If data at current stream position is not available anymore in the receive buffer, the
-     * function performs a short read.
-     *
-     * @param nBytes : the maximum number of bytes to read
-     *
-     * @return a string with receive buffer contents, encoded in hexadecimal
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readHex(int nBytes);
-
-    /**
-     * Reads a single line (or message) from the receive buffer, starting at current stream position.
-     * This function is intended to be used when the serial port is configured for a message protocol,
-     * such as 'Line' mode or frame protocols.
-     *
-     * If data at current stream position is not available anymore in the receive buffer,
-     * the function returns the oldest available line and moves the stream position just after.
-     * If no new full line is received, the function returns an empty line.
-     *
-     * @return a string with a single line of text
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual string      readLine(void);
-
-    /**
-     * Searches for incoming messages in the serial port receive buffer matching a given pattern,
-     * starting at current position. This function will only compare and return printable characters
-     * in the message strings. Binary protocols are handled as hexadecimal strings.
-     *
-     * The search returns all messages matching the expression provided as argument in the buffer.
-     * If no matching message is found, the search waits for one up to the specified maximum timeout
-     * (in milliseconds).
-     *
-     * @param pattern : a limited regular expression describing the expected message format,
-     *         or an empty string if all messages should be returned (no filtering).
-     *         When using binary protocols, the format applies to the hexadecimal
-     *         representation of the message.
-     * @param maxWait : the maximum number of milliseconds to wait for a message if none is found
-     *         in the receive buffer.
-     *
-     * @return an array of strings containing the messages found, if any.
-     *         Binary messages are converted to hexadecimal representation.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual vector<string> readMessages(string pattern,int maxWait);
-
-    /**
-     * Changes the current internal stream position to the specified value. This function
-     * does not affect the device, it only changes the value stored in the API object
-     * for the next read operations.
-     *
-     * @param absPos : the absolute position index for next read operations.
-     *
-     * @return nothing.
-     */
-    virtual int         read_seek(int absPos);
-
-    /**
-     * Returns the current absolute stream position pointer of the API object.
-     *
-     * @return the absolute position index for next read operations.
-     */
-    virtual int         read_tell(void);
-
-    /**
-     * Returns the number of bytes available to read in the input buffer starting from the
-     * current absolute stream position pointer of the API object.
-     *
-     * @return the number of bytes available to read
-     */
-    virtual int         read_avail(void);
-
-    /**
-     * Sends a text line query to the serial port, and reads the reply, if any.
-     * This function is intended to be used when the serial port is configured for 'Line' protocol.
-     *
-     * @param query : the line query to send (without CR/LF)
-     * @param maxWait : the maximum number of milliseconds to wait for a reply.
-     *
-     * @return the next text line received after sending the text query, as a string.
-     *         Additional lines can be obtained by calling readLine or readMessages.
-     *
-     * On failure, throws an exception or returns an empty array.
-     */
-    virtual string      queryLine(string query,int maxWait);
-
-    /**
-     * Saves the job definition string (JSON data) into a job file.
-     * The job file can be later enabled using selectJob().
-     *
-     * @param jobfile : name of the job file to save on the device filesystem
-     * @param jsonDef : a string containing a JSON definition of the job
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         uploadJob(string jobfile,string jsonDef);
-
-    /**
-     * Load and start processing the specified job file. The file must have
-     * been previously created using the user interface or uploaded on the
-     * device filesystem using the uploadJob() function.
-     *
-     * @param jobfile : name of the job file (on the device filesystem)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         selectJob(string jobfile);
-
-    /**
-     * Manually sets the state of the SS line. This function has no effect when
-     * the SS line is handled automatically.
-     *
-     * @param val : 1 to turn SS active, 0 to release SS.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_SS(int val);
-
-
-    inline static YSpiPort* Find(string func)
-    { return YSpiPort::FindSpiPort(func); }
-
-    /**
-     * Continues the enumeration of SPI ports started using yFirstSpiPort().
-     * Caution: You can't make any assumption about the returned SPI ports order.
-     * If you want to find a specific a SPI port, use SpiPort.findSpiPort()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YSpiPort object, corresponding to
-     *         a SPI port currently online, or a NULL pointer
-     *         if there are no more SPI ports to enumerate.
-     */
-           YSpiPort        *nextSpiPort(void);
-    inline YSpiPort        *next(void)
-    { return this->nextSpiPort();}
-
-    /**
-     * Starts the enumeration of SPI ports currently accessible.
-     * Use the method YSpiPort.nextSpiPort() to iterate on
-     * next SPI ports.
-     *
-     * @return a pointer to a YSpiPort object, corresponding to
-     *         the first SPI port currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YSpiPort* FirstSpiPort(void);
-    inline static YSpiPort* First(void)
-    { return YSpiPort::FirstSpiPort();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YSpiPort accessors declaration)
-};
-
-//--- (YSpiPort functions declaration)
-
-/**
- * Retrieves a SPI port for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the SPI port is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YSpiPort.isOnline() to test if the SPI port is
- * indeed online at a given time. In case of ambiguity when looking for
- * a SPI port by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the SPI port
- *
- * @return a YSpiPort object allowing you to drive the SPI port.
- */
-inline YSpiPort* yFindSpiPort(const string& func)
-{ return YSpiPort::FindSpiPort(func);}
-/**
- * Starts the enumeration of SPI ports currently accessible.
- * Use the method YSpiPort.nextSpiPort() to iterate on
- * next SPI ports.
- *
- * @return a pointer to a YSpiPort object, corresponding to
- *         the first SPI port currently online, or a NULL pointer
- *         if there are none.
- */
-inline YSpiPort* yFirstSpiPort(void)
-{ return YSpiPort::FirstSpiPort();}
-
-//--- (end of YSpiPort functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_steppermotor.cpp
+++ /dev/null
@@ -1,1151 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_steppermotor.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindStepperMotor(), the high-level API for StepperMotor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_steppermotor.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "steppermotor"
-
-YStepperMotor::YStepperMotor(const string& func): YFunction(func)
-//--- (YStepperMotor initialization)
-    ,_motorState(MOTORSTATE_INVALID)
-    ,_diags(DIAGS_INVALID)
-    ,_stepPos(STEPPOS_INVALID)
-    ,_speed(SPEED_INVALID)
-    ,_pullinSpeed(PULLINSPEED_INVALID)
-    ,_maxAccel(MAXACCEL_INVALID)
-    ,_maxSpeed(MAXSPEED_INVALID)
-    ,_stepping(STEPPING_INVALID)
-    ,_overcurrent(OVERCURRENT_INVALID)
-    ,_tCurrStop(TCURRSTOP_INVALID)
-    ,_tCurrRun(TCURRRUN_INVALID)
-    ,_alertMode(ALERTMODE_INVALID)
-    ,_auxMode(AUXMODE_INVALID)
-    ,_auxSignal(AUXSIGNAL_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackStepperMotor(NULL)
-//--- (end of YStepperMotor initialization)
-{
-    _className="StepperMotor";
-}
-
-YStepperMotor::~YStepperMotor()
-{
-//--- (YStepperMotor cleanup)
-//--- (end of YStepperMotor cleanup)
-}
-//--- (YStepperMotor implementation)
-// static attributes
-const double YStepperMotor::STEPPOS_INVALID = YAPI_INVALID_DOUBLE;
-const double YStepperMotor::SPEED_INVALID = YAPI_INVALID_DOUBLE;
-const double YStepperMotor::PULLINSPEED_INVALID = YAPI_INVALID_DOUBLE;
-const double YStepperMotor::MAXACCEL_INVALID = YAPI_INVALID_DOUBLE;
-const double YStepperMotor::MAXSPEED_INVALID = YAPI_INVALID_DOUBLE;
-const string YStepperMotor::ALERTMODE_INVALID = YAPI_INVALID_STRING;
-const string YStepperMotor::AUXMODE_INVALID = YAPI_INVALID_STRING;
-const string YStepperMotor::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YStepperMotor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("motorState")) {
-        _motorState =  (Y_MOTORSTATE_enum)json_val->getInt("motorState");
-    }
-    if(json_val->has("diags")) {
-        _diags =  json_val->getInt("diags");
-    }
-    if(json_val->has("stepPos")) {
-        _stepPos =  json_val->getDouble("stepPos") / 16.0;
-    }
-    if(json_val->has("speed")) {
-        _speed =  floor(json_val->getDouble("speed") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("pullinSpeed")) {
-        _pullinSpeed =  floor(json_val->getDouble("pullinSpeed") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("maxAccel")) {
-        _maxAccel =  floor(json_val->getDouble("maxAccel") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("maxSpeed")) {
-        _maxSpeed =  floor(json_val->getDouble("maxSpeed") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("stepping")) {
-        _stepping =  (Y_STEPPING_enum)json_val->getInt("stepping");
-    }
-    if(json_val->has("overcurrent")) {
-        _overcurrent =  json_val->getInt("overcurrent");
-    }
-    if(json_val->has("tCurrStop")) {
-        _tCurrStop =  json_val->getInt("tCurrStop");
-    }
-    if(json_val->has("tCurrRun")) {
-        _tCurrRun =  json_val->getInt("tCurrRun");
-    }
-    if(json_val->has("alertMode")) {
-        _alertMode =  json_val->getString("alertMode");
-    }
-    if(json_val->has("auxMode")) {
-        _auxMode =  json_val->getString("auxMode");
-    }
-    if(json_val->has("auxSignal")) {
-        _auxSignal =  json_val->getInt("auxSignal");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the motor working state.
- *
- * @return a value among Y_MOTORSTATE_ABSENT, Y_MOTORSTATE_ALERT, Y_MOTORSTATE_HI_Z,
- * Y_MOTORSTATE_STOP, Y_MOTORSTATE_RUN and Y_MOTORSTATE_BATCH corresponding to the motor working state
- *
- * On failure, throws an exception or returns Y_MOTORSTATE_INVALID.
- */
-Y_MOTORSTATE_enum YStepperMotor::get_motorState(void)
-{
-    Y_MOTORSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::MOTORSTATE_INVALID;
-                }
-            }
-        }
-        res = _motorState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the stepper motor controller diagnostics, as a bitmap.
- *
- * @return an integer corresponding to the stepper motor controller diagnostics, as a bitmap
- *
- * On failure, throws an exception or returns Y_DIAGS_INVALID.
- */
-int YStepperMotor::get_diags(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::DIAGS_INVALID;
-                }
-            }
-        }
-        res = _diags;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current logical motor position, measured in steps.
- * This command does not cause any motor move, as its purpose is only to setup
- * the origin of the position counter. The fractional part of the position,
- * that corresponds to the physical position of the rotor, is not changed.
- * To trigger a motor move, use methods moveTo() or moveRel()
- * instead.
- *
- * @param newval : a floating point number corresponding to the current logical motor position, measured in steps
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_stepPos(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf,"%.2f", floor(newval * 100.0)/100.0); rest_val = string(buf);
-        res = _setAttr("stepPos", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current logical motor position, measured in steps.
- * The value may include a fractional part when micro-stepping is in use.
- *
- * @return a floating point number corresponding to the current logical motor position, measured in steps
- *
- * On failure, throws an exception or returns Y_STEPPOS_INVALID.
- */
-double YStepperMotor::get_stepPos(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::STEPPOS_INVALID;
-                }
-            }
-        }
-        res = _stepPos;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns current motor speed, measured in steps per second.
- * To change speed, use method changeSpeed().
- *
- * @return a floating point number corresponding to current motor speed, measured in steps per second
- *
- * On failure, throws an exception or returns Y_SPEED_INVALID.
- */
-double YStepperMotor::get_speed(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::SPEED_INVALID;
-                }
-            }
-        }
-        res = _speed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the motor speed immediately reachable from stop state, measured in steps per second.
- *
- * @param newval : a floating point number corresponding to the motor speed immediately reachable from
- * stop state, measured in steps per second
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_pullinSpeed(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("pullinSpeed", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the motor speed immediately reachable from stop state, measured in steps per second.
- *
- * @return a floating point number corresponding to the motor speed immediately reachable from stop
- * state, measured in steps per second
- *
- * On failure, throws an exception or returns Y_PULLINSPEED_INVALID.
- */
-double YStepperMotor::get_pullinSpeed(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::PULLINSPEED_INVALID;
-                }
-            }
-        }
-        res = _pullinSpeed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the maximal motor acceleration, measured in steps per second^2.
- *
- * @param newval : a floating point number corresponding to the maximal motor acceleration, measured
- * in steps per second^2
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_maxAccel(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("maxAccel", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximal motor acceleration, measured in steps per second^2.
- *
- * @return a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2
- *
- * On failure, throws an exception or returns Y_MAXACCEL_INVALID.
- */
-double YStepperMotor::get_maxAccel(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::MAXACCEL_INVALID;
-                }
-            }
-        }
-        res = _maxAccel;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the maximal motor speed, measured in steps per second.
- *
- * @param newval : a floating point number corresponding to the maximal motor speed, measured in steps per second
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_maxSpeed(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("maxSpeed", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the maximal motor speed, measured in steps per second.
- *
- * @return a floating point number corresponding to the maximal motor speed, measured in steps per second
- *
- * On failure, throws an exception or returns Y_MAXSPEED_INVALID.
- */
-double YStepperMotor::get_maxSpeed(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::MAXSPEED_INVALID;
-                }
-            }
-        }
-        res = _maxSpeed;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the stepping mode used to drive the motor.
- *
- * @return a value among Y_STEPPING_MICROSTEP16, Y_STEPPING_MICROSTEP8, Y_STEPPING_MICROSTEP4,
- * Y_STEPPING_HALFSTEP and Y_STEPPING_FULLSTEP corresponding to the stepping mode used to drive the motor
- *
- * On failure, throws an exception or returns Y_STEPPING_INVALID.
- */
-Y_STEPPING_enum YStepperMotor::get_stepping(void)
-{
-    Y_STEPPING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::STEPPING_INVALID;
-                }
-            }
-        }
-        res = _stepping;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the stepping mode used to drive the motor.
- *
- * @param newval : a value among Y_STEPPING_MICROSTEP16, Y_STEPPING_MICROSTEP8, Y_STEPPING_MICROSTEP4,
- * Y_STEPPING_HALFSTEP and Y_STEPPING_FULLSTEP corresponding to the stepping mode used to drive the motor
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_stepping(Y_STEPPING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("stepping", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the overcurrent alert and emergency stop threshold, measured in mA.
- *
- * @return an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA
- *
- * On failure, throws an exception or returns Y_OVERCURRENT_INVALID.
- */
-int YStepperMotor::get_overcurrent(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::OVERCURRENT_INVALID;
-                }
-            }
-        }
-        res = _overcurrent;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the overcurrent alert and emergency stop threshold, measured in mA.
- *
- * @param newval : an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_overcurrent(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("overcurrent", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the torque regulation current when the motor is stopped, measured in mA.
- *
- * @return an integer corresponding to the torque regulation current when the motor is stopped, measured in mA
- *
- * On failure, throws an exception or returns Y_TCURRSTOP_INVALID.
- */
-int YStepperMotor::get_tCurrStop(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::TCURRSTOP_INVALID;
-                }
-            }
-        }
-        res = _tCurrStop;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the torque regulation current when the motor is stopped, measured in mA.
- *
- * @param newval : an integer corresponding to the torque regulation current when the motor is
- * stopped, measured in mA
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_tCurrStop(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("tCurrStop", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the torque regulation current when the motor is running, measured in mA.
- *
- * @return an integer corresponding to the torque regulation current when the motor is running, measured in mA
- *
- * On failure, throws an exception or returns Y_TCURRRUN_INVALID.
- */
-int YStepperMotor::get_tCurrRun(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::TCURRRUN_INVALID;
-                }
-            }
-        }
-        res = _tCurrRun;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the torque regulation current when the motor is running, measured in mA.
- *
- * @param newval : an integer corresponding to the torque regulation current when the motor is
- * running, measured in mA
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_tCurrRun(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("tCurrRun", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YStepperMotor::get_alertMode(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::ALERTMODE_INVALID;
-                }
-            }
-        }
-        res = _alertMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YStepperMotor::set_alertMode(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("alertMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YStepperMotor::get_auxMode(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::AUXMODE_INVALID;
-                }
-            }
-        }
-        res = _auxMode;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YStepperMotor::set_auxMode(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("auxMode", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current value of the signal generated on the auxiliary output.
- *
- * @return an integer corresponding to the current value of the signal generated on the auxiliary output
- *
- * On failure, throws an exception or returns Y_AUXSIGNAL_INVALID.
- */
-int YStepperMotor::get_auxSignal(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::AUXSIGNAL_INVALID;
-                }
-            }
-        }
-        res = _auxSignal;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the value of the signal generated on the auxiliary output.
- * Acceptable values depend on the auxiliary output signal type configured.
- *
- * @param newval : an integer corresponding to the value of the signal generated on the auxiliary output
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::set_auxSignal(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("auxSignal", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YStepperMotor::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YStepperMotor::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YStepperMotor::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a stepper motor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the stepper motor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YStepperMotor.isOnline() to test if the stepper motor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a stepper motor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the stepper motor
- *
- * @return a YStepperMotor object allowing you to drive the stepper motor.
- */
-YStepperMotor* YStepperMotor::FindStepperMotor(string func)
-{
-    YStepperMotor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YStepperMotor*) YFunction::_FindFromCache("StepperMotor", func);
-        if (obj == NULL) {
-            obj = new YStepperMotor(func);
-            YFunction::_AddToCache("StepperMotor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YStepperMotor::registerValueCallback(YStepperMotorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackStepperMotor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YStepperMotor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackStepperMotor != NULL) {
-        _valueCallbackStepperMotor(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-int YStepperMotor::sendCommand(string command)
-{
-    string id;
-    string url;
-    string retBin;
-    int res = 0;
-    id = this->get_functionId();
-    id = (id).substr( 12, 1);
-    url = YapiWrapper::ysprintf("cmd.txt?%s=%s", id.c_str(),command.c_str());
-    //may throw an exception
-    retBin = this->_download(url);
-    res = ((u8)retBin[0]);
-    if (res == 49) {
-        if (!(res == 48)) {
-            _throw(YAPI_DEVICE_BUSY,"Motor command pipeline is full, try again later");
-            return YAPI_DEVICE_BUSY;
-        }
-    } else {
-        if (!(res == 48)) {
-            _throw(YAPI_IO_ERROR,"Motor command failed permanently");
-            return YAPI_IO_ERROR;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Reinitialize the controller and clear all alert flags.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::reset(void)
-{
-    return this->set_command("Z");
-}
-
-/**
- * Starts the motor backward at the specified speed, to search for the motor home position.
- *
- * @param speed : desired speed, in steps per second.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::findHomePosition(double speed)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("H%d",(int) floor(1000*speed+0.5)));
-}
-
-/**
- * Starts the motor at a given speed. The time needed to reach the requested speed
- * will depend on the acceleration parameters configured for the motor.
- *
- * @param speed : desired speed, in steps per second. The minimal non-zero speed
- *         is 0.001 pulse per second.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::changeSpeed(double speed)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("R%d",(int) floor(1000*speed+0.5)));
-}
-
-/**
- * Starts the motor to reach a given absolute position. The time needed to reach the requested
- * position will depend on the acceleration and max speed parameters configured for
- * the motor.
- *
- * @param absPos : absolute position, measured in steps from the origin.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::moveTo(double absPos)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("M%d",(int) floor(16*absPos+0.5)));
-}
-
-/**
- * Starts the motor to reach a given relative position. The time needed to reach the requested
- * position will depend on the acceleration and max speed parameters configured for
- * the motor.
- *
- * @param relPos : relative position, measured in steps from the current position.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::moveRel(double relPos)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("m%d",(int) floor(16*relPos+0.5)));
-}
-
-/**
- * Starts the motor to reach a given relative position, keeping the speed under the
- * specified limit. The time needed to reach the requested position will depend on
- * the acceleration parameters configured for the motor.
- *
- * @param relPos : relative position, measured in steps from the current position.
- * @param maxSpeed : limit speed, in steps per second.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::moveRelSlow(double relPos,double maxSpeed)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("m%d@%d",(int) floor(16*relPos+0.5),(int) floor(1000*maxSpeed+0.5)));
-}
-
-/**
- * Keep the motor in the same state for the specified amount of time, before processing next command.
- *
- * @param waitMs : wait time, specified in milliseconds.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::pause(int waitMs)
-{
-    return this->sendCommand(YapiWrapper::ysprintf("_%d",waitMs));
-}
-
-/**
- * Stops the motor with an emergency alert, without taking any additional precaution.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::emergencyStop(void)
-{
-    return this->set_command("!");
-}
-
-/**
- * Move one step in the direction opposite the direction set when the most recent alert was raised.
- * The move occurs even if the system is still in alert mode (end switch depressed). Caution.
- * use this function with great care as it may cause mechanical damages !
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::alertStepOut(void)
-{
-    return this->set_command(".");
-}
-
-/**
- * Move one single step in the selected direction without regards to end switches.
- * The move occurs even if the system is still in alert mode (end switch depressed). Caution.
- * use this function with great care as it may cause mechanical damages !
- *
- * @param dir : Value +1 or -1, according to the desired direction of the move
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::alertStepDir(int dir)
-{
-    if (!(dir != 0)) {
-        _throw(YAPI_INVALID_ARGUMENT,"direction must be +1 or -1");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (dir > 0) {
-        return this->set_command(".+");
-    }
-    return this->set_command(".-");
-}
-
-/**
- * Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::abortAndBrake(void)
-{
-    return this->set_command("B");
-}
-
-/**
- * Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YStepperMotor::abortAndHiZ(void)
-{
-    return this->set_command("z");
-}
-
-YStepperMotor *YStepperMotor::nextStepperMotor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YStepperMotor::FindStepperMotor(hwid);
-}
-
-YStepperMotor* YStepperMotor::FirstStepperMotor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("StepperMotor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YStepperMotor::FindStepperMotor(serial+"."+funcId);
-}
-
-//--- (end of YStepperMotor implementation)
-
-//--- (YStepperMotor functions)
-//--- (end of YStepperMotor functions)
--- a/Sources/cpplib/yocto_steppermotor.h
+++ /dev/null
@@ -1,722 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_steppermotor.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindStepperMotor(), the high-level API for StepperMotor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_STEPPERMOTOR_H
-#define YOCTO_STEPPERMOTOR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YStepperMotor return codes)
-//--- (end of YStepperMotor return codes)
-//--- (YStepperMotor yapiwrapper)
-//--- (end of YStepperMotor yapiwrapper)
-//--- (YStepperMotor definitions)
-class YStepperMotor; // forward declaration
-
-typedef void (*YStepperMotorValueCallback)(YStepperMotor *func, const string& functionValue);
-#ifndef _Y_MOTORSTATE_ENUM
-#define _Y_MOTORSTATE_ENUM
-typedef enum {
-    Y_MOTORSTATE_ABSENT = 0,
-    Y_MOTORSTATE_ALERT = 1,
-    Y_MOTORSTATE_HI_Z = 2,
-    Y_MOTORSTATE_STOP = 3,
-    Y_MOTORSTATE_RUN = 4,
-    Y_MOTORSTATE_BATCH = 5,
-    Y_MOTORSTATE_INVALID = -1,
-} Y_MOTORSTATE_enum;
-#endif
-#ifndef _Y_STEPPING_ENUM
-#define _Y_STEPPING_ENUM
-typedef enum {
-    Y_STEPPING_MICROSTEP16 = 0,
-    Y_STEPPING_MICROSTEP8 = 1,
-    Y_STEPPING_MICROSTEP4 = 2,
-    Y_STEPPING_HALFSTEP = 3,
-    Y_STEPPING_FULLSTEP = 4,
-    Y_STEPPING_INVALID = -1,
-} Y_STEPPING_enum;
-#endif
-#define Y_DIAGS_INVALID                 (YAPI_INVALID_UINT)
-#define Y_STEPPOS_INVALID               (YAPI_INVALID_DOUBLE)
-#define Y_SPEED_INVALID                 (YAPI_INVALID_DOUBLE)
-#define Y_PULLINSPEED_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_MAXACCEL_INVALID              (YAPI_INVALID_DOUBLE)
-#define Y_MAXSPEED_INVALID              (YAPI_INVALID_DOUBLE)
-#define Y_OVERCURRENT_INVALID           (YAPI_INVALID_UINT)
-#define Y_TCURRSTOP_INVALID             (YAPI_INVALID_UINT)
-#define Y_TCURRRUN_INVALID              (YAPI_INVALID_UINT)
-#define Y_ALERTMODE_INVALID             (YAPI_INVALID_STRING)
-#define Y_AUXMODE_INVALID               (YAPI_INVALID_STRING)
-#define Y_AUXSIGNAL_INVALID             (YAPI_INVALID_INT)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YStepperMotor definitions)
-
-//--- (YStepperMotor declaration)
-/**
- * YStepperMotor Class: StepperMotor function interface
- *
- * The Yoctopuce application programming interface allows you to drive a stepper motor.
- */
-class YOCTO_CLASS_EXPORT YStepperMotor: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YStepperMotor declaration)
-protected:
-    //--- (YStepperMotor attributes)
-    // Attributes (function value cache)
-    Y_MOTORSTATE_enum _motorState;
-    int             _diags;
-    double          _stepPos;
-    double          _speed;
-    double          _pullinSpeed;
-    double          _maxAccel;
-    double          _maxSpeed;
-    Y_STEPPING_enum _stepping;
-    int             _overcurrent;
-    int             _tCurrStop;
-    int             _tCurrRun;
-    string          _alertMode;
-    string          _auxMode;
-    int             _auxSignal;
-    string          _command;
-    YStepperMotorValueCallback _valueCallbackStepperMotor;
-
-    friend YStepperMotor *yFindStepperMotor(const string& func);
-    friend YStepperMotor *yFirstStepperMotor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindStepperMotor factory function to instantiate
-    YStepperMotor(const string& func);
-    //--- (end of YStepperMotor attributes)
-
-public:
-    virtual ~YStepperMotor();
-    //--- (YStepperMotor accessors declaration)
-
-    static const Y_MOTORSTATE_enum MOTORSTATE_ABSENT = Y_MOTORSTATE_ABSENT;
-    static const Y_MOTORSTATE_enum MOTORSTATE_ALERT = Y_MOTORSTATE_ALERT;
-    static const Y_MOTORSTATE_enum MOTORSTATE_HI_Z = Y_MOTORSTATE_HI_Z;
-    static const Y_MOTORSTATE_enum MOTORSTATE_STOP = Y_MOTORSTATE_STOP;
-    static const Y_MOTORSTATE_enum MOTORSTATE_RUN = Y_MOTORSTATE_RUN;
-    static const Y_MOTORSTATE_enum MOTORSTATE_BATCH = Y_MOTORSTATE_BATCH;
-    static const Y_MOTORSTATE_enum MOTORSTATE_INVALID = Y_MOTORSTATE_INVALID;
-    static const int DIAGS_INVALID = YAPI_INVALID_UINT;
-    static const double STEPPOS_INVALID;
-    static const double SPEED_INVALID;
-    static const double PULLINSPEED_INVALID;
-    static const double MAXACCEL_INVALID;
-    static const double MAXSPEED_INVALID;
-    static const Y_STEPPING_enum STEPPING_MICROSTEP16 = Y_STEPPING_MICROSTEP16;
-    static const Y_STEPPING_enum STEPPING_MICROSTEP8 = Y_STEPPING_MICROSTEP8;
-    static const Y_STEPPING_enum STEPPING_MICROSTEP4 = Y_STEPPING_MICROSTEP4;
-    static const Y_STEPPING_enum STEPPING_HALFSTEP = Y_STEPPING_HALFSTEP;
-    static const Y_STEPPING_enum STEPPING_FULLSTEP = Y_STEPPING_FULLSTEP;
-    static const Y_STEPPING_enum STEPPING_INVALID = Y_STEPPING_INVALID;
-    static const int OVERCURRENT_INVALID = YAPI_INVALID_UINT;
-    static const int TCURRSTOP_INVALID = YAPI_INVALID_UINT;
-    static const int TCURRRUN_INVALID = YAPI_INVALID_UINT;
-    static const string ALERTMODE_INVALID;
-    static const string AUXMODE_INVALID;
-    static const int AUXSIGNAL_INVALID = YAPI_INVALID_INT;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Returns the motor working state.
-     *
-     * @return a value among Y_MOTORSTATE_ABSENT, Y_MOTORSTATE_ALERT, Y_MOTORSTATE_HI_Z,
-     * Y_MOTORSTATE_STOP, Y_MOTORSTATE_RUN and Y_MOTORSTATE_BATCH corresponding to the motor working state
-     *
-     * On failure, throws an exception or returns Y_MOTORSTATE_INVALID.
-     */
-    Y_MOTORSTATE_enum   get_motorState(void);
-
-    inline Y_MOTORSTATE_enum motorState(void)
-    { return this->get_motorState(); }
-
-    /**
-     * Returns the stepper motor controller diagnostics, as a bitmap.
-     *
-     * @return an integer corresponding to the stepper motor controller diagnostics, as a bitmap
-     *
-     * On failure, throws an exception or returns Y_DIAGS_INVALID.
-     */
-    int                 get_diags(void);
-
-    inline int          diags(void)
-    { return this->get_diags(); }
-
-    /**
-     * Changes the current logical motor position, measured in steps.
-     * This command does not cause any motor move, as its purpose is only to setup
-     * the origin of the position counter. The fractional part of the position,
-     * that corresponds to the physical position of the rotor, is not changed.
-     * To trigger a motor move, use methods moveTo() or moveRel()
-     * instead.
-     *
-     * @param newval : a floating point number corresponding to the current logical motor position, measured in steps
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_stepPos(double newval);
-    inline int      setStepPos(double newval)
-    { return this->set_stepPos(newval); }
-
-    /**
-     * Returns the current logical motor position, measured in steps.
-     * The value may include a fractional part when micro-stepping is in use.
-     *
-     * @return a floating point number corresponding to the current logical motor position, measured in steps
-     *
-     * On failure, throws an exception or returns Y_STEPPOS_INVALID.
-     */
-    double              get_stepPos(void);
-
-    inline double       stepPos(void)
-    { return this->get_stepPos(); }
-
-    /**
-     * Returns current motor speed, measured in steps per second.
-     * To change speed, use method changeSpeed().
-     *
-     * @return a floating point number corresponding to current motor speed, measured in steps per second
-     *
-     * On failure, throws an exception or returns Y_SPEED_INVALID.
-     */
-    double              get_speed(void);
-
-    inline double       speed(void)
-    { return this->get_speed(); }
-
-    /**
-     * Changes the motor speed immediately reachable from stop state, measured in steps per second.
-     *
-     * @param newval : a floating point number corresponding to the motor speed immediately reachable from
-     * stop state, measured in steps per second
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_pullinSpeed(double newval);
-    inline int      setPullinSpeed(double newval)
-    { return this->set_pullinSpeed(newval); }
-
-    /**
-     * Returns the motor speed immediately reachable from stop state, measured in steps per second.
-     *
-     * @return a floating point number corresponding to the motor speed immediately reachable from stop
-     * state, measured in steps per second
-     *
-     * On failure, throws an exception or returns Y_PULLINSPEED_INVALID.
-     */
-    double              get_pullinSpeed(void);
-
-    inline double       pullinSpeed(void)
-    { return this->get_pullinSpeed(); }
-
-    /**
-     * Changes the maximal motor acceleration, measured in steps per second^2.
-     *
-     * @param newval : a floating point number corresponding to the maximal motor acceleration, measured
-     * in steps per second^2
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxAccel(double newval);
-    inline int      setMaxAccel(double newval)
-    { return this->set_maxAccel(newval); }
-
-    /**
-     * Returns the maximal motor acceleration, measured in steps per second^2.
-     *
-     * @return a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2
-     *
-     * On failure, throws an exception or returns Y_MAXACCEL_INVALID.
-     */
-    double              get_maxAccel(void);
-
-    inline double       maxAccel(void)
-    { return this->get_maxAccel(); }
-
-    /**
-     * Changes the maximal motor speed, measured in steps per second.
-     *
-     * @param newval : a floating point number corresponding to the maximal motor speed, measured in steps per second
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxSpeed(double newval);
-    inline int      setMaxSpeed(double newval)
-    { return this->set_maxSpeed(newval); }
-
-    /**
-     * Returns the maximal motor speed, measured in steps per second.
-     *
-     * @return a floating point number corresponding to the maximal motor speed, measured in steps per second
-     *
-     * On failure, throws an exception or returns Y_MAXSPEED_INVALID.
-     */
-    double              get_maxSpeed(void);
-
-    inline double       maxSpeed(void)
-    { return this->get_maxSpeed(); }
-
-    /**
-     * Returns the stepping mode used to drive the motor.
-     *
-     * @return a value among Y_STEPPING_MICROSTEP16, Y_STEPPING_MICROSTEP8, Y_STEPPING_MICROSTEP4,
-     * Y_STEPPING_HALFSTEP and Y_STEPPING_FULLSTEP corresponding to the stepping mode used to drive the motor
-     *
-     * On failure, throws an exception or returns Y_STEPPING_INVALID.
-     */
-    Y_STEPPING_enum     get_stepping(void);
-
-    inline Y_STEPPING_enum stepping(void)
-    { return this->get_stepping(); }
-
-    /**
-     * Changes the stepping mode used to drive the motor.
-     *
-     * @param newval : a value among Y_STEPPING_MICROSTEP16, Y_STEPPING_MICROSTEP8, Y_STEPPING_MICROSTEP4,
-     * Y_STEPPING_HALFSTEP and Y_STEPPING_FULLSTEP corresponding to the stepping mode used to drive the motor
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_stepping(Y_STEPPING_enum newval);
-    inline int      setStepping(Y_STEPPING_enum newval)
-    { return this->set_stepping(newval); }
-
-    /**
-     * Returns the overcurrent alert and emergency stop threshold, measured in mA.
-     *
-     * @return an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA
-     *
-     * On failure, throws an exception or returns Y_OVERCURRENT_INVALID.
-     */
-    int                 get_overcurrent(void);
-
-    inline int          overcurrent(void)
-    { return this->get_overcurrent(); }
-
-    /**
-     * Changes the overcurrent alert and emergency stop threshold, measured in mA.
-     *
-     * @param newval : an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_overcurrent(int newval);
-    inline int      setOvercurrent(int newval)
-    { return this->set_overcurrent(newval); }
-
-    /**
-     * Returns the torque regulation current when the motor is stopped, measured in mA.
-     *
-     * @return an integer corresponding to the torque regulation current when the motor is stopped, measured in mA
-     *
-     * On failure, throws an exception or returns Y_TCURRSTOP_INVALID.
-     */
-    int                 get_tCurrStop(void);
-
-    inline int          tCurrStop(void)
-    { return this->get_tCurrStop(); }
-
-    /**
-     * Changes the torque regulation current when the motor is stopped, measured in mA.
-     *
-     * @param newval : an integer corresponding to the torque regulation current when the motor is
-     * stopped, measured in mA
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tCurrStop(int newval);
-    inline int      setTCurrStop(int newval)
-    { return this->set_tCurrStop(newval); }
-
-    /**
-     * Returns the torque regulation current when the motor is running, measured in mA.
-     *
-     * @return an integer corresponding to the torque regulation current when the motor is running, measured in mA
-     *
-     * On failure, throws an exception or returns Y_TCURRRUN_INVALID.
-     */
-    int                 get_tCurrRun(void);
-
-    inline int          tCurrRun(void)
-    { return this->get_tCurrRun(); }
-
-    /**
-     * Changes the torque regulation current when the motor is running, measured in mA.
-     *
-     * @param newval : an integer corresponding to the torque regulation current when the motor is
-     * running, measured in mA
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tCurrRun(int newval);
-    inline int      setTCurrRun(int newval)
-    { return this->set_tCurrRun(newval); }
-
-    string              get_alertMode(void);
-
-    inline string       alertMode(void)
-    { return this->get_alertMode(); }
-
-    int             set_alertMode(const string& newval);
-    inline int      setAlertMode(const string& newval)
-    { return this->set_alertMode(newval); }
-
-    string              get_auxMode(void);
-
-    inline string       auxMode(void)
-    { return this->get_auxMode(); }
-
-    int             set_auxMode(const string& newval);
-    inline int      setAuxMode(const string& newval)
-    { return this->set_auxMode(newval); }
-
-    /**
-     * Returns the current value of the signal generated on the auxiliary output.
-     *
-     * @return an integer corresponding to the current value of the signal generated on the auxiliary output
-     *
-     * On failure, throws an exception or returns Y_AUXSIGNAL_INVALID.
-     */
-    int                 get_auxSignal(void);
-
-    inline int          auxSignal(void)
-    { return this->get_auxSignal(); }
-
-    /**
-     * Changes the value of the signal generated on the auxiliary output.
-     * Acceptable values depend on the auxiliary output signal type configured.
-     *
-     * @param newval : an integer corresponding to the value of the signal generated on the auxiliary output
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_auxSignal(int newval);
-    inline int      setAuxSignal(int newval)
-    { return this->set_auxSignal(newval); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a stepper motor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the stepper motor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YStepperMotor.isOnline() to test if the stepper motor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a stepper motor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the stepper motor
-     *
-     * @return a YStepperMotor object allowing you to drive the stepper motor.
-     */
-    static YStepperMotor* FindStepperMotor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YStepperMotorValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    virtual int         sendCommand(string command);
-
-    /**
-     * Reinitialize the controller and clear all alert flags.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         reset(void);
-
-    /**
-     * Starts the motor backward at the specified speed, to search for the motor home position.
-     *
-     * @param speed : desired speed, in steps per second.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         findHomePosition(double speed);
-
-    /**
-     * Starts the motor at a given speed. The time needed to reach the requested speed
-     * will depend on the acceleration parameters configured for the motor.
-     *
-     * @param speed : desired speed, in steps per second. The minimal non-zero speed
-     *         is 0.001 pulse per second.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         changeSpeed(double speed);
-
-    /**
-     * Starts the motor to reach a given absolute position. The time needed to reach the requested
-     * position will depend on the acceleration and max speed parameters configured for
-     * the motor.
-     *
-     * @param absPos : absolute position, measured in steps from the origin.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveTo(double absPos);
-
-    /**
-     * Starts the motor to reach a given relative position. The time needed to reach the requested
-     * position will depend on the acceleration and max speed parameters configured for
-     * the motor.
-     *
-     * @param relPos : relative position, measured in steps from the current position.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveRel(double relPos);
-
-    /**
-     * Starts the motor to reach a given relative position, keeping the speed under the
-     * specified limit. The time needed to reach the requested position will depend on
-     * the acceleration parameters configured for the motor.
-     *
-     * @param relPos : relative position, measured in steps from the current position.
-     * @param maxSpeed : limit speed, in steps per second.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         moveRelSlow(double relPos,double maxSpeed);
-
-    /**
-     * Keep the motor in the same state for the specified amount of time, before processing next command.
-     *
-     * @param waitMs : wait time, specified in milliseconds.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         pause(int waitMs);
-
-    /**
-     * Stops the motor with an emergency alert, without taking any additional precaution.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         emergencyStop(void);
-
-    /**
-     * Move one step in the direction opposite the direction set when the most recent alert was raised.
-     * The move occurs even if the system is still in alert mode (end switch depressed). Caution.
-     * use this function with great care as it may cause mechanical damages !
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         alertStepOut(void);
-
-    /**
-     * Move one single step in the selected direction without regards to end switches.
-     * The move occurs even if the system is still in alert mode (end switch depressed). Caution.
-     * use this function with great care as it may cause mechanical damages !
-     *
-     * @param dir : Value +1 or -1, according to the desired direction of the move
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         alertStepDir(int dir);
-
-    /**
-     * Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         abortAndBrake(void);
-
-    /**
-     * Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         abortAndHiZ(void);
-
-
-    inline static YStepperMotor* Find(string func)
-    { return YStepperMotor::FindStepperMotor(func); }
-
-    /**
-     * Continues the enumeration of stepper motors started using yFirstStepperMotor().
-     * Caution: You can't make any assumption about the returned stepper motors order.
-     * If you want to find a specific a stepper motor, use StepperMotor.findStepperMotor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YStepperMotor object, corresponding to
-     *         a stepper motor currently online, or a NULL pointer
-     *         if there are no more stepper motors to enumerate.
-     */
-           YStepperMotor   *nextStepperMotor(void);
-    inline YStepperMotor   *next(void)
-    { return this->nextStepperMotor();}
-
-    /**
-     * Starts the enumeration of stepper motors currently accessible.
-     * Use the method YStepperMotor.nextStepperMotor() to iterate on
-     * next stepper motors.
-     *
-     * @return a pointer to a YStepperMotor object, corresponding to
-     *         the first stepper motor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YStepperMotor* FirstStepperMotor(void);
-    inline static YStepperMotor* First(void)
-    { return YStepperMotor::FirstStepperMotor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YStepperMotor accessors declaration)
-};
-
-//--- (YStepperMotor functions declaration)
-
-/**
- * Retrieves a stepper motor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the stepper motor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YStepperMotor.isOnline() to test if the stepper motor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a stepper motor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the stepper motor
- *
- * @return a YStepperMotor object allowing you to drive the stepper motor.
- */
-inline YStepperMotor* yFindStepperMotor(const string& func)
-{ return YStepperMotor::FindStepperMotor(func);}
-/**
- * Starts the enumeration of stepper motors currently accessible.
- * Use the method YStepperMotor.nextStepperMotor() to iterate on
- * next stepper motors.
- *
- * @return a pointer to a YStepperMotor object, corresponding to
- *         the first stepper motor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YStepperMotor* yFirstStepperMotor(void)
-{ return YStepperMotor::FirstStepperMotor();}
-
-//--- (end of YStepperMotor functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_temperature.cpp
+++ /dev/null
@@ -1,613 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_temperature.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindTemperature(), the high-level API for Temperature functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_temperature.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "temperature"
-
-YTemperature::YTemperature(const string& func): YSensor(func)
-//--- (YTemperature initialization)
-    ,_sensorType(SENSORTYPE_INVALID)
-    ,_signalValue(SIGNALVALUE_INVALID)
-    ,_signalUnit(SIGNALUNIT_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackTemperature(NULL)
-    ,_timedReportCallbackTemperature(NULL)
-//--- (end of YTemperature initialization)
-{
-    _className="Temperature";
-}
-
-YTemperature::~YTemperature()
-{
-//--- (YTemperature cleanup)
-//--- (end of YTemperature cleanup)
-}
-//--- (YTemperature implementation)
-// static attributes
-const double YTemperature::SIGNALVALUE_INVALID = YAPI_INVALID_DOUBLE;
-const string YTemperature::SIGNALUNIT_INVALID = YAPI_INVALID_STRING;
-const string YTemperature::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YTemperature::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("sensorType")) {
-        _sensorType =  (Y_SENSORTYPE_enum)json_val->getInt("sensorType");
-    }
-    if(json_val->has("signalValue")) {
-        _signalValue =  floor(json_val->getDouble("signalValue") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("signalUnit")) {
-        _signalUnit =  json_val->getString("signalUnit");
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the measured temperature. That unit is a string.
- * If that strings end with the letter F all temperatures values will returned in
- * Fahrenheit degrees. If that String ends with the letter K all values will be
- * returned in Kelvin degrees. If that string ends with the letter C all values will be
- * returned in Celsius degrees.  If the string ends with any other character the
- * change will be ignored. Remember to call the
- * saveToFlash() method of the module if the modification must be kept.
- * WARNING: if a specific calibration is defined for the temperature function, a
- * unit system change will probably break it.
- *
- * @param newval : a string corresponding to the measuring unit for the measured temperature
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTemperature::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the temperature sensor type.
- *
- * @return a value among Y_SENSORTYPE_DIGITAL, Y_SENSORTYPE_TYPE_K, Y_SENSORTYPE_TYPE_E,
- * Y_SENSORTYPE_TYPE_J, Y_SENSORTYPE_TYPE_N, Y_SENSORTYPE_TYPE_R, Y_SENSORTYPE_TYPE_S,
- * Y_SENSORTYPE_TYPE_T, Y_SENSORTYPE_PT100_4WIRES, Y_SENSORTYPE_PT100_3WIRES,
- * Y_SENSORTYPE_PT100_2WIRES, Y_SENSORTYPE_RES_OHM, Y_SENSORTYPE_RES_NTC, Y_SENSORTYPE_RES_LINEAR,
- * Y_SENSORTYPE_RES_INTERNAL and Y_SENSORTYPE_IR corresponding to the temperature sensor type
- *
- * On failure, throws an exception or returns Y_SENSORTYPE_INVALID.
- */
-Y_SENSORTYPE_enum YTemperature::get_sensorType(void)
-{
-    Y_SENSORTYPE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTemperature::SENSORTYPE_INVALID;
-                }
-            }
-        }
-        res = _sensorType;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the temperature sensor type.  This function is used
- * to define the type of thermocouple (K,E...) used with the device.
- * It has no effect if module is using a digital sensor or a thermistor.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a value among Y_SENSORTYPE_DIGITAL, Y_SENSORTYPE_TYPE_K, Y_SENSORTYPE_TYPE_E,
- * Y_SENSORTYPE_TYPE_J, Y_SENSORTYPE_TYPE_N, Y_SENSORTYPE_TYPE_R, Y_SENSORTYPE_TYPE_S,
- * Y_SENSORTYPE_TYPE_T, Y_SENSORTYPE_PT100_4WIRES, Y_SENSORTYPE_PT100_3WIRES,
- * Y_SENSORTYPE_PT100_2WIRES, Y_SENSORTYPE_RES_OHM, Y_SENSORTYPE_RES_NTC, Y_SENSORTYPE_RES_LINEAR,
- * Y_SENSORTYPE_RES_INTERNAL and Y_SENSORTYPE_IR corresponding to the temperature sensor type
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTemperature::set_sensorType(Y_SENSORTYPE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("sensorType", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current value of the electrical signal measured by the sensor.
- *
- * @return a floating point number corresponding to the current value of the electrical signal
- * measured by the sensor
- *
- * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
- */
-double YTemperature::get_signalValue(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTemperature::SIGNALVALUE_INVALID;
-                }
-            }
-        }
-        res = floor(_signalValue * 1000+0.5) / 1000;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the measuring unit of the electrical signal used by the sensor.
- *
- * @return a string corresponding to the measuring unit of the electrical signal used by the sensor
- *
- * On failure, throws an exception or returns Y_SIGNALUNIT_INVALID.
- */
-string YTemperature::get_signalUnit(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration == 0) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTemperature::SIGNALUNIT_INVALID;
-                }
-            }
-        }
-        res = _signalUnit;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YTemperature::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTemperature::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YTemperature::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a temperature sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the temperature sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTemperature.isOnline() to test if the temperature sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a temperature sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the temperature sensor
- *
- * @return a YTemperature object allowing you to drive the temperature sensor.
- */
-YTemperature* YTemperature::FindTemperature(string func)
-{
-    YTemperature* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YTemperature*) YFunction::_FindFromCache("Temperature", func);
-        if (obj == NULL) {
-            obj = new YTemperature(func);
-            YFunction::_AddToCache("Temperature", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YTemperature::registerValueCallback(YTemperatureValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackTemperature = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YTemperature::_invokeValueCallback(string value)
-{
-    if (_valueCallbackTemperature != NULL) {
-        _valueCallbackTemperature(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YTemperature::registerTimedReportCallback(YTemperatureTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackTemperature = callback;
-    return 0;
-}
-
-int YTemperature::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackTemperature != NULL) {
-        _timedReportCallbackTemperature(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Configures NTC thermistor parameters in order to properly compute the temperature from
- * the measured resistance. For increased precision, you can enter a complete mapping
- * table using set_thermistorResponseTable. This function can only be used with a
- * temperature sensor based on thermistors.
- *
- * @param res25 : thermistor resistance at 25 degrees Celsius
- * @param beta : Beta value
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTemperature::set_ntcParameters(double res25,double beta)
-{
-    double t0 = 0.0;
-    double t1 = 0.0;
-    double res100 = 0.0;
-    vector<double> tempValues;
-    vector<double> resValues;
-    t0 = 25.0+275.15;
-    t1 = 100.0+275.15;
-    res100 = res25 * exp(beta*(1.0/t1 - 1.0/t0));
-    tempValues.clear();
-    resValues.clear();
-    tempValues.push_back(25.0);
-    resValues.push_back(res25);
-    tempValues.push_back(100.0);
-    resValues.push_back(res100);
-    return this->set_thermistorResponseTable(tempValues, resValues);
-}
-
-/**
- * Records a thermistor response table, in order to interpolate the temperature from
- * the measured resistance. This function can only be used with a temperature
- * sensor based on thermistors.
- *
- * @param tempValues : array of floating point numbers, corresponding to all
- *         temperatures (in degrees Celsius) for which the resistance of the
- *         thermistor is specified.
- * @param resValues : array of floating point numbers, corresponding to the resistance
- *         values (in Ohms) for each of the temperature included in the first
- *         argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTemperature::set_thermistorResponseTable(vector<double> tempValues,vector<double> resValues)
-{
-    int siz = 0;
-    int res = 0;
-    int idx = 0;
-    int found = 0;
-    double prev = 0.0;
-    double curr = 0.0;
-    double currTemp = 0.0;
-    double idxres = 0.0;
-    siz = (int)tempValues.size();
-    if (!(siz >= 2)) {
-        _throw(YAPI_INVALID_ARGUMENT,"thermistor response table must have at least two points");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(siz == (int)resValues.size())) {
-        _throw(YAPI_INVALID_ARGUMENT,"table sizes mismatch");
-        return YAPI_INVALID_ARGUMENT;
-    }
-
-    res = this->set_command("Z");
-    if (!(res==YAPI_SUCCESS)) {
-        _throw(YAPI_IO_ERROR,"unable to reset thermistor parameters");
-        return YAPI_IO_ERROR;
-    }
-    // add records in growing resistance value
-    found = 1;
-    prev = 0.0;
-    while (found > 0) {
-        found = 0;
-        curr = 99999999.0;
-        currTemp = -999999.0;
-        idx = 0;
-        while (idx < siz) {
-            idxres = resValues[idx];
-            if ((idxres > prev) && (idxres < curr)) {
-                curr = idxres;
-                currTemp = tempValues[idx];
-                found = 1;
-            }
-            idx = idx + 1;
-        }
-        if (found > 0) {
-            res = this->set_command(YapiWrapper::ysprintf("m%d:%d", (int) floor(1000*curr+0.5),(int) floor(1000*currTemp+0.5)));
-            if (!(res==YAPI_SUCCESS)) {
-                _throw(YAPI_IO_ERROR,"unable to reset thermistor parameters");
-                return YAPI_IO_ERROR;
-            }
-            prev = curr;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Retrieves the thermistor response table previously configured using the
- * set_thermistorResponseTable function. This function can only be used with a
- * temperature sensor based on thermistors.
- *
- * @param tempValues : array of floating point numbers, that is filled by the function
- *         with all temperatures (in degrees Celsius) for which the resistance
- *         of the thermistor is specified.
- * @param resValues : array of floating point numbers, that is filled by the function
- *         with the value (in Ohms) for each of the temperature included in the
- *         first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTemperature::loadThermistorResponseTable(vector<double>& tempValues,vector<double>& resValues)
-{
-    string id;
-    string bin_json;
-    vector<string> paramlist;
-    vector<double> templist;
-    int siz = 0;
-    int idx = 0;
-    double temp = 0.0;
-    int found = 0;
-    double prev = 0.0;
-    double curr = 0.0;
-    double currRes = 0.0;
-    tempValues.clear();
-    resValues.clear();
-
-    id = this->get_functionId();
-    id = (id).substr( 11, (int)(id).length() - 11);
-    bin_json = this->_download(YapiWrapper::ysprintf("extra.json?page=%s",id.c_str()));
-    paramlist = this->_json_get_array(bin_json);
-    // first convert all temperatures to float
-    siz = (((int)paramlist.size()) >> (1));
-    templist.clear();
-    idx = 0;
-    while (idx < siz) {
-        temp = atof((paramlist[2*idx+1]).c_str())/1000.0;
-        templist.push_back(temp);
-        idx = idx + 1;
-    }
-    // then add records in growing temperature value
-    tempValues.clear();
-    resValues.clear();
-    found = 1;
-    prev = -999999.0;
-    while (found > 0) {
-        found = 0;
-        curr = 999999.0;
-        currRes = -999999.0;
-        idx = 0;
-        while (idx < siz) {
-            temp = templist[idx];
-            if ((temp > prev) && (temp < curr)) {
-                curr = temp;
-                currRes = atof((paramlist[2*idx]).c_str())/1000.0;
-                found = 1;
-            }
-            idx = idx + 1;
-        }
-        if (found > 0) {
-            tempValues.push_back(curr);
-            resValues.push_back(currRes);
-            prev = curr;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-YTemperature *YTemperature::nextTemperature(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YTemperature::FindTemperature(hwid);
-}
-
-YTemperature* YTemperature::FirstTemperature(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Temperature", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YTemperature::FindTemperature(serial+"."+funcId);
-}
-
-//--- (end of YTemperature implementation)
-
-//--- (YTemperature functions)
-//--- (end of YTemperature functions)
--- a/Sources/cpplib/yocto_temperature.h
+++ /dev/null
@@ -1,431 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_temperature.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindTemperature(), the high-level API for Temperature functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_TEMPERATURE_H
-#define YOCTO_TEMPERATURE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YTemperature return codes)
-//--- (end of YTemperature return codes)
-//--- (YTemperature yapiwrapper)
-//--- (end of YTemperature yapiwrapper)
-//--- (YTemperature definitions)
-class YTemperature; // forward declaration
-
-typedef void (*YTemperatureValueCallback)(YTemperature *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YTemperatureTimedReportCallback)(YTemperature *func, YMeasure measure);
-#ifndef _Y_SENSORTYPE_ENUM
-#define _Y_SENSORTYPE_ENUM
-typedef enum {
-    Y_SENSORTYPE_DIGITAL = 0,
-    Y_SENSORTYPE_TYPE_K = 1,
-    Y_SENSORTYPE_TYPE_E = 2,
-    Y_SENSORTYPE_TYPE_J = 3,
-    Y_SENSORTYPE_TYPE_N = 4,
-    Y_SENSORTYPE_TYPE_R = 5,
-    Y_SENSORTYPE_TYPE_S = 6,
-    Y_SENSORTYPE_TYPE_T = 7,
-    Y_SENSORTYPE_PT100_4WIRES = 8,
-    Y_SENSORTYPE_PT100_3WIRES = 9,
-    Y_SENSORTYPE_PT100_2WIRES = 10,
-    Y_SENSORTYPE_RES_OHM = 11,
-    Y_SENSORTYPE_RES_NTC = 12,
-    Y_SENSORTYPE_RES_LINEAR = 13,
-    Y_SENSORTYPE_RES_INTERNAL = 14,
-    Y_SENSORTYPE_IR = 15,
-    Y_SENSORTYPE_INVALID = -1,
-} Y_SENSORTYPE_enum;
-#endif
-#define Y_SIGNALVALUE_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_SIGNALUNIT_INVALID            (YAPI_INVALID_STRING)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YTemperature definitions)
-
-//--- (YTemperature declaration)
-/**
- * YTemperature Class: Temperature function interface
- *
- * The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature
- * sensors. It inherits from YSensor class the core functions to read measurements, to
- * register callback functions, to access the autonomous datalogger.
- * This class adds the ability to configure some specific parameters for some
- * sensors (connection type, temperature mapping table).
- */
-class YOCTO_CLASS_EXPORT YTemperature: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YTemperature declaration)
-protected:
-    //--- (YTemperature attributes)
-    // Attributes (function value cache)
-    Y_SENSORTYPE_enum _sensorType;
-    double          _signalValue;
-    string          _signalUnit;
-    string          _command;
-    YTemperatureValueCallback _valueCallbackTemperature;
-    YTemperatureTimedReportCallback _timedReportCallbackTemperature;
-
-    friend YTemperature *yFindTemperature(const string& func);
-    friend YTemperature *yFirstTemperature(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindTemperature factory function to instantiate
-    YTemperature(const string& func);
-    //--- (end of YTemperature attributes)
-
-public:
-    virtual ~YTemperature();
-    //--- (YTemperature accessors declaration)
-
-    static const Y_SENSORTYPE_enum SENSORTYPE_DIGITAL = Y_SENSORTYPE_DIGITAL;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_K = Y_SENSORTYPE_TYPE_K;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_E = Y_SENSORTYPE_TYPE_E;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_J = Y_SENSORTYPE_TYPE_J;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_N = Y_SENSORTYPE_TYPE_N;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_R = Y_SENSORTYPE_TYPE_R;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_S = Y_SENSORTYPE_TYPE_S;
-    static const Y_SENSORTYPE_enum SENSORTYPE_TYPE_T = Y_SENSORTYPE_TYPE_T;
-    static const Y_SENSORTYPE_enum SENSORTYPE_PT100_4WIRES = Y_SENSORTYPE_PT100_4WIRES;
-    static const Y_SENSORTYPE_enum SENSORTYPE_PT100_3WIRES = Y_SENSORTYPE_PT100_3WIRES;
-    static const Y_SENSORTYPE_enum SENSORTYPE_PT100_2WIRES = Y_SENSORTYPE_PT100_2WIRES;
-    static const Y_SENSORTYPE_enum SENSORTYPE_RES_OHM = Y_SENSORTYPE_RES_OHM;
-    static const Y_SENSORTYPE_enum SENSORTYPE_RES_NTC = Y_SENSORTYPE_RES_NTC;
-    static const Y_SENSORTYPE_enum SENSORTYPE_RES_LINEAR = Y_SENSORTYPE_RES_LINEAR;
-    static const Y_SENSORTYPE_enum SENSORTYPE_RES_INTERNAL = Y_SENSORTYPE_RES_INTERNAL;
-    static const Y_SENSORTYPE_enum SENSORTYPE_IR = Y_SENSORTYPE_IR;
-    static const Y_SENSORTYPE_enum SENSORTYPE_INVALID = Y_SENSORTYPE_INVALID;
-    static const double SIGNALVALUE_INVALID;
-    static const string SIGNALUNIT_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the measuring unit for the measured temperature. That unit is a string.
-     * If that strings end with the letter F all temperatures values will returned in
-     * Fahrenheit degrees. If that String ends with the letter K all values will be
-     * returned in Kelvin degrees. If that string ends with the letter C all values will be
-     * returned in Celsius degrees.  If the string ends with any other character the
-     * change will be ignored. Remember to call the
-     * saveToFlash() method of the module if the modification must be kept.
-     * WARNING: if a specific calibration is defined for the temperature function, a
-     * unit system change will probably break it.
-     *
-     * @param newval : a string corresponding to the measuring unit for the measured temperature
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the temperature sensor type.
-     *
-     * @return a value among Y_SENSORTYPE_DIGITAL, Y_SENSORTYPE_TYPE_K, Y_SENSORTYPE_TYPE_E,
-     * Y_SENSORTYPE_TYPE_J, Y_SENSORTYPE_TYPE_N, Y_SENSORTYPE_TYPE_R, Y_SENSORTYPE_TYPE_S,
-     * Y_SENSORTYPE_TYPE_T, Y_SENSORTYPE_PT100_4WIRES, Y_SENSORTYPE_PT100_3WIRES,
-     * Y_SENSORTYPE_PT100_2WIRES, Y_SENSORTYPE_RES_OHM, Y_SENSORTYPE_RES_NTC, Y_SENSORTYPE_RES_LINEAR,
-     * Y_SENSORTYPE_RES_INTERNAL and Y_SENSORTYPE_IR corresponding to the temperature sensor type
-     *
-     * On failure, throws an exception or returns Y_SENSORTYPE_INVALID.
-     */
-    Y_SENSORTYPE_enum   get_sensorType(void);
-
-    inline Y_SENSORTYPE_enum sensorType(void)
-    { return this->get_sensorType(); }
-
-    /**
-     * Changes the temperature sensor type.  This function is used
-     * to define the type of thermocouple (K,E...) used with the device.
-     * It has no effect if module is using a digital sensor or a thermistor.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a value among Y_SENSORTYPE_DIGITAL, Y_SENSORTYPE_TYPE_K, Y_SENSORTYPE_TYPE_E,
-     * Y_SENSORTYPE_TYPE_J, Y_SENSORTYPE_TYPE_N, Y_SENSORTYPE_TYPE_R, Y_SENSORTYPE_TYPE_S,
-     * Y_SENSORTYPE_TYPE_T, Y_SENSORTYPE_PT100_4WIRES, Y_SENSORTYPE_PT100_3WIRES,
-     * Y_SENSORTYPE_PT100_2WIRES, Y_SENSORTYPE_RES_OHM, Y_SENSORTYPE_RES_NTC, Y_SENSORTYPE_RES_LINEAR,
-     * Y_SENSORTYPE_RES_INTERNAL and Y_SENSORTYPE_IR corresponding to the temperature sensor type
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_sensorType(Y_SENSORTYPE_enum newval);
-    inline int      setSensorType(Y_SENSORTYPE_enum newval)
-    { return this->set_sensorType(newval); }
-
-    /**
-     * Returns the current value of the electrical signal measured by the sensor.
-     *
-     * @return a floating point number corresponding to the current value of the electrical signal
-     * measured by the sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALVALUE_INVALID.
-     */
-    double              get_signalValue(void);
-
-    inline double       signalValue(void)
-    { return this->get_signalValue(); }
-
-    /**
-     * Returns the measuring unit of the electrical signal used by the sensor.
-     *
-     * @return a string corresponding to the measuring unit of the electrical signal used by the sensor
-     *
-     * On failure, throws an exception or returns Y_SIGNALUNIT_INVALID.
-     */
-    string              get_signalUnit(void);
-
-    inline string       signalUnit(void)
-    { return this->get_signalUnit(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a temperature sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the temperature sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YTemperature.isOnline() to test if the temperature sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a temperature sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the temperature sensor
-     *
-     * @return a YTemperature object allowing you to drive the temperature sensor.
-     */
-    static YTemperature* FindTemperature(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YTemperatureValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YTemperatureTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Configures NTC thermistor parameters in order to properly compute the temperature from
-     * the measured resistance. For increased precision, you can enter a complete mapping
-     * table using set_thermistorResponseTable. This function can only be used with a
-     * temperature sensor based on thermistors.
-     *
-     * @param res25 : thermistor resistance at 25 degrees Celsius
-     * @param beta : Beta value
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_ntcParameters(double res25,double beta);
-
-    /**
-     * Records a thermistor response table, in order to interpolate the temperature from
-     * the measured resistance. This function can only be used with a temperature
-     * sensor based on thermistors.
-     *
-     * @param tempValues : array of floating point numbers, corresponding to all
-     *         temperatures (in degrees Celsius) for which the resistance of the
-     *         thermistor is specified.
-     * @param resValues : array of floating point numbers, corresponding to the resistance
-     *         values (in Ohms) for each of the temperature included in the first
-     *         argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_thermistorResponseTable(vector<double> tempValues,vector<double> resValues);
-
-    /**
-     * Retrieves the thermistor response table previously configured using the
-     * set_thermistorResponseTable function. This function can only be used with a
-     * temperature sensor based on thermistors.
-     *
-     * @param tempValues : array of floating point numbers, that is filled by the function
-     *         with all temperatures (in degrees Celsius) for which the resistance
-     *         of the thermistor is specified.
-     * @param resValues : array of floating point numbers, that is filled by the function
-     *         with the value (in Ohms) for each of the temperature included in the
-     *         first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadThermistorResponseTable(vector<double>& tempValues,vector<double>& resValues);
-
-
-    inline static YTemperature* Find(string func)
-    { return YTemperature::FindTemperature(func); }
-
-    /**
-     * Continues the enumeration of temperature sensors started using yFirstTemperature().
-     * Caution: You can't make any assumption about the returned temperature sensors order.
-     * If you want to find a specific a temperature sensor, use Temperature.findTemperature()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YTemperature object, corresponding to
-     *         a temperature sensor currently online, or a NULL pointer
-     *         if there are no more temperature sensors to enumerate.
-     */
-           YTemperature    *nextTemperature(void);
-    inline YTemperature    *next(void)
-    { return this->nextTemperature();}
-
-    /**
-     * Starts the enumeration of temperature sensors currently accessible.
-     * Use the method YTemperature.nextTemperature() to iterate on
-     * next temperature sensors.
-     *
-     * @return a pointer to a YTemperature object, corresponding to
-     *         the first temperature sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YTemperature* FirstTemperature(void);
-    inline static YTemperature* First(void)
-    { return YTemperature::FirstTemperature();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YTemperature accessors declaration)
-};
-
-//--- (YTemperature functions declaration)
-
-/**
- * Retrieves a temperature sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the temperature sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTemperature.isOnline() to test if the temperature sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a temperature sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the temperature sensor
- *
- * @return a YTemperature object allowing you to drive the temperature sensor.
- */
-inline YTemperature* yFindTemperature(const string& func)
-{ return YTemperature::FindTemperature(func);}
-/**
- * Starts the enumeration of temperature sensors currently accessible.
- * Use the method YTemperature.nextTemperature() to iterate on
- * next temperature sensors.
- *
- * @return a pointer to a YTemperature object, corresponding to
- *         the first temperature sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YTemperature* yFirstTemperature(void)
-{ return YTemperature::FirstTemperature();}
-
-//--- (end of YTemperature functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_tilt.cpp
+++ /dev/null
@@ -1,308 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_tilt.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindTilt(), the high-level API for Tilt functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_tilt.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "tilt"
-
-YTilt::YTilt(const string& func): YSensor(func)
-//--- (YTilt initialization)
-    ,_bandwidth(BANDWIDTH_INVALID)
-    ,_axis(AXIS_INVALID)
-    ,_valueCallbackTilt(NULL)
-    ,_timedReportCallbackTilt(NULL)
-//--- (end of YTilt initialization)
-{
-    _className="Tilt";
-}
-
-YTilt::~YTilt()
-{
-//--- (YTilt cleanup)
-//--- (end of YTilt cleanup)
-}
-//--- (YTilt implementation)
-// static attributes
-
-int YTilt::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("bandwidth")) {
-        _bandwidth =  json_val->getInt("bandwidth");
-    }
-    if(json_val->has("axis")) {
-        _axis =  (Y_AXIS_enum) json_val->getInt("axis");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
- *
- * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
- */
-int YTilt::get_bandwidth(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTilt::BANDWIDTH_INVALID;
-                }
-            }
-        }
-        res = _bandwidth;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
- * frequency is lower, the device performs averaging.
- *
- * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YTilt::set_bandwidth(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("bandwidth", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-Y_AXIS_enum YTilt::get_axis(void)
-{
-    Y_AXIS_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YTilt::AXIS_INVALID;
-                }
-            }
-        }
-        res = _axis;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a tilt sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the tilt sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTilt.isOnline() to test if the tilt sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a tilt sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the tilt sensor
- *
- * @return a YTilt object allowing you to drive the tilt sensor.
- */
-YTilt* YTilt::FindTilt(string func)
-{
-    YTilt* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YTilt*) YFunction::_FindFromCache("Tilt", func);
-        if (obj == NULL) {
-            obj = new YTilt(func);
-            YFunction::_AddToCache("Tilt", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YTilt::registerValueCallback(YTiltValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackTilt = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YTilt::_invokeValueCallback(string value)
-{
-    if (_valueCallbackTilt != NULL) {
-        _valueCallbackTilt(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YTilt::registerTimedReportCallback(YTiltTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackTilt = callback;
-    return 0;
-}
-
-int YTilt::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackTilt != NULL) {
-        _timedReportCallbackTilt(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YTilt *YTilt::nextTilt(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YTilt::FindTilt(hwid);
-}
-
-YTilt* YTilt::FirstTilt(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Tilt", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YTilt::FindTilt(serial+"."+funcId);
-}
-
-//--- (end of YTilt implementation)
-
-//--- (YTilt functions)
-//--- (end of YTilt functions)
--- a/Sources/cpplib/yocto_tilt.h
+++ /dev/null
@@ -1,291 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_tilt.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindTilt(), the high-level API for Tilt functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_TILT_H
-#define YOCTO_TILT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YTilt return codes)
-//--- (end of YTilt return codes)
-//--- (YTilt yapiwrapper)
-//--- (end of YTilt yapiwrapper)
-//--- (YTilt definitions)
-class YTilt; // forward declaration
-
-typedef void (*YTiltValueCallback)(YTilt *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YTiltTimedReportCallback)(YTilt *func, YMeasure measure);
-#ifndef _Y_AXIS_ENUM
-#define _Y_AXIS_ENUM
-typedef enum {
-    Y_AXIS_X = 0,
-    Y_AXIS_Y = 1,
-    Y_AXIS_Z = 2,
-    Y_AXIS_INVALID = -1,
-} Y_AXIS_enum;
-#endif
-#define Y_BANDWIDTH_INVALID             (YAPI_INVALID_INT)
-//--- (end of YTilt definitions)
-
-//--- (YTilt declaration)
-/**
- * YTilt Class: Tilt function interface
- *
- * The YSensor class is the parent class for all Yoctopuce sensors. It can be
- * used to read the current value and unit of any sensor, read the min/max
- * value, configure autonomous recording frequency and access recorded data.
- * It also provide a function to register a callback invoked each time the
- * observed value changes, or at a predefined interval. Using this class rather
- * than a specific subclass makes it possible to create generic applications
- * that work with any Yoctopuce sensor, even those that do not yet exist.
- * Note: The YAnButton class is the only analog input which does not inherit
- * from YSensor.
- */
-class YOCTO_CLASS_EXPORT YTilt: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YTilt declaration)
-protected:
-    //--- (YTilt attributes)
-    // Attributes (function value cache)
-    int             _bandwidth;
-    Y_AXIS_enum     _axis;
-    YTiltValueCallback _valueCallbackTilt;
-    YTiltTimedReportCallback _timedReportCallbackTilt;
-
-    friend YTilt *yFindTilt(const string& func);
-    friend YTilt *yFirstTilt(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindTilt factory function to instantiate
-    YTilt(const string& func);
-    //--- (end of YTilt attributes)
-
-public:
-    virtual ~YTilt();
-    //--- (YTilt accessors declaration)
-
-    static const int BANDWIDTH_INVALID = YAPI_INVALID_INT;
-    static const Y_AXIS_enum AXIS_X = Y_AXIS_X;
-    static const Y_AXIS_enum AXIS_Y = Y_AXIS_Y;
-    static const Y_AXIS_enum AXIS_Z = Y_AXIS_Z;
-    static const Y_AXIS_enum AXIS_INVALID = Y_AXIS_INVALID;
-
-    /**
-     * Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).
-     *
-     * @return an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * On failure, throws an exception or returns Y_BANDWIDTH_INVALID.
-     */
-    int                 get_bandwidth(void);
-
-    inline int          bandwidth(void)
-    { return this->get_bandwidth(); }
-
-    /**
-     * Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the
-     * frequency is lower, the device performs averaging.
-     *
-     * @param newval : an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_bandwidth(int newval);
-    inline int      setBandwidth(int newval)
-    { return this->set_bandwidth(newval); }
-
-    Y_AXIS_enum         get_axis(void);
-
-    inline Y_AXIS_enum  axis(void)
-    { return this->get_axis(); }
-
-    /**
-     * Retrieves a tilt sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the tilt sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YTilt.isOnline() to test if the tilt sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a tilt sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the tilt sensor
-     *
-     * @return a YTilt object allowing you to drive the tilt sensor.
-     */
-    static YTilt*       FindTilt(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YTiltValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YTiltTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YTilt* Find(string func)
-    { return YTilt::FindTilt(func); }
-
-    /**
-     * Continues the enumeration of tilt sensors started using yFirstTilt().
-     * Caution: You can't make any assumption about the returned tilt sensors order.
-     * If you want to find a specific a tilt sensor, use Tilt.findTilt()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YTilt object, corresponding to
-     *         a tilt sensor currently online, or a NULL pointer
-     *         if there are no more tilt sensors to enumerate.
-     */
-           YTilt           *nextTilt(void);
-    inline YTilt           *next(void)
-    { return this->nextTilt();}
-
-    /**
-     * Starts the enumeration of tilt sensors currently accessible.
-     * Use the method YTilt.nextTilt() to iterate on
-     * next tilt sensors.
-     *
-     * @return a pointer to a YTilt object, corresponding to
-     *         the first tilt sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YTilt* FirstTilt(void);
-    inline static YTilt* First(void)
-    { return YTilt::FirstTilt();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YTilt accessors declaration)
-};
-
-//--- (YTilt functions declaration)
-
-/**
- * Retrieves a tilt sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the tilt sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTilt.isOnline() to test if the tilt sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a tilt sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the tilt sensor
- *
- * @return a YTilt object allowing you to drive the tilt sensor.
- */
-inline YTilt* yFindTilt(const string& func)
-{ return YTilt::FindTilt(func);}
-/**
- * Starts the enumeration of tilt sensors currently accessible.
- * Use the method YTilt.nextTilt() to iterate on
- * next tilt sensors.
- *
- * @return a pointer to a YTilt object, corresponding to
- *         the first tilt sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YTilt* yFirstTilt(void)
-{ return YTilt::FirstTilt();}
-
-//--- (end of YTilt functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_tvoc.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_tvoc.cpp 33270 2018-11-22 08:41:15Z seb $
- *
- *  Implements yFindTvoc(), the high-level API for Tvoc functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_tvoc.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "tvoc"
-
-YTvoc::YTvoc(const string& func): YSensor(func)
-//--- (YTvoc initialization)
-    ,_valueCallbackTvoc(NULL)
-    ,_timedReportCallbackTvoc(NULL)
-//--- (end of YTvoc initialization)
-{
-    _className="Tvoc";
-}
-
-YTvoc::~YTvoc()
-{
-//--- (YTvoc cleanup)
-//--- (end of YTvoc cleanup)
-}
-//--- (YTvoc implementation)
-// static attributes
-
-
-/**
- * Retrieves a Total  Volatile Organic Compound sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Total  Volatile Organic Compound sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTvoc.isOnline() to test if the Total  Volatile Organic Compound sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Total  Volatile Organic Compound sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Total  Volatile Organic Compound sensor
- *
- * @return a YTvoc object allowing you to drive the Total  Volatile Organic Compound sensor.
- */
-YTvoc* YTvoc::FindTvoc(string func)
-{
-    YTvoc* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YTvoc*) YFunction::_FindFromCache("Tvoc", func);
-        if (obj == NULL) {
-            obj = new YTvoc(func);
-            YFunction::_AddToCache("Tvoc", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YTvoc::registerValueCallback(YTvocValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackTvoc = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YTvoc::_invokeValueCallback(string value)
-{
-    if (_valueCallbackTvoc != NULL) {
-        _valueCallbackTvoc(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YTvoc::registerTimedReportCallback(YTvocTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackTvoc = callback;
-    return 0;
-}
-
-int YTvoc::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackTvoc != NULL) {
-        _timedReportCallbackTvoc(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YTvoc *YTvoc::nextTvoc(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YTvoc::FindTvoc(hwid);
-}
-
-YTvoc* YTvoc::FirstTvoc(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Tvoc", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YTvoc::FindTvoc(serial+"."+funcId);
-}
-
-//--- (end of YTvoc implementation)
-
-//--- (YTvoc functions)
-//--- (end of YTvoc functions)
--- a/Sources/cpplib/yocto_tvoc.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_tvoc.h 33270 2018-11-22 08:41:15Z seb $
- *
- *  Declares yFindTvoc(), the high-level API for Tvoc functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_TVOC_H
-#define YOCTO_TVOC_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YTvoc return codes)
-//--- (end of YTvoc return codes)
-//--- (YTvoc yapiwrapper)
-//--- (end of YTvoc yapiwrapper)
-//--- (YTvoc definitions)
-class YTvoc; // forward declaration
-
-typedef void (*YTvocValueCallback)(YTvoc *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YTvocTimedReportCallback)(YTvoc *func, YMeasure measure);
-//--- (end of YTvoc definitions)
-
-//--- (YTvoc declaration)
-/**
- * YTvoc Class: Tvoc function interface
- *
- * The Yoctopuce class YTvoc allows you to read and configure Yoctopuce Total Volatile Organic
- * Compound sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YTvoc: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YTvoc declaration)
-protected:
-    //--- (YTvoc attributes)
-    // Attributes (function value cache)
-    YTvocValueCallback _valueCallbackTvoc;
-    YTvocTimedReportCallback _timedReportCallbackTvoc;
-
-    friend YTvoc *yFindTvoc(const string& func);
-    friend YTvoc *yFirstTvoc(void);
-
-    // Constructor is protected, use yFindTvoc factory function to instantiate
-    YTvoc(const string& func);
-    //--- (end of YTvoc attributes)
-
-public:
-    virtual ~YTvoc();
-    //--- (YTvoc accessors declaration)
-
-
-    /**
-     * Retrieves a Total  Volatile Organic Compound sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the Total  Volatile Organic Compound sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YTvoc.isOnline() to test if the Total  Volatile Organic Compound sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a Total  Volatile Organic Compound sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the Total  Volatile Organic Compound sensor
-     *
-     * @return a YTvoc object allowing you to drive the Total  Volatile Organic Compound sensor.
-     */
-    static YTvoc*       FindTvoc(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YTvocValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YTvocTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YTvoc* Find(string func)
-    { return YTvoc::FindTvoc(func); }
-
-    /**
-     * Continues the enumeration of Total Volatile Organic Compound sensors started using yFirstTvoc().
-     * Caution: You can't make any assumption about the returned Total Volatile Organic Compound sensors order.
-     * If you want to find a specific a Total  Volatile Organic Compound sensor, use Tvoc.findTvoc()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YTvoc object, corresponding to
-     *         a Total  Volatile Organic Compound sensor currently online, or a NULL pointer
-     *         if there are no more Total Volatile Organic Compound sensors to enumerate.
-     */
-           YTvoc           *nextTvoc(void);
-    inline YTvoc           *next(void)
-    { return this->nextTvoc();}
-
-    /**
-     * Starts the enumeration of Total Volatile Organic Compound sensors currently accessible.
-     * Use the method YTvoc.nextTvoc() to iterate on
-     * next Total Volatile Organic Compound sensors.
-     *
-     * @return a pointer to a YTvoc object, corresponding to
-     *         the first Total Volatile Organic Compound sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YTvoc* FirstTvoc(void);
-    inline static YTvoc* First(void)
-    { return YTvoc::FirstTvoc();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YTvoc accessors declaration)
-};
-
-//--- (YTvoc functions declaration)
-
-/**
- * Retrieves a Total  Volatile Organic Compound sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Total  Volatile Organic Compound sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YTvoc.isOnline() to test if the Total  Volatile Organic Compound sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Total  Volatile Organic Compound sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Total  Volatile Organic Compound sensor
- *
- * @return a YTvoc object allowing you to drive the Total  Volatile Organic Compound sensor.
- */
-inline YTvoc* yFindTvoc(const string& func)
-{ return YTvoc::FindTvoc(func);}
-/**
- * Starts the enumeration of Total Volatile Organic Compound sensors currently accessible.
- * Use the method YTvoc.nextTvoc() to iterate on
- * next Total Volatile Organic Compound sensors.
- *
- * @return a pointer to a YTvoc object, corresponding to
- *         the first Total Volatile Organic Compound sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YTvoc* yFirstTvoc(void)
-{ return YTvoc::FirstTvoc();}
-
-//--- (end of YTvoc functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_voc.cpp
+++ /dev/null
@@ -1,218 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voc.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindVoc(), the high-level API for Voc functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_voc.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "voc"
-
-YVoc::YVoc(const string& func): YSensor(func)
-//--- (YVoc initialization)
-    ,_valueCallbackVoc(NULL)
-    ,_timedReportCallbackVoc(NULL)
-//--- (end of YVoc initialization)
-{
-    _className="Voc";
-}
-
-YVoc::~YVoc()
-{
-//--- (YVoc cleanup)
-//--- (end of YVoc cleanup)
-}
-//--- (YVoc implementation)
-// static attributes
-
-
-/**
- * Retrieves a Volatile Organic Compound sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Volatile Organic Compound sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoc.isOnline() to test if the Volatile Organic Compound sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Volatile Organic Compound sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Volatile Organic Compound sensor
- *
- * @return a YVoc object allowing you to drive the Volatile Organic Compound sensor.
- */
-YVoc* YVoc::FindVoc(string func)
-{
-    YVoc* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YVoc*) YFunction::_FindFromCache("Voc", func);
-        if (obj == NULL) {
-            obj = new YVoc(func);
-            YFunction::_AddToCache("Voc", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YVoc::registerValueCallback(YVocValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackVoc = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YVoc::_invokeValueCallback(string value)
-{
-    if (_valueCallbackVoc != NULL) {
-        _valueCallbackVoc(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YVoc::registerTimedReportCallback(YVocTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackVoc = callback;
-    return 0;
-}
-
-int YVoc::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackVoc != NULL) {
-        _timedReportCallbackVoc(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YVoc *YVoc::nextVoc(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YVoc::FindVoc(hwid);
-}
-
-YVoc* YVoc::FirstVoc(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Voc", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YVoc::FindVoc(serial+"."+funcId);
-}
-
-//--- (end of YVoc implementation)
-
-//--- (YVoc functions)
-//--- (end of YVoc functions)
--- a/Sources/cpplib/yocto_voc.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voc.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindVoc(), the high-level API for Voc functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_VOC_H
-#define YOCTO_VOC_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YVoc return codes)
-//--- (end of YVoc return codes)
-//--- (YVoc yapiwrapper)
-//--- (end of YVoc yapiwrapper)
-//--- (YVoc definitions)
-class YVoc; // forward declaration
-
-typedef void (*YVocValueCallback)(YVoc *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YVocTimedReportCallback)(YVoc *func, YMeasure measure);
-//--- (end of YVoc definitions)
-
-//--- (YVoc declaration)
-/**
- * YVoc Class: Voc function interface
- *
- * The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic
- * Compound sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YVoc: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YVoc declaration)
-protected:
-    //--- (YVoc attributes)
-    // Attributes (function value cache)
-    YVocValueCallback _valueCallbackVoc;
-    YVocTimedReportCallback _timedReportCallbackVoc;
-
-    friend YVoc *yFindVoc(const string& func);
-    friend YVoc *yFirstVoc(void);
-
-    // Constructor is protected, use yFindVoc factory function to instantiate
-    YVoc(const string& func);
-    //--- (end of YVoc attributes)
-
-public:
-    virtual ~YVoc();
-    //--- (YVoc accessors declaration)
-
-
-    /**
-     * Retrieves a Volatile Organic Compound sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the Volatile Organic Compound sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YVoc.isOnline() to test if the Volatile Organic Compound sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a Volatile Organic Compound sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the Volatile Organic Compound sensor
-     *
-     * @return a YVoc object allowing you to drive the Volatile Organic Compound sensor.
-     */
-    static YVoc*        FindVoc(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YVocValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YVocTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YVoc* Find(string func)
-    { return YVoc::FindVoc(func); }
-
-    /**
-     * Continues the enumeration of Volatile Organic Compound sensors started using yFirstVoc().
-     * Caution: You can't make any assumption about the returned Volatile Organic Compound sensors order.
-     * If you want to find a specific a Volatile Organic Compound sensor, use Voc.findVoc()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YVoc object, corresponding to
-     *         a Volatile Organic Compound sensor currently online, or a NULL pointer
-     *         if there are no more Volatile Organic Compound sensors to enumerate.
-     */
-           YVoc            *nextVoc(void);
-    inline YVoc            *next(void)
-    { return this->nextVoc();}
-
-    /**
-     * Starts the enumeration of Volatile Organic Compound sensors currently accessible.
-     * Use the method YVoc.nextVoc() to iterate on
-     * next Volatile Organic Compound sensors.
-     *
-     * @return a pointer to a YVoc object, corresponding to
-     *         the first Volatile Organic Compound sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YVoc* FirstVoc(void);
-    inline static YVoc* First(void)
-    { return YVoc::FirstVoc();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YVoc accessors declaration)
-};
-
-//--- (YVoc functions declaration)
-
-/**
- * Retrieves a Volatile Organic Compound sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the Volatile Organic Compound sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoc.isOnline() to test if the Volatile Organic Compound sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a Volatile Organic Compound sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the Volatile Organic Compound sensor
- *
- * @return a YVoc object allowing you to drive the Volatile Organic Compound sensor.
- */
-inline YVoc* yFindVoc(const string& func)
-{ return YVoc::FindVoc(func);}
-/**
- * Starts the enumeration of Volatile Organic Compound sensors currently accessible.
- * Use the method YVoc.nextVoc() to iterate on
- * next Volatile Organic Compound sensors.
- *
- * @return a pointer to a YVoc object, corresponding to
- *         the first Volatile Organic Compound sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YVoc* yFirstVoc(void)
-{ return YVoc::FirstVoc();}
-
-//--- (end of YVoc functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_voltage.cpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voltage.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindVoltage(), the high-level API for Voltage functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_voltage.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "voltage"
-
-YVoltage::YVoltage(const string& func): YSensor(func)
-//--- (YVoltage initialization)
-    ,_enabled(ENABLED_INVALID)
-    ,_valueCallbackVoltage(NULL)
-    ,_timedReportCallbackVoltage(NULL)
-//--- (end of YVoltage initialization)
-{
-    _className="Voltage";
-}
-
-YVoltage::~YVoltage()
-{
-//--- (YVoltage cleanup)
-//--- (end of YVoltage cleanup)
-}
-//--- (YVoltage implementation)
-// static attributes
-
-int YVoltage::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("enabled")) {
-        _enabled =  (Y_ENABLED_enum)json_val->getInt("enabled");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-Y_ENABLED_enum YVoltage::get_enabled(void)
-{
-    Y_ENABLED_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YVoltage::ENABLED_INVALID;
-                }
-            }
-        }
-        res = _enabled;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YVoltage::set_enabled(Y_ENABLED_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("enabled", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a voltage sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoltage.isOnline() to test if the voltage sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage sensor
- *
- * @return a YVoltage object allowing you to drive the voltage sensor.
- */
-YVoltage* YVoltage::FindVoltage(string func)
-{
-    YVoltage* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YVoltage*) YFunction::_FindFromCache("Voltage", func);
-        if (obj == NULL) {
-            obj = new YVoltage(func);
-            YFunction::_AddToCache("Voltage", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YVoltage::registerValueCallback(YVoltageValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackVoltage = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YVoltage::_invokeValueCallback(string value)
-{
-    if (_valueCallbackVoltage != NULL) {
-        _valueCallbackVoltage(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YVoltage::registerTimedReportCallback(YVoltageTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackVoltage = callback;
-    return 0;
-}
-
-int YVoltage::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackVoltage != NULL) {
-        _timedReportCallbackVoltage(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-YVoltage *YVoltage::nextVoltage(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YVoltage::FindVoltage(hwid);
-}
-
-YVoltage* YVoltage::FirstVoltage(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Voltage", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YVoltage::FindVoltage(serial+"."+funcId);
-}
-
-//--- (end of YVoltage implementation)
-
-//--- (YVoltage functions)
-//--- (end of YVoltage functions)
--- a/Sources/cpplib/yocto_voltage.h
+++ /dev/null
@@ -1,258 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voltage.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindVoltage(), the high-level API for Voltage functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_VOLTAGE_H
-#define YOCTO_VOLTAGE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YVoltage return codes)
-//--- (end of YVoltage return codes)
-//--- (YVoltage yapiwrapper)
-//--- (end of YVoltage yapiwrapper)
-//--- (YVoltage definitions)
-class YVoltage; // forward declaration
-
-typedef void (*YVoltageValueCallback)(YVoltage *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YVoltageTimedReportCallback)(YVoltage *func, YMeasure measure);
-#ifndef _Y_ENABLED_ENUM
-#define _Y_ENABLED_ENUM
-typedef enum {
-    Y_ENABLED_FALSE = 0,
-    Y_ENABLED_TRUE = 1,
-    Y_ENABLED_INVALID = -1,
-} Y_ENABLED_enum;
-#endif
-//--- (end of YVoltage definitions)
-
-//--- (YVoltage declaration)
-/**
- * YVoltage Class: Voltage function interface
- *
- * The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage
- * sensors. It inherits from YSensor class the core functions to read measurements,
- * to register callback functions, to access the autonomous datalogger.
- */
-class YOCTO_CLASS_EXPORT YVoltage: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YVoltage declaration)
-protected:
-    //--- (YVoltage attributes)
-    // Attributes (function value cache)
-    Y_ENABLED_enum  _enabled;
-    YVoltageValueCallback _valueCallbackVoltage;
-    YVoltageTimedReportCallback _timedReportCallbackVoltage;
-
-    friend YVoltage *yFindVoltage(const string& func);
-    friend YVoltage *yFirstVoltage(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindVoltage factory function to instantiate
-    YVoltage(const string& func);
-    //--- (end of YVoltage attributes)
-
-public:
-    virtual ~YVoltage();
-    //--- (YVoltage accessors declaration)
-
-    static const Y_ENABLED_enum ENABLED_FALSE = Y_ENABLED_FALSE;
-    static const Y_ENABLED_enum ENABLED_TRUE = Y_ENABLED_TRUE;
-    static const Y_ENABLED_enum ENABLED_INVALID = Y_ENABLED_INVALID;
-
-    Y_ENABLED_enum      get_enabled(void);
-
-    inline Y_ENABLED_enum enabled(void)
-    { return this->get_enabled(); }
-
-    int             set_enabled(Y_ENABLED_enum newval);
-    inline int      setEnabled(Y_ENABLED_enum newval)
-    { return this->set_enabled(newval); }
-
-    /**
-     * Retrieves a voltage sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the voltage sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YVoltage.isOnline() to test if the voltage sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a voltage sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the voltage sensor
-     *
-     * @return a YVoltage object allowing you to drive the voltage sensor.
-     */
-    static YVoltage*    FindVoltage(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YVoltageValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YVoltageTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-
-    inline static YVoltage* Find(string func)
-    { return YVoltage::FindVoltage(func); }
-
-    /**
-     * Continues the enumeration of voltage sensors started using yFirstVoltage().
-     * Caution: You can't make any assumption about the returned voltage sensors order.
-     * If you want to find a specific a voltage sensor, use Voltage.findVoltage()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YVoltage object, corresponding to
-     *         a voltage sensor currently online, or a NULL pointer
-     *         if there are no more voltage sensors to enumerate.
-     */
-           YVoltage        *nextVoltage(void);
-    inline YVoltage        *next(void)
-    { return this->nextVoltage();}
-
-    /**
-     * Starts the enumeration of voltage sensors currently accessible.
-     * Use the method YVoltage.nextVoltage() to iterate on
-     * next voltage sensors.
-     *
-     * @return a pointer to a YVoltage object, corresponding to
-     *         the first voltage sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YVoltage* FirstVoltage(void);
-    inline static YVoltage* First(void)
-    { return YVoltage::FirstVoltage();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YVoltage accessors declaration)
-};
-
-//--- (YVoltage functions declaration)
-
-/**
- * Retrieves a voltage sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoltage.isOnline() to test if the voltage sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage sensor
- *
- * @return a YVoltage object allowing you to drive the voltage sensor.
- */
-inline YVoltage* yFindVoltage(const string& func)
-{ return YVoltage::FindVoltage(func);}
-/**
- * Starts the enumeration of voltage sensors currently accessible.
- * Use the method YVoltage.nextVoltage() to iterate on
- * next voltage sensors.
- *
- * @return a pointer to a YVoltage object, corresponding to
- *         the first voltage sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YVoltage* yFirstVoltage(void)
-{ return YVoltage::FirstVoltage();}
-
-//--- (end of YVoltage functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_voltageoutput.cpp
+++ /dev/null
@@ -1,374 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voltageoutput.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindVoltageOutput(), the high-level API for VoltageOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_voltageoutput.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "voltageoutput"
-
-YVoltageOutput::YVoltageOutput(const string& func): YFunction(func)
-//--- (YVoltageOutput initialization)
-    ,_currentVoltage(CURRENTVOLTAGE_INVALID)
-    ,_voltageTransition(VOLTAGETRANSITION_INVALID)
-    ,_voltageAtStartUp(VOLTAGEATSTARTUP_INVALID)
-    ,_valueCallbackVoltageOutput(NULL)
-//--- (end of YVoltageOutput initialization)
-{
-    _className="VoltageOutput";
-}
-
-YVoltageOutput::~YVoltageOutput()
-{
-//--- (YVoltageOutput cleanup)
-//--- (end of YVoltageOutput cleanup)
-}
-//--- (YVoltageOutput implementation)
-// static attributes
-const double YVoltageOutput::CURRENTVOLTAGE_INVALID = YAPI_INVALID_DOUBLE;
-const string YVoltageOutput::VOLTAGETRANSITION_INVALID = YAPI_INVALID_STRING;
-const double YVoltageOutput::VOLTAGEATSTARTUP_INVALID = YAPI_INVALID_DOUBLE;
-
-int YVoltageOutput::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("currentVoltage")) {
-        _currentVoltage =  floor(json_val->getDouble("currentVoltage") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("voltageTransition")) {
-        _voltageTransition =  json_val->getString("voltageTransition");
-    }
-    if(json_val->has("voltageAtStartUp")) {
-        _voltageAtStartUp =  floor(json_val->getDouble("voltageAtStartUp") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the output voltage, in V. Valid range is from 0 to 10V.
- *
- * @param newval : a floating point number corresponding to the output voltage, in V
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YVoltageOutput::set_currentVoltage(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("currentVoltage", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the output voltage set point, in V.
- *
- * @return a floating point number corresponding to the output voltage set point, in V
- *
- * On failure, throws an exception or returns Y_CURRENTVOLTAGE_INVALID.
- */
-double YVoltageOutput::get_currentVoltage(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YVoltageOutput::CURRENTVOLTAGE_INVALID;
-                }
-            }
-        }
-        res = _currentVoltage;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YVoltageOutput::get_voltageTransition(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YVoltageOutput::VOLTAGETRANSITION_INVALID;
-                }
-            }
-        }
-        res = _voltageTransition;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YVoltageOutput::set_voltageTransition(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("voltageTransition", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the output voltage at device start up. Remember to call the matching
- * module saveToFlash() method, otherwise this call has no effect.
- *
- * @param newval : a floating point number corresponding to the output voltage at device start up
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YVoltageOutput::set_voltageAtStartUp(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("voltageAtStartUp", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the selected voltage output at device startup, in V.
- *
- * @return a floating point number corresponding to the selected voltage output at device startup, in V
- *
- * On failure, throws an exception or returns Y_VOLTAGEATSTARTUP_INVALID.
- */
-double YVoltageOutput::get_voltageAtStartUp(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YVoltageOutput::VOLTAGEATSTARTUP_INVALID;
-                }
-            }
-        }
-        res = _voltageAtStartUp;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a voltage output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoltageOutput.isOnline() to test if the voltage output is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage output
- *
- * @return a YVoltageOutput object allowing you to drive the voltage output.
- */
-YVoltageOutput* YVoltageOutput::FindVoltageOutput(string func)
-{
-    YVoltageOutput* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YVoltageOutput*) YFunction::_FindFromCache("VoltageOutput", func);
-        if (obj == NULL) {
-            obj = new YVoltageOutput(func);
-            YFunction::_AddToCache("VoltageOutput", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YVoltageOutput::registerValueCallback(YVoltageOutputValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackVoltageOutput = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YVoltageOutput::_invokeValueCallback(string value)
-{
-    if (_valueCallbackVoltageOutput != NULL) {
-        _valueCallbackVoltageOutput(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Performs a smooth transition of output voltage. Any explicit voltage
- * change cancels any ongoing transition process.
- *
- * @param V_target   : new output voltage value at the end of the transition
- *         (floating-point number, representing the end voltage in V)
- * @param ms_duration : total duration of the transition, in milliseconds
- *
- * @return YAPI_SUCCESS when the call succeeds.
- */
-int YVoltageOutput::voltageMove(double V_target,int ms_duration)
-{
-    string newval;
-    if (V_target < 0.0) {
-        V_target  = 0.0;
-    }
-    if (V_target > 10.0) {
-        V_target = 10.0;
-    }
-    newval = YapiWrapper::ysprintf("%d:%d", (int) floor(V_target*65536+0.5),ms_duration);
-
-    return this->set_voltageTransition(newval);
-}
-
-YVoltageOutput *YVoltageOutput::nextVoltageOutput(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YVoltageOutput::FindVoltageOutput(hwid);
-}
-
-YVoltageOutput* YVoltageOutput::FirstVoltageOutput(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("VoltageOutput", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YVoltageOutput::FindVoltageOutput(serial+"."+funcId);
-}
-
-//--- (end of YVoltageOutput implementation)
-
-//--- (YVoltageOutput functions)
-//--- (end of YVoltageOutput functions)
--- a/Sources/cpplib/yocto_voltageoutput.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_voltageoutput.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindVoltageOutput(), the high-level API for VoltageOutput functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_VOLTAGEOUTPUT_H
-#define YOCTO_VOLTAGEOUTPUT_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YVoltageOutput return codes)
-//--- (end of YVoltageOutput return codes)
-//--- (YVoltageOutput yapiwrapper)
-//--- (end of YVoltageOutput yapiwrapper)
-//--- (YVoltageOutput definitions)
-class YVoltageOutput; // forward declaration
-
-typedef void (*YVoltageOutputValueCallback)(YVoltageOutput *func, const string& functionValue);
-#define Y_CURRENTVOLTAGE_INVALID        (YAPI_INVALID_DOUBLE)
-#define Y_VOLTAGETRANSITION_INVALID     (YAPI_INVALID_STRING)
-#define Y_VOLTAGEATSTARTUP_INVALID      (YAPI_INVALID_DOUBLE)
-//--- (end of YVoltageOutput definitions)
-
-//--- (YVoltageOutput declaration)
-/**
- * YVoltageOutput Class: VoltageOutput function interface
- *
- * The Yoctopuce application programming interface allows you to change the value of the voltage output.
- */
-class YOCTO_CLASS_EXPORT YVoltageOutput: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YVoltageOutput declaration)
-protected:
-    //--- (YVoltageOutput attributes)
-    // Attributes (function value cache)
-    double          _currentVoltage;
-    string          _voltageTransition;
-    double          _voltageAtStartUp;
-    YVoltageOutputValueCallback _valueCallbackVoltageOutput;
-
-    friend YVoltageOutput *yFindVoltageOutput(const string& func);
-    friend YVoltageOutput *yFirstVoltageOutput(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindVoltageOutput factory function to instantiate
-    YVoltageOutput(const string& func);
-    //--- (end of YVoltageOutput attributes)
-
-public:
-    virtual ~YVoltageOutput();
-    //--- (YVoltageOutput accessors declaration)
-
-    static const double CURRENTVOLTAGE_INVALID;
-    static const string VOLTAGETRANSITION_INVALID;
-    static const double VOLTAGEATSTARTUP_INVALID;
-
-    /**
-     * Changes the output voltage, in V. Valid range is from 0 to 10V.
-     *
-     * @param newval : a floating point number corresponding to the output voltage, in V
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_currentVoltage(double newval);
-    inline int      setCurrentVoltage(double newval)
-    { return this->set_currentVoltage(newval); }
-
-    /**
-     * Returns the output voltage set point, in V.
-     *
-     * @return a floating point number corresponding to the output voltage set point, in V
-     *
-     * On failure, throws an exception or returns Y_CURRENTVOLTAGE_INVALID.
-     */
-    double              get_currentVoltage(void);
-
-    inline double       currentVoltage(void)
-    { return this->get_currentVoltage(); }
-
-    string              get_voltageTransition(void);
-
-    inline string       voltageTransition(void)
-    { return this->get_voltageTransition(); }
-
-    int             set_voltageTransition(const string& newval);
-    inline int      setVoltageTransition(const string& newval)
-    { return this->set_voltageTransition(newval); }
-
-    /**
-     * Changes the output voltage at device start up. Remember to call the matching
-     * module saveToFlash() method, otherwise this call has no effect.
-     *
-     * @param newval : a floating point number corresponding to the output voltage at device start up
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_voltageAtStartUp(double newval);
-    inline int      setVoltageAtStartUp(double newval)
-    { return this->set_voltageAtStartUp(newval); }
-
-    /**
-     * Returns the selected voltage output at device startup, in V.
-     *
-     * @return a floating point number corresponding to the selected voltage output at device startup, in V
-     *
-     * On failure, throws an exception or returns Y_VOLTAGEATSTARTUP_INVALID.
-     */
-    double              get_voltageAtStartUp(void);
-
-    inline double       voltageAtStartUp(void)
-    { return this->get_voltageAtStartUp(); }
-
-    /**
-     * Retrieves a voltage output for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the voltage output is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YVoltageOutput.isOnline() to test if the voltage output is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a voltage output by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the voltage output
-     *
-     * @return a YVoltageOutput object allowing you to drive the voltage output.
-     */
-    static YVoltageOutput* FindVoltageOutput(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YVoltageOutputValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Performs a smooth transition of output voltage. Any explicit voltage
-     * change cancels any ongoing transition process.
-     *
-     * @param V_target   : new output voltage value at the end of the transition
-     *         (floating-point number, representing the end voltage in V)
-     * @param ms_duration : total duration of the transition, in milliseconds
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     */
-    virtual int         voltageMove(double V_target,int ms_duration);
-
-
-    inline static YVoltageOutput* Find(string func)
-    { return YVoltageOutput::FindVoltageOutput(func); }
-
-    /**
-     * Continues the enumeration of voltage outputs started using yFirstVoltageOutput().
-     * Caution: You can't make any assumption about the returned voltage outputs order.
-     * If you want to find a specific a voltage output, use VoltageOutput.findVoltageOutput()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YVoltageOutput object, corresponding to
-     *         a voltage output currently online, or a NULL pointer
-     *         if there are no more voltage outputs to enumerate.
-     */
-           YVoltageOutput  *nextVoltageOutput(void);
-    inline YVoltageOutput  *next(void)
-    { return this->nextVoltageOutput();}
-
-    /**
-     * Starts the enumeration of voltage outputs currently accessible.
-     * Use the method YVoltageOutput.nextVoltageOutput() to iterate on
-     * next voltage outputs.
-     *
-     * @return a pointer to a YVoltageOutput object, corresponding to
-     *         the first voltage output currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YVoltageOutput* FirstVoltageOutput(void);
-    inline static YVoltageOutput* First(void)
-    { return YVoltageOutput::FirstVoltageOutput();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YVoltageOutput accessors declaration)
-};
-
-//--- (YVoltageOutput functions declaration)
-
-/**
- * Retrieves a voltage output for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the voltage output is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YVoltageOutput.isOnline() to test if the voltage output is
- * indeed online at a given time. In case of ambiguity when looking for
- * a voltage output by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the voltage output
- *
- * @return a YVoltageOutput object allowing you to drive the voltage output.
- */
-inline YVoltageOutput* yFindVoltageOutput(const string& func)
-{ return YVoltageOutput::FindVoltageOutput(func);}
-/**
- * Starts the enumeration of voltage outputs currently accessible.
- * Use the method YVoltageOutput.nextVoltageOutput() to iterate on
- * next voltage outputs.
- *
- * @return a pointer to a YVoltageOutput object, corresponding to
- *         the first voltage output currently online, or a NULL pointer
- *         if there are none.
- */
-inline YVoltageOutput* yFirstVoltageOutput(void)
-{ return YVoltageOutput::FirstVoltageOutput();}
-
-//--- (end of YVoltageOutput functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_wakeupmonitor.cpp
+++ /dev/null
@@ -1,568 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_wakeupmonitor.cpp 32610 2018-10-10 06:52:20Z seb $
- *
- *  Implements yFindWakeUpMonitor(), the high-level API for WakeUpMonitor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_wakeupmonitor.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "wakeupmonitor"
-
-YWakeUpMonitor::YWakeUpMonitor(const string& func): YFunction(func)
-//--- (YWakeUpMonitor initialization)
-    ,_powerDuration(POWERDURATION_INVALID)
-    ,_sleepCountdown(SLEEPCOUNTDOWN_INVALID)
-    ,_nextWakeUp(NEXTWAKEUP_INVALID)
-    ,_wakeUpReason(WAKEUPREASON_INVALID)
-    ,_wakeUpState(WAKEUPSTATE_INVALID)
-    ,_rtcTime(RTCTIME_INVALID)
-    ,_endOfTime(2145960000)
-    ,_valueCallbackWakeUpMonitor(NULL)
-//--- (end of YWakeUpMonitor initialization)
-{
-    _className="WakeUpMonitor";
-}
-
-YWakeUpMonitor::~YWakeUpMonitor()
-{
-//--- (YWakeUpMonitor cleanup)
-//--- (end of YWakeUpMonitor cleanup)
-}
-//--- (YWakeUpMonitor implementation)
-// static attributes
-
-int YWakeUpMonitor::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("powerDuration")) {
-        _powerDuration =  json_val->getInt("powerDuration");
-    }
-    if(json_val->has("sleepCountdown")) {
-        _sleepCountdown =  json_val->getInt("sleepCountdown");
-    }
-    if(json_val->has("nextWakeUp")) {
-        _nextWakeUp =  json_val->getLong("nextWakeUp");
-    }
-    if(json_val->has("wakeUpReason")) {
-        _wakeUpReason =  (Y_WAKEUPREASON_enum)json_val->getInt("wakeUpReason");
-    }
-    if(json_val->has("wakeUpState")) {
-        _wakeUpState =  (Y_WAKEUPSTATE_enum)json_val->getInt("wakeUpState");
-    }
-    if(json_val->has("rtcTime")) {
-        _rtcTime =  json_val->getLong("rtcTime");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the maximal wake up time (in seconds) before automatically going to sleep.
- *
- * @return an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep
- *
- * On failure, throws an exception or returns Y_POWERDURATION_INVALID.
- */
-int YWakeUpMonitor::get_powerDuration(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::POWERDURATION_INVALID;
-                }
-            }
-        }
-        res = _powerDuration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the maximal wake up time (seconds) before automatically going to sleep.
- *
- * @param newval : an integer corresponding to the maximal wake up time (seconds) before automatically
- * going to sleep
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::set_powerDuration(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("powerDuration", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the delay before the  next sleep period.
- *
- * @return an integer corresponding to the delay before the  next sleep period
- *
- * On failure, throws an exception or returns Y_SLEEPCOUNTDOWN_INVALID.
- */
-int YWakeUpMonitor::get_sleepCountdown(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::SLEEPCOUNTDOWN_INVALID;
-                }
-            }
-        }
-        res = _sleepCountdown;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the delay before the next sleep period.
- *
- * @param newval : an integer corresponding to the delay before the next sleep period
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::set_sleepCountdown(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("sleepCountdown", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the next scheduled wake up date/time (UNIX format).
- *
- * @return an integer corresponding to the next scheduled wake up date/time (UNIX format)
- *
- * On failure, throws an exception or returns Y_NEXTWAKEUP_INVALID.
- */
-s64 YWakeUpMonitor::get_nextWakeUp(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::NEXTWAKEUP_INVALID;
-                }
-            }
-        }
-        res = _nextWakeUp;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the days of the week when a wake up must take place.
- *
- * @param newval : an integer corresponding to the days of the week when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::set_nextWakeUp(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("nextWakeUp", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the latest wake up reason.
- *
- * @return a value among Y_WAKEUPREASON_USBPOWER, Y_WAKEUPREASON_EXTPOWER, Y_WAKEUPREASON_ENDOFSLEEP,
- * Y_WAKEUPREASON_EXTSIG1, Y_WAKEUPREASON_SCHEDULE1 and Y_WAKEUPREASON_SCHEDULE2 corresponding to the
- * latest wake up reason
- *
- * On failure, throws an exception or returns Y_WAKEUPREASON_INVALID.
- */
-Y_WAKEUPREASON_enum YWakeUpMonitor::get_wakeUpReason(void)
-{
-    Y_WAKEUPREASON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::WAKEUPREASON_INVALID;
-                }
-            }
-        }
-        res = _wakeUpReason;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns  the current state of the monitor.
- *
- * @return either Y_WAKEUPSTATE_SLEEPING or Y_WAKEUPSTATE_AWAKE, according to  the current state of the monitor
- *
- * On failure, throws an exception or returns Y_WAKEUPSTATE_INVALID.
- */
-Y_WAKEUPSTATE_enum YWakeUpMonitor::get_wakeUpState(void)
-{
-    Y_WAKEUPSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::WAKEUPSTATE_INVALID;
-                }
-            }
-        }
-        res = _wakeUpState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YWakeUpMonitor::set_wakeUpState(Y_WAKEUPSTATE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("wakeUpState", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-s64 YWakeUpMonitor::get_rtcTime(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpMonitor::RTCTIME_INVALID;
-                }
-            }
-        }
-        res = _rtcTime;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a monitor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the monitor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWakeUpMonitor.isOnline() to test if the monitor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a monitor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the monitor
- *
- * @return a YWakeUpMonitor object allowing you to drive the monitor.
- */
-YWakeUpMonitor* YWakeUpMonitor::FindWakeUpMonitor(string func)
-{
-    YWakeUpMonitor* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YWakeUpMonitor*) YFunction::_FindFromCache("WakeUpMonitor", func);
-        if (obj == NULL) {
-            obj = new YWakeUpMonitor(func);
-            YFunction::_AddToCache("WakeUpMonitor", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YWakeUpMonitor::registerValueCallback(YWakeUpMonitorValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackWakeUpMonitor = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YWakeUpMonitor::_invokeValueCallback(string value)
-{
-    if (_valueCallbackWakeUpMonitor != NULL) {
-        _valueCallbackWakeUpMonitor(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Forces a wake up.
- */
-int YWakeUpMonitor::wakeUp(void)
-{
-    return this->set_wakeUpState(Y_WAKEUPSTATE_AWAKE);
-}
-
-/**
- * Goes to sleep until the next wake up condition is met,  the
- * RTC time must have been set before calling this function.
- *
- * @param secBeforeSleep : number of seconds before going into sleep mode,
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::sleep(int secBeforeSleep)
-{
-    int currTime = 0;
-    currTime = (int)(this->get_rtcTime());
-    if (!(currTime != 0)) {
-        _throw(YAPI_RTC_NOT_READY,"RTC time not set");
-        return YAPI_RTC_NOT_READY;
-    }
-    this->set_nextWakeUp(_endOfTime);
-    this->set_sleepCountdown(secBeforeSleep);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Goes to sleep for a specific duration or until the next wake up condition is met, the
- * RTC time must have been set before calling this function. The count down before sleep
- * can be canceled with resetSleepCountDown.
- *
- * @param secUntilWakeUp : number of seconds before next wake up
- * @param secBeforeSleep : number of seconds before going into sleep mode
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::sleepFor(int secUntilWakeUp,int secBeforeSleep)
-{
-    int currTime = 0;
-    currTime = (int)(this->get_rtcTime());
-    if (!(currTime != 0)) {
-        _throw(YAPI_RTC_NOT_READY,"RTC time not set");
-        return YAPI_RTC_NOT_READY;
-    }
-    this->set_nextWakeUp(currTime+secUntilWakeUp);
-    this->set_sleepCountdown(secBeforeSleep);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Go to sleep until a specific date is reached or until the next wake up condition is met, the
- * RTC time must have been set before calling this function. The count down before sleep
- * can be canceled with resetSleepCountDown.
- *
- * @param wakeUpTime : wake-up datetime (UNIX format)
- * @param secBeforeSleep : number of seconds before going into sleep mode
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::sleepUntil(int wakeUpTime,int secBeforeSleep)
-{
-    int currTime = 0;
-    currTime = (int)(this->get_rtcTime());
-    if (!(currTime != 0)) {
-        _throw(YAPI_RTC_NOT_READY,"RTC time not set");
-        return YAPI_RTC_NOT_READY;
-    }
-    this->set_nextWakeUp(wakeUpTime);
-    this->set_sleepCountdown(secBeforeSleep);
-    return YAPI_SUCCESS;
-}
-
-/**
- * Resets the sleep countdown.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *         On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpMonitor::resetSleepCountDown(void)
-{
-    this->set_sleepCountdown(0);
-    this->set_nextWakeUp(0);
-    return YAPI_SUCCESS;
-}
-
-YWakeUpMonitor *YWakeUpMonitor::nextWakeUpMonitor(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YWakeUpMonitor::FindWakeUpMonitor(hwid);
-}
-
-YWakeUpMonitor* YWakeUpMonitor::FirstWakeUpMonitor(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("WakeUpMonitor", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YWakeUpMonitor::FindWakeUpMonitor(serial+"."+funcId);
-}
-
-//--- (end of YWakeUpMonitor implementation)
-
-//--- (YWakeUpMonitor functions)
-//--- (end of YWakeUpMonitor functions)
--- a/Sources/cpplib/yocto_wakeupmonitor.h
+++ /dev/null
@@ -1,426 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_wakeupmonitor.h 32901 2018-11-02 10:13:09Z seb $
- *
- *  Declares yFindWakeUpMonitor(), the high-level API for WakeUpMonitor functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_WAKEUPMONITOR_H
-#define YOCTO_WAKEUPMONITOR_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YWakeUpMonitor return codes)
-//--- (end of YWakeUpMonitor return codes)
-//--- (YWakeUpMonitor yapiwrapper)
-//--- (end of YWakeUpMonitor yapiwrapper)
-//--- (YWakeUpMonitor definitions)
-class YWakeUpMonitor; // forward declaration
-
-typedef void (*YWakeUpMonitorValueCallback)(YWakeUpMonitor *func, const string& functionValue);
-#ifndef _Y_WAKEUPREASON_ENUM
-#define _Y_WAKEUPREASON_ENUM
-typedef enum {
-    Y_WAKEUPREASON_USBPOWER = 0,
-    Y_WAKEUPREASON_EXTPOWER = 1,
-    Y_WAKEUPREASON_ENDOFSLEEP = 2,
-    Y_WAKEUPREASON_EXTSIG1 = 3,
-    Y_WAKEUPREASON_SCHEDULE1 = 4,
-    Y_WAKEUPREASON_SCHEDULE2 = 5,
-    Y_WAKEUPREASON_INVALID = -1,
-} Y_WAKEUPREASON_enum;
-#endif
-#ifndef _Y_WAKEUPSTATE_ENUM
-#define _Y_WAKEUPSTATE_ENUM
-typedef enum {
-    Y_WAKEUPSTATE_SLEEPING = 0,
-    Y_WAKEUPSTATE_AWAKE = 1,
-    Y_WAKEUPSTATE_INVALID = -1,
-} Y_WAKEUPSTATE_enum;
-#endif
-#define Y_POWERDURATION_INVALID         (YAPI_INVALID_INT)
-#define Y_SLEEPCOUNTDOWN_INVALID        (YAPI_INVALID_INT)
-#define Y_NEXTWAKEUP_INVALID            (YAPI_INVALID_LONG)
-#define Y_RTCTIME_INVALID               (YAPI_INVALID_LONG)
-//--- (end of YWakeUpMonitor definitions)
-
-//--- (YWakeUpMonitor declaration)
-/**
- * YWakeUpMonitor Class: WakeUpMonitor function interface
- *
- * The WakeUpMonitor function handles globally all wake-up sources, as well
- * as automated sleep mode.
- */
-class YOCTO_CLASS_EXPORT YWakeUpMonitor: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YWakeUpMonitor declaration)
-protected:
-    //--- (YWakeUpMonitor attributes)
-    // Attributes (function value cache)
-    int             _powerDuration;
-    int             _sleepCountdown;
-    s64             _nextWakeUp;
-    Y_WAKEUPREASON_enum _wakeUpReason;
-    Y_WAKEUPSTATE_enum _wakeUpState;
-    s64             _rtcTime;
-    int             _endOfTime;
-    YWakeUpMonitorValueCallback _valueCallbackWakeUpMonitor;
-
-    friend YWakeUpMonitor *yFindWakeUpMonitor(const string& func);
-    friend YWakeUpMonitor *yFirstWakeUpMonitor(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindWakeUpMonitor factory function to instantiate
-    YWakeUpMonitor(const string& func);
-    //--- (end of YWakeUpMonitor attributes)
-
-public:
-    virtual ~YWakeUpMonitor();
-    //--- (YWakeUpMonitor accessors declaration)
-
-    static const int POWERDURATION_INVALID = YAPI_INVALID_INT;
-    static const int SLEEPCOUNTDOWN_INVALID = YAPI_INVALID_INT;
-    static const s64 NEXTWAKEUP_INVALID = YAPI_INVALID_LONG;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_USBPOWER = Y_WAKEUPREASON_USBPOWER;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_EXTPOWER = Y_WAKEUPREASON_EXTPOWER;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_ENDOFSLEEP = Y_WAKEUPREASON_ENDOFSLEEP;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_EXTSIG1 = Y_WAKEUPREASON_EXTSIG1;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_SCHEDULE1 = Y_WAKEUPREASON_SCHEDULE1;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_SCHEDULE2 = Y_WAKEUPREASON_SCHEDULE2;
-    static const Y_WAKEUPREASON_enum WAKEUPREASON_INVALID = Y_WAKEUPREASON_INVALID;
-    static const Y_WAKEUPSTATE_enum WAKEUPSTATE_SLEEPING = Y_WAKEUPSTATE_SLEEPING;
-    static const Y_WAKEUPSTATE_enum WAKEUPSTATE_AWAKE = Y_WAKEUPSTATE_AWAKE;
-    static const Y_WAKEUPSTATE_enum WAKEUPSTATE_INVALID = Y_WAKEUPSTATE_INVALID;
-    static const s64 RTCTIME_INVALID = YAPI_INVALID_LONG;
-
-    /**
-     * Returns the maximal wake up time (in seconds) before automatically going to sleep.
-     *
-     * @return an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep
-     *
-     * On failure, throws an exception or returns Y_POWERDURATION_INVALID.
-     */
-    int                 get_powerDuration(void);
-
-    inline int          powerDuration(void)
-    { return this->get_powerDuration(); }
-
-    /**
-     * Changes the maximal wake up time (seconds) before automatically going to sleep.
-     *
-     * @param newval : an integer corresponding to the maximal wake up time (seconds) before automatically
-     * going to sleep
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_powerDuration(int newval);
-    inline int      setPowerDuration(int newval)
-    { return this->set_powerDuration(newval); }
-
-    /**
-     * Returns the delay before the  next sleep period.
-     *
-     * @return an integer corresponding to the delay before the  next sleep period
-     *
-     * On failure, throws an exception or returns Y_SLEEPCOUNTDOWN_INVALID.
-     */
-    int                 get_sleepCountdown(void);
-
-    inline int          sleepCountdown(void)
-    { return this->get_sleepCountdown(); }
-
-    /**
-     * Changes the delay before the next sleep period.
-     *
-     * @param newval : an integer corresponding to the delay before the next sleep period
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_sleepCountdown(int newval);
-    inline int      setSleepCountdown(int newval)
-    { return this->set_sleepCountdown(newval); }
-
-    /**
-     * Returns the next scheduled wake up date/time (UNIX format).
-     *
-     * @return an integer corresponding to the next scheduled wake up date/time (UNIX format)
-     *
-     * On failure, throws an exception or returns Y_NEXTWAKEUP_INVALID.
-     */
-    s64                 get_nextWakeUp(void);
-
-    inline s64          nextWakeUp(void)
-    { return this->get_nextWakeUp(); }
-
-    /**
-     * Changes the days of the week when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the days of the week when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_nextWakeUp(s64 newval);
-    inline int      setNextWakeUp(s64 newval)
-    { return this->set_nextWakeUp(newval); }
-
-    /**
-     * Returns the latest wake up reason.
-     *
-     * @return a value among Y_WAKEUPREASON_USBPOWER, Y_WAKEUPREASON_EXTPOWER, Y_WAKEUPREASON_ENDOFSLEEP,
-     * Y_WAKEUPREASON_EXTSIG1, Y_WAKEUPREASON_SCHEDULE1 and Y_WAKEUPREASON_SCHEDULE2 corresponding to the
-     * latest wake up reason
-     *
-     * On failure, throws an exception or returns Y_WAKEUPREASON_INVALID.
-     */
-    Y_WAKEUPREASON_enum get_wakeUpReason(void);
-
-    inline Y_WAKEUPREASON_enum wakeUpReason(void)
-    { return this->get_wakeUpReason(); }
-
-    /**
-     * Returns  the current state of the monitor.
-     *
-     * @return either Y_WAKEUPSTATE_SLEEPING or Y_WAKEUPSTATE_AWAKE, according to  the current state of the monitor
-     *
-     * On failure, throws an exception or returns Y_WAKEUPSTATE_INVALID.
-     */
-    Y_WAKEUPSTATE_enum  get_wakeUpState(void);
-
-    inline Y_WAKEUPSTATE_enum wakeUpState(void)
-    { return this->get_wakeUpState(); }
-
-    int             set_wakeUpState(Y_WAKEUPSTATE_enum newval);
-    inline int      setWakeUpState(Y_WAKEUPSTATE_enum newval)
-    { return this->set_wakeUpState(newval); }
-
-    s64                 get_rtcTime(void);
-
-    inline s64          rtcTime(void)
-    { return this->get_rtcTime(); }
-
-    /**
-     * Retrieves a monitor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the monitor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YWakeUpMonitor.isOnline() to test if the monitor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a monitor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the monitor
-     *
-     * @return a YWakeUpMonitor object allowing you to drive the monitor.
-     */
-    static YWakeUpMonitor* FindWakeUpMonitor(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YWakeUpMonitorValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Forces a wake up.
-     */
-    virtual int         wakeUp(void);
-
-    /**
-     * Goes to sleep until the next wake up condition is met,  the
-     * RTC time must have been set before calling this function.
-     *
-     * @param secBeforeSleep : number of seconds before going into sleep mode,
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sleep(int secBeforeSleep);
-
-    /**
-     * Goes to sleep for a specific duration or until the next wake up condition is met, the
-     * RTC time must have been set before calling this function. The count down before sleep
-     * can be canceled with resetSleepCountDown.
-     *
-     * @param secUntilWakeUp : number of seconds before next wake up
-     * @param secBeforeSleep : number of seconds before going into sleep mode
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sleepFor(int secUntilWakeUp,int secBeforeSleep);
-
-    /**
-     * Go to sleep until a specific date is reached or until the next wake up condition is met, the
-     * RTC time must have been set before calling this function. The count down before sleep
-     * can be canceled with resetSleepCountDown.
-     *
-     * @param wakeUpTime : wake-up datetime (UNIX format)
-     * @param secBeforeSleep : number of seconds before going into sleep mode
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         sleepUntil(int wakeUpTime,int secBeforeSleep);
-
-    /**
-     * Resets the sleep countdown.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *         On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         resetSleepCountDown(void);
-
-
-    inline static YWakeUpMonitor* Find(string func)
-    { return YWakeUpMonitor::FindWakeUpMonitor(func); }
-
-    /**
-     * Continues the enumeration of monitors started using yFirstWakeUpMonitor().
-     * Caution: You can't make any assumption about the returned monitors order.
-     * If you want to find a specific a monitor, use WakeUpMonitor.findWakeUpMonitor()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YWakeUpMonitor object, corresponding to
-     *         a monitor currently online, or a NULL pointer
-     *         if there are no more monitors to enumerate.
-     */
-           YWakeUpMonitor  *nextWakeUpMonitor(void);
-    inline YWakeUpMonitor  *next(void)
-    { return this->nextWakeUpMonitor();}
-
-    /**
-     * Starts the enumeration of monitors currently accessible.
-     * Use the method YWakeUpMonitor.nextWakeUpMonitor() to iterate on
-     * next monitors.
-     *
-     * @return a pointer to a YWakeUpMonitor object, corresponding to
-     *         the first monitor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YWakeUpMonitor* FirstWakeUpMonitor(void);
-    inline static YWakeUpMonitor* First(void)
-    { return YWakeUpMonitor::FirstWakeUpMonitor();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YWakeUpMonitor accessors declaration)
-};
-
-//--- (YWakeUpMonitor functions declaration)
-
-/**
- * Retrieves a monitor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the monitor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWakeUpMonitor.isOnline() to test if the monitor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a monitor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the monitor
- *
- * @return a YWakeUpMonitor object allowing you to drive the monitor.
- */
-inline YWakeUpMonitor* yFindWakeUpMonitor(const string& func)
-{ return YWakeUpMonitor::FindWakeUpMonitor(func);}
-/**
- * Starts the enumeration of monitors currently accessible.
- * Use the method YWakeUpMonitor.nextWakeUpMonitor() to iterate on
- * next monitors.
- *
- * @return a pointer to a YWakeUpMonitor object, corresponding to
- *         the first monitor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YWakeUpMonitor* yFirstWakeUpMonitor(void)
-{ return YWakeUpMonitor::FirstWakeUpMonitor();}
-
-//--- (end of YWakeUpMonitor functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_wakeupschedule.cpp
+++ /dev/null
@@ -1,598 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_wakeupschedule.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindWakeUpSchedule(), the high-level API for WakeUpSchedule functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_wakeupschedule.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "wakeupschedule"
-
-YWakeUpSchedule::YWakeUpSchedule(const string& func): YFunction(func)
-//--- (YWakeUpSchedule initialization)
-    ,_minutesA(MINUTESA_INVALID)
-    ,_minutesB(MINUTESB_INVALID)
-    ,_hours(HOURS_INVALID)
-    ,_weekDays(WEEKDAYS_INVALID)
-    ,_monthDays(MONTHDAYS_INVALID)
-    ,_months(MONTHS_INVALID)
-    ,_nextOccurence(NEXTOCCURENCE_INVALID)
-    ,_valueCallbackWakeUpSchedule(NULL)
-//--- (end of YWakeUpSchedule initialization)
-{
-    _className="WakeUpSchedule";
-}
-
-YWakeUpSchedule::~YWakeUpSchedule()
-{
-//--- (YWakeUpSchedule cleanup)
-//--- (end of YWakeUpSchedule cleanup)
-}
-//--- (YWakeUpSchedule implementation)
-// static attributes
-
-int YWakeUpSchedule::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("minutesA")) {
-        _minutesA =  json_val->getInt("minutesA");
-    }
-    if(json_val->has("minutesB")) {
-        _minutesB =  json_val->getInt("minutesB");
-    }
-    if(json_val->has("hours")) {
-        _hours =  json_val->getInt("hours");
-    }
-    if(json_val->has("weekDays")) {
-        _weekDays =  json_val->getInt("weekDays");
-    }
-    if(json_val->has("monthDays")) {
-        _monthDays =  json_val->getInt("monthDays");
-    }
-    if(json_val->has("months")) {
-        _months =  json_val->getInt("months");
-    }
-    if(json_val->has("nextOccurence")) {
-        _nextOccurence =  json_val->getLong("nextOccurence");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the minutes in the 00-29 interval of each hour scheduled for wake up.
- *
- * @return an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up
- *
- * On failure, throws an exception or returns Y_MINUTESA_INVALID.
- */
-int YWakeUpSchedule::get_minutesA(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::MINUTESA_INVALID;
-                }
-            }
-        }
-        res = _minutesA;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minutes in the 00-29 interval when a wake up must take place.
- *
- * @param newval : an integer corresponding to the minutes in the 00-29 interval when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_minutesA(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("minutesA", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the minutes in the 30-59 interval of each hour scheduled for wake up.
- *
- * @return an integer corresponding to the minutes in the 30-59 interval of each hour scheduled for wake up
- *
- * On failure, throws an exception or returns Y_MINUTESB_INVALID.
- */
-int YWakeUpSchedule::get_minutesB(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::MINUTESB_INVALID;
-                }
-            }
-        }
-        res = _minutesB;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the minutes in the 30-59 interval when a wake up must take place.
- *
- * @param newval : an integer corresponding to the minutes in the 30-59 interval when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_minutesB(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("minutesB", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the hours scheduled for wake up.
- *
- * @return an integer corresponding to the hours scheduled for wake up
- *
- * On failure, throws an exception or returns Y_HOURS_INVALID.
- */
-int YWakeUpSchedule::get_hours(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::HOURS_INVALID;
-                }
-            }
-        }
-        res = _hours;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the hours when a wake up must take place.
- *
- * @param newval : an integer corresponding to the hours when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_hours(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("hours", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the days of the week scheduled for wake up.
- *
- * @return an integer corresponding to the days of the week scheduled for wake up
- *
- * On failure, throws an exception or returns Y_WEEKDAYS_INVALID.
- */
-int YWakeUpSchedule::get_weekDays(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::WEEKDAYS_INVALID;
-                }
-            }
-        }
-        res = _weekDays;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the days of the week when a wake up must take place.
- *
- * @param newval : an integer corresponding to the days of the week when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_weekDays(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("weekDays", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the days of the month scheduled for wake up.
- *
- * @return an integer corresponding to the days of the month scheduled for wake up
- *
- * On failure, throws an exception or returns Y_MONTHDAYS_INVALID.
- */
-int YWakeUpSchedule::get_monthDays(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::MONTHDAYS_INVALID;
-                }
-            }
-        }
-        res = _monthDays;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the days of the month when a wake up must take place.
- *
- * @param newval : an integer corresponding to the days of the month when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_monthDays(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("monthDays", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the months scheduled for wake up.
- *
- * @return an integer corresponding to the months scheduled for wake up
- *
- * On failure, throws an exception or returns Y_MONTHS_INVALID.
- */
-int YWakeUpSchedule::get_months(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::MONTHS_INVALID;
-                }
-            }
-        }
-        res = _months;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the months when a wake up must take place.
- *
- * @param newval : an integer corresponding to the months when a wake up must take place
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_months(int newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("months", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the date/time (seconds) of the next wake up occurrence.
- *
- * @return an integer corresponding to the date/time (seconds) of the next wake up occurrence
- *
- * On failure, throws an exception or returns Y_NEXTOCCURENCE_INVALID.
- */
-s64 YWakeUpSchedule::get_nextOccurence(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWakeUpSchedule::NEXTOCCURENCE_INVALID;
-                }
-            }
-        }
-        res = _nextOccurence;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a wake up schedule for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the wake up schedule is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWakeUpSchedule.isOnline() to test if the wake up schedule is
- * indeed online at a given time. In case of ambiguity when looking for
- * a wake up schedule by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the wake up schedule
- *
- * @return a YWakeUpSchedule object allowing you to drive the wake up schedule.
- */
-YWakeUpSchedule* YWakeUpSchedule::FindWakeUpSchedule(string func)
-{
-    YWakeUpSchedule* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YWakeUpSchedule*) YFunction::_FindFromCache("WakeUpSchedule", func);
-        if (obj == NULL) {
-            obj = new YWakeUpSchedule(func);
-            YFunction::_AddToCache("WakeUpSchedule", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YWakeUpSchedule::registerValueCallback(YWakeUpScheduleValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackWakeUpSchedule = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YWakeUpSchedule::_invokeValueCallback(string value)
-{
-    if (_valueCallbackWakeUpSchedule != NULL) {
-        _valueCallbackWakeUpSchedule(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Returns all the minutes of each hour that are scheduled for wake up.
- */
-s64 YWakeUpSchedule::get_minutes(void)
-{
-    s64 res = 0;
-
-    res = this->get_minutesB();
-    res = ((res) << (30));
-    res = res + this->get_minutesA();
-    return res;
-}
-
-/**
- * Changes all the minutes where a wake up must take place.
- *
- * @param bitmap : Minutes 00-59 of each hour scheduled for wake up.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWakeUpSchedule::set_minutes(s64 bitmap)
-{
-    this->set_minutesA((int)(((bitmap) & (0x3fffffff))));
-    bitmap = ((bitmap) >> (30));
-    return this->set_minutesB((int)(((bitmap) & (0x3fffffff))));
-}
-
-YWakeUpSchedule *YWakeUpSchedule::nextWakeUpSchedule(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YWakeUpSchedule::FindWakeUpSchedule(hwid);
-}
-
-YWakeUpSchedule* YWakeUpSchedule::FirstWakeUpSchedule(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("WakeUpSchedule", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YWakeUpSchedule::FindWakeUpSchedule(serial+"."+funcId);
-}
-
-//--- (end of YWakeUpSchedule implementation)
-
-//--- (YWakeUpSchedule functions)
-//--- (end of YWakeUpSchedule functions)
--- a/Sources/cpplib/yocto_wakeupschedule.h
+++ /dev/null
@@ -1,417 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_wakeupschedule.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindWakeUpSchedule(), the high-level API for WakeUpSchedule functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_WAKEUPSCHEDULE_H
-#define YOCTO_WAKEUPSCHEDULE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YWakeUpSchedule return codes)
-//--- (end of YWakeUpSchedule return codes)
-//--- (YWakeUpSchedule yapiwrapper)
-//--- (end of YWakeUpSchedule yapiwrapper)
-//--- (YWakeUpSchedule definitions)
-class YWakeUpSchedule; // forward declaration
-
-typedef void (*YWakeUpScheduleValueCallback)(YWakeUpSchedule *func, const string& functionValue);
-#define Y_MINUTESA_INVALID              (YAPI_INVALID_UINT)
-#define Y_MINUTESB_INVALID              (YAPI_INVALID_UINT)
-#define Y_HOURS_INVALID                 (YAPI_INVALID_UINT)
-#define Y_WEEKDAYS_INVALID              (YAPI_INVALID_UINT)
-#define Y_MONTHDAYS_INVALID             (YAPI_INVALID_UINT)
-#define Y_MONTHS_INVALID                (YAPI_INVALID_UINT)
-#define Y_NEXTOCCURENCE_INVALID         (YAPI_INVALID_LONG)
-//--- (end of YWakeUpSchedule definitions)
-
-//--- (YWakeUpSchedule declaration)
-/**
- * YWakeUpSchedule Class: WakeUpSchedule function interface
- *
- * The WakeUpSchedule function implements a wake up condition. The wake up time is
- * specified as a set of months and/or days and/or hours and/or minutes when the
- * wake up should happen.
- */
-class YOCTO_CLASS_EXPORT YWakeUpSchedule: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YWakeUpSchedule declaration)
-protected:
-    //--- (YWakeUpSchedule attributes)
-    // Attributes (function value cache)
-    int             _minutesA;
-    int             _minutesB;
-    int             _hours;
-    int             _weekDays;
-    int             _monthDays;
-    int             _months;
-    s64             _nextOccurence;
-    YWakeUpScheduleValueCallback _valueCallbackWakeUpSchedule;
-
-    friend YWakeUpSchedule *yFindWakeUpSchedule(const string& func);
-    friend YWakeUpSchedule *yFirstWakeUpSchedule(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindWakeUpSchedule factory function to instantiate
-    YWakeUpSchedule(const string& func);
-    //--- (end of YWakeUpSchedule attributes)
-
-public:
-    virtual ~YWakeUpSchedule();
-    //--- (YWakeUpSchedule accessors declaration)
-
-    static const int MINUTESA_INVALID = YAPI_INVALID_UINT;
-    static const int MINUTESB_INVALID = YAPI_INVALID_UINT;
-    static const int HOURS_INVALID = YAPI_INVALID_UINT;
-    static const int WEEKDAYS_INVALID = YAPI_INVALID_UINT;
-    static const int MONTHDAYS_INVALID = YAPI_INVALID_UINT;
-    static const int MONTHS_INVALID = YAPI_INVALID_UINT;
-    static const s64 NEXTOCCURENCE_INVALID = YAPI_INVALID_LONG;
-
-    /**
-     * Returns the minutes in the 00-29 interval of each hour scheduled for wake up.
-     *
-     * @return an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_MINUTESA_INVALID.
-     */
-    int                 get_minutesA(void);
-
-    inline int          minutesA(void)
-    { return this->get_minutesA(); }
-
-    /**
-     * Changes the minutes in the 00-29 interval when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the minutes in the 00-29 interval when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_minutesA(int newval);
-    inline int      setMinutesA(int newval)
-    { return this->set_minutesA(newval); }
-
-    /**
-     * Returns the minutes in the 30-59 interval of each hour scheduled for wake up.
-     *
-     * @return an integer corresponding to the minutes in the 30-59 interval of each hour scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_MINUTESB_INVALID.
-     */
-    int                 get_minutesB(void);
-
-    inline int          minutesB(void)
-    { return this->get_minutesB(); }
-
-    /**
-     * Changes the minutes in the 30-59 interval when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the minutes in the 30-59 interval when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_minutesB(int newval);
-    inline int      setMinutesB(int newval)
-    { return this->set_minutesB(newval); }
-
-    /**
-     * Returns the hours scheduled for wake up.
-     *
-     * @return an integer corresponding to the hours scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_HOURS_INVALID.
-     */
-    int                 get_hours(void);
-
-    inline int          hours(void)
-    { return this->get_hours(); }
-
-    /**
-     * Changes the hours when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the hours when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_hours(int newval);
-    inline int      setHours(int newval)
-    { return this->set_hours(newval); }
-
-    /**
-     * Returns the days of the week scheduled for wake up.
-     *
-     * @return an integer corresponding to the days of the week scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_WEEKDAYS_INVALID.
-     */
-    int                 get_weekDays(void);
-
-    inline int          weekDays(void)
-    { return this->get_weekDays(); }
-
-    /**
-     * Changes the days of the week when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the days of the week when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_weekDays(int newval);
-    inline int      setWeekDays(int newval)
-    { return this->set_weekDays(newval); }
-
-    /**
-     * Returns the days of the month scheduled for wake up.
-     *
-     * @return an integer corresponding to the days of the month scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_MONTHDAYS_INVALID.
-     */
-    int                 get_monthDays(void);
-
-    inline int          monthDays(void)
-    { return this->get_monthDays(); }
-
-    /**
-     * Changes the days of the month when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the days of the month when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_monthDays(int newval);
-    inline int      setMonthDays(int newval)
-    { return this->set_monthDays(newval); }
-
-    /**
-     * Returns the months scheduled for wake up.
-     *
-     * @return an integer corresponding to the months scheduled for wake up
-     *
-     * On failure, throws an exception or returns Y_MONTHS_INVALID.
-     */
-    int                 get_months(void);
-
-    inline int          months(void)
-    { return this->get_months(); }
-
-    /**
-     * Changes the months when a wake up must take place.
-     *
-     * @param newval : an integer corresponding to the months when a wake up must take place
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_months(int newval);
-    inline int      setMonths(int newval)
-    { return this->set_months(newval); }
-
-    /**
-     * Returns the date/time (seconds) of the next wake up occurrence.
-     *
-     * @return an integer corresponding to the date/time (seconds) of the next wake up occurrence
-     *
-     * On failure, throws an exception or returns Y_NEXTOCCURENCE_INVALID.
-     */
-    s64                 get_nextOccurence(void);
-
-    inline s64          nextOccurence(void)
-    { return this->get_nextOccurence(); }
-
-    /**
-     * Retrieves a wake up schedule for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the wake up schedule is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YWakeUpSchedule.isOnline() to test if the wake up schedule is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a wake up schedule by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the wake up schedule
-     *
-     * @return a YWakeUpSchedule object allowing you to drive the wake up schedule.
-     */
-    static YWakeUpSchedule* FindWakeUpSchedule(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YWakeUpScheduleValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Returns all the minutes of each hour that are scheduled for wake up.
-     */
-    virtual s64         get_minutes(void);
-
-    /**
-     * Changes all the minutes where a wake up must take place.
-     *
-     * @param bitmap : Minutes 00-59 of each hour scheduled for wake up.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_minutes(s64 bitmap);
-
-
-    inline static YWakeUpSchedule* Find(string func)
-    { return YWakeUpSchedule::FindWakeUpSchedule(func); }
-
-    /**
-     * Continues the enumeration of wake up schedules started using yFirstWakeUpSchedule().
-     * Caution: You can't make any assumption about the returned wake up schedules order.
-     * If you want to find a specific a wake up schedule, use WakeUpSchedule.findWakeUpSchedule()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YWakeUpSchedule object, corresponding to
-     *         a wake up schedule currently online, or a NULL pointer
-     *         if there are no more wake up schedules to enumerate.
-     */
-           YWakeUpSchedule *nextWakeUpSchedule(void);
-    inline YWakeUpSchedule *next(void)
-    { return this->nextWakeUpSchedule();}
-
-    /**
-     * Starts the enumeration of wake up schedules currently accessible.
-     * Use the method YWakeUpSchedule.nextWakeUpSchedule() to iterate on
-     * next wake up schedules.
-     *
-     * @return a pointer to a YWakeUpSchedule object, corresponding to
-     *         the first wake up schedule currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YWakeUpSchedule* FirstWakeUpSchedule(void);
-    inline static YWakeUpSchedule* First(void)
-    { return YWakeUpSchedule::FirstWakeUpSchedule();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YWakeUpSchedule accessors declaration)
-};
-
-//--- (YWakeUpSchedule functions declaration)
-
-/**
- * Retrieves a wake up schedule for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the wake up schedule is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWakeUpSchedule.isOnline() to test if the wake up schedule is
- * indeed online at a given time. In case of ambiguity when looking for
- * a wake up schedule by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the wake up schedule
- *
- * @return a YWakeUpSchedule object allowing you to drive the wake up schedule.
- */
-inline YWakeUpSchedule* yFindWakeUpSchedule(const string& func)
-{ return YWakeUpSchedule::FindWakeUpSchedule(func);}
-/**
- * Starts the enumeration of wake up schedules currently accessible.
- * Use the method YWakeUpSchedule.nextWakeUpSchedule() to iterate on
- * next wake up schedules.
- *
- * @return a pointer to a YWakeUpSchedule object, corresponding to
- *         the first wake up schedule currently online, or a NULL pointer
- *         if there are none.
- */
-inline YWakeUpSchedule* yFirstWakeUpSchedule(void)
-{ return YWakeUpSchedule::FirstWakeUpSchedule();}
-
-//--- (end of YWakeUpSchedule functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_watchdog.cpp
+++ /dev/null
@@ -1,916 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_watchdog.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindWatchdog(), the high-level API for Watchdog functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_watchdog.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "watchdog"
-
-YWatchdog::YWatchdog(const string& func): YFunction(func)
-//--- (YWatchdog initialization)
-    ,_state(STATE_INVALID)
-    ,_stateAtPowerOn(STATEATPOWERON_INVALID)
-    ,_maxTimeOnStateA(MAXTIMEONSTATEA_INVALID)
-    ,_maxTimeOnStateB(MAXTIMEONSTATEB_INVALID)
-    ,_output(OUTPUT_INVALID)
-    ,_pulseTimer(PULSETIMER_INVALID)
-    ,_delayedPulseTimer(DELAYEDPULSETIMER_INVALID)
-    ,_countdown(COUNTDOWN_INVALID)
-    ,_autoStart(AUTOSTART_INVALID)
-    ,_running(RUNNING_INVALID)
-    ,_triggerDelay(TRIGGERDELAY_INVALID)
-    ,_triggerDuration(TRIGGERDURATION_INVALID)
-    ,_valueCallbackWatchdog(NULL)
-//--- (end of YWatchdog initialization)
-{
-    _className="Watchdog";
-}
-
-YWatchdog::~YWatchdog()
-{
-//--- (YWatchdog cleanup)
-//--- (end of YWatchdog cleanup)
-}
-//--- (YWatchdog implementation)
-// static attributes
-const YDelayedPulse YWatchdog::DELAYEDPULSETIMER_INVALID = YDelayedPulse();
-
-int YWatchdog::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("state")) {
-        _state =  (Y_STATE_enum)json_val->getInt("state");
-    }
-    if(json_val->has("stateAtPowerOn")) {
-        _stateAtPowerOn =  (Y_STATEATPOWERON_enum)json_val->getInt("stateAtPowerOn");
-    }
-    if(json_val->has("maxTimeOnStateA")) {
-        _maxTimeOnStateA =  json_val->getLong("maxTimeOnStateA");
-    }
-    if(json_val->has("maxTimeOnStateB")) {
-        _maxTimeOnStateB =  json_val->getLong("maxTimeOnStateB");
-    }
-    if(json_val->has("output")) {
-        _output =  (Y_OUTPUT_enum)json_val->getInt("output");
-    }
-    if(json_val->has("pulseTimer")) {
-        _pulseTimer =  json_val->getLong("pulseTimer");
-    }
-    if(json_val->has("delayedPulseTimer")) {
-        YJSONObject* subjson = json_val->getYJSONObject("delayedPulseTimer");
-        if (subjson->has("moving")) {
-            _delayedPulseTimer.moving = subjson->getInt("moving");
-        }
-        if (subjson->has("target")) {
-            _delayedPulseTimer.target = subjson->getInt("target");
-        }
-        if (subjson->has("ms")) {
-            _delayedPulseTimer.ms = subjson->getInt("ms");
-        }
-    }
-    if(json_val->has("countdown")) {
-        _countdown =  json_val->getLong("countdown");
-    }
-    if(json_val->has("autoStart")) {
-        _autoStart =  (Y_AUTOSTART_enum)json_val->getInt("autoStart");
-    }
-    if(json_val->has("running")) {
-        _running =  (Y_RUNNING_enum)json_val->getInt("running");
-    }
-    if(json_val->has("triggerDelay")) {
-        _triggerDelay =  json_val->getLong("triggerDelay");
-    }
-    if(json_val->has("triggerDuration")) {
-        _triggerDuration =  json_val->getLong("triggerDuration");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the state of the watchdog (A for the idle position, B for the active position).
- *
- * @return either Y_STATE_A or Y_STATE_B, according to the state of the watchdog (A for the idle
- * position, B for the active position)
- *
- * On failure, throws an exception or returns Y_STATE_INVALID.
- */
-Y_STATE_enum YWatchdog::get_state(void)
-{
-    Y_STATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::STATE_INVALID;
-                }
-            }
-        }
-        res = _state;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the state of the watchdog (A for the idle position, B for the active position).
- *
- * @param newval : either Y_STATE_A or Y_STATE_B, according to the state of the watchdog (A for the
- * idle position, B for the active position)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_state(Y_STATE_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("state", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the state of the watchdog at device startup (A for the idle position, B for the active
- * position, UNCHANGED for no change).
- *
- * @return a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
- * corresponding to the state of the watchdog at device startup (A for the idle position, B for the
- * active position, UNCHANGED for no change)
- *
- * On failure, throws an exception or returns Y_STATEATPOWERON_INVALID.
- */
-Y_STATEATPOWERON_enum YWatchdog::get_stateAtPowerOn(void)
-{
-    Y_STATEATPOWERON_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::STATEATPOWERON_INVALID;
-                }
-            }
-        }
-        res = _stateAtPowerOn;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Preset the state of the watchdog at device startup (A for the idle position,
- * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
- * method, otherwise this call will have no effect.
- *
- * @param newval : a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_stateAtPowerOn(Y_STATEATPOWERON_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("stateAtPowerOn", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
- * switching back in to B state. Zero means no maximum time.
- *
- * @return an integer
- *
- * On failure, throws an exception or returns Y_MAXTIMEONSTATEA_INVALID.
- */
-s64 YWatchdog::get_maxTimeOnStateA(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::MAXTIMEONSTATEA_INVALID;
-                }
-            }
-        }
-        res = _maxTimeOnStateA;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
- * switching back in to B state. Use zero for no maximum time.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_maxTimeOnStateA(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("maxTimeOnStateA", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
- * switching back in to A state. Zero means no maximum time.
- *
- * @return an integer
- *
- * On failure, throws an exception or returns Y_MAXTIMEONSTATEB_INVALID.
- */
-s64 YWatchdog::get_maxTimeOnStateB(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::MAXTIMEONSTATEB_INVALID;
-                }
-            }
-        }
-        res = _maxTimeOnStateB;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
- * switching back in to A state. Use zero for no maximum time.
- *
- * @param newval : an integer
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_maxTimeOnStateB(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("maxTimeOnStateB", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the output state of the watchdog, when used as a simple switch (single throw).
- *
- * @return either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the watchdog, when
- * used as a simple switch (single throw)
- *
- * On failure, throws an exception or returns Y_OUTPUT_INVALID.
- */
-Y_OUTPUT_enum YWatchdog::get_output(void)
-{
-    Y_OUTPUT_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::OUTPUT_INVALID;
-                }
-            }
-        }
-        res = _output;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the output state of the watchdog, when used as a simple switch (single throw).
- *
- * @param newval : either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the watchdog,
- * when used as a simple switch (single throw)
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_output(Y_OUTPUT_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("output", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the number of milliseconds remaining before the watchdog is returned to idle position
- * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
- *
- * @return an integer corresponding to the number of milliseconds remaining before the watchdog is
- * returned to idle position
- *         (state A), during a measured pulse generation
- *
- * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
- */
-s64 YWatchdog::get_pulseTimer(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::PULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _pulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YWatchdog::set_pulseTimer(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("pulseTimer", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Sets the relay to output B (active) for a specified duration, then brings it
- * automatically back to output A (idle state).
- *
- * @param ms_duration : pulse duration, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::pulse(int ms_duration)
-{
-    string rest_val;
-    char buf[32]; sprintf(buf, "%u", (u32)ms_duration); rest_val = string(buf);
-    return _setAttr("pulseTimer", rest_val);
-}
-
-YDelayedPulse YWatchdog::get_delayedPulseTimer(void)
-{
-    YDelayedPulse res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::DELAYEDPULSETIMER_INVALID;
-                }
-            }
-        }
-        res = _delayedPulseTimer;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YWatchdog::set_delayedPulseTimer(YDelayedPulse newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buff[64]; sprintf(buff,"%d:%d",newval.target,newval.ms); rest_val = string(buff);
-        res = _setAttr("delayedPulseTimer", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Schedules a pulse.
- *
- * @param ms_delay : waiting time before the pulse, in milliseconds
- * @param ms_duration : pulse duration, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::delayedPulse(int ms_delay,int ms_duration)
-{
-    string rest_val;
-    char buff[64]; sprintf(buff,"%d:%d",ms_delay,ms_duration); rest_val = string(buff);
-    return _setAttr("delayedPulseTimer", rest_val);
-}
-
-/**
- * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
- * When there is no scheduled pulse, returns zero.
- *
- * @return an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call)
- *         When there is no scheduled pulse, returns zero
- *
- * On failure, throws an exception or returns Y_COUNTDOWN_INVALID.
- */
-s64 YWatchdog::get_countdown(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::COUNTDOWN_INVALID;
-                }
-            }
-        }
-        res = _countdown;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the watchdog running state at module power on.
- *
- * @return either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the watchdog running state at module power on
- *
- * On failure, throws an exception or returns Y_AUTOSTART_INVALID.
- */
-Y_AUTOSTART_enum YWatchdog::get_autoStart(void)
-{
-    Y_AUTOSTART_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::AUTOSTART_INVALID;
-                }
-            }
-        }
-        res = _autoStart;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the watchdog running state at module power on. Remember to call the
- * saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param newval : either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the watchdog running state
- * at module power on
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_autoStart(Y_AUTOSTART_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("autoStart", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the watchdog running state.
- *
- * @return either Y_RUNNING_OFF or Y_RUNNING_ON, according to the watchdog running state
- *
- * On failure, throws an exception or returns Y_RUNNING_INVALID.
- */
-Y_RUNNING_enum YWatchdog::get_running(void)
-{
-    Y_RUNNING_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::RUNNING_INVALID;
-                }
-            }
-        }
-        res = _running;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the running state of the watchdog.
- *
- * @param newval : either Y_RUNNING_OFF or Y_RUNNING_ON, according to the running state of the watchdog
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_running(Y_RUNNING_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = (newval>0 ? "1" : "0");
-        res = _setAttr("running", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Resets the watchdog. When the watchdog is running, this function
- * must be called on a regular basis to prevent the watchdog to
- * trigger
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::resetWatchdog(void)
-{
-    string rest_val;
-    rest_val = "1";
-    return _setAttr("running", rest_val);
-}
-
-/**
- * Returns  the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.
- *
- * @return an integer corresponding to  the waiting duration before a reset is automatically triggered
- * by the watchdog, in milliseconds
- *
- * On failure, throws an exception or returns Y_TRIGGERDELAY_INVALID.
- */
-s64 YWatchdog::get_triggerDelay(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::TRIGGERDELAY_INVALID;
-                }
-            }
-        }
-        res = _triggerDelay;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.
- *
- * @param newval : an integer corresponding to the waiting delay before a reset is triggered by the
- * watchdog, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_triggerDelay(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("triggerDelay", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the duration of resets caused by the watchdog, in milliseconds.
- *
- * @return an integer corresponding to the duration of resets caused by the watchdog, in milliseconds
- *
- * On failure, throws an exception or returns Y_TRIGGERDURATION_INVALID.
- */
-s64 YWatchdog::get_triggerDuration(void)
-{
-    s64 res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWatchdog::TRIGGERDURATION_INVALID;
-                }
-            }
-        }
-        res = _triggerDuration;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the duration of resets caused by the watchdog, in milliseconds.
- *
- * @param newval : an integer corresponding to the duration of resets caused by the watchdog, in milliseconds
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWatchdog::set_triggerDuration(s64 newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%u", (u32)newval); rest_val = string(buf);
-        res = _setAttr("triggerDuration", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a watchdog for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the watchdog is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWatchdog.isOnline() to test if the watchdog is
- * indeed online at a given time. In case of ambiguity when looking for
- * a watchdog by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the watchdog
- *
- * @return a YWatchdog object allowing you to drive the watchdog.
- */
-YWatchdog* YWatchdog::FindWatchdog(string func)
-{
-    YWatchdog* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YWatchdog*) YFunction::_FindFromCache("Watchdog", func);
-        if (obj == NULL) {
-            obj = new YWatchdog(func);
-            YFunction::_AddToCache("Watchdog", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YWatchdog::registerValueCallback(YWatchdogValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackWatchdog = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YWatchdog::_invokeValueCallback(string value)
-{
-    if (_valueCallbackWatchdog != NULL) {
-        _valueCallbackWatchdog(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-YWatchdog *YWatchdog::nextWatchdog(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YWatchdog::FindWatchdog(hwid);
-}
-
-YWatchdog* YWatchdog::FirstWatchdog(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Watchdog", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YWatchdog::FindWatchdog(serial+"."+funcId);
-}
-
-//--- (end of YWatchdog implementation)
-
-//--- (YWatchdog functions)
-//--- (end of YWatchdog functions)
--- a/Sources/cpplib/yocto_watchdog.h
+++ /dev/null
@@ -1,639 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_watchdog.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindWatchdog(), the high-level API for Watchdog functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_WATCHDOG_H
-#define YOCTO_WATCHDOG_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YWatchdog return codes)
-//--- (end of YWatchdog return codes)
-//--- (YWatchdog yapiwrapper)
-//--- (end of YWatchdog yapiwrapper)
-//--- (YWatchdog definitions)
-class YWatchdog; // forward declaration
-
-typedef void (*YWatchdogValueCallback)(YWatchdog *func, const string& functionValue);
-#ifndef _Y_STATE_ENUM
-#define _Y_STATE_ENUM
-typedef enum {
-    Y_STATE_A = 0,
-    Y_STATE_B = 1,
-    Y_STATE_INVALID = -1,
-} Y_STATE_enum;
-#endif
-#ifndef _Y_STATEATPOWERON_ENUM
-#define _Y_STATEATPOWERON_ENUM
-typedef enum {
-    Y_STATEATPOWERON_UNCHANGED = 0,
-    Y_STATEATPOWERON_A = 1,
-    Y_STATEATPOWERON_B = 2,
-    Y_STATEATPOWERON_INVALID = -1,
-} Y_STATEATPOWERON_enum;
-#endif
-#ifndef _Y_OUTPUT_ENUM
-#define _Y_OUTPUT_ENUM
-typedef enum {
-    Y_OUTPUT_OFF = 0,
-    Y_OUTPUT_ON = 1,
-    Y_OUTPUT_INVALID = -1,
-} Y_OUTPUT_enum;
-#endif
-#ifndef _CLASS_YDELAYEDPULSE
-#define _CLASS_YDELAYEDPULSE
-class YOCTO_CLASS_EXPORT YDelayedPulse {
-public:
-    int             target;
-    int             ms;
-    int             moving;
-
-    YDelayedPulse()
-        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
-    {}
-
-    bool operator==(const YDelayedPulse& o) const {
-         return (target == o.target) && (ms == o.ms) && (moving == o.moving);
-    }
-};
-#endif
-#ifndef _Y_AUTOSTART_ENUM
-#define _Y_AUTOSTART_ENUM
-typedef enum {
-    Y_AUTOSTART_OFF = 0,
-    Y_AUTOSTART_ON = 1,
-    Y_AUTOSTART_INVALID = -1,
-} Y_AUTOSTART_enum;
-#endif
-#ifndef _Y_RUNNING_ENUM
-#define _Y_RUNNING_ENUM
-typedef enum {
-    Y_RUNNING_OFF = 0,
-    Y_RUNNING_ON = 1,
-    Y_RUNNING_INVALID = -1,
-} Y_RUNNING_enum;
-#endif
-#define Y_MAXTIMEONSTATEA_INVALID       (YAPI_INVALID_LONG)
-#define Y_MAXTIMEONSTATEB_INVALID       (YAPI_INVALID_LONG)
-#define Y_PULSETIMER_INVALID            (YAPI_INVALID_LONG)
-#define Y_COUNTDOWN_INVALID             (YAPI_INVALID_LONG)
-#define Y_TRIGGERDELAY_INVALID          (YAPI_INVALID_LONG)
-#define Y_TRIGGERDURATION_INVALID       (YAPI_INVALID_LONG)
-//--- (end of YWatchdog definitions)
-
-//--- (YWatchdog declaration)
-/**
- * YWatchdog Class: Watchdog function interface
- *
- * The watchdog function works like a relay and can cause a brief power cut
- * to an appliance after a preset delay to force this appliance to
- * reset. The Watchdog must be called from time to time to reset the
- * timer and prevent the appliance reset.
- * The watchdog can be driven directly with <i>pulse</i> and <i>delayedpulse</i> methods to switch
- * off an appliance for a given duration.
- */
-class YOCTO_CLASS_EXPORT YWatchdog: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YWatchdog declaration)
-protected:
-    //--- (YWatchdog attributes)
-    // Attributes (function value cache)
-    Y_STATE_enum    _state;
-    Y_STATEATPOWERON_enum _stateAtPowerOn;
-    s64             _maxTimeOnStateA;
-    s64             _maxTimeOnStateB;
-    Y_OUTPUT_enum   _output;
-    s64             _pulseTimer;
-    YDelayedPulse   _delayedPulseTimer;
-    s64             _countdown;
-    Y_AUTOSTART_enum _autoStart;
-    Y_RUNNING_enum  _running;
-    s64             _triggerDelay;
-    s64             _triggerDuration;
-    YWatchdogValueCallback _valueCallbackWatchdog;
-
-    friend YWatchdog *yFindWatchdog(const string& func);
-    friend YWatchdog *yFirstWatchdog(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindWatchdog factory function to instantiate
-    YWatchdog(const string& func);
-    //--- (end of YWatchdog attributes)
-
-public:
-    virtual ~YWatchdog();
-    //--- (YWatchdog accessors declaration)
-
-    static const Y_STATE_enum STATE_A = Y_STATE_A;
-    static const Y_STATE_enum STATE_B = Y_STATE_B;
-    static const Y_STATE_enum STATE_INVALID = Y_STATE_INVALID;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_UNCHANGED = Y_STATEATPOWERON_UNCHANGED;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_A = Y_STATEATPOWERON_A;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_B = Y_STATEATPOWERON_B;
-    static const Y_STATEATPOWERON_enum STATEATPOWERON_INVALID = Y_STATEATPOWERON_INVALID;
-    static const s64 MAXTIMEONSTATEA_INVALID = YAPI_INVALID_LONG;
-    static const s64 MAXTIMEONSTATEB_INVALID = YAPI_INVALID_LONG;
-    static const Y_OUTPUT_enum OUTPUT_OFF = Y_OUTPUT_OFF;
-    static const Y_OUTPUT_enum OUTPUT_ON = Y_OUTPUT_ON;
-    static const Y_OUTPUT_enum OUTPUT_INVALID = Y_OUTPUT_INVALID;
-    static const s64 PULSETIMER_INVALID = YAPI_INVALID_LONG;
-    static const YDelayedPulse DELAYEDPULSETIMER_INVALID;
-    static const s64 COUNTDOWN_INVALID = YAPI_INVALID_LONG;
-    static const Y_AUTOSTART_enum AUTOSTART_OFF = Y_AUTOSTART_OFF;
-    static const Y_AUTOSTART_enum AUTOSTART_ON = Y_AUTOSTART_ON;
-    static const Y_AUTOSTART_enum AUTOSTART_INVALID = Y_AUTOSTART_INVALID;
-    static const Y_RUNNING_enum RUNNING_OFF = Y_RUNNING_OFF;
-    static const Y_RUNNING_enum RUNNING_ON = Y_RUNNING_ON;
-    static const Y_RUNNING_enum RUNNING_INVALID = Y_RUNNING_INVALID;
-    static const s64 TRIGGERDELAY_INVALID = YAPI_INVALID_LONG;
-    static const s64 TRIGGERDURATION_INVALID = YAPI_INVALID_LONG;
-
-    /**
-     * Returns the state of the watchdog (A for the idle position, B for the active position).
-     *
-     * @return either Y_STATE_A or Y_STATE_B, according to the state of the watchdog (A for the idle
-     * position, B for the active position)
-     *
-     * On failure, throws an exception or returns Y_STATE_INVALID.
-     */
-    Y_STATE_enum        get_state(void);
-
-    inline Y_STATE_enum state(void)
-    { return this->get_state(); }
-
-    /**
-     * Changes the state of the watchdog (A for the idle position, B for the active position).
-     *
-     * @param newval : either Y_STATE_A or Y_STATE_B, according to the state of the watchdog (A for the
-     * idle position, B for the active position)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_state(Y_STATE_enum newval);
-    inline int      setState(Y_STATE_enum newval)
-    { return this->set_state(newval); }
-
-    /**
-     * Returns the state of the watchdog at device startup (A for the idle position, B for the active
-     * position, UNCHANGED for no change).
-     *
-     * @return a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
-     * corresponding to the state of the watchdog at device startup (A for the idle position, B for the
-     * active position, UNCHANGED for no change)
-     *
-     * On failure, throws an exception or returns Y_STATEATPOWERON_INVALID.
-     */
-    Y_STATEATPOWERON_enum get_stateAtPowerOn(void);
-
-    inline Y_STATEATPOWERON_enum stateAtPowerOn(void)
-    { return this->get_stateAtPowerOn(); }
-
-    /**
-     * Preset the state of the watchdog at device startup (A for the idle position,
-     * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
-     * method, otherwise this call will have no effect.
-     *
-     * @param newval : a value among Y_STATEATPOWERON_UNCHANGED, Y_STATEATPOWERON_A and Y_STATEATPOWERON_B
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_stateAtPowerOn(Y_STATEATPOWERON_enum newval);
-    inline int      setStateAtPowerOn(Y_STATEATPOWERON_enum newval)
-    { return this->set_stateAtPowerOn(newval); }
-
-    /**
-     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
-     * switching back in to B state. Zero means no maximum time.
-     *
-     * @return an integer
-     *
-     * On failure, throws an exception or returns Y_MAXTIMEONSTATEA_INVALID.
-     */
-    s64                 get_maxTimeOnStateA(void);
-
-    inline s64          maxTimeOnStateA(void)
-    { return this->get_maxTimeOnStateA(); }
-
-    /**
-     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
-     * switching back in to B state. Use zero for no maximum time.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxTimeOnStateA(s64 newval);
-    inline int      setMaxTimeOnStateA(s64 newval)
-    { return this->set_maxTimeOnStateA(newval); }
-
-    /**
-     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
-     * switching back in to A state. Zero means no maximum time.
-     *
-     * @return an integer
-     *
-     * On failure, throws an exception or returns Y_MAXTIMEONSTATEB_INVALID.
-     */
-    s64                 get_maxTimeOnStateB(void);
-
-    inline s64          maxTimeOnStateB(void)
-    { return this->get_maxTimeOnStateB(); }
-
-    /**
-     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
-     * switching back in to A state. Use zero for no maximum time.
-     *
-     * @param newval : an integer
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_maxTimeOnStateB(s64 newval);
-    inline int      setMaxTimeOnStateB(s64 newval)
-    { return this->set_maxTimeOnStateB(newval); }
-
-    /**
-     * Returns the output state of the watchdog, when used as a simple switch (single throw).
-     *
-     * @return either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the watchdog, when
-     * used as a simple switch (single throw)
-     *
-     * On failure, throws an exception or returns Y_OUTPUT_INVALID.
-     */
-    Y_OUTPUT_enum       get_output(void);
-
-    inline Y_OUTPUT_enum output(void)
-    { return this->get_output(); }
-
-    /**
-     * Changes the output state of the watchdog, when used as a simple switch (single throw).
-     *
-     * @param newval : either Y_OUTPUT_OFF or Y_OUTPUT_ON, according to the output state of the watchdog,
-     * when used as a simple switch (single throw)
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_output(Y_OUTPUT_enum newval);
-    inline int      setOutput(Y_OUTPUT_enum newval)
-    { return this->set_output(newval); }
-
-    /**
-     * Returns the number of milliseconds remaining before the watchdog is returned to idle position
-     * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
-     *
-     * @return an integer corresponding to the number of milliseconds remaining before the watchdog is
-     * returned to idle position
-     *         (state A), during a measured pulse generation
-     *
-     * On failure, throws an exception or returns Y_PULSETIMER_INVALID.
-     */
-    s64                 get_pulseTimer(void);
-
-    inline s64          pulseTimer(void)
-    { return this->get_pulseTimer(); }
-
-    int             set_pulseTimer(s64 newval);
-    inline int      setPulseTimer(s64 newval)
-    { return this->set_pulseTimer(newval); }
-
-    /**
-     * Sets the relay to output B (active) for a specified duration, then brings it
-     * automatically back to output A (idle state).
-     *
-     * @param ms_duration : pulse duration, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             pulse(int ms_duration);
-
-    YDelayedPulse       get_delayedPulseTimer(void);
-
-    inline YDelayedPulse delayedPulseTimer(void)
-    { return this->get_delayedPulseTimer(); }
-
-    int             set_delayedPulseTimer(YDelayedPulse newval);
-    inline int      setDelayedPulseTimer(YDelayedPulse newval)
-    { return this->set_delayedPulseTimer(newval); }
-
-    /**
-     * Schedules a pulse.
-     *
-     * @param ms_delay : waiting time before the pulse, in milliseconds
-     * @param ms_duration : pulse duration, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             delayedPulse(int ms_delay,int ms_duration);
-
-    /**
-     * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
-     * When there is no scheduled pulse, returns zero.
-     *
-     * @return an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call)
-     *         When there is no scheduled pulse, returns zero
-     *
-     * On failure, throws an exception or returns Y_COUNTDOWN_INVALID.
-     */
-    s64                 get_countdown(void);
-
-    inline s64          countdown(void)
-    { return this->get_countdown(); }
-
-    /**
-     * Returns the watchdog running state at module power on.
-     *
-     * @return either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the watchdog running state at module power on
-     *
-     * On failure, throws an exception or returns Y_AUTOSTART_INVALID.
-     */
-    Y_AUTOSTART_enum    get_autoStart(void);
-
-    inline Y_AUTOSTART_enum autoStart(void)
-    { return this->get_autoStart(); }
-
-    /**
-     * Changes the watchdog running state at module power on. Remember to call the
-     * saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param newval : either Y_AUTOSTART_OFF or Y_AUTOSTART_ON, according to the watchdog running state
-     * at module power on
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_autoStart(Y_AUTOSTART_enum newval);
-    inline int      setAutoStart(Y_AUTOSTART_enum newval)
-    { return this->set_autoStart(newval); }
-
-    /**
-     * Returns the watchdog running state.
-     *
-     * @return either Y_RUNNING_OFF or Y_RUNNING_ON, according to the watchdog running state
-     *
-     * On failure, throws an exception or returns Y_RUNNING_INVALID.
-     */
-    Y_RUNNING_enum      get_running(void);
-
-    inline Y_RUNNING_enum running(void)
-    { return this->get_running(); }
-
-    /**
-     * Changes the running state of the watchdog.
-     *
-     * @param newval : either Y_RUNNING_OFF or Y_RUNNING_ON, according to the running state of the watchdog
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_running(Y_RUNNING_enum newval);
-    inline int      setRunning(Y_RUNNING_enum newval)
-    { return this->set_running(newval); }
-
-    /**
-     * Resets the watchdog. When the watchdog is running, this function
-     * must be called on a regular basis to prevent the watchdog to
-     * trigger
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             resetWatchdog(void);
-
-    /**
-     * Returns  the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.
-     *
-     * @return an integer corresponding to  the waiting duration before a reset is automatically triggered
-     * by the watchdog, in milliseconds
-     *
-     * On failure, throws an exception or returns Y_TRIGGERDELAY_INVALID.
-     */
-    s64                 get_triggerDelay(void);
-
-    inline s64          triggerDelay(void)
-    { return this->get_triggerDelay(); }
-
-    /**
-     * Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.
-     *
-     * @param newval : an integer corresponding to the waiting delay before a reset is triggered by the
-     * watchdog, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_triggerDelay(s64 newval);
-    inline int      setTriggerDelay(s64 newval)
-    { return this->set_triggerDelay(newval); }
-
-    /**
-     * Returns the duration of resets caused by the watchdog, in milliseconds.
-     *
-     * @return an integer corresponding to the duration of resets caused by the watchdog, in milliseconds
-     *
-     * On failure, throws an exception or returns Y_TRIGGERDURATION_INVALID.
-     */
-    s64                 get_triggerDuration(void);
-
-    inline s64          triggerDuration(void)
-    { return this->get_triggerDuration(); }
-
-    /**
-     * Changes the duration of resets caused by the watchdog, in milliseconds.
-     *
-     * @param newval : an integer corresponding to the duration of resets caused by the watchdog, in milliseconds
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_triggerDuration(s64 newval);
-    inline int      setTriggerDuration(s64 newval)
-    { return this->set_triggerDuration(newval); }
-
-    /**
-     * Retrieves a watchdog for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the watchdog is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YWatchdog.isOnline() to test if the watchdog is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a watchdog by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the watchdog
-     *
-     * @return a YWatchdog object allowing you to drive the watchdog.
-     */
-    static YWatchdog*   FindWatchdog(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YWatchdogValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-
-    inline static YWatchdog* Find(string func)
-    { return YWatchdog::FindWatchdog(func); }
-
-    /**
-     * Continues the enumeration of watchdog started using yFirstWatchdog().
-     * Caution: You can't make any assumption about the returned watchdog order.
-     * If you want to find a specific a watchdog, use Watchdog.findWatchdog()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YWatchdog object, corresponding to
-     *         a watchdog currently online, or a NULL pointer
-     *         if there are no more watchdog to enumerate.
-     */
-           YWatchdog       *nextWatchdog(void);
-    inline YWatchdog       *next(void)
-    { return this->nextWatchdog();}
-
-    /**
-     * Starts the enumeration of watchdog currently accessible.
-     * Use the method YWatchdog.nextWatchdog() to iterate on
-     * next watchdog.
-     *
-     * @return a pointer to a YWatchdog object, corresponding to
-     *         the first watchdog currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YWatchdog* FirstWatchdog(void);
-    inline static YWatchdog* First(void)
-    { return YWatchdog::FirstWatchdog();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YWatchdog accessors declaration)
-};
-
-//--- (YWatchdog functions declaration)
-
-/**
- * Retrieves a watchdog for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the watchdog is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWatchdog.isOnline() to test if the watchdog is
- * indeed online at a given time. In case of ambiguity when looking for
- * a watchdog by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the watchdog
- *
- * @return a YWatchdog object allowing you to drive the watchdog.
- */
-inline YWatchdog* yFindWatchdog(const string& func)
-{ return YWatchdog::FindWatchdog(func);}
-/**
- * Starts the enumeration of watchdog currently accessible.
- * Use the method YWatchdog.nextWatchdog() to iterate on
- * next watchdog.
- *
- * @return a pointer to a YWatchdog object, corresponding to
- *         the first watchdog currently online, or a NULL pointer
- *         if there are none.
- */
-inline YWatchdog* yFirstWatchdog(void)
-{ return YWatchdog::FirstWatchdog();}
-
-//--- (end of YWatchdog functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_weighscale.cpp
+++ /dev/null
@@ -1,923 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_weighscale.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- *  Implements yFindWeighScale(), the high-level API for WeighScale functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_weighscale.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "weighscale"
-
-YWeighScale::YWeighScale(const string& func): YSensor(func)
-//--- (YWeighScale initialization)
-    ,_excitation(EXCITATION_INVALID)
-    ,_tempAvgAdaptRatio(TEMPAVGADAPTRATIO_INVALID)
-    ,_tempChgAdaptRatio(TEMPCHGADAPTRATIO_INVALID)
-    ,_compTempAvg(COMPTEMPAVG_INVALID)
-    ,_compTempChg(COMPTEMPCHG_INVALID)
-    ,_compensation(COMPENSATION_INVALID)
-    ,_zeroTracking(ZEROTRACKING_INVALID)
-    ,_command(COMMAND_INVALID)
-    ,_valueCallbackWeighScale(NULL)
-    ,_timedReportCallbackWeighScale(NULL)
-//--- (end of YWeighScale initialization)
-{
-    _className="WeighScale";
-}
-
-YWeighScale::~YWeighScale()
-{
-//--- (YWeighScale cleanup)
-//--- (end of YWeighScale cleanup)
-}
-//--- (YWeighScale implementation)
-// static attributes
-const double YWeighScale::TEMPAVGADAPTRATIO_INVALID = YAPI_INVALID_DOUBLE;
-const double YWeighScale::TEMPCHGADAPTRATIO_INVALID = YAPI_INVALID_DOUBLE;
-const double YWeighScale::COMPTEMPAVG_INVALID = YAPI_INVALID_DOUBLE;
-const double YWeighScale::COMPTEMPCHG_INVALID = YAPI_INVALID_DOUBLE;
-const double YWeighScale::COMPENSATION_INVALID = YAPI_INVALID_DOUBLE;
-const double YWeighScale::ZEROTRACKING_INVALID = YAPI_INVALID_DOUBLE;
-const string YWeighScale::COMMAND_INVALID = YAPI_INVALID_STRING;
-
-int YWeighScale::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("excitation")) {
-        _excitation =  (Y_EXCITATION_enum)json_val->getInt("excitation");
-    }
-    if(json_val->has("tempAvgAdaptRatio")) {
-        _tempAvgAdaptRatio =  floor(json_val->getDouble("tempAvgAdaptRatio") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("tempChgAdaptRatio")) {
-        _tempChgAdaptRatio =  floor(json_val->getDouble("tempChgAdaptRatio") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compTempAvg")) {
-        _compTempAvg =  floor(json_val->getDouble("compTempAvg") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compTempChg")) {
-        _compTempChg =  floor(json_val->getDouble("compTempChg") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("compensation")) {
-        _compensation =  floor(json_val->getDouble("compensation") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("zeroTracking")) {
-        _zeroTracking =  floor(json_val->getDouble("zeroTracking") * 1000.0 / 65536.0 + 0.5) / 1000.0;
-    }
-    if(json_val->has("command")) {
-        _command =  json_val->getString("command");
-    }
-    return YSensor::_parseAttr(json_val);
-}
-
-
-/**
- * Changes the measuring unit for the weight.
- * Remember to call the saveToFlash() method of the module if the
- * modification must be kept.
- *
- * @param newval : a string corresponding to the measuring unit for the weight
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_unit(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("unit", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current load cell bridge excitation method.
- *
- * @return a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding to the
- * current load cell bridge excitation method
- *
- * On failure, throws an exception or returns Y_EXCITATION_INVALID.
- */
-Y_EXCITATION_enum YWeighScale::get_excitation(void)
-{
-    Y_EXCITATION_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::EXCITATION_INVALID;
-                }
-            }
-        }
-        res = _excitation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the current load cell bridge excitation method.
- *
- * @param newval : a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding
- * to the current load cell bridge excitation method
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_excitation(Y_EXCITATION_enum newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%d", newval); rest_val = string(buf);
-        res = _setAttr("excitation", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the averaged temperature update rate, in per mille.
- * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
- * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current compensation
- * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
- *
- * @param newval : a floating point number corresponding to the averaged temperature update rate, in per mille
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_tempAvgAdaptRatio(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("tempAvgAdaptRatio", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the averaged temperature update rate, in per mille.
- * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
- * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current compensation
- * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
- *
- * @return a floating point number corresponding to the averaged temperature update rate, in per mille
- *
- * On failure, throws an exception or returns Y_TEMPAVGADAPTRATIO_INVALID.
- */
-double YWeighScale::get_tempAvgAdaptRatio(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::TEMPAVGADAPTRATIO_INVALID;
-                }
-            }
-        }
-        res = _tempAvgAdaptRatio;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the temperature change update rate, in per mille.
- * The temperature change is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current temperature used for
- * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
- *
- * @param newval : a floating point number corresponding to the temperature change update rate, in per mille
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_tempChgAdaptRatio(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("tempChgAdaptRatio", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the temperature change update rate, in per mille.
- * The temperature change is updated every 10 seconds, by applying this adaptation rate
- * to the difference between the measures ambient temperature and the current temperature used for
- * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
- *
- * @return a floating point number corresponding to the temperature change update rate, in per mille
- *
- * On failure, throws an exception or returns Y_TEMPCHGADAPTRATIO_INVALID.
- */
-double YWeighScale::get_tempChgAdaptRatio(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::TEMPCHGADAPTRATIO_INVALID;
-                }
-            }
-        }
-        res = _tempChgAdaptRatio;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current averaged temperature, used for thermal compensation.
- *
- * @return a floating point number corresponding to the current averaged temperature, used for thermal compensation
- *
- * On failure, throws an exception or returns Y_COMPTEMPAVG_INVALID.
- */
-double YWeighScale::get_compTempAvg(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::COMPTEMPAVG_INVALID;
-                }
-            }
-        }
-        res = _compTempAvg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current temperature variation, used for thermal compensation.
- *
- * @return a floating point number corresponding to the current temperature variation, used for
- * thermal compensation
- *
- * On failure, throws an exception or returns Y_COMPTEMPCHG_INVALID.
- */
-double YWeighScale::get_compTempChg(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::COMPTEMPCHG_INVALID;
-                }
-            }
-        }
-        res = _compTempChg;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current current thermal compensation value.
- *
- * @return a floating point number corresponding to the current current thermal compensation value
- *
- * On failure, throws an exception or returns Y_COMPENSATION_INVALID.
- */
-double YWeighScale::get_compensation(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::COMPENSATION_INVALID;
-                }
-            }
-        }
-        res = _compensation;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Changes the zero tracking threshold value. When this threshold is larger than
- * zero, any measure under the threshold will automatically be ignored and the
- * zero compensation will be updated.
- *
- * @param newval : a floating point number corresponding to the zero tracking threshold value
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_zeroTracking(double newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        char buf[32]; sprintf(buf, "%" FMTs64, (s64)floor(newval * 65536.0 + 0.5)); rest_val = string(buf);
-        res = _setAttr("zeroTracking", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the zero tracking threshold value. When this threshold is larger than
- * zero, any measure under the threshold will automatically be ignored and the
- * zero compensation will be updated.
- *
- * @return a floating point number corresponding to the zero tracking threshold value
- *
- * On failure, throws an exception or returns Y_ZEROTRACKING_INVALID.
- */
-double YWeighScale::get_zeroTracking(void)
-{
-    double res = 0.0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::ZEROTRACKING_INVALID;
-                }
-            }
-        }
-        res = _zeroTracking;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YWeighScale::get_command(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWeighScale::COMMAND_INVALID;
-                }
-            }
-        }
-        res = _command;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YWeighScale::set_command(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("command", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a weighing scale sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the weighing scale sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWeighScale.isOnline() to test if the weighing scale sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a weighing scale sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the weighing scale sensor
- *
- * @return a YWeighScale object allowing you to drive the weighing scale sensor.
- */
-YWeighScale* YWeighScale::FindWeighScale(string func)
-{
-    YWeighScale* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YWeighScale*) YFunction::_FindFromCache("WeighScale", func);
-        if (obj == NULL) {
-            obj = new YWeighScale(func);
-            YFunction::_AddToCache("WeighScale", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YWeighScale::registerValueCallback(YWeighScaleValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackWeighScale = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YWeighScale::_invokeValueCallback(string value)
-{
-    if (_valueCallbackWeighScale != NULL) {
-        _valueCallbackWeighScale(this, value);
-    } else {
-        YSensor::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Registers the callback function that is invoked on every periodic timed notification.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and an YMeasure object describing
- *         the new advertised value.
- * @noreturn
- */
-int YWeighScale::registerTimedReportCallback(YWeighScaleTimedReportCallback callback)
-{
-    YSensor* sensor = NULL;
-    sensor = this;
-    if (callback != NULL) {
-        YFunction::_UpdateTimedReportCallbackList(sensor, true);
-    } else {
-        YFunction::_UpdateTimedReportCallbackList(sensor, false);
-    }
-    _timedReportCallbackWeighScale = callback;
-    return 0;
-}
-
-int YWeighScale::_invokeTimedReportCallback(YMeasure value)
-{
-    if (_timedReportCallbackWeighScale != NULL) {
-        _timedReportCallbackWeighScale(this, value);
-    } else {
-        YSensor::_invokeTimedReportCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Adapts the load cell signal bias (stored in the corresponding genericSensor)
- * so that the current signal corresponds to a zero weight.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::tare(void)
-{
-    return this->set_command("T");
-}
-
-/**
- * Configures the load cell span parameters (stored in the corresponding genericSensor)
- * so that the current signal corresponds to the specified reference weight.
- *
- * @param currWeight : reference weight presently on the load cell.
- * @param maxWeight : maximum weight to be expected on the load cell.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::setupSpan(double currWeight,double maxWeight)
-{
-    return this->set_command(YapiWrapper::ysprintf("S%d:%d", (int) floor(1000*currWeight+0.5),(int) floor(1000*maxWeight+0.5)));
-}
-
-int YWeighScale::setCompensationTable(int tableIndex,vector<double> tempValues,vector<double> compValues)
-{
-    int siz = 0;
-    int res = 0;
-    int idx = 0;
-    int found = 0;
-    double prev = 0.0;
-    double curr = 0.0;
-    double currComp = 0.0;
-    double idxTemp = 0.0;
-    siz = (int)tempValues.size();
-    if (!(siz != 1)) {
-        _throw(YAPI_INVALID_ARGUMENT,"thermal compensation table must have at least two points");
-        return YAPI_INVALID_ARGUMENT;
-    }
-    if (!(siz == (int)compValues.size())) {
-        _throw(YAPI_INVALID_ARGUMENT,"table sizes mismatch");
-        return YAPI_INVALID_ARGUMENT;
-    }
-
-    res = this->set_command(YapiWrapper::ysprintf("%dZ",tableIndex));
-    if (!(res==YAPI_SUCCESS)) {
-        _throw(YAPI_IO_ERROR,"unable to reset thermal compensation table");
-        return YAPI_IO_ERROR;
-    }
-    // add records in growing temperature value
-    found = 1;
-    prev = -999999.0;
-    while (found > 0) {
-        found = 0;
-        curr = 99999999.0;
-        currComp = -999999.0;
-        idx = 0;
-        while (idx < siz) {
-            idxTemp = tempValues[idx];
-            if ((idxTemp > prev) && (idxTemp < curr)) {
-                curr = idxTemp;
-                currComp = compValues[idx];
-                found = 1;
-            }
-            idx = idx + 1;
-        }
-        if (found > 0) {
-            res = this->set_command(YapiWrapper::ysprintf("%dm%d:%d", tableIndex, (int) floor(1000*curr+0.5),(int) floor(1000*currComp+0.5)));
-            if (!(res==YAPI_SUCCESS)) {
-                _throw(YAPI_IO_ERROR,"unable to set thermal compensation table");
-                return YAPI_IO_ERROR;
-            }
-            prev = curr;
-        }
-    }
-    return YAPI_SUCCESS;
-}
-
-int YWeighScale::loadCompensationTable(int tableIndex,vector<double>& tempValues,vector<double>& compValues)
-{
-    string id;
-    string bin_json;
-    vector<string> paramlist;
-    int siz = 0;
-    int idx = 0;
-    double temp = 0.0;
-    double comp = 0.0;
-
-    id = this->get_functionId();
-    id = (id).substr( 10, (int)(id).length() - 10);
-    bin_json = this->_download(YapiWrapper::ysprintf("extra.json?page=%d",(4*atoi((id).c_str()))+tableIndex));
-    paramlist = this->_json_get_array(bin_json);
-    // convert all values to float and append records
-    siz = (((int)paramlist.size()) >> (1));
-    tempValues.clear();
-    compValues.clear();
-    idx = 0;
-    while (idx < siz) {
-        temp = atof((paramlist[2*idx]).c_str())/1000.0;
-        comp = atof((paramlist[2*idx+1]).c_str())/1000.0;
-        tempValues.push_back(temp);
-        compValues.push_back(comp);
-        idx = idx + 1;
-    }
-    return YAPI_SUCCESS;
-}
-
-/**
- * Records a weight offset thermal compensation table, in order to automatically correct the
- * measured weight based on the averaged compensation temperature.
- * The weight correction will be applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, corresponding to all averaged
- *         temperatures for which an offset correction is specified.
- * @param compValues : array of floating point numbers, corresponding to the offset correction
- *         to apply for each of the temperature included in the first
- *         argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_offsetAvgCompensationTable(vector<double> tempValues,vector<double> compValues)
-{
-    return this->setCompensationTable(0, tempValues, compValues);
-}
-
-/**
- * Retrieves the weight offset thermal compensation table previously configured using the
- * set_offsetAvgCompensationTable function.
- * The weight correction is applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, that is filled by the function
- *         with all averaged temperatures for which an offset correction is specified.
- * @param compValues : array of floating point numbers, that is filled by the function
- *         with the offset correction applied for each of the temperature
- *         included in the first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::loadOffsetAvgCompensationTable(vector<double>& tempValues,vector<double>& compValues)
-{
-    return this->loadCompensationTable(0, tempValues, compValues);
-}
-
-/**
- * Records a weight offset thermal compensation table, in order to automatically correct the
- * measured weight based on the variation of temperature.
- * The weight correction will be applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, corresponding to temperature
- *         variations for which an offset correction is specified.
- * @param compValues : array of floating point numbers, corresponding to the offset correction
- *         to apply for each of the temperature variation included in the first
- *         argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_offsetChgCompensationTable(vector<double> tempValues,vector<double> compValues)
-{
-    return this->setCompensationTable(1, tempValues, compValues);
-}
-
-/**
- * Retrieves the weight offset thermal compensation table previously configured using the
- * set_offsetChgCompensationTable function.
- * The weight correction is applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, that is filled by the function
- *         with all temperature variations for which an offset correction is specified.
- * @param compValues : array of floating point numbers, that is filled by the function
- *         with the offset correction applied for each of the temperature
- *         variation included in the first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::loadOffsetChgCompensationTable(vector<double>& tempValues,vector<double>& compValues)
-{
-    return this->loadCompensationTable(1, tempValues, compValues);
-}
-
-/**
- * Records a weight span thermal compensation table, in order to automatically correct the
- * measured weight based on the compensation temperature.
- * The weight correction will be applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, corresponding to all averaged
- *         temperatures for which a span correction is specified.
- * @param compValues : array of floating point numbers, corresponding to the span correction
- *         (in percents) to apply for each of the temperature included in the first
- *         argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_spanAvgCompensationTable(vector<double> tempValues,vector<double> compValues)
-{
-    return this->setCompensationTable(2, tempValues, compValues);
-}
-
-/**
- * Retrieves the weight span thermal compensation table previously configured using the
- * set_spanAvgCompensationTable function.
- * The weight correction is applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, that is filled by the function
- *         with all averaged temperatures for which an span correction is specified.
- * @param compValues : array of floating point numbers, that is filled by the function
- *         with the span correction applied for each of the temperature
- *         included in the first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::loadSpanAvgCompensationTable(vector<double>& tempValues,vector<double>& compValues)
-{
-    return this->loadCompensationTable(2, tempValues, compValues);
-}
-
-/**
- * Records a weight span thermal compensation table, in order to automatically correct the
- * measured weight based on the variation of temperature.
- * The weight correction will be applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, corresponding to all variations of
- *         temperatures for which a span correction is specified.
- * @param compValues : array of floating point numbers, corresponding to the span correction
- *         (in percents) to apply for each of the temperature variation included
- *         in the first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::set_spanChgCompensationTable(vector<double> tempValues,vector<double> compValues)
-{
-    return this->setCompensationTable(3, tempValues, compValues);
-}
-
-/**
- * Retrieves the weight span thermal compensation table previously configured using the
- * set_spanChgCompensationTable function.
- * The weight correction is applied by linear interpolation between specified points.
- *
- * @param tempValues : array of floating point numbers, that is filled by the function
- *         with all variation of temperature for which an span correction is specified.
- * @param compValues : array of floating point numbers, that is filled by the function
- *         with the span correction applied for each of variation of temperature
- *         included in the first argument, index by index.
- *
- * @return YAPI_SUCCESS if the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWeighScale::loadSpanChgCompensationTable(vector<double>& tempValues,vector<double>& compValues)
-{
-    return this->loadCompensationTable(3, tempValues, compValues);
-}
-
-YWeighScale *YWeighScale::nextWeighScale(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YWeighScale::FindWeighScale(hwid);
-}
-
-YWeighScale* YWeighScale::FirstWeighScale(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("WeighScale", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YWeighScale::FindWeighScale(serial+"."+funcId);
-}
-
-//--- (end of YWeighScale implementation)
-
-//--- (YWeighScale functions)
-//--- (end of YWeighScale functions)
--- a/Sources/cpplib/yocto_weighscale.h
+++ /dev/null
@@ -1,618 +0,0 @@
-/*********************************************************************
- *
- *  $Id: yocto_weighscale.h 33710 2018-12-14 14:18:53Z seb $
- *
- *  Declares yFindWeighScale(), the high-level API for WeighScale functions
- *
- *  - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#ifndef YOCTO_WEIGHSCALE_H
-#define YOCTO_WEIGHSCALE_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (YWeighScale return codes)
-//--- (end of YWeighScale return codes)
-//--- (YWeighScale yapiwrapper)
-//--- (end of YWeighScale yapiwrapper)
-//--- (YWeighScale definitions)
-class YWeighScale; // forward declaration
-
-typedef void (*YWeighScaleValueCallback)(YWeighScale *func, const string& functionValue);
-class YMeasure; // forward declaration
-typedef void (*YWeighScaleTimedReportCallback)(YWeighScale *func, YMeasure measure);
-#ifndef _Y_EXCITATION_ENUM
-#define _Y_EXCITATION_ENUM
-typedef enum {
-    Y_EXCITATION_OFF = 0,
-    Y_EXCITATION_DC = 1,
-    Y_EXCITATION_AC = 2,
-    Y_EXCITATION_INVALID = -1,
-} Y_EXCITATION_enum;
-#endif
-#define Y_TEMPAVGADAPTRATIO_INVALID     (YAPI_INVALID_DOUBLE)
-#define Y_TEMPCHGADAPTRATIO_INVALID     (YAPI_INVALID_DOUBLE)
-#define Y_COMPTEMPAVG_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_COMPTEMPCHG_INVALID           (YAPI_INVALID_DOUBLE)
-#define Y_COMPENSATION_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_ZEROTRACKING_INVALID          (YAPI_INVALID_DOUBLE)
-#define Y_COMMAND_INVALID               (YAPI_INVALID_STRING)
-//--- (end of YWeighScale definitions)
-
-//--- (YWeighScale declaration)
-/**
- * YWeighScale Class: WeighScale function interface
- *
- * The YWeighScale class provides a weight measurement from a ratiometric load cell
- * sensor. It can be used to control the bridge excitation parameters, in order to avoid
- * measure shifts caused by temperature variation in the electronics, and can also
- * automatically apply an additional correction factor based on temperature to
- * compensate for offsets in the load cell itself.
- */
-class YOCTO_CLASS_EXPORT YWeighScale: public YSensor {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of YWeighScale declaration)
-protected:
-    //--- (YWeighScale attributes)
-    // Attributes (function value cache)
-    Y_EXCITATION_enum _excitation;
-    double          _tempAvgAdaptRatio;
-    double          _tempChgAdaptRatio;
-    double          _compTempAvg;
-    double          _compTempChg;
-    double          _compensation;
-    double          _zeroTracking;
-    string          _command;
-    YWeighScaleValueCallback _valueCallbackWeighScale;
-    YWeighScaleTimedReportCallback _timedReportCallbackWeighScale;
-
-    friend YWeighScale *yFindWeighScale(const string& func);
-    friend YWeighScale *yFirstWeighScale(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindWeighScale factory function to instantiate
-    YWeighScale(const string& func);
-    //--- (end of YWeighScale attributes)
-
-public:
-    virtual ~YWeighScale();
-    //--- (YWeighScale accessors declaration)
-
-    static const Y_EXCITATION_enum EXCITATION_OFF = Y_EXCITATION_OFF;
-    static const Y_EXCITATION_enum EXCITATION_DC = Y_EXCITATION_DC;
-    static const Y_EXCITATION_enum EXCITATION_AC = Y_EXCITATION_AC;
-    static const Y_EXCITATION_enum EXCITATION_INVALID = Y_EXCITATION_INVALID;
-    static const double TEMPAVGADAPTRATIO_INVALID;
-    static const double TEMPCHGADAPTRATIO_INVALID;
-    static const double COMPTEMPAVG_INVALID;
-    static const double COMPTEMPCHG_INVALID;
-    static const double COMPENSATION_INVALID;
-    static const double ZEROTRACKING_INVALID;
-    static const string COMMAND_INVALID;
-
-    /**
-     * Changes the measuring unit for the weight.
-     * Remember to call the saveToFlash() method of the module if the
-     * modification must be kept.
-     *
-     * @param newval : a string corresponding to the measuring unit for the weight
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_unit(const string& newval);
-    inline int      setUnit(const string& newval)
-    { return this->set_unit(newval); }
-
-    /**
-     * Returns the current load cell bridge excitation method.
-     *
-     * @return a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding to the
-     * current load cell bridge excitation method
-     *
-     * On failure, throws an exception or returns Y_EXCITATION_INVALID.
-     */
-    Y_EXCITATION_enum   get_excitation(void);
-
-    inline Y_EXCITATION_enum excitation(void)
-    { return this->get_excitation(); }
-
-    /**
-     * Changes the current load cell bridge excitation method.
-     *
-     * @param newval : a value among Y_EXCITATION_OFF, Y_EXCITATION_DC and Y_EXCITATION_AC corresponding
-     * to the current load cell bridge excitation method
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_excitation(Y_EXCITATION_enum newval);
-    inline int      setExcitation(Y_EXCITATION_enum newval)
-    { return this->set_excitation(newval); }
-
-    /**
-     * Changes the averaged temperature update rate, in per mille.
-     * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
-     * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current compensation
-     * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
-     *
-     * @param newval : a floating point number corresponding to the averaged temperature update rate, in per mille
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tempAvgAdaptRatio(double newval);
-    inline int      setTempAvgAdaptRatio(double newval)
-    { return this->set_tempAvgAdaptRatio(newval); }
-
-    /**
-     * Returns the averaged temperature update rate, in per mille.
-     * The purpose of this adaptation ratio is to model the thermal inertia of the load cell.
-     * The averaged temperature is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current compensation
-     * temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.
-     *
-     * @return a floating point number corresponding to the averaged temperature update rate, in per mille
-     *
-     * On failure, throws an exception or returns Y_TEMPAVGADAPTRATIO_INVALID.
-     */
-    double              get_tempAvgAdaptRatio(void);
-
-    inline double       tempAvgAdaptRatio(void)
-    { return this->get_tempAvgAdaptRatio(); }
-
-    /**
-     * Changes the temperature change update rate, in per mille.
-     * The temperature change is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current temperature used for
-     * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
-     *
-     * @param newval : a floating point number corresponding to the temperature change update rate, in per mille
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_tempChgAdaptRatio(double newval);
-    inline int      setTempChgAdaptRatio(double newval)
-    { return this->set_tempChgAdaptRatio(newval); }
-
-    /**
-     * Returns the temperature change update rate, in per mille.
-     * The temperature change is updated every 10 seconds, by applying this adaptation rate
-     * to the difference between the measures ambient temperature and the current temperature used for
-     * change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.
-     *
-     * @return a floating point number corresponding to the temperature change update rate, in per mille
-     *
-     * On failure, throws an exception or returns Y_TEMPCHGADAPTRATIO_INVALID.
-     */
-    double              get_tempChgAdaptRatio(void);
-
-    inline double       tempChgAdaptRatio(void)
-    { return this->get_tempChgAdaptRatio(); }
-
-    /**
-     * Returns the current averaged temperature, used for thermal compensation.
-     *
-     * @return a floating point number corresponding to the current averaged temperature, used for thermal compensation
-     *
-     * On failure, throws an exception or returns Y_COMPTEMPAVG_INVALID.
-     */
-    double              get_compTempAvg(void);
-
-    inline double       compTempAvg(void)
-    { return this->get_compTempAvg(); }
-
-    /**
-     * Returns the current temperature variation, used for thermal compensation.
-     *
-     * @return a floating point number corresponding to the current temperature variation, used for
-     * thermal compensation
-     *
-     * On failure, throws an exception or returns Y_COMPTEMPCHG_INVALID.
-     */
-    double              get_compTempChg(void);
-
-    inline double       compTempChg(void)
-    { return this->get_compTempChg(); }
-
-    /**
-     * Returns the current current thermal compensation value.
-     *
-     * @return a floating point number corresponding to the current current thermal compensation value
-     *
-     * On failure, throws an exception or returns Y_COMPENSATION_INVALID.
-     */
-    double              get_compensation(void);
-
-    inline double       compensation(void)
-    { return this->get_compensation(); }
-
-    /**
-     * Changes the zero tracking threshold value. When this threshold is larger than
-     * zero, any measure under the threshold will automatically be ignored and the
-     * zero compensation will be updated.
-     *
-     * @param newval : a floating point number corresponding to the zero tracking threshold value
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    int             set_zeroTracking(double newval);
-    inline int      setZeroTracking(double newval)
-    { return this->set_zeroTracking(newval); }
-
-    /**
-     * Returns the zero tracking threshold value. When this threshold is larger than
-     * zero, any measure under the threshold will automatically be ignored and the
-     * zero compensation will be updated.
-     *
-     * @return a floating point number corresponding to the zero tracking threshold value
-     *
-     * On failure, throws an exception or returns Y_ZEROTRACKING_INVALID.
-     */
-    double              get_zeroTracking(void);
-
-    inline double       zeroTracking(void)
-    { return this->get_zeroTracking(); }
-
-    string              get_command(void);
-
-    inline string       command(void)
-    { return this->get_command(); }
-
-    int             set_command(const string& newval);
-    inline int      setCommand(const string& newval)
-    { return this->set_command(newval); }
-
-    /**
-     * Retrieves a weighing scale sensor for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the weighing scale sensor is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YWeighScale.isOnline() to test if the weighing scale sensor is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a weighing scale sensor by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the weighing scale sensor
-     *
-     * @return a YWeighScale object allowing you to drive the weighing scale sensor.
-     */
-    static YWeighScale* FindWeighScale(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YWeighScaleValueCallback callback);
-    using YSensor::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Registers the callback function that is invoked on every periodic timed notification.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and an YMeasure object describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerTimedReportCallback(YWeighScaleTimedReportCallback callback);
-    using YSensor::registerTimedReportCallback;
-
-    virtual int         _invokeTimedReportCallback(YMeasure value);
-
-    /**
-     * Adapts the load cell signal bias (stored in the corresponding genericSensor)
-     * so that the current signal corresponds to a zero weight.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         tare(void);
-
-    /**
-     * Configures the load cell span parameters (stored in the corresponding genericSensor)
-     * so that the current signal corresponds to the specified reference weight.
-     *
-     * @param currWeight : reference weight presently on the load cell.
-     * @param maxWeight : maximum weight to be expected on the load cell.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         setupSpan(double currWeight,double maxWeight);
-
-    virtual int         setCompensationTable(int tableIndex,vector<double> tempValues,vector<double> compValues);
-
-    virtual int         loadCompensationTable(int tableIndex,vector<double>& tempValues,vector<double>& compValues);
-
-    /**
-     * Records a weight offset thermal compensation table, in order to automatically correct the
-     * measured weight based on the averaged compensation temperature.
-     * The weight correction will be applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, corresponding to all averaged
-     *         temperatures for which an offset correction is specified.
-     * @param compValues : array of floating point numbers, corresponding to the offset correction
-     *         to apply for each of the temperature included in the first
-     *         argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_offsetAvgCompensationTable(vector<double> tempValues,vector<double> compValues);
-
-    /**
-     * Retrieves the weight offset thermal compensation table previously configured using the
-     * set_offsetAvgCompensationTable function.
-     * The weight correction is applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, that is filled by the function
-     *         with all averaged temperatures for which an offset correction is specified.
-     * @param compValues : array of floating point numbers, that is filled by the function
-     *         with the offset correction applied for each of the temperature
-     *         included in the first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadOffsetAvgCompensationTable(vector<double>& tempValues,vector<double>& compValues);
-
-    /**
-     * Records a weight offset thermal compensation table, in order to automatically correct the
-     * measured weight based on the variation of temperature.
-     * The weight correction will be applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, corresponding to temperature
-     *         variations for which an offset correction is specified.
-     * @param compValues : array of floating point numbers, corresponding to the offset correction
-     *         to apply for each of the temperature variation included in the first
-     *         argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_offsetChgCompensationTable(vector<double> tempValues,vector<double> compValues);
-
-    /**
-     * Retrieves the weight offset thermal compensation table previously configured using the
-     * set_offsetChgCompensationTable function.
-     * The weight correction is applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, that is filled by the function
-     *         with all temperature variations for which an offset correction is specified.
-     * @param compValues : array of floating point numbers, that is filled by the function
-     *         with the offset correction applied for each of the temperature
-     *         variation included in the first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadOffsetChgCompensationTable(vector<double>& tempValues,vector<double>& compValues);
-
-    /**
-     * Records a weight span thermal compensation table, in order to automatically correct the
-     * measured weight based on the compensation temperature.
-     * The weight correction will be applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, corresponding to all averaged
-     *         temperatures for which a span correction is specified.
-     * @param compValues : array of floating point numbers, corresponding to the span correction
-     *         (in percents) to apply for each of the temperature included in the first
-     *         argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_spanAvgCompensationTable(vector<double> tempValues,vector<double> compValues);
-
-    /**
-     * Retrieves the weight span thermal compensation table previously configured using the
-     * set_spanAvgCompensationTable function.
-     * The weight correction is applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, that is filled by the function
-     *         with all averaged temperatures for which an span correction is specified.
-     * @param compValues : array of floating point numbers, that is filled by the function
-     *         with the span correction applied for each of the temperature
-     *         included in the first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadSpanAvgCompensationTable(vector<double>& tempValues,vector<double>& compValues);
-
-    /**
-     * Records a weight span thermal compensation table, in order to automatically correct the
-     * measured weight based on the variation of temperature.
-     * The weight correction will be applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, corresponding to all variations of
-     *         temperatures for which a span correction is specified.
-     * @param compValues : array of floating point numbers, corresponding to the span correction
-     *         (in percents) to apply for each of the temperature variation included
-     *         in the first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         set_spanChgCompensationTable(vector<double> tempValues,vector<double> compValues);
-
-    /**
-     * Retrieves the weight span thermal compensation table previously configured using the
-     * set_spanChgCompensationTable function.
-     * The weight correction is applied by linear interpolation between specified points.
-     *
-     * @param tempValues : array of floating point numbers, that is filled by the function
-     *         with all variation of temperature for which an span correction is specified.
-     * @param compValues : array of floating point numbers, that is filled by the function
-     *         with the span correction applied for each of variation of temperature
-     *         included in the first argument, index by index.
-     *
-     * @return YAPI_SUCCESS if the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         loadSpanChgCompensationTable(vector<double>& tempValues,vector<double>& compValues);
-
-
-    inline static YWeighScale* Find(string func)
-    { return YWeighScale::FindWeighScale(func); }
-
-    /**
-     * Continues the enumeration of weighing scale sensors started using yFirstWeighScale().
-     * Caution: You can't make any assumption about the returned weighing scale sensors order.
-     * If you want to find a specific a weighing scale sensor, use WeighScale.findWeighScale()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YWeighScale object, corresponding to
-     *         a weighing scale sensor currently online, or a NULL pointer
-     *         if there are no more weighing scale sensors to enumerate.
-     */
-           YWeighScale     *nextWeighScale(void);
-    inline YWeighScale     *next(void)
-    { return this->nextWeighScale();}
-
-    /**
-     * Starts the enumeration of weighing scale sensors currently accessible.
-     * Use the method YWeighScale.nextWeighScale() to iterate on
-     * next weighing scale sensors.
-     *
-     * @return a pointer to a YWeighScale object, corresponding to
-     *         the first weighing scale sensor currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YWeighScale* FirstWeighScale(void);
-    inline static YWeighScale* First(void)
-    { return YWeighScale::FirstWeighScale();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of YWeighScale accessors declaration)
-};
-
-//--- (YWeighScale functions declaration)
-
-/**
- * Retrieves a weighing scale sensor for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the weighing scale sensor is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWeighScale.isOnline() to test if the weighing scale sensor is
- * indeed online at a given time. In case of ambiguity when looking for
- * a weighing scale sensor by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the weighing scale sensor
- *
- * @return a YWeighScale object allowing you to drive the weighing scale sensor.
- */
-inline YWeighScale* yFindWeighScale(const string& func)
-{ return YWeighScale::FindWeighScale(func);}
-/**
- * Starts the enumeration of weighing scale sensors currently accessible.
- * Use the method YWeighScale.nextWeighScale() to iterate on
- * next weighing scale sensors.
- *
- * @return a pointer to a YWeighScale object, corresponding to
- *         the first weighing scale sensor currently online, or a NULL pointer
- *         if there are none.
- */
-inline YWeighScale* yFirstWeighScale(void)
-{ return YWeighScale::FirstWeighScale();}
-
-//--- (end of YWeighScale functions declaration)
-
-#endif
--- a/Sources/cpplib/yocto_wireless.cpp
+++ /dev/null
@@ -1,631 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_wireless.cpp 33710 2018-12-14 14:18:53Z seb $
- *
- * Implements yFindWireless(), the high-level API for Wireless functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-
-#define _CRT_SECURE_NO_DEPRECATE //do not use windows secure crt
-#include "yocto_wireless.h"
-#include "yapi/yjson.h"
-#include "yapi/yapi.h"
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#define  __FILE_ID__  "wireless"
-
-
-
-YWlanRecord::YWlanRecord(const string& json):
-//--- (generated code: YWlanRecord initialization)
-    _channel(0)
-    ,_rssi(0)
-//--- (end of generated code: YWlanRecord initialization)
-{
-    yJsonStateMachine j;
-
-    // Parse JSON data
-    j.src = json.c_str();
-    j.end = j.src + strlen(j.src);
-    j.st = YJSON_START;
-    if(yJsonParse(&j) != YJSON_PARSE_AVAIL || j.st != YJSON_PARSE_STRUCT) {
-        return ;
-    }
-    while(yJsonParse(&j) == YJSON_PARSE_AVAIL && j.st == YJSON_PARSE_MEMBNAME) {
-        if (!strcmp(j.token, "ssid")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return ;
-            }
-            _ssid = (string)j.token;
-            while(j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-                _ssid +=(string)j.token;
-            }
-        }else if (!strcmp(j.token, "sec")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return ;
-            }
-            _sec = (string)j.token;
-            while(j.next == YJSON_PARSE_STRINGCONT && yJsonParse(&j) == YJSON_PARSE_AVAIL) {
-                _sec +=(string)j.token;
-            }
-        } else if(!strcmp(j.token, "channel")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return;
-            }
-            _channel = atoi(j.token);;
-        } else if(!strcmp(j.token, "rssi")) {
-            if (yJsonParse(&j) != YJSON_PARSE_AVAIL) {
-                return;
-            }
-            _rssi = atoi(j.token);;
-        } else {
-            yJsonSkip(&j, 1);
-        }
-    }
-}
-
-//--- (generated code: YWlanRecord implementation)
-// static attributes
-
-
-string YWlanRecord::get_ssid(void)
-{
-    return _ssid;
-}
-
-int YWlanRecord::get_channel(void)
-{
-    return _channel;
-}
-
-string YWlanRecord::get_security(void)
-{
-    return _sec;
-}
-
-int YWlanRecord::get_linkQuality(void)
-{
-    return _rssi;
-}
-//--- (end of generated code: YWlanRecord implementation)
-
-
-YWireless::YWireless(const string& func): YFunction(func)
-//--- (generated code: YWireless initialization)
-    ,_linkQuality(LINKQUALITY_INVALID)
-    ,_ssid(SSID_INVALID)
-    ,_channel(CHANNEL_INVALID)
-    ,_security(SECURITY_INVALID)
-    ,_message(MESSAGE_INVALID)
-    ,_wlanConfig(WLANCONFIG_INVALID)
-    ,_wlanState(WLANSTATE_INVALID)
-    ,_valueCallbackWireless(NULL)
-//--- (end of generated code: YWireless initialization)
-{
-    _className = "Wireless";
-}
-
-YWireless::~YWireless()
-{
-//--- (generated code: YWireless cleanup)
-//--- (end of generated code: YWireless cleanup)
-}
-//--- (generated code: YWireless implementation)
-// static attributes
-const string YWireless::SSID_INVALID = YAPI_INVALID_STRING;
-const string YWireless::MESSAGE_INVALID = YAPI_INVALID_STRING;
-const string YWireless::WLANCONFIG_INVALID = YAPI_INVALID_STRING;
-
-int YWireless::_parseAttr(YJSONObject* json_val)
-{
-    if(json_val->has("linkQuality")) {
-        _linkQuality =  json_val->getInt("linkQuality");
-    }
-    if(json_val->has("ssid")) {
-        _ssid =  json_val->getString("ssid");
-    }
-    if(json_val->has("channel")) {
-        _channel =  json_val->getInt("channel");
-    }
-    if(json_val->has("security")) {
-        _security =  (Y_SECURITY_enum)json_val->getInt("security");
-    }
-    if(json_val->has("message")) {
-        _message =  json_val->getString("message");
-    }
-    if(json_val->has("wlanConfig")) {
-        _wlanConfig =  json_val->getString("wlanConfig");
-    }
-    if(json_val->has("wlanState")) {
-        _wlanState =  (Y_WLANSTATE_enum)json_val->getInt("wlanState");
-    }
-    return YFunction::_parseAttr(json_val);
-}
-
-
-/**
- * Returns the link quality, expressed in percent.
- *
- * @return an integer corresponding to the link quality, expressed in percent
- *
- * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
- */
-int YWireless::get_linkQuality(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::LINKQUALITY_INVALID;
-                }
-            }
-        }
-        res = _linkQuality;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the wireless network name (SSID).
- *
- * @return a string corresponding to the wireless network name (SSID)
- *
- * On failure, throws an exception or returns Y_SSID_INVALID.
- */
-string YWireless::get_ssid(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::SSID_INVALID;
-                }
-            }
-        }
-        res = _ssid;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the 802.11 channel currently used, or 0 when the selected network has not been found.
- *
- * @return an integer corresponding to the 802.11 channel currently used, or 0 when the selected
- * network has not been found
- *
- * On failure, throws an exception or returns Y_CHANNEL_INVALID.
- */
-int YWireless::get_channel(void)
-{
-    int res = 0;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::CHANNEL_INVALID;
-                }
-            }
-        }
-        res = _channel;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the security algorithm used by the selected wireless network.
- *
- * @return a value among Y_SECURITY_UNKNOWN, Y_SECURITY_OPEN, Y_SECURITY_WEP, Y_SECURITY_WPA and
- * Y_SECURITY_WPA2 corresponding to the security algorithm used by the selected wireless network
- *
- * On failure, throws an exception or returns Y_SECURITY_INVALID.
- */
-Y_SECURITY_enum YWireless::get_security(void)
-{
-    Y_SECURITY_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::SECURITY_INVALID;
-                }
-            }
-        }
-        res = _security;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the latest status message from the wireless interface.
- *
- * @return a string corresponding to the latest status message from the wireless interface
- *
- * On failure, throws an exception or returns Y_MESSAGE_INVALID.
- */
-string YWireless::get_message(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::MESSAGE_INVALID;
-                }
-            }
-        }
-        res = _message;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-string YWireless::get_wlanConfig(void)
-{
-    string res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::WLANCONFIG_INVALID;
-                }
-            }
-        }
-        res = _wlanConfig;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-int YWireless::set_wlanConfig(const string& newval)
-{
-    string rest_val;
-    int res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        rest_val = newval;
-        res = _setAttr("wlanConfig", rest_val);
-    } catch (std::exception) {
-         yLeaveCriticalSection(&_this_cs);
-         throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Returns the current state of the wireless interface. The state Y_WLANSTATE_DOWN means that the
- * network interface is
- * not connected to a network. The state Y_WLANSTATE_SCANNING means that the network interface is
- * scanning available
- * frequencies. During this stage, the device is not reachable, and the network settings are not yet
- * applied. The state
- * Y_WLANSTATE_CONNECTED means that the network settings have been successfully applied ant that the
- * device is reachable
- * from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that
- * the wireless network
- * is up and that other devices can join the network. The state Y_WLANSTATE_REJECTED means that the
- * network interface has
- * not been able to join the requested network. The description of the error can be obtain with the
- * get_message() method.
- *
- * @return a value among Y_WLANSTATE_DOWN, Y_WLANSTATE_SCANNING, Y_WLANSTATE_CONNECTED and
- * Y_WLANSTATE_REJECTED corresponding to the current state of the wireless interface
- *
- * On failure, throws an exception or returns Y_WLANSTATE_INVALID.
- */
-Y_WLANSTATE_enum YWireless::get_wlanState(void)
-{
-    Y_WLANSTATE_enum res;
-    yEnterCriticalSection(&_this_cs);
-    try {
-        if (_cacheExpiration <= YAPI::GetTickCount()) {
-            if (this->_load_unsafe(YAPI::_yapiContext.GetCacheValidity()) != YAPI_SUCCESS) {
-                {
-                    yLeaveCriticalSection(&_this_cs);
-                    return YWireless::WLANSTATE_INVALID;
-                }
-            }
-        }
-        res = _wlanState;
-    } catch (std::exception) {
-        yLeaveCriticalSection(&_this_cs);
-        throw;
-    }
-    yLeaveCriticalSection(&_this_cs);
-    return res;
-}
-
-/**
- * Retrieves a wireless lan interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the wireless lan interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWireless.isOnline() to test if the wireless lan interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a wireless lan interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the wireless lan interface
- *
- * @return a YWireless object allowing you to drive the wireless lan interface.
- */
-YWireless* YWireless::FindWireless(string func)
-{
-    YWireless* obj = NULL;
-    int taken = 0;
-    if (YAPI::_apiInitialized) {
-        yEnterCriticalSection(&YAPI::_global_cs);
-        taken = 1;
-    }try {
-        obj = (YWireless*) YFunction::_FindFromCache("Wireless", func);
-        if (obj == NULL) {
-            obj = new YWireless(func);
-            YFunction::_AddToCache("Wireless", func, obj);
-        }
-    } catch (std::exception) {
-        if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-        throw;
-    }
-    if (taken) yLeaveCriticalSection(&YAPI::_global_cs);
-    return obj;
-}
-
-/**
- * Registers the callback function that is invoked on every change of advertised value.
- * The callback is invoked only during the execution of ySleep or yHandleEvents.
- * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
- * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
- *
- * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
- *         arguments: the function object of which the value has changed, and the character string describing
- *         the new advertised value.
- * @noreturn
- */
-int YWireless::registerValueCallback(YWirelessValueCallback callback)
-{
-    string val;
-    if (callback != NULL) {
-        YFunction::_UpdateValueCallbackList(this, true);
-    } else {
-        YFunction::_UpdateValueCallbackList(this, false);
-    }
-    _valueCallbackWireless = callback;
-    // Immediately invoke value callback with current value
-    if (callback != NULL && this->isOnline()) {
-        val = _advertisedValue;
-        if (!(val == "")) {
-            this->_invokeValueCallback(val);
-        }
-    }
-    return 0;
-}
-
-int YWireless::_invokeValueCallback(string value)
-{
-    if (_valueCallbackWireless != NULL) {
-        _valueCallbackWireless(this, value);
-    } else {
-        YFunction::_invokeValueCallback(value);
-    }
-    return 0;
-}
-
-/**
- * Triggers a scan of the wireless frequency and builds the list of available networks.
- * The scan forces a disconnection from the current network. At then end of the process, the
- * the network interface attempts to reconnect to the previous network. During the scan, the wlanState
- * switches to Y_WLANSTATE_DOWN, then to Y_WLANSTATE_SCANNING. When the scan is completed,
- * get_wlanState() returns either Y_WLANSTATE_DOWN or Y_WLANSTATE_SCANNING. At this
- * point, the list of detected network can be retrieved with the get_detectedWlans() method.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWireless::startWlanScan(void)
-{
-    string config;
-    config = this->get_wlanConfig();
-    // a full scan is triggered when a config is applied
-    return this->set_wlanConfig(config);
-}
-
-/**
- * Changes the configuration of the wireless lan interface to connect to an existing
- * access point (infrastructure mode).
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param ssid : the name of the network to connect to
- * @param securityKey : the network key, as a character string
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWireless::joinNetwork(string ssid,string securityKey)
-{
-    return this->set_wlanConfig(YapiWrapper::ysprintf("INFRA:%s\\%s", ssid.c_str(),securityKey.c_str()));
-}
-
-/**
- * Changes the configuration of the wireless lan interface to create an ad-hoc
- * wireless network, without using an access point. On the YoctoHub-Wireless-g,
- * it is best to use softAPNetworkInstead(), which emulates an access point
- * (Soft AP) which is more efficient and more widely supported than ad-hoc networks.
- *
- * When a security key is specified for an ad-hoc network, the network is protected
- * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
- * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
- * using 26 hexadecimal digits to maximize security.
- * Remember to call the saveToFlash() method and then to reboot the module
- * to apply this setting.
- *
- * @param ssid : the name of the network to connect to
- * @param securityKey : the network key, as a character string
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWireless::adhocNetwork(string ssid,string securityKey)
-{
-    return this->set_wlanConfig(YapiWrapper::ysprintf("ADHOC:%s\\%s", ssid.c_str(),securityKey.c_str()));
-}
-
-/**
- * Changes the configuration of the wireless lan interface to create a new wireless
- * network by emulating a WiFi access point (Soft AP). This function can only be
- * used with the YoctoHub-Wireless-g.
- *
- * When a security key is specified for a SoftAP network, the network is protected
- * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
- * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
- * using 26 hexadecimal digits to maximize security.
- * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
- *
- * @param ssid : the name of the network to connect to
- * @param securityKey : the network key, as a character string
- *
- * @return YAPI_SUCCESS when the call succeeds.
- *
- * On failure, throws an exception or returns a negative error code.
- */
-int YWireless::softAPNetwork(string ssid,string securityKey)
-{
-    return this->set_wlanConfig(YapiWrapper::ysprintf("SOFTAP:%s\\%s", ssid.c_str(),securityKey.c_str()));
-}
-
-/**
- * Returns a list of YWlanRecord objects that describe detected Wireless networks.
- * This list is not updated when the module is already connected to an access point (infrastructure mode).
- * To force an update of this list, startWlanScan() must be called.
- * Note that an languages without garbage collections, the returned list must be freed by the caller.
- *
- * @return a list of YWlanRecord objects, containing the SSID, channel,
- *         link quality and the type of security of the wireless network.
- *
- * On failure, throws an exception or returns an empty list.
- */
-vector<YWlanRecord> YWireless::get_detectedWlans(void)
-{
-    string json;
-    vector<string> wlanlist;
-    vector<YWlanRecord> res;
-
-    json = this->_download("wlan.json?by=name");
-    wlanlist = this->_json_get_array(json);
-    res.clear();
-    for (unsigned ii = 0; ii < wlanlist.size(); ii++) {
-        res.push_back(YWlanRecord(wlanlist[ii]));
-    }
-    return res;
-}
-
-YWireless *YWireless::nextWireless(void)
-{
-    string  hwid;
-
-    if(YISERR(_nextFunction(hwid)) || hwid=="") {
-        return NULL;
-    }
-    return YWireless::FindWireless(hwid);
-}
-
-YWireless* YWireless::FirstWireless(void)
-{
-    vector<YFUN_DESCR>   v_fundescr;
-    YDEV_DESCR             ydevice;
-    string              serial, funcId, funcName, funcVal, errmsg;
-
-    if(YISERR(YapiWrapper::getFunctionsByClass("Wireless", 0, v_fundescr, sizeof(YFUN_DESCR), errmsg)) ||
-       v_fundescr.size() == 0 ||
-       YISERR(YapiWrapper::getFunctionInfo(v_fundescr[0], ydevice, serial, funcId, funcName, funcVal, errmsg))) {
-        return NULL;
-    }
-    return YWireless::FindWireless(serial+"."+funcId);
-}
-
-//--- (end of generated code: YWireless implementation)
-
-//--- (generated code: YWireless functions)
-//--- (end of generated code: YWireless functions)
--- a/Sources/cpplib/yocto_wireless.h
+++ /dev/null
@@ -1,491 +0,0 @@
-/*********************************************************************
- *
- * $Id: yocto_wireless.h 33710 2018-12-14 14:18:53Z seb $
- *
- * Declares yFindWireless(), the high-level API for Wireless functions
- *
- * - - - - - - - - - License information: - - - - - - - - -
- *
- *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
- *
- *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
- *  non-exclusive license to use, modify, copy and integrate this
- *  file into your software for the sole purpose of interfacing
- *  with Yoctopuce products.
- *
- *  You may reproduce and distribute copies of this file in
- *  source or object form, as long as the sole purpose of this
- *  code is to interface with Yoctopuce products. You must retain
- *  this notice in the distributed source file.
- *
- *  You should refer to Yoctopuce General Terms and Conditions
- *  for additional information regarding your rights and
- *  obligations.
- *
- *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
- *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
- *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
- *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
- *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
- *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
- *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
- *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
- *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
- *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
- *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
- *  WARRANTY, OR OTHERWISE.
- *
- *********************************************************************/
-
-#ifndef YOCTO_WIRELESS_H
-#define YOCTO_WIRELESS_H
-
-#include "yocto_api.h"
-#include <cfloat>
-#include <cmath>
-#include <map>
-
-//--- (generated code: YWireless definitions)
-class YWireless; // forward declaration
-
-typedef void (*YWirelessValueCallback)(YWireless *func, const string& functionValue);
-#ifndef _Y_SECURITY_ENUM
-#define _Y_SECURITY_ENUM
-typedef enum {
-    Y_SECURITY_UNKNOWN = 0,
-    Y_SECURITY_OPEN = 1,
-    Y_SECURITY_WEP = 2,
-    Y_SECURITY_WPA = 3,
-    Y_SECURITY_WPA2 = 4,
-    Y_SECURITY_INVALID = -1,
-} Y_SECURITY_enum;
-#endif
-#ifndef _Y_WLANSTATE_ENUM
-#define _Y_WLANSTATE_ENUM
-typedef enum {
-    Y_WLANSTATE_DOWN = 0,
-    Y_WLANSTATE_SCANNING = 1,
-    Y_WLANSTATE_CONNECTED = 2,
-    Y_WLANSTATE_REJECTED = 3,
-    Y_WLANSTATE_INVALID = -1,
-} Y_WLANSTATE_enum;
-#endif
-#define Y_LINKQUALITY_INVALID           (YAPI_INVALID_UINT)
-#define Y_SSID_INVALID                  (YAPI_INVALID_STRING)
-#define Y_CHANNEL_INVALID               (YAPI_INVALID_UINT)
-#define Y_MESSAGE_INVALID               (YAPI_INVALID_STRING)
-#define Y_WLANCONFIG_INVALID            (YAPI_INVALID_STRING)
-//--- (end of generated code: YWireless definitions)
-
-
-//--- (generated code: YWlanRecord definitions)
-//--- (end of generated code: YWlanRecord definitions)
-
-//--- (generated code: YWlanRecord declaration)
-/**
- * YWlanRecord Class: Description of a wireless network
- *
- *
- */
-class YOCTO_CLASS_EXPORT YWlanRecord {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YWlanRecord declaration)
-    //--- (generated code: YWlanRecord attributes)
-    // Attributes (function value cache)
-    string          _ssid;
-    int             _channel;
-    string          _sec;
-    int             _rssi;
-    //--- (end of generated code: YWlanRecord attributes)
-    //--- (generated code: YWlanRecord constructor)
-
-    //--- (end of generated code: YWlanRecord constructor)
-    //--- (generated code: YWlanRecord initialization)
-    //--- (end of generated code: YWlanRecord initialization)
-
-public:
-    YWlanRecord(const string& json);
-    virtual ~YWlanRecord(){};
-    //--- (generated code: YWlanRecord accessors declaration)
-
-
-    virtual string      get_ssid(void);
-
-    virtual int         get_channel(void);
-
-    virtual string      get_security(void);
-
-    virtual int         get_linkQuality(void);
-
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YWlanRecord accessors declaration)
-};
-
-
-
-
-//--- (generated code: YWireless declaration)
-/**
- * YWireless Class: Wireless function interface
- *
- * YWireless functions provides control over wireless network parameters
- * and status for devices that are wireless-enabled.
- */
-class YOCTO_CLASS_EXPORT YWireless: public YFunction {
-#ifdef __BORLANDC__
-#pragma option push -w-8022
-#endif
-//--- (end of generated code: YWireless declaration)
-    //--- (generated code: YWireless attributes)
-    // Attributes (function value cache)
-    int             _linkQuality;
-    string          _ssid;
-    int             _channel;
-    Y_SECURITY_enum _security;
-    string          _message;
-    string          _wlanConfig;
-    Y_WLANSTATE_enum _wlanState;
-    YWirelessValueCallback _valueCallbackWireless;
-
-    friend YWireless *yFindWireless(const string& func);
-    friend YWireless *yFirstWireless(void);
-
-    // Function-specific method for parsing of JSON output and caching result
-    virtual int     _parseAttr(YJSONObject* json_val);
-
-    // Constructor is protected, use yFindWireless factory function to instantiate
-    YWireless(const string& func);
-    //--- (end of generated code: YWireless attributes)
-    //--- (generated code: YWireless initialization)
-    //--- (end of generated code: YWireless initialization)
-
-public:
-    ~YWireless();
-    //--- (generated code: YWireless accessors declaration)
-
-    static const int LINKQUALITY_INVALID = YAPI_INVALID_UINT;
-    static const string SSID_INVALID;
-    static const int CHANNEL_INVALID = YAPI_INVALID_UINT;
-    static const Y_SECURITY_enum SECURITY_UNKNOWN = Y_SECURITY_UNKNOWN;
-    static const Y_SECURITY_enum SECURITY_OPEN = Y_SECURITY_OPEN;
-    static const Y_SECURITY_enum SECURITY_WEP = Y_SECURITY_WEP;
-    static const Y_SECURITY_enum SECURITY_WPA = Y_SECURITY_WPA;
-    static const Y_SECURITY_enum SECURITY_WPA2 = Y_SECURITY_WPA2;
-    static const Y_SECURITY_enum SECURITY_INVALID = Y_SECURITY_INVALID;
-    static const string MESSAGE_INVALID;
-    static const string WLANCONFIG_INVALID;
-    static const Y_WLANSTATE_enum WLANSTATE_DOWN = Y_WLANSTATE_DOWN;
-    static const Y_WLANSTATE_enum WLANSTATE_SCANNING = Y_WLANSTATE_SCANNING;
-    static const Y_WLANSTATE_enum WLANSTATE_CONNECTED = Y_WLANSTATE_CONNECTED;
-    static const Y_WLANSTATE_enum WLANSTATE_REJECTED = Y_WLANSTATE_REJECTED;
-    static const Y_WLANSTATE_enum WLANSTATE_INVALID = Y_WLANSTATE_INVALID;
-
-    /**
-     * Returns the link quality, expressed in percent.
-     *
-     * @return an integer corresponding to the link quality, expressed in percent
-     *
-     * On failure, throws an exception or returns Y_LINKQUALITY_INVALID.
-     */
-    int                 get_linkQuality(void);
-
-    inline int          linkQuality(void)
-    { return this->get_linkQuality(); }
-
-    /**
-     * Returns the wireless network name (SSID).
-     *
-     * @return a string corresponding to the wireless network name (SSID)
-     *
-     * On failure, throws an exception or returns Y_SSID_INVALID.
-     */
-    string              get_ssid(void);
-
-    inline string       ssid(void)
-    { return this->get_ssid(); }
-
-    /**
-     * Returns the 802.11 channel currently used, or 0 when the selected network has not been found.
-     *
-     * @return an integer corresponding to the 802.11 channel currently used, or 0 when the selected
-     * network has not been found
-     *
-     * On failure, throws an exception or returns Y_CHANNEL_INVALID.
-     */
-    int                 get_channel(void);
-
-    inline int          channel(void)
-    { return this->get_channel(); }
-
-    /**
-     * Returns the security algorithm used by the selected wireless network.
-     *
-     * @return a value among Y_SECURITY_UNKNOWN, Y_SECURITY_OPEN, Y_SECURITY_WEP, Y_SECURITY_WPA and
-     * Y_SECURITY_WPA2 corresponding to the security algorithm used by the selected wireless network
-     *
-     * On failure, throws an exception or returns Y_SECURITY_INVALID.
-     */
-    Y_SECURITY_enum     get_security(void);
-
-    inline Y_SECURITY_enum security(void)
-    { return this->get_security(); }
-
-    /**
-     * Returns the latest status message from the wireless interface.
-     *
-     * @return a string corresponding to the latest status message from the wireless interface
-     *
-     * On failure, throws an exception or returns Y_MESSAGE_INVALID.
-     */
-    string              get_message(void);
-
-    inline string       message(void)
-    { return this->get_message(); }
-
-    string              get_wlanConfig(void);
-
-    inline string       wlanConfig(void)
-    { return this->get_wlanConfig(); }
-
-    int             set_wlanConfig(const string& newval);
-    inline int      setWlanConfig(const string& newval)
-    { return this->set_wlanConfig(newval); }
-
-    /**
-     * Returns the current state of the wireless interface. The state Y_WLANSTATE_DOWN means that the
-     * network interface is
-     * not connected to a network. The state Y_WLANSTATE_SCANNING means that the network interface is
-     * scanning available
-     * frequencies. During this stage, the device is not reachable, and the network settings are not yet
-     * applied. The state
-     * Y_WLANSTATE_CONNECTED means that the network settings have been successfully applied ant that the
-     * device is reachable
-     * from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that
-     * the wireless network
-     * is up and that other devices can join the network. The state Y_WLANSTATE_REJECTED means that the
-     * network interface has
-     * not been able to join the requested network. The description of the error can be obtain with the
-     * get_message() method.
-     *
-     * @return a value among Y_WLANSTATE_DOWN, Y_WLANSTATE_SCANNING, Y_WLANSTATE_CONNECTED and
-     * Y_WLANSTATE_REJECTED corresponding to the current state of the wireless interface
-     *
-     * On failure, throws an exception or returns Y_WLANSTATE_INVALID.
-     */
-    Y_WLANSTATE_enum    get_wlanState(void);
-
-    inline Y_WLANSTATE_enum wlanState(void)
-    { return this->get_wlanState(); }
-
-    /**
-     * Retrieves a wireless lan interface for a given identifier.
-     * The identifier can be specified using several formats:
-     * <ul>
-     * <li>FunctionLogicalName</li>
-     * <li>ModuleSerialNumber.FunctionIdentifier</li>
-     * <li>ModuleSerialNumber.FunctionLogicalName</li>
-     * <li>ModuleLogicalName.FunctionIdentifier</li>
-     * <li>ModuleLogicalName.FunctionLogicalName</li>
-     * </ul>
-     *
-     * This function does not require that the wireless lan interface is online at the time
-     * it is invoked. The returned object is nevertheless valid.
-     * Use the method YWireless.isOnline() to test if the wireless lan interface is
-     * indeed online at a given time. In case of ambiguity when looking for
-     * a wireless lan interface by logical name, no error is notified: the first instance
-     * found is returned. The search is performed first by hardware name,
-     * then by logical name.
-     *
-     * If a call to this object's is_online() method returns FALSE although
-     * you are certain that the matching device is plugged, make sure that you did
-     * call registerHub() at application initialization time.
-     *
-     * @param func : a string that uniquely characterizes the wireless lan interface
-     *
-     * @return a YWireless object allowing you to drive the wireless lan interface.
-     */
-    static YWireless*   FindWireless(string func);
-
-    /**
-     * Registers the callback function that is invoked on every change of advertised value.
-     * The callback is invoked only during the execution of ySleep or yHandleEvents.
-     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
-     * one of these two functions periodically. To unregister a callback, pass a NULL pointer as argument.
-     *
-     * @param callback : the callback function to call, or a NULL pointer. The callback function should take two
-     *         arguments: the function object of which the value has changed, and the character string describing
-     *         the new advertised value.
-     * @noreturn
-     */
-    virtual int         registerValueCallback(YWirelessValueCallback callback);
-    using YFunction::registerValueCallback;
-
-    virtual int         _invokeValueCallback(string value);
-
-    /**
-     * Triggers a scan of the wireless frequency and builds the list of available networks.
-     * The scan forces a disconnection from the current network. At then end of the process, the
-     * the network interface attempts to reconnect to the previous network. During the scan, the wlanState
-     * switches to Y_WLANSTATE_DOWN, then to Y_WLANSTATE_SCANNING. When the scan is completed,
-     * get_wlanState() returns either Y_WLANSTATE_DOWN or Y_WLANSTATE_SCANNING. At this
-     * point, the list of detected network can be retrieved with the get_detectedWlans() method.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         startWlanScan(void);
-
-    /**
-     * Changes the configuration of the wireless lan interface to connect to an existing
-     * access point (infrastructure mode).
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param ssid : the name of the network to connect to
-     * @param securityKey : the network key, as a character string
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         joinNetwork(string ssid,string securityKey);
-
-    /**
-     * Changes the configuration of the wireless lan interface to create an ad-hoc
-     * wireless network, without using an access point. On the YoctoHub-Wireless-g,
-     * it is best to use softAPNetworkInstead(), which emulates an access point
-     * (Soft AP) which is more efficient and more widely supported than ad-hoc networks.
-     *
-     * When a security key is specified for an ad-hoc network, the network is protected
-     * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
-     * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
-     * using 26 hexadecimal digits to maximize security.
-     * Remember to call the saveToFlash() method and then to reboot the module
-     * to apply this setting.
-     *
-     * @param ssid : the name of the network to connect to
-     * @param securityKey : the network key, as a character string
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         adhocNetwork(string ssid,string securityKey);
-
-    /**
-     * Changes the configuration of the wireless lan interface to create a new wireless
-     * network by emulating a WiFi access point (Soft AP). This function can only be
-     * used with the YoctoHub-Wireless-g.
-     *
-     * When a security key is specified for a SoftAP network, the network is protected
-     * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
-     * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
-     * using 26 hexadecimal digits to maximize security.
-     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
-     *
-     * @param ssid : the name of the network to connect to
-     * @param securityKey : the network key, as a character string
-     *
-     * @return YAPI_SUCCESS when the call succeeds.
-     *
-     * On failure, throws an exception or returns a negative error code.
-     */
-    virtual int         softAPNetwork(string ssid,string securityKey);
-
-    /**
-     * Returns a list of YWlanRecord objects that describe detected Wireless networks.
-     * This list is not updated when the module is already connected to an access point (infrastructure mode).
-     * To force an update of this list, startWlanScan() must be called.
-     * Note that an languages without garbage collections, the returned list must be freed by the caller.
-     *
-     * @return a list of YWlanRecord objects, containing the SSID, channel,
-     *         link quality and the type of security of the wireless network.
-     *
-     * On failure, throws an exception or returns an empty list.
-     */
-    virtual vector<YWlanRecord> get_detectedWlans(void);
-
-
-    inline static YWireless* Find(string func)
-    { return YWireless::FindWireless(func); }
-
-    /**
-     * Continues the enumeration of wireless lan interfaces started using yFirstWireless().
-     * Caution: You can't make any assumption about the returned wireless lan interfaces order.
-     * If you want to find a specific a wireless lan interface, use Wireless.findWireless()
-     * and a hardwareID or a logical name.
-     *
-     * @return a pointer to a YWireless object, corresponding to
-     *         a wireless lan interface currently online, or a NULL pointer
-     *         if there are no more wireless lan interfaces to enumerate.
-     */
-           YWireless       *nextWireless(void);
-    inline YWireless       *next(void)
-    { return this->nextWireless();}
-
-    /**
-     * Starts the enumeration of wireless lan interfaces currently accessible.
-     * Use the method YWireless.nextWireless() to iterate on
-     * next wireless lan interfaces.
-     *
-     * @return a pointer to a YWireless object, corresponding to
-     *         the first wireless lan interface currently online, or a NULL pointer
-     *         if there are none.
-     */
-           static YWireless* FirstWireless(void);
-    inline static YWireless* First(void)
-    { return YWireless::FirstWireless();}
-#ifdef __BORLANDC__
-#pragma option pop
-#endif
-    //--- (end of generated code: YWireless accessors declaration)
-};
-
-//--- (generated code: YWireless functions declaration)
-
-/**
- * Retrieves a wireless lan interface for a given identifier.
- * The identifier can be specified using several formats:
- * <ul>
- * <li>FunctionLogicalName</li>
- * <li>ModuleSerialNumber.FunctionIdentifier</li>
- * <li>ModuleSerialNumber.FunctionLogicalName</li>
- * <li>ModuleLogicalName.FunctionIdentifier</li>
- * <li>ModuleLogicalName.FunctionLogicalName</li>
- * </ul>
- *
- * This function does not require that the wireless lan interface is online at the time
- * it is invoked. The returned object is nevertheless valid.
- * Use the method YWireless.isOnline() to test if the wireless lan interface is
- * indeed online at a given time. In case of ambiguity when looking for
- * a wireless lan interface by logical name, no error is notified: the first instance
- * found is returned. The search is performed first by hardware name,
- * then by logical name.
- *
- * If a call to this object's is_online() method returns FALSE although
- * you are certain that the matching device is plugged, make sure that you did
- * call registerHub() at application initialization time.
- *
- * @param func : a string that uniquely characterizes the wireless lan interface
- *
- * @return a YWireless object allowing you to drive the wireless lan interface.
- */
-inline YWireless* yFindWireless(const string& func)
-{ return YWireless::FindWireless(func);}
-/**
- * Starts the enumeration of wireless lan interfaces currently accessible.
- * Use the method YWireless.nextWireless() to iterate on
- * next wireless lan interfaces.
- *
- * @return a pointer to a YWireless object, corresponding to
- *         the first wireless lan interface currently online, or a NULL pointer
- *         if there are none.
- */
-inline YWireless* yFirstWireless(void)
-{ return YWireless::FirstWireless();}
-
-//--- (end of generated code: YWireless functions declaration)
-
-#endif
